<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron Flow & Resistance Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            background: #0f0f1e;
            cursor: default;
            touch-action: none;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #4a4a6a;
            max-width: 320px;
            cursor: move;
            user-select: none;
        }
        
        .controls.collapsed .control-content {
            display: none;
        }
        
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }
        
        .controls.collapsed .controls-header {
            margin-bottom: 0;
        }
        
        .collapse-btn {
            background: #4a4a6a;
            border: none;
            color: #66d9ff;
            width: 28px;
            height: 28px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .collapse-btn:hover {
            background: #5a5a7a;
        }
        
        .collapse-btn:active {
            background: #6a6a8a;
        }
        
        h2 {
            color: #66d9ff;
            margin-bottom: 0;
            font-size: 1.3em;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 0.95em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #2a2a4a;
            outline: none;
            -webkit-appearance: none;
            touch-action: manipulation;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #66d9ff;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #66d9ff;
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            color: #66d9ff;
            font-weight: bold;
            font-size: 1.1em;
            margin-top: 5px;
        }
        
        .info {
            background: rgba(102, 217, 255, 0.1);
            padding: 12px;
            border-radius: 5px;
            font-size: 0.85em;
            line-height: 1.5;
            border-left: 3px solid #66d9ff;
            margin-top: 15px;
        }
        
        .resistor-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a4a6a;
        }
        
        .spawn-btn {
            background: #66d9ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
            margin-bottom: 10px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .spawn-btn:hover {
            background: #88e5ff;
            transform: translateY(-2px);
        }
        
        .spawn-btn:active {
            transform: translateY(0);
            background: #4dabf7;
        }
        
        .delete-btn {
            background: #ff6464;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
            display: none;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .delete-btn.active {
            display: block;
        }
        
        .delete-btn:hover {
            background: #ff4444;
        }
        
        .delete-btn:active {
            background: #cc0000;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a4a6a;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 0.9em;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls" id="controls">
        <div class="controls-header">
            <h2>‚ö° Electron Flow Simulator</h2>
            <button class="collapse-btn" id="collapseBtn">‚àí</button>
        </div>
        
        <div class="control-content">
            <div class="control-group">
                <label for="temperature">Temperature (affects Brownian motion)</label>
                <input type="range" id="temperature" min="1" max="10000" value="300" step="1">
                <div class="value-display" id="tempDisplay">300¬∞C - Room Temperature</div>
            </div>
            
            <div class="control-group">
                <label for="electricField">Electric Field Strength</label>
                <input type="range" id="electricField" min="0" max="10" value="1" step="0.1">
                <div class="value-display" id="fieldDisplay">1.0√ó - Normal</div>
            </div>
            
            <div class="info">
                <strong>üí° Instructions:</strong><br>
                ‚Ä¢ Electric field pushes electrons left ‚Üí right<br>
                ‚Ä¢ Drag plastic resistors to move them<br>
                ‚Ä¢ Drag corners to resize<br>
                ‚Ä¢ Click to select/deselect<br>
                ‚Ä¢ Higher temperature = more random motion<br>
                ‚Ä¢ Drag this panel by its header
            </div>
        </div>
    </div>
    
    <div class="resistor-controls">
        <button class="spawn-btn" id="spawnBtn">‚ûï Spawn Plastic Resistor</button>
        <button class="delete-btn" id="deleteBtn">üóëÔ∏è Delete Selected</button>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #ff9640;"></div>
            <span>Cu‚Å∫ ions (copper lattice)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4dabf7;"></div>
            <span>Free electrons (e‚Åª)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 100, 100, 0.3); border: 2px solid #ff6464;"></div>
            <span>Plastic resistor (drag/resize)</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tempSlider = document.getElementById('temperature');
        const tempDisplay = document.getElementById('tempDisplay');
        const fieldSlider = document.getElementById('electricField');
        const fieldDisplay = document.getElementById('fieldDisplay');
        
        // Physics constants
        const BASE_ELECTRIC_FIELD_STRENGTH = 0.15;
        const ELECTRON_REPULSION = 800;
        const ION_REPULSION = 300;
        const DAMPING = 0.92;
        const MAX_SPEED = 3;
        
        // Lattice setup
        const LATTICE_SPACING = 60;
        const ions = [];
        const electrons = [];
        
        // Plastic resistors array
        const plasticResistors = [];
        let selectedResistor = null;
        let dragMode = null;
        const CORNER_SIZE = 12;
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createLattice();
            createElectrons();
        }
        
        // Create copper ion lattice
        function createLattice() {
            ions.length = 0;
            const cols = Math.ceil(canvas.width / LATTICE_SPACING) + 2;
            const rows = Math.ceil(canvas.height / LATTICE_SPACING) + 2;
            
            for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                    ions.push({
                        x: col * LATTICE_SPACING + LATTICE_SPACING / 2,
                        y: row * LATTICE_SPACING + LATTICE_SPACING / 2,
                        baseX: col * LATTICE_SPACING + LATTICE_SPACING / 2,
                        baseY: row * LATTICE_SPACING + LATTICE_SPACING / 2,
                        vx: 0,
                        vy: 0
                    });
                }
            }
        }
        
        // Create free electrons
        function createElectrons() {
            electrons.length = 0;
            const numElectrons = Math.floor((canvas.width * canvas.height) / 3500);
            
            for (let i = 0; i < numElectrons; i++) {
                electrons.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0,
                    radius: 5
                });
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Spawn button
        document.getElementById('spawnBtn').addEventListener('click', () => {
            const newResistor = {
                x: canvas.width / 2 - 75,
                y: canvas.height / 2 - 50,
                width: 150,
                height: 100,
                selected: false
            };
            plasticResistors.push(newResistor);
        });
        
        // Delete button
        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedResistor !== null) {
                plasticResistors.splice(selectedResistor, 1);
                selectedResistor = null;
                updateDeleteButton();
            }
        });
        
        function updateDeleteButton() {
            const deleteBtn = document.getElementById('deleteBtn');
            if (selectedResistor !== null) {
                deleteBtn.classList.add('active');
            } else {
                deleteBtn.classList.remove('active');
            }
        }
        
        function getCornerAtPoint(resistor, x, y) {
            const touchSize = 20; // Larger hit area for touch
            const corners = {
                'corner-tl': {x: resistor.x, y: resistor.y},
                'corner-tr': {x: resistor.x + resistor.width, y: resistor.y},
                'corner-bl': {x: resistor.x, y: resistor.y + resistor.height},
                'corner-br': {x: resistor.x + resistor.width, y: resistor.y + resistor.height}
            };
            
            for (let [name, corner] of Object.entries(corners)) {
                if (Math.abs(x - corner.x) < touchSize && Math.abs(y - corner.y) < touchSize) {
                    return name;
                }
            }
            return null;
        }
        
        function isPointInResistor(resistor, x, y) {
            return x >= resistor.x && x <= resistor.x + resistor.width &&
                   y >= resistor.y && y <= resistor.y + resistor.height;
        }
        
        // Controls panel dragging
        const controlsPanel = document.getElementById('controls');
        const collapseBtn = document.getElementById('collapseBtn');
        let isDraggingPanel = false;
        let panelOffsetX = 0;
        let panelOffsetY = 0;
        
        controlsPanel.addEventListener('mousedown', (e) => {
            if (e.target === collapseBtn || e.target.closest('.collapse-btn')) return;
            if (e.target.tagName === 'INPUT') return;
            
            isDraggingPanel = true;
            const rect = controlsPanel.getBoundingClientRect();
            panelOffsetX = e.clientX - rect.left;
            panelOffsetY = e.clientY - rect.top;
            controlsPanel.style.cursor = 'grabbing';
        });
        
        controlsPanel.addEventListener('touchstart', (e) => {
            if (e.target === collapseBtn || e.target.closest('.collapse-btn')) return;
            if (e.target.tagName === 'INPUT') return;
            
            e.preventDefault();
            isDraggingPanel = true;
            const touch = e.touches[0];
            const rect = controlsPanel.getBoundingClientRect();
            panelOffsetX = touch.clientX - rect.left;
            panelOffsetY = touch.clientY - rect.top;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDraggingPanel) {
                controlsPanel.style.left = (e.clientX - panelOffsetX) + 'px';
                controlsPanel.style.top = (e.clientY - panelOffsetY) + 'px';
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (isDraggingPanel) {
                const touch = e.touches[0];
                controlsPanel.style.left = (touch.clientX - panelOffsetX) + 'px';
                controlsPanel.style.top = (touch.clientY - panelOffsetY) + 'px';
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDraggingPanel) {
                isDraggingPanel = false;
                controlsPanel.style.cursor = 'move';
            }
        });
        
        document.addEventListener('touchend', () => {
            if (isDraggingPanel) {
                isDraggingPanel = false;
            }
        });
        
        // Collapse/expand functionality
        collapseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            controlsPanel.classList.toggle('collapsed');
            collapseBtn.textContent = controlsPanel.classList.contains('collapsed') ? '+' : '‚àí';
        });
        
        // Mouse handling for resistor dragging and resizing
        let dragStartX = 0, dragStartY = 0;
        let isDraggingResistor = false;
        
        function handlePointerDown(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            dragStartX = mouseX;
            dragStartY = mouseY;
            
            // Check if clicking on a resistor
            for (let i = plasticResistors.length - 1; i >= 0; i--) {
                const resistor = plasticResistors[i];
                const corner = getCornerAtPoint(resistor, mouseX, mouseY);
                
                if (corner) {
                    selectedResistor = i;
                    dragMode = corner;
                    isDraggingResistor = true;
                    updateDeleteButton();
                    return true;
                } else if (isPointInResistor(resistor, mouseX, mouseY)) {
                    if (selectedResistor === i) {
                        dragMode = 'move';
                        isDraggingResistor = true;
                    } else {
                        selectedResistor = i;
                        updateDeleteButton();
                    }
                    return true;
                }
            }
            
            selectedResistor = null;
            updateDeleteButton();
            return false;
        }
        
        function handlePointerMove(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            
            if (isDraggingResistor && selectedResistor !== null) {
                const resistor = plasticResistors[selectedResistor];
                const dx = mouseX - dragStartX;
                const dy = mouseY - dragStartY;
                
                if (dragMode === 'move') {
                    resistor.x += dx;
                    resistor.y += dy;
                } else if (dragMode === 'corner-tl') {
                    resistor.width -= dx;
                    resistor.height -= dy;
                    resistor.x += dx;
                    resistor.y += dy;
                } else if (dragMode === 'corner-tr') {
                    resistor.width += dx;
                    resistor.height -= dy;
                    resistor.y += dy;
                } else if (dragMode === 'corner-bl') {
                    resistor.width -= dx;
                    resistor.height += dy;
                    resistor.x += dx;
                } else if (dragMode === 'corner-br') {
                    resistor.width += dx;
                    resistor.height += dy;
                }
                
                if (resistor.width < 40) resistor.width = 40;
                if (resistor.height < 40) resistor.height = 40;
                
                dragStartX = mouseX;
                dragStartY = mouseY;
            } else {
                let overCorner = false;
                let overResistor = false;
                
                for (let i = plasticResistors.length - 1; i >= 0; i--) {
                    const resistor = plasticResistors[i];
                    if (getCornerAtPoint(resistor, mouseX, mouseY)) {
                        canvas.style.cursor = 'nwse-resize';
                        overCorner = true;
                        break;
                    } else if (isPointInResistor(resistor, mouseX, mouseY)) {
                        canvas.style.cursor = selectedResistor === i ? 'move' : 'pointer';
                        overResistor = true;
                        break;
                    }
                }
                
                if (!overCorner && !overResistor) {
                    canvas.style.cursor = 'default';
                }
            }
        }
        
        function handlePointerUp() {
            isDraggingResistor = false;
            dragMode = null;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            handlePointerDown(e.clientX, e.clientY);
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handlePointerDown(touch.clientX, touch.clientY);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            handlePointerMove(e.clientX, e.clientY);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handlePointerMove(touch.clientX, touch.clientY);
        });
        
        canvas.addEventListener('mouseup', () => {
            handlePointerUp();
        });
        
        canvas.addEventListener('touchend', () => {
            handlePointerUp();
        });
        
        // Temperature slider
        tempSlider.addEventListener('input', (e) => {
            const temp = parseInt(e.target.value);
            let tempText = '';
            if (temp < 50) tempText = 'Very Cold';
            else if (temp < 300) tempText = 'Cold';
            else if (temp < 400) tempText = 'Room Temperature';
            else if (temp < 1000) tempText = 'Warm';
            else if (temp < 2000) tempText = 'Hot';
            else if (temp < 5000) tempText = 'Very Hot';
            else tempText = 'Extreme Heat';
            
            tempDisplay.textContent = `${temp}¬∞C - ${tempText}`;
        });
        
        // Electric field slider
        fieldSlider.addEventListener('input', (e) => {
            const fieldStrength = parseFloat(e.target.value);
            let fieldText = '';
            if (fieldStrength === 0) fieldText = 'Off';
            else if (fieldStrength < 0.5) fieldText = 'Very Weak';
            else if (fieldStrength < 1) fieldText = 'Weak';
            else if (fieldStrength === 1) fieldText = 'Normal';
            else if (fieldStrength <= 2) fieldText = 'Strong';
            else if (fieldStrength <= 5) fieldText = 'Very Strong';
            else fieldText = 'Extreme';
            
            fieldDisplay.textContent = `${fieldStrength.toFixed(1)}√ó - ${fieldText}`;
        });
        
        // Physics simulation
        function updateIons() {
            const temperature = parseInt(tempSlider.value);
            const thermalIntensity = Math.sqrt(temperature) * 0.05;
            const restoreForce = 0.15;
            const ionDamping = 0.85;
            
            ions.forEach(ion => {
                ion.vx += (Math.random() - 0.5) * thermalIntensity;
                ion.vy += (Math.random() - 0.5) * thermalIntensity;
                
                const dx = ion.baseX - ion.x;
                const dy = ion.baseY - ion.y;
                ion.vx += dx * restoreForce;
                ion.vy += dy * restoreForce;
                
                ion.vx *= ionDamping;
                ion.vy *= ionDamping;
                
                ion.x += ion.vx;
                ion.y += ion.vy;
            });
        }
        
        function updateElectrons() {
            const temperature = parseInt(tempSlider.value);
            const brownianIntensity = Math.sqrt(temperature) * 0.03;
            const electricFieldStrength = BASE_ELECTRIC_FIELD_STRENGTH * parseFloat(fieldSlider.value);
            
            electrons.forEach((electron, i) => {
                electron.vx += electricFieldStrength;
                
                electron.vx += (Math.random() - 0.5) * brownianIntensity;
                electron.vy += (Math.random() - 0.5) * brownianIntensity;
                
                // Calculate electron density gradient for drift away from crowded areas
                // Scale with electric field strength - stronger field = stronger drift effect
                let densityDriftX = 0;
                let densityDriftY = 0;
                const DENSITY_RADIUS = 100;
                const baseDriftStrength = 0.12 * (0.3 + parseFloat(fieldSlider.value) * 0.7); // Scale from 0.3x to 1x based on field
                
                let nearbyCount = 0;
                electrons.forEach((other, j) => {
                    if (i === j) return;
                    
                    const dx = electron.x - other.x;
                    const dy = electron.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < DENSITY_RADIUS && dist > 0) {
                        nearbyCount++;
                        const weight = (1 - (dist / DENSITY_RADIUS)) * 2;
                        densityDriftX += (dx / dist) * weight;
                        densityDriftY += (dy / dist) * weight;
                    }
                });
                
                if (nearbyCount > 2) {
                    const driftMagnitude = Math.sqrt(densityDriftX * densityDriftX + densityDriftY * densityDriftY);
                    if (driftMagnitude > 0) {
                        const scaledStrength = baseDriftStrength * Math.sqrt(nearbyCount);
                        electron.vx += (densityDriftX / driftMagnitude) * scaledStrength;
                        electron.vy += (densityDriftY / driftMagnitude) * scaledStrength;
                    }
                }
                
                plasticResistors.forEach(resistor => {
                    // Check if electron is trapped inside resistor
                    const isInside = electron.x > resistor.x && 
                                    electron.x < resistor.x + resistor.width &&
                                    electron.y > resistor.y && 
                                    electron.y < resistor.y + resistor.height;
                    
                    if (isInside) {
                        // Calculate distances to each edge
                        const distLeft = electron.x - resistor.x;
                        const distRight = (resistor.x + resistor.width) - electron.x;
                        const distTop = electron.y - resistor.y;
                        const distBottom = (resistor.y + resistor.height) - electron.y;
                        
                        // Find closest edge
                        const minDist = Math.min(distLeft, distRight, distTop, distBottom);
                        
                        // Push electron quickly to closest edge
                        if (minDist === distLeft) {
                            electron.x = resistor.x - 5;
                            electron.vx = -3;
                        } else if (minDist === distRight) {
                            electron.x = resistor.x + resistor.width + 5;
                            electron.vx = 3;
                        } else if (minDist === distTop) {
                            electron.y = resistor.y - 5;
                            electron.vy = -3;
                        } else {
                            electron.y = resistor.y + resistor.height + 5;
                            electron.vy = 3;
                        }
                    } else {
                        // Normal repulsion for electrons outside
                        const closestX = Math.max(resistor.x, Math.min(electron.x, resistor.x + resistor.width));
                        const closestY = Math.max(resistor.y, Math.min(electron.y, resistor.y + resistor.height));
                        
                        const dx = electron.x - closestX;
                        const dy = electron.y - closestY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 30) {
                            const repulsionStrength = dist < 1 ? 8 : 8 / (dist + 1);
                            const angle = Math.atan2(dy, dx);
                            electron.vx += Math.cos(angle) * repulsionStrength;
                            electron.vy += Math.sin(angle) * repulsionStrength;
                        }
                    }
                });
                
                for (let j = i + 1; j < electrons.length; j++) {
                    const other = electrons[j];
                    const dx = electron.x - other.x;
                    const dy = electron.y - other.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    
                    if (dist < 50 && dist > 0) {
                        const force = ELECTRON_REPULSION / (distSq + 100);
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        electron.vx += fx;
                        electron.vy += fy;
                        other.vx -= fx;
                        other.vy -= fy;
                    }
                }
                
                ions.forEach(ion => {
                    const dx = electron.x - ion.x;
                    const dy = electron.y - ion.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    
                    if (dist < 30 && dist > 0) {
                        const force = ION_REPULSION / (distSq + 50);
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        electron.vx += fx;
                        electron.vy += fy;
                    }
                });
                
                electron.vx *= DAMPING;
                electron.vy *= DAMPING;
                
                const speed = Math.sqrt(electron.vx * electron.vx + electron.vy * electron.vy);
                if (speed > MAX_SPEED) {
                    electron.vx = (electron.vx / speed) * MAX_SPEED;
                    electron.vy = (electron.vy / speed) * MAX_SPEED;
                }
                
                electron.x += electron.vx;
                electron.y += electron.vy;
                
                if (electron.x > canvas.width) electron.x = 0;
                if (electron.x < 0) electron.x = canvas.width;
                if (electron.y > canvas.height) electron.y = 0;
                if (electron.y < 0) electron.y = canvas.height;
            });
        }
        
        // Rendering
        function draw() {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw electric field arrows (only if field is active)
            const fieldStrength = parseFloat(fieldSlider.value);
            if (fieldStrength > 0) {
                const opacity = Math.min(0.15 + (fieldStrength * 0.1), 0.5); // More visible with stronger field
                ctx.strokeStyle = `rgba(100, 200, 255, ${opacity})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                for (let y = 50; y < canvas.height; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(20, y);
                    ctx.lineTo(canvas.width - 20, y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(canvas.width - 30, y - 5);
                    ctx.lineTo(canvas.width - 20, y);
                    ctx.lineTo(canvas.width - 30, y + 5);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }
            
            ctx.fillStyle = '#ff9640';
            ctx.strokeStyle = '#ffb366';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ions.forEach(ion => {
                ctx.beginPath();
                ctx.arc(ion.x, ion.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                ctx.fillText('+', ion.x, ion.y);
                ctx.fillStyle = '#ff9640';
            });
            
            plasticResistors.forEach((resistor, index) => {
                const isSelected = selectedResistor === index;
                
                ctx.fillStyle = 'rgba(255, 100, 100, 0.25)';
                ctx.strokeStyle = isSelected ? '#ffff00' : '#ff6464';
                ctx.lineWidth = isSelected ? 4 : 3;
                ctx.fillRect(resistor.x, resistor.y, resistor.width, resistor.height);
                ctx.strokeRect(resistor.x, resistor.y, resistor.width, resistor.height);
                
                ctx.fillStyle = '#ff6464';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PLASTIC', resistor.x + resistor.width / 2, resistor.y + resistor.height / 2 - 10);
                ctx.font = '11px Arial';
                ctx.fillText('RESISTOR', resistor.x + resistor.width / 2, resistor.y + resistor.height / 2 + 10);
                
                if (isSelected) {
                    const corners = [
                        {x: resistor.x, y: resistor.y},
                        {x: resistor.x + resistor.width, y: resistor.y},
                        {x: resistor.x, y: resistor.y + resistor.height},
                        {x: resistor.x + resistor.width, y: resistor.y + resistor.height}
                    ];
                    
                    const handleSize = 16; // Larger visual handles for touch
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    
                    corners.forEach(corner => {
                        ctx.fillRect(corner.x - handleSize / 2, corner.y - handleSize / 2, handleSize, handleSize);
                        ctx.strokeRect(corner.x - handleSize / 2, corner.y - handleSize / 2, handleSize, handleSize);
                    });
                }
            });
            
            electrons.forEach(electron => {
                const gradient = ctx.createRadialGradient(
                    electron.x, electron.y, 0,
                    electron.x, electron.y, electron.radius * 2
                );
                gradient.addColorStop(0, '#4dabf7');
                gradient.addColorStop(0.5, 'rgba(77, 171, 247, 0.5)');
                gradient.addColorStop(1, 'rgba(77, 171, 247, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(electron.x, electron.y, electron.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#4dabf7';
                ctx.beginPath();
                ctx.arc(electron.x, electron.y, electron.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#0f0f1e';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚àí', electron.x, electron.y);
            });
        }
        
        // Animation loop
        function animate() {
            updateIons();
            updateElectrons();
            draw();
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>