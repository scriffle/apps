<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Electron Drift in a Metal Lattice — Interactive Simulation</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e6f0ff; --muted:#9fb1d4; --accent:#6ee7ff; --accent2:#6dffa7;
    --panel:#111936; --panel2:#0e1530; --shadow:rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: radial-gradient(1200px 600px at 10% -10%, #1c2750 0%, #0b1020 50%),
                radial-gradient(1200px 800px at 110% 110%, #08122b 0%, #0b1020 60%);
    color:var(--fg);
    display:grid; grid-template-rows:auto 1fr; gap:10px;
  }
  header{
    padding:10px 16px; position:sticky; top:0; z-index:10; backdrop-filter: blur(6px);
  }
  .wrap{display:grid; grid-template-columns: 330px 1fr; gap:12px; padding:0 12px 12px}
  .panel{background:linear-gradient(180deg,var(--panel),var(--panel2)); border:1px solid #1a2550; border-radius:14px; box-shadow:0 10px 30px var(--shadow)}
  #ui{padding:14px; display:grid; gap:12px}
  #ui h2{margin:0 0 6px; font-size:16px; letter-spacing:.3px; color:var(--accent)}
  .row{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center}
  .row > label{font-size:13px; color:var(--muted)}
  .row input[type="range"]{width:100%}
  .row .v{font-variant-numeric: tabular-nums; min-width:70px; text-align:right; color:var(--fg)}
  canvas{width:100%; height:100%; display:block; border-radius:14px}
  #vis{position:relative}
  .legend{position:absolute; left:10px; top:8px; font-size:12px; color:#cdd9ff; background:rgba(8,12,28,.55); padding:6px 8px; border-radius:8px; border:1px solid rgba(120,150,255,.2)}
  .legend div{display:flex; align-items:center; gap:6px}
  .dot{width:10px; height:10px; border-radius:50%}
  .dot.e{background: radial-gradient(circle at 30% 30%, #b6f3ff, #6ee7ff)}
  .dot.a{background: radial-gradient(circle at 30% 30%, #ffd4b6, #ff9a6d)}
  .kpi{position:absolute; right:10px; top:8px; font-size:12px; color:#cdd9ff; background:rgba(8,12,28,.55); padding:6px 8px; border-radius:8px; border:1px solid rgba(120,150,255,.2); text-align:right; min-width:180px}
  .small{font-size:11px; color:#a9b8e8}
  .hr{height:1px; background:#1e2a63; margin:2px 0 6px}
  .test-chip{position:absolute; bottom:8px; left:8px; font-size:11px; color:#bfeccb; background:rgba(16,60,22,.55); padding:6px 8px; border-radius:8px; border:1px solid rgba(120,255,180,.25)}
</style>
</head>
<body>
  <header>
    <div style="display:flex; align-items:center; gap:14px; flex-wrap:wrap">
      <h1 style="margin:0; font-size:18px; letter-spacing:.3px">Electron Flow Through a Metal Lattice</h1>
      <span style="color:var(--muted); font-size:13px">Coulomb repulsion & lattice scattering — adjust field and electron count</span>
    </div>
  </header>
  <div class="wrap">
    <section id="ui" class="panel" aria-label="Controls">
      <h2>Controls</h2>
      <div class="row"><label for="count">Electrons</label><span class="v" id="countV"></span></div>
      <input id="count" type="range" min="20" max="800" step="10" value="200"/>

      <div class="row"><label for="field">Electric Field (→)</label><span class="v" id="fieldV"></span></div>
      <input id="field" type="range" min="0" max="150" step="1" value="40"/>

      <details class="card">
        <summary>Model (simplified)</summary>
        <div style="font-size:12px; color:var(--muted); line-height:1.35">
          <p>Electrons (blue) move in 2D under:<br>
          <b>F</b> = <b>F</b><sub>E</sub> + Σ<sub>j</sub> <b>F</b><sub>Coulomb</sub> + Σ<sub>a</sub> <b>F</b><sub>atom</sub> + <b>η</b> (random)</p>
          <ul>
            <li>Electric field adds constant acceleration a<sub>E</sub> = (qE/m) x̂.</li>
            <li>Coulomb: k q² (r̂ / (r² + ε²)) with cutoff and softening ε.</li>
            <li>Atoms are fixed repulsive cores on a square lattice; short-range force reflects/deflects.</li>
          </ul>
          <p>Temperature jitter is fixed at a moderate level to mimic phonon scattering.</p>
        </div>
      </details>
    </section>

    <section id="vis" class="panel" aria-label="Visualization">
      <div class="legend">
        <div><span class="dot e"></span> electrons</div>
        <div><span class="dot a"></span> metal atoms</div>
      </div>
      <div class="kpi">
        <div>FPS: <b id="fps">0</b></div>
        <div>Electrons: <b id="nElectrons">0</b></div>
        <div>Cells: <b id="nCells">0</b></div>
        <div class="hr"></div>
        <div>Drift vₓ: <b id="vx">0</b></div>
        <div>Current (arb.): <b id="current">0</b></div>
        <div>Collisions/e⁻: <b id="coll">0</b></div>
        <div>Jitter: <b id="tj">0</b></div>
      </div>
      <div id="testChip" class="test-chip" style="display:none"></div>
      <canvas id="canvas" aria-label="Electron lattice animation"></canvas>
    </section>
  </div>

<script>
(function(){
  // === Utilities ===
  const rand = (a=0,b=1)=>a+(b-a)*Math.random();
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const TAU=Math.PI*2;

  // === Canvas Setup ===
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W=canvas.clientWidth, H=canvas.clientHeight, DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function resize(){
    W = canvas.clientWidth; H = canvas.clientHeight;
    canvas.width = Math.round(W*DPR); canvas.height = Math.round(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  const ro = new ResizeObserver(resize); ro.observe(canvas);
  resize();

  // === Parameters ===
  const params = {
    count: 200,
    field: 40,         // arbitrary E field strength
    temp: 60,          // temperature scaled 0..200 (fixed UI)
    lattice: 50,       // atom spacing (px)
    zoom: 1.0,
    damping: 0.992,    // slightly less damping so repulsion is more visible
    coulombK: 4200,    // stronger Coulomb term for visible separation
    softening: 10,     // smaller softening -> sharper inverse-square at close range
    maxForce: 4000,    // higher cap to avoid underpowered close-range repulsion
    atomRepel: 2500,   // short-range atom repulsion strength
    atomRadius: 16,    // visual/interaction radius for atoms
    dt: 0.016,         // seconds per update step target
    trails: true,
    showAtoms: true,
    minSep: 6,         // minimum electron-electron separation in pixels for collision resolution
    restitution: 0.98, // near-elastic reflect on close contact
  };

  // === Lattice (fixed atoms) ===
  let atoms=[];
  function rebuildLattice(){
    atoms.length=0;
    const s = params.lattice * params.zoom;
    const pad = 40 * params.zoom;
    for(let y=pad; y<H-pad; y+=s){
      for(let x=pad; x<W-pad; x+=s){
        atoms.push({x, y});
      }
    }
  }

  // === Particles (electrons) ===
  let electrons = [];
  function seedElectrons(n){
    for(let i=0;i<n;i++){
      let x = rand(10, W-10), y = rand(10, H-10);
      // avoid spawning inside atoms
      let tries=0;
      while(tries<30){
        let ok=true;
        for(const a of atoms){
          const dx=x-a.x, dy=y-a.y; if(dx*dx+dy*dy < (params.atomRadius*params.zoom+8)**2){ ok=false; break; }
        }
        if(ok) break; else { x = rand(10, W-10); y = rand(10, H-10); tries++; }
      }
      electrons.push({x, y, vx: rand(-10,10), vy: rand(-10,10)});
    }
  }

  // === Spatial Grid for neighbour queries ===
  let grid, cols, rows, cellSize;
  function buildGrid(){
    cellSize = Math.max(24, params.lattice*0.9) * params.zoom; // coarse enough for perf
    cols = Math.ceil(W / cellSize);
    rows = Math.ceil(H / cellSize);
    grid = Array.from({length: cols*rows}, ()=>[]);
  }
  function cellIndex(x,y){
    const cx = clamp(Math.floor(x/cellSize), 0, cols-1);
    const cy = clamp(Math.floor(y/cellSize), 0, rows-1);
    return cy*cols + cx;
  }

  // === Physics Update ===
  let tAccum=0, lastT=performance.now(), frames=0, fps=0, fpsT=0;
  let collisions=0;

  function step(){
    const now=performance.now();
    const dtRaw = (now-lastT)/1000; lastT=now;

    // FPS counter
    fpsT+=dtRaw; frames++; if(fpsT>0.5){ fps=Math.round(frames/fpsT); frames=0; fpsT=0; }

    tAccum+=dtRaw;
    const targetDt = params.dt; // integrate at fixed steps for stability

    while(tAccum>=targetDt){
      // Rebuild grid and assign electrons
      buildGrid();
      for(const p of electrons){ grid[cellIndex(p.x,p.y)].push(p); }

      // Precompute constants
      const soft2 = params.softening*params.softening;
      const maxF = params.maxForce;
      const atomR2 = (params.atomRadius*params.zoom)**2;
      const jitter = params.temp * 0.08; // temperature → random kick scale
      const aE = params.field * 0.08;    // field accel (→)
      const minSep = params.minSep;
      collisions=0;

      // --- Force accumulation (Coulomb + lattice + field + jitter)
      for(const p of electrons){
        let fx = aE; // electric field to +x
        let fy = 0;

        // Coulomb repulsion from nearby electrons (check surrounding 9 cells)
        const cx = Math.floor(p.x/cellSize);
        const cy = Math.floor(p.y/cellSize);
        for(let oy=-1; oy<=1; oy++){
          for(let ox=-1; ox<=1; ox++){
            const nx=cx+ox, ny=cy+oy; if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
            const cell = grid[ny*cols+nx];
            for(const q of cell){ if(q===p) continue;
              let dx = p.x - q.x; let dy = p.y - q.y;
              let r2 = dx*dx + dy*dy + soft2;
              const inv = 1/Math.sqrt(r2);
              // F = k / r^2 along r̂ (repulsive)
              const f = Math.min(maxF, params.coulombK * inv * inv);
              fx += f * dx * inv;
              fy += f * dy * inv;
            }
          }
        }

        // Atom (lattice core) short-range repulsion
        const rCheck = cellSize*2;
        for(const a of atoms){
          if(Math.abs(a.x - p.x) > rCheck || Math.abs(a.y - p.y) > rCheck) continue;
          const dx = p.x - a.x; const dy = p.y - a.y; const r2 = dx*dx + dy*dy;
          if(r2 < atomR2*1.8){ // engage force a bit before hard radius
            const r = Math.sqrt(r2)+1e-6; const nxf = dx/r, nyf = dy/r;
            const pen = (params.atomRadius*params.zoom*1.2 - r);
            if(pen>0){
              const f = Math.min(maxF, params.atomRepel * (pen/(params.atomRadius*params.zoom)));
              fx += f * nxf; fy += f * nyf; collisions++;
            }
          }
        }

        // Random thermal kicks
        if(jitter>0){
          fx += (Math.random()*2-1) * jitter;
          fy += (Math.random()*2-1) * jitter;
        }

        // Integrate (semi-implicit Euler)
        p.vx = (p.vx + fx*targetDt) * params.damping;
        p.vy = (p.vy + fy*targetDt) * params.damping;
      }

      // Integrate positions
      for(const p of electrons){
        p.x += p.vx * targetDt;
        p.y += p.vy * targetDt;
        // Periodic boundaries
        if(p.x < 0){ p.x += W; }
        if(p.x >= W){ p.x -= W; }
        if(p.y < 0){ p.y += H; }
        if(p.y >= H){ p.y -= H; }
      }

      // --- Close-range collision resolution (hard reflect feel, while still using Coulomb law)
      // This prevents numerical overlap and visually shows "bounce".
      for(const p of electrons){
        const cx = Math.floor(p.x/cellSize);
        const cy = Math.floor(p.y/cellSize);
        for(let oy=-1; oy<=1; oy++){
          for(let ox=-1; ox<=1; ox++){
            const nx=cx+ox, ny=cy+oy; if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
            const cell = grid[ny*cols+nx];
            for(const q of cell){ if(q===p) continue;
              const dx = p.x - q.x, dy = p.y - q.y;
              const r2 = dx*dx + dy*dy;
              const r = Math.sqrt(r2)+1e-8;
              if(r < minSep){
                // push apart equally
                const nX = dx/r, nY = dy/r;
                const push = (minSep - r) * 0.5;
                p.x += nX * push; p.y += nY * push;
                q.x -= nX * push; q.y -= nY * push;
                // reflect relative velocity along normal (near-elastic)
                const rvx = p.vx - q.vx, rvy = p.vy - q.vy;
                const vRelN = rvx*nX + rvy*nY;
                if(vRelN < 0){
                  const imp = -(1+params.restitution) * vRelN * 0.5; // equal mass
                  p.vx += nX * imp; p.vy += nY * imp;
                  q.vx -= nX * imp; q.vy -= nY * imp;
                }
              }
            }
          }
        }
      }

      tAccum -= targetDt;
    }

    // === Render ===
    if(params.trails){
      ctx.fillStyle = 'rgba(7,10,24,0.22)';
      ctx.fillRect(0,0,W,H);
    }else{
      ctx.clearRect(0,0,W,H);
    }

    // Atoms
    if(params.showAtoms){
      ctx.save();
      for(const a of atoms){
        const r = Math.max(3, params.atomRadius*0.45*params.zoom);
        const grd = ctx.createRadialGradient(a.x-r*0.2, a.y-r*0.2, r*0.2, a.x, a.y, r);
        grd.addColorStop(0, '#ffe6d1');
        grd.addColorStop(1, '#ff9a6d');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(a.x, a.y, r, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    }

    // Electrons
    ctx.save();
    for(const p of electrons){
      const r = 2.3 * params.zoom;
      const grd = ctx.createRadialGradient(p.x-r*0.6, p.y-r*0.6, r*0.3, p.x, p.y, r);
      grd.addColorStop(0, '#c7f3ff');
      grd.addColorStop(1, '#6ee7ff');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // Readouts
    const avgVx = electrons.length ? electrons.reduce((s,p)=>s+p.vx,0)/electrons.length : 0;
    const current = Math.max(0, avgVx) * electrons.length * 0.005;
    const fpsEl = document.getElementById('fps'); if(fpsEl) fpsEl.textContent = fps.toFixed(0);
    const nEl = document.getElementById('nElectrons'); if(nEl) nEl.textContent = electrons.length;
    const nCellsEl = document.getElementById('nCells'); if(nCellsEl) nCellsEl.textContent = (cols*rows);
    const vxEl = document.getElementById('vx'); if(vxEl) vxEl.textContent = (avgVx).toFixed(2);
    const curEl = document.getElementById('current'); if(curEl) curEl.textContent = current.toFixed(1);
    const collEl = document.getElementById('coll'); if(collEl) collEl.textContent = Math.round(collisions / Math.max(1,electrons.length));
    const tjEl = document.getElementById('tj'); if(tjEl) tjEl.textContent = params.temp.toFixed(0);

    requestAnimationFrame(step);
  }

  // === Controls wiring ===
  const bindRange = (id, fmt=(v)=>v)=>{
    const el = document.getElementById(id);
    const v = document.getElementById(id+"V");
    const set=()=>{ if(v) v.textContent = fmt(+el.value); params[id] = +el.value; };
    el.addEventListener('input', set); set();
  };
  bindRange('count', v=>v);
  bindRange('field', v=>v);

  // Keep electron count in sync with slider continuously
  const countEl = document.getElementById('count');
  const countSync = ()=>{
    const target = +countEl.value;
    const diff = target - electrons.length;
    if(diff>0) seedElectrons(diff);
    else if(diff<0) electrons.splice(0, -diff);
    const nEl = document.getElementById('nElectrons'); if(nEl) nEl.textContent = electrons.length;
  };
  countEl.addEventListener('input', countSync);

  // === Minimal tests ===
  function runTests(){
    const chip = document.getElementById('testChip');
    const tests = [];
    const must = id => { const el = document.getElementById(id); tests.push([id, !!el]); return el; };
    must('canvas'); must('count'); must('field'); must('fps'); must('nElectrons'); must('nCells'); must('vx'); must('current'); must('coll'); must('tj');

    // Coulomb separation sanity test (off-screen sandbox)
    let p1={x:50,y:50,vx:0,vy:0}, p2={x:56,y:50,vx:0,vy:0};
    const soft2 = params.softening*params.softening;
    const dt=0.01; let d0=6, d1=6;
    for(let i=0;i<40;i++){
      const dx=p1.x-p2.x, dy=p1.y-p2.y; const r2=dx*dx+dy*dy+soft2; const inv=1/Math.sqrt(r2); const f=params.coulombK*inv*inv; const fx=f*dx*inv, fy=f*dy*inv;
      p1.vx += fx*dt; p1.vy += fy*dt; p2.vx -= fx*dt; p2.vy -= fy*dt;
      p1.x += p1.vx*dt; p1.y += p1.vy*dt; p2.x += p2.vx*dt; p2.y += p2.vy*dt;
    }
    d1 = Math.hypot(p1.x-p2.x, p1.y-p2.y);
    tests.push(["coulomb-separates", d1>d0+0.5]);

    const fails = tests.filter(([_, ok])=>!ok);
    if(chip){
      chip.style.display='block';
      chip.textContent = fails.length? (`❌ ${fails.length} test(s) failed: `+fails.map(t=>t[0]).join(', ')) : '✅ All DOM & Coulomb tests passed';
    }
  }

  // === Initialize ===
  rebuildLattice();
  seedElectrons(params.count);
  runTests();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
