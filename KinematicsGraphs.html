#movingObject {
    position: absolute;
    font-size: 24px;
    transition: none;
    top: 50%;
    transform: translate(-50%, -50%);
}<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kinematics Visualizer</title>
<style>
body {
    margin: 0;
    padding: 10px;
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
}

#container {
    max-width: 800px;
    margin: 0 auto;
    background-color: white;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

h1 {
    margin: 0 0 10px 0;
    font-size: 24px;
}

#controls {
    margin-bottom: 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
}

button {
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    transition: background-color 0.3s;
}

button:hover:not(:disabled) {
    background-color: #45a049;
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

#emojiSelector {
    padding: 6px;
    font-size: 16px;
}

#animationBox {
    width: 100%;
    height: 60px;
    border: 2px solid #333;
    margin-bottom: 10px;
    position: relative;
    background-color: #f9f9f9;
    overflow: hidden;
}

#rulerCanvas {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 20px;
    pointer-events: none;
}

#originMarker {
    position: absolute;
    left: 20px;
    top: 0;
    bottom: 0;
    width: 2px;
    background-color: #333;
    z-index: 1;
}

#originLabel {
    position: absolute;
    left: 5px;
    top: 5px;
    font-size: 10px;
    color: #666;
}

#movingObject {
    position: absolute;
    font-size: 24px;
    transition: none;
    top: 50%;
    transform: translateY(-50%);
}

#velocityDisplay {
    position: absolute;
    font-size: 11px;
    color: #0066cc;
    font-weight: bold;
    pointer-events: none;
    transform: translateX(-50%);
    top: 5px;
}

#accelerationVector {
    position: absolute;
    pointer-events: none;
    bottom: 5px;
    transform: translateX(-50%);
    background: transparent;
    border: none;
}

.graph-container {
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 8px;
}

.graph-label {
    font-weight: bold;
    margin-bottom: 3px;
    font-size: 14px;
}

canvas {
    border: 1px solid #ccc;
    cursor: crosshair;
    display: block;
}

#tooltip {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    display: none;
    font-family: monospace;
    white-space: pre-line;
}

.graph-container.displacement .graph-label { color: green; }
.graph-container.velocity .graph-label { color: blue; }
.graph-container.acceleration .graph-label { color: red; }
</style>
</head>
<body>
<div id="container">
<h1>Interactive Kinematics Visualizer</h1>

<div id="controls">
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="resetBtn">Reset</button>
    <button id="undoBtn">‚Ü∂ Undo</button>
    <button id="redoBtn">‚Ü∑ Redo</button>
    <label for="emojiSelector">Object:</label>
    <select id="emojiSelector">
        <option value="‚öΩ">‚öΩ Ball</option>
        <option value="üõ∏">üõ∏ UFO</option>
        <option value="üõπ">üõπ Skateboard</option>
        <option value="üöÅ">üöÅ Helicopter</option>
        <option value="üì¶">üì¶ Box</option>
    </select>
</div>

<div id="animationBox">
    <canvas id="rulerCanvas"></canvas>
    <div id="originMarker"></div>
    <div id="originLabel">Origin</div>
    <div id="movingObject">üöó</div>
    <div id="velocityDisplay"></div>
    <canvas id="accelerationVector" width="80" height="40"></canvas>
</div>

<div class="graph-container displacement">
    <div class="graph-label">Displacement (m) - Green</div>
    <canvas id="displacementCanvas" width="760" height="180"></canvas>
</div>

<div class="graph-container velocity">
    <div class="graph-label">Velocity (m/s) - Blue</div>
    <canvas id="velocityCanvas" width="760" height="180"></canvas>
</div>

<div class="graph-container acceleration">
    <div class="graph-label">Acceleration (m/s¬≤) - Red</div>
    <canvas id="accelerationCanvas" width="760" height="180"></canvas>
</div>

<div id="tooltip"></div>
</div>

<script>
// Constants
const NUM_POINTS = 17;
const NUM_SEGMENTS = NUM_POINTS - 1;
const GRAPH_PADDING = 35;
const POINT_RADIUS = 4;
const GRID_DIVISIONS = 10;
const TOOLTIP_DELAY = 3000; // 3 seconds

// Graph colors
const COLORS = {
    displacement: '#00aa00',
    velocity: '#0066cc',
    acceleration: '#cc0000'
};

// State
let points = {
    displacement: [],
    velocity: [],
    acceleration: []
};

let history = [];
let historyIndex = -1;
let isDragging = false;
let draggedPoint = null;
let draggedGraph = null;
let animationFrame = null;
let animationStartTime = null;
let isPlaying = false;
let tooltipTimeout = null;
let currentAnimationTime = 0;
let lastMousePosition = { x: 0, y: 0 };
let isShiftDragging = false;
let initialDragValue = null;
let animationPhase = 'playing'; // 'playing', 'waiting', 'returning'
let waitStartTime = null;

// Canvas elements
const canvases = {
    displacement: document.getElementById('displacementCanvas'),
    velocity: document.getElementById('velocityCanvas'),
    acceleration: document.getElementById('accelerationCanvas')
};

const contexts = {};
for (let key in canvases) {
    contexts[key] = canvases[key].getContext('2d');
}

// UI elements
const playBtn = document.getElementById('playBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const emojiSelector = document.getElementById('emojiSelector');
const movingObject = document.getElementById('movingObject');
const tooltip = document.getElementById('tooltip');
const animationBox = document.getElementById('animationBox');
const velocityDisplay = document.getElementById('velocityDisplay');
const accelerationVector = document.getElementById('accelerationVector');
const accelerationCtx = accelerationVector.getContext('2d');
const rulerCanvas = document.getElementById('rulerCanvas');
const rulerCtx = rulerCanvas.getContext('2d');

// Initialize points
function initializePoints() {
    const defaultTime = 16; // Total time span
    
    for (let i = 0; i < NUM_POINTS; i++) {
        const t = (i / NUM_SEGMENTS) * defaultTime;
        
        points.displacement[i] = { x: t, y: 0 };
        points.velocity[i] = { x: t, y: 0 };
        points.acceleration[i] = { x: t, y: 0 };
    }
    
    saveState();
    updateAllGraphs();
    updateOriginPosition();
}

// Update origin position based on current displacement range
function updateOriginPosition() {
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    
    const boxWidth = animationBox.offsetWidth;
    const usableWidth = boxWidth - 60;
    
    let originPixel;
    
    if (minDisplacement >= 0) {
        originPixel = 20;
    } else if (maxDisplacement <= 0) {
        originPixel = boxWidth - 20;
    } else {
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
    }
    
    const originMarker = document.getElementById('originMarker');
    const originLabel = document.getElementById('originLabel');
    originMarker.style.left = originPixel + 'px';
    originLabel.style.left = (originPixel - 15) + 'px';
    
    // Recenter emoji at origin if not animating
    if (!isPlaying) {
        movingObject.style.left = originPixel + 'px';
    }
    
    // Draw ruler
    drawRuler();
}

// Draw ruler with meter ticks
function drawRuler() {
    const boxWidth = animationBox.offsetWidth;
    rulerCanvas.width = boxWidth;
    rulerCanvas.height = 20;
    
    rulerCtx.clearRect(0, 0, boxWidth, 20);
    
    // Get displacement range and scaling
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    const displacementRange = maxDisplacement - minDisplacement;
    
    if (displacementRange === 0) return;
    
    const usableWidth = boxWidth - 60;
    let originPixel;
    let pixelsPerUnit;
    
    if (minDisplacement >= 0) {
        originPixel = 20;
        pixelsPerUnit = usableWidth / (maxDisplacement || 1);
    } else if (maxDisplacement <= 0) {
        originPixel = boxWidth - 20;
        pixelsPerUnit = usableWidth / (Math.abs(minDisplacement) || 1);
    } else {
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    // Calculate tick spacing
    const targetTickSpacing = 40; // Target pixel spacing between ticks
    const unitsPerTick = Math.pow(10, Math.floor(Math.log10(targetTickSpacing / pixelsPerUnit)));
    const possibleSpacings = [1, 2, 5, 10].map(x => x * unitsPerTick);
    const tickSpacing = possibleSpacings.find(spacing => spacing * pixelsPerUnit >= targetTickSpacing) || possibleSpacings[3];
    
    // Draw ticks
    rulerCtx.strokeStyle = '#00aa00';
    rulerCtx.fillStyle = '#00aa00';
    rulerCtx.font = '9px Arial';
    rulerCtx.textAlign = 'center';
    rulerCtx.lineWidth = 1;
    
    // Start from a multiple of tickSpacing
    const startValue = Math.floor(minDisplacement / tickSpacing) * tickSpacing;
    const endValue = Math.ceil(maxDisplacement / tickSpacing) * tickSpacing;
    
    for (let value = startValue; value <= endValue; value += tickSpacing) {
        const pixelX = originPixel + value * pixelsPerUnit;
        
        if (pixelX >= 10 && pixelX <= boxWidth - 10) {
            // Draw tick
            rulerCtx.beginPath();
            rulerCtx.moveTo(pixelX, 15);
            rulerCtx.lineTo(pixelX, 20);
            rulerCtx.stroke();
            
            // Draw label
            rulerCtx.fillText(value.toFixed(0), pixelX, 12);
        }
    }
}

// Calculate velocity at time
function calculateVelocityAtTime(t) {
    // Sort points by time
    const sortedPoints = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.velocity[a].x - points.velocity[b].x
    );
    
    // Handle edge cases
    if (t <= points.velocity[sortedPoints[0]].x) {
        return points.velocity[sortedPoints[0]].y;
    }
    if (t >= points.velocity[sortedPoints[NUM_POINTS - 1]].x) {
        return points.velocity[sortedPoints[NUM_POINTS - 1]].y;
    }
    
    // Find the segment containing time t
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const idx1 = sortedPoints[i];
        const idx2 = sortedPoints[i + 1];
        
        const t1 = points.velocity[idx1].x;
        const t2 = points.velocity[idx2].x;
        
        if (t >= t1 && t < t2) {
            const v0 = points.velocity[idx1].y;
            const a = points.acceleration[idx1].y;
            const dt = t - t1;
            
            // v = v0 + a*t
            return v0 + a * dt;
        }
    }
    
    return points.velocity[sortedPoints[NUM_SEGMENTS]].y;
}

// Calculate acceleration at time
function calculateAccelerationAtTime(t) {
    // Sort points by time
    const sortedPoints = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.acceleration[a].x - points.acceleration[b].x
    );
    
    // Find the segment containing time t
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const idx1 = sortedPoints[i];
        const idx2 = sortedPoints[i + 1];
        
        const t1 = points.acceleration[idx1].x;
        const t2 = points.acceleration[idx2].x;
        
        if (t >= t1 && t < t2) {
            return points.acceleration[idx1].y; // Constant acceleration in segment
        }
    }
    
    return 0;
}

// Draw acceleration vector
function drawAccelerationVector(acceleration) {
    const canvas = accelerationVector;
    const ctx = accelerationCtx;
    
    // Clear the entire canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Hide if acceleration is essentially zero
    if (Math.abs(acceleration) < 0.01) {
        canvas.style.display = 'none';
        return;
    }
    
    // Show the canvas
    canvas.style.display = 'block';
    
    // Set drawing properties
    ctx.strokeStyle = '#cc0000';
    ctx.fillStyle = '#cc0000';
    ctx.lineWidth = 3;
    
    // Canvas dimensions and center point
    const canvasWidth = 80;
    const canvasHeight = 40;
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    
    // Calculate arrow dimensions
    const scaleFactor = 6; // Pixels per m/s¬≤ (increased for larger arrows)
    const maxArrowLength = 35; // Maximum arrow length
    const arrowLength = Math.min(Math.abs(acceleration) * scaleFactor, maxArrowLength);
    const direction = acceleration > 0 ? 1 : -1; // 1 for right, -1 for left
    
    // Arrow parameters
    const arrowStartX = centerX - (direction * arrowLength / 2);
    const arrowEndX = centerX + (direction * arrowLength / 2);
    const headLength = Math.min(8, arrowLength * 0.3); // Arrow head size scales with length
    const headWidth = headLength * 0.8;
    
    // Draw arrow shaft
    ctx.beginPath();
    ctx.moveTo(arrowStartX, centerY);
    ctx.lineTo(arrowEndX, centerY);
    ctx.stroke();
    
    // Draw arrow head (filled triangle)
    ctx.beginPath();
    ctx.moveTo(arrowEndX, centerY); // Tip of arrow
    ctx.lineTo(arrowEndX - direction * headLength, centerY - headWidth);
    ctx.lineTo(arrowEndX - direction * headLength, centerY + headWidth);
    ctx.closePath();
    ctx.fill();
}

// Save state for undo/redo
function saveState() {
    const state = JSON.parse(JSON.stringify(points));
    
    // Remove any states after current index
    history = history.slice(0, historyIndex + 1);
    
    history.push(state);
    historyIndex++;
    
    // Limit history size
    if (history.length > 100) {
        history.shift();
        historyIndex--;
    }
    
    updateUndoRedoButtons();
}

// Update undo/redo button states
function updateUndoRedoButtons() {
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
}

// Undo
function undo() {
    if (historyIndex > 0) {
        // Stop animation if playing
        if (isPlaying) {
            stopAnimation();
        }
        
        historyIndex--;
        points = JSON.parse(JSON.stringify(history[historyIndex]));
        updateAllGraphs();
        updateOriginPosition();
        updateUndoRedoButtons();
    }
}

// Redo
function redo() {
    if (historyIndex < history.length - 1) {
        // Stop animation if playing
        if (isPlaying) {
            stopAnimation();
        }
        
        historyIndex++;
        points = JSON.parse(JSON.stringify(history[historyIndex]));
        updateAllGraphs();
        updateOriginPosition();
        updateUndoRedoButtons();
    }
}

// Get graph bounds
function getGraphBounds(graphType) {
    const pts = points[graphType];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    for (let pt of pts) {
        minX = Math.min(minX, pt.x);
        maxX = Math.max(maxX, pt.x);
        minY = Math.min(minY, pt.y);
        maxY = Math.max(maxY, pt.y);
    }
    
    // Add padding
    const xRange = maxX - minX || 1;
    const yRange = maxY - minY || 1;
    
    minX -= xRange * 0.1;
    maxX += xRange * 0.1;
    minY -= yRange * 0.1;
    maxY += yRange * 0.1;
    
    // Ensure minimum range
    if (maxX - minX < 1) {
        const center = (minX + maxX) / 2;
        minX = center - 0.5;
        maxX = center + 0.5;
    }
    
    if (maxY - minY < 1) {
        const center = (minY + maxY) / 2;
        minY = center - 0.5;
        maxY = center + 0.5;
    }
    
    return { minX, maxX, minY, maxY };
}

// Convert graph coordinates to canvas coordinates
function graphToCanvas(x, y, graphType, canvas) {
    const bounds = getGraphBounds(graphType);
    const canvasWidth = canvas.width - 2 * GRAPH_PADDING;
    const canvasHeight = canvas.height - 2 * GRAPH_PADDING;
    
    const canvasX = GRAPH_PADDING + ((x - bounds.minX) / (bounds.maxX - bounds.minX)) * canvasWidth;
    const canvasY = GRAPH_PADDING + ((bounds.maxY - y) / (bounds.maxY - bounds.minY)) * canvasHeight;
    
    return { x: canvasX, y: canvasY };
}

// Convert canvas coordinates to graph coordinates
function canvasToGraph(canvasX, canvasY, graphType, canvas) {
    const bounds = getGraphBounds(graphType);
    const canvasWidth = canvas.width - 2 * GRAPH_PADDING;
    const canvasHeight = canvas.height - 2 * GRAPH_PADDING;
    
    const x = bounds.minX + ((canvasX - GRAPH_PADDING) / canvasWidth) * (bounds.maxX - bounds.minX);
    const y = bounds.maxY - ((canvasY - GRAPH_PADDING) / canvasHeight) * (bounds.maxY - bounds.minY);
    
    return { x, y };
}

// Draw grid and axes
function drawGrid(ctx, graphType, canvas) {
    const bounds = getGraphBounds(graphType);
    
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    
    // Vertical grid lines
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const x = bounds.minX + (i / GRID_DIVISIONS) * (bounds.maxX - bounds.minX);
        const canvasPos = graphToCanvas(x, 0, graphType, canvas);
        
        ctx.beginPath();
        ctx.moveTo(canvasPos.x, GRAPH_PADDING);
        ctx.lineTo(canvasPos.x, canvas.height - GRAPH_PADDING);
        ctx.stroke();
    }
    
    // Horizontal grid lines
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const y = bounds.minY + (i / GRID_DIVISIONS) * (bounds.maxY - bounds.minY);
        const canvasPos = graphToCanvas(0, y, graphType, canvas);
        
        ctx.beginPath();
        ctx.moveTo(GRAPH_PADDING, canvasPos.y);
        ctx.lineTo(canvas.width - GRAPH_PADDING, canvasPos.y);
        ctx.stroke();
    }
    
    // Draw axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    
    // X-axis (if 0 is in view)
    if (bounds.minY <= 0 && bounds.maxY >= 0) {
        const yPos = graphToCanvas(0, 0, graphType, canvas).y;
        ctx.beginPath();
        ctx.moveTo(GRAPH_PADDING, yPos);
        ctx.lineTo(canvas.width - GRAPH_PADDING, yPos);
        ctx.stroke();
    }
    
    // Y-axis (if 0 is in view)
    if (bounds.minX <= 0 && bounds.maxX >= 0) {
        const xPos = graphToCanvas(0, 0, graphType, canvas).x;
        ctx.beginPath();
        ctx.moveTo(xPos, GRAPH_PADDING);
        ctx.lineTo(xPos, canvas.height - GRAPH_PADDING);
        ctx.stroke();
    }
    
    // Labels
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    
    // X-axis labels
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const x = bounds.minX + (i / GRID_DIVISIONS) * (bounds.maxX - bounds.minX);
        const canvasPos = graphToCanvas(x, 0, graphType, canvas);
        ctx.fillText(x.toFixed(1), canvasPos.x, canvas.height - GRAPH_PADDING + 5);
    }
    
    // Y-axis labels
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const y = bounds.minY + (i / GRID_DIVISIONS) * (bounds.maxY - bounds.minY);
        const canvasPos = graphToCanvas(0, y, graphType, canvas);
        ctx.fillText(y.toFixed(1), GRAPH_PADDING - 5, canvasPos.y);
    }
}

// Draw graph
function drawGraph(graphType) {
    const canvas = canvases[graphType];
    const ctx = contexts[graphType];
    const pts = points[graphType];
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    drawGrid(ctx, graphType, canvas);
    
    // Draw lines
    ctx.strokeStyle = COLORS[graphType];
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < pts.length; i++) {
        const canvasPos = graphToCanvas(pts[i].x, pts[i].y, graphType, canvas);
        
        if (i === 0) {
            ctx.moveTo(canvasPos.x, canvasPos.y);
        } else {
            // For acceleration, draw step function
            if (graphType === 'acceleration') {
                const prevCanvasPos = graphToCanvas(pts[i-1].x, pts[i-1].y, graphType, canvas);
                ctx.lineTo(canvasPos.x, prevCanvasPos.y);
                ctx.lineTo(canvasPos.x, canvasPos.y);
            } else {
                ctx.lineTo(canvasPos.x, canvasPos.y);
            }
        }
    }
    
    ctx.stroke();
    
    // Draw playhead if animating
    if (isPlaying && currentAnimationTime >= 0) {
        const playheadCanvas = graphToCanvas(currentAnimationTime, 0, graphType, canvas);
        ctx.strokeStyle = '#666666';
        ctx.lineWidth = 0.5;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(playheadCanvas.x, GRAPH_PADDING);
        ctx.lineTo(playheadCanvas.x, canvas.height - GRAPH_PADDING);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Draw points
    for (let i = 0; i < pts.length; i++) {
        const canvasPos = graphToCanvas(pts[i].x, pts[i].y, graphType, canvas);
        
        ctx.fillStyle = COLORS[graphType];
        ctx.beginPath();
        ctx.arc(canvasPos.x, canvasPos.y, POINT_RADIUS, 0, 2 * Math.PI);
        ctx.fill();
        
        // Point border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

// Calculate kinematics for a segment
function calculateSegmentKinematics(segmentIndex) {
    if (segmentIndex < 0 || segmentIndex >= NUM_SEGMENTS) return null;
    
    const t1 = points.acceleration[segmentIndex].x;
    const t2 = points.acceleration[segmentIndex + 1].x;
    const dt = t2 - t1;
    
    const a = points.acceleration[segmentIndex].y;
    const u = points.velocity[segmentIndex].y;
    const v = points.velocity[segmentIndex + 1].y;
    const s1 = points.displacement[segmentIndex].y;
    const s2 = points.displacement[segmentIndex + 1].y;
    const s = s2 - s1;
    
    return {
        u: u,           // Initial velocity
        v: v,           // Final velocity
        s: s,           // Displacement
        a: a,           // Acceleration
        t: dt,          // Time duration
        t1: t1,         // Start time
        t2: t2          // End time
    };
}

// Update velocity from acceleration
function updateVelocityFromAcceleration() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.acceleration[a].x - points.acceleration[b].x
    );
    
    for (let i = 1; i < NUM_POINTS; i++) {
        const prevIdx = sortedIndices[i - 1];
        const currIdx = sortedIndices[i];
        
        const dt = points.acceleration[currIdx].x - points.acceleration[prevIdx].x;
        const a = points.acceleration[prevIdx].y;
        
        // v = u + at
        points.velocity[currIdx].y = points.velocity[prevIdx].y + a * dt;
        points.velocity[currIdx].x = points.acceleration[currIdx].x;
    }
}

// Update displacement from velocity
function updateDisplacementFromVelocity() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.velocity[a].x - points.velocity[b].x
    );
    
    for (let i = 1; i < NUM_POINTS; i++) {
        const prevIdx = sortedIndices[i - 1];
        const currIdx = sortedIndices[i];
        
        const dt = points.velocity[currIdx].x - points.velocity[prevIdx].x;
        const u = points.velocity[prevIdx].y;
        const v = points.velocity[currIdx].y;
        
        // For constant acceleration: s = ut + 0.5at¬≤ = (u + v)/2 * t
        const avgVelocity = (u + v) / 2;
        points.displacement[currIdx].y = points.displacement[prevIdx].y + avgVelocity * dt;
        points.displacement[currIdx].x = points.velocity[currIdx].x;
    }
}

// Update acceleration from velocity
function updateAccelerationFromVelocity() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.velocity[a].x - points.velocity[b].x
    );
    
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const currIdx = sortedIndices[i];
        const nextIdx = sortedIndices[i + 1];
        
        const dt = points.velocity[nextIdx].x - points.velocity[currIdx].x;
        const dv = points.velocity[nextIdx].y - points.velocity[currIdx].y;
        
        // a = dv/dt
        points.acceleration[currIdx].y = dt > 0 ? dv / dt : 0;
        points.acceleration[currIdx].x = points.velocity[currIdx].x;
    }
    
    // Last acceleration point matches x coordinate
    points.acceleration[sortedIndices[NUM_SEGMENTS]].x = points.velocity[sortedIndices[NUM_SEGMENTS]].x;
}

// Update velocity from displacement
function updateVelocityFromDisplacement() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.displacement[a].x - points.displacement[b].x
    );
    
    // First pass: calculate average velocities
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const currIdx = sortedIndices[i];
        const nextIdx = sortedIndices[i + 1];
        
        const dt = points.displacement[nextIdx].x - points.displacement[currIdx].x;
        const ds = points.displacement[nextIdx].y - points.displacement[currIdx].y;
        
        // Average velocity for the segment
        const avgVelocity = dt > 0 ? ds / dt : 0;
        
        // For constant acceleration, we need to solve for initial and final velocities
        // We'll use the constraint that acceleration is constant in each segment
        if (i === 0) {
            points.velocity[currIdx].y = avgVelocity;
        }
        
        points.velocity[currIdx].x = points.displacement[currIdx].x;
    }
    
    // Last point
    points.velocity[sortedIndices[NUM_SEGMENTS]].x = points.displacement[sortedIndices[NUM_SEGMENTS]].x;
    
    // Second pass: adjust velocities to maintain constant acceleration
    for (let i = 1; i < NUM_SEGMENTS; i++) {
        const prevIdx = sortedIndices[i - 1];
        const currIdx = sortedIndices[i];
        const nextIdx = sortedIndices[i + 1];
        
        const dt1 = points.displacement[currIdx].x - points.displacement[prevIdx].x;
        const dt2 = points.displacement[nextIdx].x - points.displacement[currIdx].x;
        const ds1 = points.displacement[currIdx].y - points.displacement[prevIdx].y;
        const ds2 = points.displacement[nextIdx].y - points.displacement[currIdx].y;
        
        if (dt1 > 0 && dt2 > 0) {
            // Calculate velocities that maintain constant acceleration
            const avgV1 = ds1 / dt1;
            const avgV2 = ds2 / dt2;
            
            // The velocity at the middle point should be such that
            // the acceleration is continuous
            points.velocity[currIdx].y = (avgV1 + avgV2) / 2;
        }
    }
    
    // Final velocity
    const lastSegmentIdx = NUM_SEGMENTS - 1;
    const prevIdx = sortedIndices[lastSegmentIdx];
    const lastIdx = sortedIndices[NUM_SEGMENTS];
    
    const dt = points.displacement[lastIdx].x - points.displacement[prevIdx].x;
    const ds = points.displacement[lastIdx].y - points.displacement[prevIdx].y;
    
    if (dt > 0) {
        const avgV = ds / dt;
        points.velocity[lastIdx].y = 2 * avgV - points.velocity[prevIdx].y;
    }
}

// Update all graphs based on which one was modified
function updateGraphsFrom(sourceGraph) {
    if (sourceGraph === 'acceleration') {
        updateVelocityFromAcceleration();
        updateDisplacementFromVelocity();
    } else if (sourceGraph === 'velocity') {
        updateAccelerationFromVelocity();
        updateDisplacementFromVelocity();
    } else if (sourceGraph === 'displacement') {
        updateVelocityFromDisplacement();
        updateAccelerationFromVelocity();
    }
    
    updateAllGraphs();
    updateOriginPosition();
}

// Update all graph displays
function updateAllGraphs() {
    drawGraph('displacement');
    drawGraph('velocity');
    drawGraph('acceleration');
}

// Find nearest point
function findNearestPoint(canvasX, canvasY, graphType, canvas) {
    const pts = points[graphType];
    let minDist = Infinity;
    let nearestIdx = -1;
    
    for (let i = 0; i < pts.length; i++) {
        const canvasPos = graphToCanvas(pts[i].x, pts[i].y, graphType, canvas);
        const dist = Math.sqrt(
            Math.pow(canvasX - canvasPos.x, 2) + 
            Math.pow(canvasY - canvasPos.y, 2)
        );
        
        if (dist < minDist && dist < POINT_RADIUS * 3) {
            minDist = dist;
            nearestIdx = i;
        }
    }
    
    return nearestIdx;
}

// Find segment at x position
function findSegmentAtX(x, graphType) {
    const pts = points[graphType];
    
    // Sort indices by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        pts[a].x - pts[b].x
    );
    
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const idx1 = sortedIndices[i];
        const idx2 = sortedIndices[i + 1];
        
        if (x >= pts[idx1].x && x <= pts[idx2].x) {
            return i;
        }
    }
    
    return -1;
}

// Mouse event handlers
function handleMouseDown(e, graphType) {
    const canvas = canvases[graphType];
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    
    const pointIdx = findNearestPoint(canvasX, canvasY, graphType, canvas);
    
    if (pointIdx !== -1) {
        isDragging = true;
        draggedPoint = pointIdx;
        draggedGraph = graphType;
        isShiftDragging = e.shiftKey;
        initialDragValue = points[graphType][pointIdx].y;
        canvas.style.cursor = 'grabbing';
        
        // Clear tooltip timeout when starting to drag
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        tooltip.style.display = 'none';
    }
}

function handleMouseMove(e, graphType) {
    const canvas = canvases[graphType];
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    
    // Check if mouse has moved significantly
    const mouseMoved = Math.abs(e.clientX - lastMousePosition.x) > 5 || 
                     Math.abs(e.clientY - lastMousePosition.y) > 5;
    
    if (mouseMoved) {
        lastMousePosition = { x: e.clientX, y: e.clientY };
        // Clear any existing tooltip timeout and hide tooltip
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        tooltip.style.display = 'none';
    }
    
    // Handle dragging
    if (isDragging && draggedGraph === graphType) {
        // Stop animation when dragging
        if (isPlaying) {
            stopAnimation();
        }
        
        const graphPos = canvasToGraph(canvasX, canvasY, graphType, canvas);
        
        // Calculate delta for shift-drag
        const delta = graphPos.y - points[graphType][draggedPoint].y;
        
        // Update point position
        points[graphType][draggedPoint].x = Math.max(0, graphPos.x);
        points[graphType][draggedPoint].y = graphPos.y;
        
        // If shift is held, update all points to the right
        if (isShiftDragging) {
            for (let i = draggedPoint + 1; i < NUM_POINTS; i++) {
                points[graphType][i].y += delta;
            }
        }
        
        // Ensure x coordinates don't cross
        if (draggedPoint > 0) {
            points[graphType][draggedPoint].x = Math.max(
                points[graphType][draggedPoint].x,
                points[graphType][draggedPoint - 1].x + 0.1
            );
        }
        if (draggedPoint < NUM_POINTS - 1) {
            points[graphType][draggedPoint].x = Math.min(
                points[graphType][draggedPoint].x,
                points[graphType][draggedPoint + 1].x - 0.1
            );
        }
        
        updateGraphsFrom(graphType);
        updateOriginPosition();
    }
    
    // Show tooltip for segments after delay
    if (!isDragging && mouseMoved) {
        tooltipTimeout = setTimeout(() => {
            const graphPos = canvasToGraph(canvasX, canvasY, graphType, canvas);
            const segmentIdx = findSegmentAtX(graphPos.x, graphType);
            
            if (segmentIdx !== -1) {
                const kinematics = calculateSegmentKinematics(segmentIdx);
                if (kinematics) {
                    const tooltipText = `Segment ${segmentIdx + 1} (t: ${kinematics.t1.toFixed(2)} ‚Üí ${kinematics.t2.toFixed(2)} s)\n` +
                                      `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                      `u = ${kinematics.u.toFixed(3)} m/s\n` +
                                      `v = ${kinematics.v.toFixed(3)} m/s\n` +
                                      `s = ${kinematics.s.toFixed(3)} m\n` +
                                      `a = ${kinematics.a.toFixed(3)} m/s¬≤\n` +
                                      `t = ${kinematics.t.toFixed(3)} s`;
                    
                    tooltip.textContent = tooltipText;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 10) + 'px';
                    tooltip.style.top = (e.clientY - 10) + 'px';
                }
            }
        }, TOOLTIP_DELAY);
    }
    
    // Update cursor
    const pointIdx = findNearestPoint(canvasX, canvasY, graphType, canvas);
    canvas.style.cursor = pointIdx !== -1 ? 'grab' : 'crosshair';
}

function handleMouseUp(e, graphType) {
    if (isDragging) {
        isDragging = false;
        draggedPoint = null;
        draggedGraph = null;
        isShiftDragging = false;
        initialDragValue = null;
        canvases[graphType].style.cursor = 'crosshair';
        saveState();
    }
}

function handleMouseLeave(e, graphType) {
    tooltip.style.display = 'none';
    if (tooltipTimeout) {
        clearTimeout(tooltipTimeout);
        tooltipTimeout = null;
    }
    if (!isDragging) {
        canvases[graphType].style.cursor = 'crosshair';
    }
}

// Animation functions
function calculateDisplacementAtTime(t) {
    // Sort points by time
    const sortedPoints = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.displacement[a].x - points.displacement[b].x
    );
    
    // Handle edge cases
    if (t <= points.displacement[sortedPoints[0]].x) {
        return points.displacement[sortedPoints[0]].y;
    }
    if (t >= points.displacement[sortedPoints[NUM_POINTS - 1]].x) {
        return points.displacement[sortedPoints[NUM_POINTS - 1]].y;
    }
    
    // Find the segment containing time t
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const idx1 = sortedPoints[i];
        const idx2 = sortedPoints[i + 1];
        
        const t1 = points.displacement[idx1].x;
        const t2 = points.displacement[idx2].x;
        
        if (t >= t1 && t < t2) {
            // Get kinematic values at start of segment
            const s0 = points.displacement[idx1].y;
            const v0 = points.velocity[idx1].y;
            const a = points.acceleration[idx1].y; // Constant for this segment
            
            // Time within segment
            const dt = t - t1;
            
            // Calculate displacement using kinematic equation
            // s = s0 + v0*t + 0.5*a*t¬≤
            return s0 + v0 * dt + 0.5 * a * dt * dt;
        }
    }
    
    return points.displacement[sortedPoints[NUM_SEGMENTS]].y;
}

function startAnimation() {
    if (isPlaying) return;
    
    isPlaying = true;
    playBtn.textContent = '‚è∏ Pause';
    animationStartTime = performance.now();
    animationPhase = 'playing';
    waitStartTime = null;
    movingObject.style.transition = 'none';
    movingObject.style.opacity = '1';
    
    // Get displacement range
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    const displacementRange = maxDisplacement - minDisplacement;
    
    // Calculate origin position and scaling
    let originPixel;
    let pixelsPerUnit;
    const boxWidth = animationBox.offsetWidth;
    const usableWidth = boxWidth - 60; // Leave margin for object
    
    if (minDisplacement >= 0) {
        // All positive: origin on left
        originPixel = 20;
        pixelsPerUnit = displacementRange > 0 ? usableWidth / displacementRange : 50;
    } else if (maxDisplacement <= 0) {
        // All negative: origin on right
        originPixel = boxWidth - 20;
        pixelsPerUnit = displacementRange > 0 ? usableWidth / displacementRange : 50;
    } else {
        // Mixed: position proportionally
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        
        // Origin position based on proportion
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    // Get time range
    const times = points.displacement.map(p => p.x);
    const maxTime = Math.max(...times);
    const totalDuration = maxTime * 1000; // Convert to milliseconds
    
    animate();
    
    function animate() {
        if (!isPlaying) return;
        
        const elapsed = performance.now() - animationStartTime;
        
        if (animationPhase === 'playing') {
            if (elapsed < totalDuration) {
                // Normal playback
                const currentTime = elapsed / 1000;
                currentAnimationTime = currentTime;
                
                // Calculate current displacement
                const currentDisplacement = calculateDisplacementAtTime(currentTime);
                
                // Convert displacement to pixel position
                const pixelOffset = currentDisplacement * pixelsPerUnit;
                const pixelPosition = originPixel + pixelOffset;
                
                // Update object position
                movingObject.style.left = pixelPosition + 'px';
                
                // Update velocity display
                const currentVelocity = calculateVelocityAtTime(currentTime);
                if (Math.abs(currentVelocity) > 0.01) {
                    velocityDisplay.textContent = `${currentVelocity.toFixed(1)} m/s`;
                    velocityDisplay.style.display = 'block';
                    velocityDisplay.style.left = pixelPosition + 'px';
                } else {
                    velocityDisplay.style.display = 'none';
                }
                
                // Update acceleration vector
                const currentAcceleration = calculateAccelerationAtTime(currentTime);
                drawAccelerationVector(currentAcceleration);
                accelerationVector.style.left = pixelPosition + 'px';
                
                // Redraw graphs to show playhead
                updateAllGraphs();
            } else {
                // Finished playing, start waiting
                animationPhase = 'waiting';
                waitStartTime = performance.now();
                currentAnimationTime = maxTime;
                
                // Hide velocity display at end
                velocityDisplay.style.display = 'none';
                accelerationVector.style.display = 'none';
                
                updateAllGraphs();
            }
        } else if (animationPhase === 'waiting') {
            // Wait for 2 seconds
            if (performance.now() - waitStartTime >= 2000) {
                // Start return animation
                animationPhase = 'returning';
                movingObject.style.transition = 'opacity 0.1s, left 1s ease-in-out';
                movingObject.style.opacity = '0.25';
                // Small delay to ensure opacity is set before movement
                setTimeout(() => {
                    movingObject.style.left = originPixel + 'px';
                }, 100);
                
                // Hide velocity and acceleration displays
                velocityDisplay.style.display = 'none';
                accelerationVector.style.display = 'none';
                
                // Stop after transition completes
                setTimeout(() => {
                    stopAnimation();
                }, 1100);
            }
        }
        
        if (animationPhase !== 'returning') {
            animationFrame = requestAnimationFrame(animate);
        }
    }
}

function stopAnimation() {
    isPlaying = false;
    playBtn.textContent = '‚ñ∂Ô∏è Play';
    currentAnimationTime = 0;
    animationPhase = 'playing';
    waitStartTime = null;
    
    // Reset object
    movingObject.style.transition = 'none';
    movingObject.style.opacity = '1';
    
    // Hide velocity and acceleration displays
    velocityDisplay.style.display = 'none';
    accelerationVector.style.display = 'none';
    
    // Position at origin
    const originMarker = document.getElementById('originMarker');
    const originPixel = parseFloat(originMarker.style.left);
    movingObject.style.left = originPixel + 'px';
    
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    updateAllGraphs(); // Redraw without playhead
}

// Event listeners
for (let graphType in canvases) {
    const canvas = canvases[graphType];
    
    canvas.addEventListener('mousedown', (e) => handleMouseDown(e, graphType));
    canvas.addEventListener('mousemove', (e) => handleMouseMove(e, graphType));
    canvas.addEventListener('mouseup', (e) => handleMouseUp(e, graphType));
    canvas.addEventListener('mouseleave', (e) => handleMouseLeave(e, graphType));
}

// Global mouse up (in case mouse leaves canvas while dragging)
document.addEventListener('mouseup', () => {
    if (isDragging) {
        isDragging = false;
        draggedPoint = null;
        draggedGraph = null;
        isShiftDragging = false;
        initialDragValue = null;
        saveState();
        for (let canvas of Object.values(canvases)) {
            canvas.style.cursor = 'crosshair';
        }
    }
});

// Handle shift key release
document.addEventListener('keyup', (e) => {
    if (e.key === 'Shift' && isDragging) {
        isShiftDragging = false;
    }
});

// Button event listeners
playBtn.addEventListener('click', () => {
    if (isPlaying) {
        stopAnimation();
    } else {
        startAnimation();
    }
});

resetBtn.addEventListener('click', () => {
    stopAnimation();
    initializePoints();
});

undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

emojiSelector.addEventListener('change', (e) => {
    movingObject.textContent = e.target.value;
});

// Handle window resize
window.addEventListener('resize', () => {
    rulerCanvas.width = animationBox.offsetWidth;
    updateOriginPosition();
});

// Initialize
function initialize() {
    // Set up ruler canvas
    rulerCanvas.width = animationBox.offsetWidth;
    rulerCanvas.height = 20;
    
    // Select random emoji
    const emojis = ['‚öΩ', 'üõ∏', 'üõπ', 'üöÅ', 'üì¶'];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    movingObject.textContent = randomEmoji;
    emojiSelector.value = randomEmoji;
    
    // Initialize points
    initializePoints();
}

initialize();
</script>
</body>
</html>