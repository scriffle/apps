<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pauli's Vector Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            color: #4a5568;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .pauli-intro {
            font-size: 4em;
            animation: pulse 2s infinite;
            display: inline-block;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 0 30px rgba(102, 126, 234, 0.8); }
        }
        
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .nav-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: glow 3s infinite;
        }
        
        .nav-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.4);
        }
        
        .nav-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }
        
        .panel {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.5s ease-out;
        }
        
        .panel.active {
            display: block;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .panel h2 {
            color: #4a5568;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .instructions {
            background: linear-gradient(45deg, #ffeaa7, #fdcb6e);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 25px;
            font-size: 1.1em;
            text-align: center;
            color: #2d3436;
        }
        
        .grid-area {
            background: linear-gradient(45deg, #dfe6e9, #b2bec3);
            border-radius: 15px;
            position: relative;
            margin: 20px 0;
            overflow: hidden;
            border: 3px solid #636e72;
            height: 400px;
            background-image: 
                linear-gradient(rgba(99, 110, 114, 0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(99, 110, 114, 0.3) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        .pauli {
            position: absolute;
            font-size: 2.5em;
            animation: bounce 1s infinite;
            transition: all 0.5s ease;
            z-index: 10;
        }
        
        .path-line {
            position: absolute;
            height: 3px;
            background: #ff7675;
            transform-origin: left center;
            z-index: 5;
        }
        
        .displacement-line {
            position: absolute;
            height: 4px;
            background: #00b894;
            transform-origin: left center;
            z-index: 6;
        }
        
        .point-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #636e72;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 7;
        }
        
        .line-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: bold;
            z-index: 8;
            pointer-events: none;
        }
        
        .distance-label {
            color: #d63031;
        }
        
        .displacement-label {
            color: #00b894;
        }
        
        .compass {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            margin: 20px auto;
            position: relative;
            border: 4px solid #2d3436;
        }
        
        .compass-direction {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .compass-direction:hover {
            background: #ffeaa7;
            transform: scale(1.1);
        }
        
        .compass-direction.selected {
            background: #00b894;
            color: white;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: bold;
            color: #4a5568;
        }
        
        .slider {
            width: 150px;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        .display-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
            min-width: 80px;
            text-align: center;
        }
        
        .input-area {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .input-field {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.1em;
            width: 120px;
            text-align: center;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .action-btn {
            background: linear-gradient(45deg, #55a3ff, #667eea);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .result-display {
            background: linear-gradient(45deg, #00b894, #00cec9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            font-size: 1.3em;
            text-align: center;
            display: none;
        }
        
        .result-display.show {
            display: block;
            animation: slideIn 0.5s ease-out;
        }
        
        .feedback {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
        }
        
        .feedback.success {
            background: linear-gradient(45deg, #00b894, #00cec9);
            color: white;
        }
        
        .feedback.error {
            background: linear-gradient(45deg, #ff7675, #e17055);
            color: white;
        }
        
        .feedback.show {
            display: block;
            animation: slideIn 0.5s ease-out;
        }
        
        .sorting-area {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .drop-zone {
            background: linear-gradient(45deg, #fd79a8, #e84393);
            color: white;
            padding: 20px;
            border-radius: 15px;
            min-height: 200px;
            min-width: 200px;
            border: 3px dashed rgba(255, 255, 255, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .drop-zone.vector {
            background: linear-gradient(45deg, #00cec9, #00b894);
        }
        
        .drop-zone.dragover {
            border-color: #ffeaa7;
            background: rgba(255, 234, 167, 0.8);
            color: #2d3436;
        }
        
        .quantity-item {
            background: rgba(255, 255, 255, 0.9);
            color: #2d3436;
            padding: 10px 15px;
            border-radius: 10px;
            margin: 5px;
            cursor: grab;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .quantity-item:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .quantity-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .quantity-bank {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .stats-display {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .stat-item {
            text-align: center;
            color: #4a5568;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 1.1em;
            margin-top: 5px;
        }
        
        .star {
            position: fixed;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.5s ease-out;
        }
        
        .star.fade {
            opacity: 0;
            transform: scale(0.5);
        }
        
        .speed-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 10px;
            font-weight: bold;
            color: #4a5568;
            display: none;
            z-index: 999;
        }
        
        .explosion {
            position: fixed;
            font-size: 3em;
            pointer-events: none;
            z-index: 1001;
            animation: explode 0.8s ease-out;
        }
        
        @keyframes explode {
            0% { transform: scale(0.5); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        .pauli-launching {
            position: fixed;
            z-index: 998;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="pauli-intro">üëÄ</div>
            <h1>Pauli's Vector Adventure</h1>
            <p>Explore Scalars vs Vectors with your rolling friend</p>
        </div>
        
        <div class="nav-buttons">
            <button class="nav-btn active" onclick="showPanel('pathplotter')">üó∫Ô∏è Path Plotter</button>
            <button class="nav-btn" onclick="showPanel('compass')">üß≠ Direction Selector</button>
            <button class="nav-btn" onclick="showPanel('sorting')">üéÆ Vector Sorting</button>
        </div>
        
        <!-- Panel 1: Path Plotter -->
        <div id="pathplotter" class="panel active">
            <h2>üó∫Ô∏è Pauli's Path Plotter</h2>
            <div class="instructions">
                Click points on the grid to create Pauli's path. Watch the difference between <span title="Total path length traveled" style="cursor: help; border-bottom: 1px dotted #4a5568;">distance</span> traveled and <span title="Straight-line distance from start to finish with direction" style="cursor: help; border-bottom: 1px dotted #4a5568;">displacement</span>.
            </div>
            
            <div class="grid-area" id="gridArea" onclick="addPoint(event)">
                <div class="pauli" id="gridPauli">üëÄ</div>
                <div class="pauli" id="displacementPauli" style="display: none;">üëÄ</div>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="action-btn" onclick="animatePath()">üöÄ Animate Pauli's Journey</button>
                <button class="action-btn" onclick="clearPath()">üóëÔ∏è Clear Path</button>
            </div>
            
            <div id="movementOptions" style="text-align: center; margin: 20px 0; display: none;">
                <p style="margin-bottom: 10px; font-weight: bold; color: #4a5568;">Movement Style:</p>
                <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="radio" name="movementStyle" value="realistic" checked>
                        <span>‚ö° Realistic</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="radio" name="movementStyle" value="zoomy">
                        <span>üìè Zoomy</span>
                    </label>
                </div>
            </div>
            
            <div class="stats-display" id="pathStats">
                <div class="stat-item">
                    <div class="stat-value" id="totalDistance">0</div>
                    <div class="stat-label"><span title="Total path length traveled (scalar quantity)" style="cursor: help; border-bottom: 1px dotted #667eea;">Distance</span> (scalar)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="displacementMag">0</div>
                    <div class="stat-label"><span title="Straight-line distance from start to finish with direction (vector quantity)" style="cursor: help; border-bottom: 1px dotted #667eea;">Displacement</span> (vector)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="pathPoints">0</div>
                    <div class="stat-label">Points Clicked</div>
                </div>
            </div>
            
            <div class="feedback" id="pathFeedback"></div>
        </div>
        
        <!-- Panel 2: Direction Selector -->
        <div id="compass" class="panel">
            <h2>üß≠ Direction Selector</h2>
            <div class="instructions">
                Set Pauli's <span title="Speed with direction - a vector quantity" style="cursor: help; border-bottom: 1px dotted #4a5568;">velocity</span> by choosing direction and <span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted #4a5568;">magnitude</span>. See how <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted #4a5568;">vectors</span> have both size and direction.
            </div>
            
            <div class="speed-indicator" id="speedIndicator">Speed: 0 m/s</div>
            
            <div style="text-align: center; margin: 20px 0;">
                <div class="pauli-intro" id="compassPauli">üëÄ</div>
                <p style="font-size: 1.2em; margin: 10px 0;">Choose Pauli's direction</p>
            </div>
            
            <div class="compass" id="compassRose">
                <div class="compass-direction" style="top: 5px; left: 50%; transform: translateX(-50%);" onclick="selectDirection('N', 0)">N</div>
                <div class="compass-direction" style="top: 25%; right: 5px;" onclick="selectDirection('NE', 45)">NE</div>
                <div class="compass-direction" style="top: 50%; right: 5px; transform: translateY(-50%);" onclick="selectDirection('E', 90)">E</div>
                <div class="compass-direction" style="bottom: 25%; right: 5px;" onclick="selectDirection('SE', 135)">SE</div>
                <div class="compass-direction" style="bottom: 5px; left: 50%; transform: translateX(-50%);" onclick="selectDirection('S', 180)">S</div>
                <div class="compass-direction" style="bottom: 25%; left: 5px;" onclick="selectDirection('SW', 225)">SW</div>
                <div class="compass-direction" style="top: 50%; left: 5px; transform: translateY(-50%);" onclick="selectDirection('W', 270)">W</div>
                <div class="compass-direction" style="top: 25%; left: 5px;" onclick="selectDirection('NW', 315)">NW</div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Speed <span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted #4a5568;">Magnitude</span></label>
                    <input type="range" class="slider" id="speedMagnitude" min="1" max="20" value="10">
                    <div class="display-value" id="speedMagDisplay">10 m/s</div>
                </div>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="action-btn" onclick="launchPauliVector()">üöÄ Launch Pauli</button>
                <button class="action-btn" onclick="resetCompass()">üîÑ Reset</button>
            </div>
            
            <div class="result-display" id="compassResult"></div>
            <div class="feedback" id="compassFeedback"></div>
        </div>
        
        <!-- Panel 3: Vector Sorting Game -->
        <div id="sorting" class="panel">
            <h2>üéÆ Vector vs Scalar Sorting</h2>
            <div class="instructions">
                Drag the physical quantities into the correct category. <span title="Quantities with magnitude only (size but no direction)" style="cursor: help; border-bottom: 1px dotted #4a5568;">Scalars</span> have only <span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted #4a5568;">magnitude</span>, <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted #4a5568;">vectors</span> have <span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted #4a5568;">magnitude</span> AND direction.
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <div class="pauli-intro">üëÄ</div>
                <p style="font-size: 1.2em; margin: 10px 0;">Help Pauli sort these quantities</p>
            </div>
            
            <div class="quantity-bank" id="quantityBank">
                <!-- Quantities will be populated by JavaScript -->
            </div>
            
            <div class="sorting-area">
                <div class="drop-zone scalar" id="scalarZone" ondrop="drop(event, 'scalar')" ondragover="allowDrop(event)">
                    <h3>üìè <span title="Quantities with magnitude only (size but no direction)" style="cursor: help; border-bottom: 1px dotted white;">Scalars</span></h3>
                    <p><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span> Only</p>
                </div>
                <div class="drop-zone vector" id="vectorZone" ondrop="drop(event, 'vector')" ondragover="allowDrop(event)">
                    <h3>üß≠ <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted white;">Vectors</span></h3>
                    <p><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span> + Direction</p>
                </div>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="action-btn" onclick="checkSorting()">‚úÖ Check My Sorting</button>
                <button class="action-btn" onclick="resetSorting()">üîÑ Reset Game</button>
                <button class="action-btn" onclick="newSortingRound()">üé≤ New Round</button>
            </div>
            
            <div class="stats-display">
                <div class="stat-item">
                    <div class="stat-value" id="correctCount">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalItems">0</div>
                    <div class="stat-label">Total Items</div>
                </div>
            </div>
            
            <div class="feedback" id="sortingFeedback"></div>
        </div>
    </div>

    <script>
        // Global variables
        let pathPoints = [];
        let currentDirection = '';
        let currentAngle = 0;
        let vectorList = [];
        
        // Quantities for sorting game
        const quantities = {
            scalars: ['Temperature', 'Mass', 'Time', 'Distance', 'Speed', 'Energy', 'Volume', 'Density'],
            vectors: ['Velocity', 'Acceleration', 'Force', 'Displacement', 'Wind Velocity', 'Weight', 'Gravitational Force', 'Magnetic Force']
        };
        
        let currentGameItems = [];
        let sortingScore = 0;
        
        // Panel switching function
        function showPanel(panelId) {
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => panel.classList.remove('active'));
            
            document.getElementById(panelId).classList.add('active');
            
            const buttons = document.querySelectorAll('.nav-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const clickedButton = Array.from(buttons).find(btn => 
                btn.onclick && btn.onclick.toString().includes(panelId)
            );
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
        }
        
        // Path Plotter Functions
        function addPoint(event) {
            const gridArea = document.getElementById('gridArea');
            const rect = gridArea.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            pathPoints.push({x, y});
            
            // Add visual point marker
            const pointMarker = document.createElement('div');
            pointMarker.className = 'point-marker';
            pointMarker.style.left = x + 'px';
            pointMarker.style.top = y + 'px';
            gridArea.appendChild(pointMarker);
            
            updatePathStats();
            drawLinesRealTime();
            
            // Show movement options when 2+ points
            const movementOptions = document.getElementById('movementOptions');
            if (pathPoints.length >= 2) {
                movementOptions.style.display = 'block';
            }
            
            showFeedback('pathFeedback', `Point ${pathPoints.length} added. Pauli says: Great navigation üëÄ`, 'success');
        }
        
        function drawLinesRealTime() {
            // Clear existing lines and labels
            const existingLines = document.querySelectorAll('.displacement-line, .path-line, .line-label');
            existingLines.forEach(element => element.remove());
            
            if (pathPoints.length < 2) return;
            
            const gridArea = document.getElementById('gridArea');
            
            // Draw path lines (red) with labels
            for (let i = 1; i < pathPoints.length; i++) {
                const start = pathPoints[i-1];
                const end = pathPoints[i];
                const line = createLineWithLabel(start, end, 'path-line', 'Distance', 'distance-label');
                gridArea.appendChild(line.lineElement);
                gridArea.appendChild(line.labelElement);
            }
            
            // Draw displacement line (green) with label
            const start = pathPoints[0];
            const end = pathPoints[pathPoints.length - 1];
            const dispLine = createLineWithLabel(start, end, 'displacement-line', 'Displacement', 'displacement-label');
            gridArea.appendChild(dispLine.lineElement);
            gridArea.appendChild(dispLine.labelElement);
        }
        
        function createLineWithLabel(start, end, lineClass, labelText, labelClass) {
            const line = document.createElement('div');
            line.className = lineClass;
            
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const length = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            line.style.left = start.x + 'px';
            line.style.top = start.y + 'px';
            line.style.width = length + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            
            // Create label positioned at the center of the line
            const label = document.createElement('div');
            label.className = `line-label ${labelClass}`;
            label.textContent = labelText;
            
            // Calculate label position (center of line, above it)
            const centerX = start.x + (dx / 2);
            const centerY = start.y + (dy / 2) - 15; // 15px above the line
            
            label.style.left = centerX - 30 + 'px'; // Offset to center the text
            label.style.top = centerY + 'px';
            
            return {
                lineElement: line,
                labelElement: label
            };
        }
        
        function updatePathStats() {
            document.getElementById('pathPoints').textContent = pathPoints.length;
            
            if (pathPoints.length < 2) {
                document.getElementById('totalDistance').textContent = '0';
                document.getElementById('displacementMag').textContent = '0';
                return;
            }
            
            // Calculate total distance (scalar)
            let totalDistance = 0;
            for (let i = 1; i < pathPoints.length; i++) {
                const dx = pathPoints[i].x - pathPoints[i-1].x;
                const dy = pathPoints[i].y - pathPoints[i-1].y;
                totalDistance += Math.sqrt(dx*dx + dy*dy);
            }
            
            // Calculate displacement (vector magnitude)
            const start = pathPoints[0];
            const end = pathPoints[pathPoints.length - 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const displacement = Math.sqrt(dx*dx + dy*dy);
            
            document.getElementById('totalDistance').textContent = Math.round(totalDistance) + 'px';
            document.getElementById('displacementMag').textContent = Math.round(displacement) + 'px';
        }
        
        function animatePath() {
            if (pathPoints.length < 2) {
                showFeedback('pathFeedback', 'Pauli says: I need at least 2 points to travel üëÄ', 'error');
                return;
            }
            
            const pathPauli = document.getElementById('gridPauli');
            const dispPauli = document.getElementById('displacementPauli');
            
            // Show displacement Pauli
            dispPauli.style.display = 'block';
            
            // Calculate total path distance for timing
            let totalPathDistance = 0;
            for (let i = 1; i < pathPoints.length; i++) {
                const dx = pathPoints[i].x - pathPoints[i-1].x;
                const dy = pathPoints[i].y - pathPoints[i-1].y;
                totalPathDistance += Math.sqrt(dx*dx + dy*dy);
            }
            
            // Calculate displacement distance
            const start = pathPoints[0];
            const end = pathPoints[pathPoints.length - 1];
            const dispDx = end.x - start.x;
            const dispDy = end.y - start.y;
            const displacementDistance = Math.sqrt(dispDx*dispDx + dispDy*dispDy);
            
            const totalAnimationTime = 3000; // 3 seconds total
            
            // Animate path Pauli (along the red path)
            let currentPoint = 0;
            let currentTime = 0;
            
            function movePathPauli() {
                if (currentPoint < pathPoints.length) {
                    pathPauli.style.left = pathPoints[currentPoint].x - 25 + 'px';
                    pathPauli.style.top = pathPoints[currentPoint].y - 25 + 'px';
                    
                    if (currentPoint < pathPoints.length - 1) {
                        // Calculate time for this segment based on distance
                        const segmentStart = pathPoints[currentPoint];
                        const segmentEnd = pathPoints[currentPoint + 1];
                        const segmentDistance = Math.sqrt(
                            Math.pow(segmentEnd.x - segmentStart.x, 2) + 
                            Math.pow(segmentEnd.y - segmentStart.y, 2)
                        );
                        const segmentTime = (segmentDistance / totalPathDistance) * totalAnimationTime;
                        
                        currentPoint++;
                        setTimeout(movePathPauli, segmentTime);
                    }
                }
            }
            
            // Animate displacement Pauli (straight line)
            function moveDisplacementPauli() {
                const startTime = Date.now();
                
                function updatePosition() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalAnimationTime, 1);
                    
                    const currentX = start.x + (dispDx * progress);
                    const currentY = start.y + (dispDy * progress);
                    
                    dispPauli.style.left = currentX - 25 + 'px';
                    dispPauli.style.top = currentY - 25 + 'px';
                    
                    if (progress < 1) {
                        requestAnimationFrame(updatePosition);
                    } else {
                        // Animation complete
                        setTimeout(() => {
                            showFeedback('pathFeedback', `Journey complete. Red Pauli traveled the full distance, green Pauli took the displacement shortcut üëÄ`, 'success');
                        }, 500);
                    }
                }
                
                updatePosition();
            }
            
            // Start both animations simultaneously
            movePathPauli();
            moveDisplacementPauli();
        }
        
        function clearPath() {
            pathPoints = [];
            const pathPauli = document.getElementById('gridPauli');
            const dispPauli = document.getElementById('displacementPauli');
            
            // Reset both Paulis
            pathPauli.style.left = '20px';
            pathPauli.style.top = '20px';
            dispPauli.style.left = '20px';
            dispPauli.style.top = '20px';
            dispPauli.style.display = 'none';
            
            // Clear all visual elements
            const elements = document.querySelectorAll('.displacement-line, .path-line, .point-marker, .line-label');
            elements.forEach(element => element.remove());
            
            updatePathStats();
            document.getElementById('pathFeedback').classList.remove('show');
        }
        
        // Remove the old showDisplacement function since we draw lines real-time now
        
        // Direction Selector Functions
        let isLaunching = false;
        let launchInterval;
        let starInterval;
        
        document.getElementById('speedMagnitude').addEventListener('input', function() {
            document.getElementById('speedMagDisplay').textContent = this.value + ' m/s';
        });
        
        function selectDirection(direction, angle) {
            currentDirection = direction;
            currentAngle = angle;
            
            // Update compass visual
            const directions = document.querySelectorAll('.compass-direction');
            directions.forEach(dir => dir.classList.remove('selected'));
            event.target.classList.add('selected');
            
            showFeedback('compassFeedback', `Pauli says: Direction set to ${direction} (${angle}¬∞) üëÄ`, 'success');
        }
        
        function launchPauliVector() {
            if (!currentDirection) {
                showFeedback('compassFeedback', 'Pauli says: Choose a direction first üëÄ', 'error');
                return;
            }
            
            if (isLaunching) return;
            
            const magnitude = parseFloat(document.getElementById('speedMagnitude').value);
            const pauli = document.getElementById('compassPauli');
            const speedIndicator = document.getElementById('speedIndicator');
            
            // Show vector info during launch
            showResult('compassResult', `
                <div style="font-size: 1.5em;">üöÄ Vector Launch Active üöÄ</div>
                <div><strong><span title="Speed with direction - a vector quantity" style="cursor: help; border-bottom: 1px dotted white;">Velocity</span> Vector:</strong> ${magnitude} m/s ${currentDirection}</div>
                <div><strong><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span>:</strong> ${magnitude} m/s (<span title="Quantities with magnitude only" style="cursor: help; border-bottom: 1px dotted white;">scalar</span>)</div>
                <div><strong>Direction:</strong> ${currentAngle}¬∞ (gives it <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted white;">vector</span> properties)</div>
                <div><strong>Pauli says:</strong> Speed is <span title="Quantities with magnitude only" style="cursor: help; border-bottom: 1px dotted white;">scalar</span>, <span title="Speed with direction - a vector quantity" style="cursor: help; border-bottom: 1px dotted white;">velocity</span> is <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted white;">vector</span> üëÄ</div>
            `);
            
            isLaunching = true;
            speedIndicator.style.display = 'block';
            
            // Get Pauli's starting position
            const rect = pauli.getBoundingClientRect();
            let startX = rect.left;
            let startY = rect.top;
            
            // Make Pauli fixed position for movement
            pauli.classList.add('pauli-launching');
            pauli.style.left = startX + 'px';
            pauli.style.top = startY + 'px';
            
            // Calculate direction vector (corrected for proper compass directions)
            const radians = (currentAngle - 90) * Math.PI / 180; // Subtract 90 to make N=0¬∞ point up
            const directionX = Math.cos(radians);
            const directionY = Math.sin(radians);
            
            // Animation parameters - follow slider speed
            const totalTime = Math.random() * 2000 + 1000; // 1-3 seconds
            let startTime = Date.now();
            let currentSpeed = 0;
            
            // Track viewport boundaries for explosion detection
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Star trail
            function createStar(x, y) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = '‚≠ê';
                star.style.left = x + 'px';
                star.style.top = y + 'px';
                
                // Random outward movement
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDistance = Math.random() * 30 + 10;
                const randomX = Math.cos(randomAngle) * randomDistance;
                const randomY = Math.sin(randomAngle) * randomDistance;
                
                document.body.appendChild(star);
                
                // Animate star
                setTimeout(() => {
                    star.style.transform = `translate(${randomX}px, ${randomY}px)`;
                    star.classList.add('fade');
                }, 10);
                
                // Remove star
                setTimeout(() => {
                    if (star.parentElement) {
                        star.remove();
                    }
                }, 500);
            }
            
            // Main animation loop
            function animatelaunch() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / totalTime;
                
                // Exponential acceleration following slider speed
                currentSpeed = magnitude * Math.pow(progress, 0.3);
                
                // Update position
                const distance = currentSpeed * (elapsed / 1000) * 50; // Scale for visible movement
                const newX = startX + (directionX * distance);
                const newY = startY + (directionY * distance);
                
                pauli.style.left = newX + 'px';
                pauli.style.top = newY + 'px';
                
                // Update speed indicator
                speedIndicator.textContent = `Speed: ${currentSpeed.toFixed(1)} m/s`;
                
                // Create stars (20 per time unit)
                if (elapsed % 50 < 16) { // Approximately every 50ms
                    createStar(newX + 25, newY + 25);
                }
                
                // Check if Pauli reached viewport edge (purple background)
                if (newX <= -50 || newX >= viewportWidth || newY <= -50 || newY >= viewportHeight) {
                    // Hit the purple wall - EXPLOSION!
                    createExplosion(newX + 25, newY + 25);
                    
                    // Reset after explosion
                    setTimeout(() => {
                        resetCompass();
                    }, 800);
                    return;
                }
                
                requestAnimationFrame(animatelaunch);
            }
            
            animatelaunch();
        }
        
        function createExplosion(x, y) {
            const explosions = ['üí•', '‚ú®', 'üåü', 'üí´'];
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const explosion = document.createElement('div');
                    explosion.className = 'explosion';
                    explosion.textContent = explosions[Math.floor(Math.random() * explosions.length)];
                    explosion.style.left = (x + Math.random() * 60 - 30) + 'px';
                    explosion.style.top = (y + Math.random() * 60 - 30) + 'px';
                    
                    document.body.appendChild(explosion);
                    
                    setTimeout(() => {
                        if (explosion.parentElement) {
                            explosion.remove();
                        }
                    }, 800);
                }, i * 100);
            }
        }
        
        function resetCompass() {
            isLaunching = false;
            currentDirection = '';
            currentAngle = 0;
            
            const pauli = document.getElementById('compassPauli');
            const speedIndicator = document.getElementById('speedIndicator');
            
            // Reset Pauli position and class
            pauli.classList.remove('pauli-launching');
            pauli.style.left = '';
            pauli.style.top = '';
            
            // Hide speed indicator
            speedIndicator.style.display = 'none';
            
            // Clear compass selection
            const directions = document.querySelectorAll('.compass-direction');
            directions.forEach(dir => dir.classList.remove('selected'));
            
            // Clear displays
            document.getElementById('compassResult').classList.remove('show');
            document.getElementById('compassFeedback').classList.remove('show');
            
            // Clear any remaining stars
            const stars = document.querySelectorAll('.star');
            stars.forEach(star => star.remove());
        }
        
        // Vector Sorting Functions
        function initializeSorting() {
            newSortingRound();
        }
        
        function newSortingRound() {
            currentGameItems = [];
            
            // Select random items from each category (3 scalars + 3 vectors = 6 total)
            const scalarItems = quantities.scalars.sort(() => 0.5 - Math.random()).slice(0, 3);
            const vectorItems = quantities.vectors.sort(() => 0.5 - Math.random()).slice(0, 3);
            
            currentGameItems = [
                ...scalarItems.map(item => ({name: item, type: 'scalar'})),
                ...vectorItems.map(item => ({name: item, type: 'vector'}))
            ];
            
            // Shuffle the items
            currentGameItems.sort(() => 0.5 - Math.random());
            
            // Populate the bank
            const bank = document.getElementById('quantityBank');
            bank.innerHTML = '';
            
            currentGameItems.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'quantity-item';
                itemEl.textContent = item.name;
                itemEl.draggable = true;
                itemEl.dataset.type = item.type;
                itemEl.dataset.index = index;
                itemEl.addEventListener('dragstart', dragStart);
                bank.appendChild(itemEl);
            });
            
            // Clear sorting zones
            document.getElementById('scalarZone').innerHTML = '<h3>üìè <span title="Quantities with magnitude only (size but no direction)" style="cursor: help; border-bottom: 1px dotted white;">Scalars</span></h3><p><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span> Only</p>';
            document.getElementById('vectorZone').innerHTML = '<h3>üß≠ <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted white;">Vectors</span></h3><p><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span> + Direction</p>';
            
            // Update stats
            document.getElementById('correctCount').textContent = '0';
            
            document.getElementById('sortingFeedback').classList.remove('show');
        }
        
        function dragStart(event) {
            event.dataTransfer.setData('text/plain', event.target.dataset.index);
            event.target.classList.add('dragging');
        }
        
        function allowDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        
        function drop(event, zone) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const itemIndex = event.dataTransfer.getData('text/plain');
            const item = currentGameItems[itemIndex];
            const itemElement = document.querySelector(`[data-index="${itemIndex}"]`);
            
            if (itemElement && itemElement.parentElement.classList.contains('quantity-bank')) {
                // Move item to the drop zone
                const dropZone = event.currentTarget;
                itemElement.classList.remove('dragging');
                itemElement.draggable = false;
                dropZone.appendChild(itemElement);
            }
        }
        
        function checkSorting() {
            const scalarZone = document.getElementById('scalarZone');
            const vectorZone = document.getElementById('vectorZone');
            
            const scalarItems = Array.from(scalarZone.querySelectorAll('.quantity-item'));
            const vectorItems = Array.from(vectorZone.querySelectorAll('.quantity-item'));
            
            let correct = 0;
            let total = scalarItems.length + vectorItems.length;
            
            // Check scalar zone
            scalarItems.forEach(item => {
                if (item.dataset.type === 'scalar') {
                    correct++;
                    item.style.background = '#00b894';
                    item.style.color = 'white';
                } else {
                    item.style.background = '#ff7675';
                    item.style.color = 'white';
                }
            });
            
            // Check vector zone
            vectorItems.forEach(item => {
                if (item.dataset.type === 'vector') {
                    correct++;
                    item.style.background = '#00b894';
                    item.style.color = 'white';
                } else {
                    item.style.background = '#ff7675';
                    item.style.color = 'white';
                }
            });
            
            const percentage = total > 0 ? Math.round((correct / total) * 100) : 0;
            
            document.getElementById('correctCount').textContent = correct;
            document.getElementById('scorePercent').textContent = percentage + '%';
            
            if (percentage === 100) {
                showFeedback('sortingFeedback', `üéâ Perfect score. Pauli is proud of your vector knowledge üëÄ`, 'success');
            } else if (percentage >= 75) {
                showFeedback('sortingFeedback', `Good job. ${correct}/${total} correct. Pauli says: Keep practicing üëÄ`, 'success');
            } else {
                showFeedback('sortingFeedback', `Pauli says: ${correct}/${total} correct. Remember: vectors have direction, scalars don't üëÄ`, 'error');
            }
        }
        
        function resetSorting() {
            const allItems = document.querySelectorAll('.quantity-item');
            allItems.forEach(item => {
                item.style.background = 'rgba(255, 255, 255, 0.9)';
                item.style.color = '#2d3436';
                item.draggable = true;
            });
            
            const bank = document.getElementById('quantityBank');
            const scalarZone = document.getElementById('scalarZone');
            const vectorZone = document.getElementById('vectorZone');
            
            // Move all items back to bank
            const itemsInZones = [
                ...scalarZone.querySelectorAll('.quantity-item'),
                ...vectorZone.querySelectorAll('.quantity-item')
            ];
            
            itemsInZones.forEach(item => {
                bank.appendChild(item);
            });
            
            // Reset zone headers
            scalarZone.innerHTML = '<h3>üìè <span title="Quantities with magnitude only (size but no direction)" style="cursor: help; border-bottom: 1px dotted white;">Scalars</span></h3><p><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span> Only</p>';
            vectorZone.innerHTML = '<h3>üß≠ <span title="Quantities with magnitude and direction" style="cursor: help; border-bottom: 1px dotted white;">Vectors</span></h3><p><span title="Size or amount of a quantity" style="cursor: help; border-bottom: 1px dotted white;">Magnitude</span> + Direction</p>';
            
            document.getElementById('correctCount').textContent = '0';
            document.getElementById('sortingFeedback').classList.remove('show');
        }
        
        // Vector Calculator Functions
        function calculateVector() {
            const magnitude = parseFloat(document.getElementById('vectorMagnitude').value);
            const direction = parseFloat(document.getElementById('vectorDirection').value);
            
            if (isNaN(magnitude) || isNaN(direction)) {
                showFeedback('calculatorFeedback', 'Pauli says: Please enter both magnitude and direction üëÄ', 'error');
                return;
            }
            
            if (magnitude <= 0 || direction < 0 || direction >= 360) {
                showFeedback('calculatorFeedback', 'Pauli says: Magnitude must be positive, direction 0-359¬∞ üëÄ', 'error');
                return;
            }
            
            // Calculate components
            const radians = direction * Math.PI / 180;
            const xComponent = magnitude * Math.cos(radians);
            const yComponent = magnitude * Math.sin(radians);
            
            showResult('calculatorResult', `
                <div style="font-size: 1.5em;">üìä Vector Analysis üìä</div>
                <div><strong>Magnitude:</strong> ${magnitude} m/s</div>
                <div><strong>Direction:</strong> ${direction}¬∞</div>
                <div><strong>X-Component:</strong> ${xComponent.toFixed(2)} m/s</div>
                <div><strong>Y-Component:</strong> ${yComponent.toFixed(2)} m/s</div>
                <div><strong>Pauli says:</strong> This vector has both size AND direction üëÄ</div>
            `);
        }
        
        function addToComparison() {
            const magnitude = parseFloat(document.getElementById('vectorMagnitude').value);
            const direction = parseFloat(document.getElementById('vectorDirection').value);
            
            if (isNaN(magnitude) || isNaN(direction)) {
                showFeedback('calculatorFeedback', 'Pauli says: Please enter both magnitude and direction first üëÄ', 'error');
                return;
            }
            
            vectorList.push({magnitude, direction});
            
            const comparison = document.getElementById('vectorComparison');
            comparison.style.display = 'block';
            
            // Add vector to comparison
            const vectorDiv = document.createElement('div');
            vectorDiv.className = 'stat-item';
            vectorDiv.innerHTML = `
                <div class="stat-value">${magnitude}</div>
                <div class="stat-label">${direction}¬∞ direction</div>
            `;
            comparison.appendChild(vectorDiv);
            
            showFeedback('calculatorFeedback', `Vector added to comparison. Pauli says: Notice how same speeds can be different vectors üëÄ`, 'success');
        }
        
        function clearCalculator() {
            document.getElementById('vectorMagnitude').value = '';
            document.getElementById('vectorDirection').value = '';
            document.getElementById('calculatorResult').classList.remove('show');
            document.getElementById('calculatorFeedback').classList.remove('show');
            
            vectorList = [];
            const comparison = document.getElementById('vectorComparison');
            comparison.style.display = 'none';
            comparison.innerHTML = '<h3 style="width: 100%; text-align: center; color: #4a5568;">Vector Comparison</h3>';
        }
        
        // Utility Functions
        function showFeedback(elementId, message, type) {
            const feedback = document.getElementById(elementId);
            feedback.innerHTML = message;
            feedback.className = `feedback ${type} show`;
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 5000);
        }
        
        function showResult(elementId, message) {
            const result = document.getElementById(elementId);
            result.innerHTML = message;
            result.classList.add('show');
            
            setTimeout(() => {
                result.classList.remove('show');
            }, 8000);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeSorting();
            
            // Add event listeners for drag and drop
            document.addEventListener('dragend', function(event) {
                event.target.classList.remove('dragging');
                document.querySelectorAll('.drop-zone').forEach(zone => {
                    zone.classList.remove('dragover');
                });
            });
        });
    </script>
</body>
</html>