
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kinematics Visualizer</title>
<style>
body {
    margin: 0;
    padding: 10px;
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
}

#container {
    max-width: 800px;
    margin: 0 auto;
    background-color: white;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

h1 {
    margin: 0 0 10px 0;
    font-size: 24px;
}

#controls {
    margin-bottom: 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
}

button {
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    transition: background-color 0.3s;
}

button:hover:not(:disabled) {
    background-color: #45a049;
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

#applyPresetBtn {
    background-color: #2196F3;
}

#applyPresetBtn:hover:not(:disabled) {
    background-color: #1976D2;
}

#emojiSelector {
    padding: 6px;
    font-size: 16px;
}

#animationBox {
    width: 100%;
    height: 60px;
    border: 2px solid #333;
    margin-bottom: 10px;
    position: relative;
    background-color: #f9f9f9;
    overflow: hidden;
}

#rulerCanvas {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 20px;
    pointer-events: none;
}

#originMarker {
    position: absolute;
    left: 20px;
    top: 0;
    bottom: 0;
    width: 2px;
    background-color: #333;
    z-index: 1;
}

#originLabel {
    position: absolute;
    left: 5px;
    top: 5px;
    font-size: 10px;
    color: #666;
}

#movingObject {
    position: absolute;
    font-size: 24px;
    transition: none;
    top: 50%;
    transform: translateY(-50%);
}

#velocityDisplay {
    position: absolute;
    font-size: 11px;
    color: #0066cc;
    font-weight: bold;
    pointer-events: none;
    transform: translateX(-50%);
    top: 5px;
}

#accelerationVector {
    position: absolute;
    pointer-events: none;
    top: calc(50% + 12px);
    transform: translateX(-50%);
    background: transparent;
    border: none;
}

#saveLoadControls {
    margin-bottom: 10px;
    padding: 10px;
    background-color: #f5f5f5;
    border-radius: 5px;
}

.control-group {
    margin-bottom: 8px;
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
}

#saveName {
    padding: 6px;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 150px;
}

#presetSelector {
    padding: 6px;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

#savedList {
    margin-top: 10px;
    padding: 10px;
    background-color: white;
    border-radius: 5px;
    max-height: 200px;
    overflow-y: auto;
}

#savedList h3 {
    margin: 0 0 8px 0;
    font-size: 16px;
}

#savedItems {
    list-style: none;
    padding: 0;
    margin: 0;
}

.saved-item {
    padding: 6px;
    margin-bottom: 4px;
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.saved-item-name {
    flex-grow: 1;
    margin-right: 10px;
}

.saved-item-actions {
    display: flex;
    gap: 5px;
}

.saved-item-actions button {
    padding: 4px 8px;
    font-size: 12px;
}

.graph-container {
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 8px;
}

.graph-label {
    font-weight: bold;
    margin-bottom: 3px;
    font-size: 14px;
}

canvas {
    border: 1px solid #ccc;
    cursor: crosshair;
    display: block;
}

#tooltip {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    display: none;
    font-family: monospace;
    white-space: pre-line;
}

.graph-container.displacement .graph-label { color: green; }
.graph-container.velocity .graph-label { color: blue; }
.graph-container.acceleration .graph-label { color: red; }
</style>
</head>
<body>
<div id="container">
<h1>Interactive Kinematics Visualizer</h1>

<div id="controls">
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="resetBtn">Reset</button>
    <button id="undoBtn">‚Ü∂ Undo</button>
    <button id="redoBtn">‚Ü∑ Redo</button>
    <label for="emojiSelector">Object:</label>
    <select id="emojiSelector">
        <option value="‚öΩ">‚öΩ Ball</option>
        <option value="üõ∏">üõ∏ UFO</option>
        <option value="üõπ">üõπ Skateboard</option>
        <option value="üöÅ">üöÅ Helicopter</option>
        <option value="üì¶">üì¶ Box</option>
    </select>
</div>

<div id="animationBox">
    <canvas id="rulerCanvas"></canvas>
    <div id="originMarker"></div>
    <div id="originLabel">Origin</div>
    <div id="movingObject">üöó</div>
    <div id="velocityDisplay"></div>
    <canvas id="accelerationVector" width="200" height="30"></canvas>
</div>

<div class="graph-container displacement">
    <div class="graph-label">Displacement (m) - Green</div>
    <canvas id="displacementCanvas" width="760" height="180"></canvas>
</div>

<div class="graph-container velocity">
    <div class="graph-label">Velocity (m/s) - Blue</div>
    <canvas id="velocityCanvas" width="760" height="180"></canvas>
</div>

<div class="graph-container acceleration">
    <div class="graph-label">Acceleration (m/s¬≤) - Red</div>
    <canvas id="accelerationCanvas" width="760" height="180"></canvas>
</div>

<div id="saveLoadControls">
    <div class="control-group">
        <label for="presetSelector">Presets:</label>
        <select id="presetSelector">
            <option value="">-- Select Preset --</option>
            <option value="freefall">Free Fall</option>
            <option value="freefall-up">Free Fall (Initial Upward)</option>
            <option value="uniform">Uniform Motion</option>
            <option value="accelerated">Constant Acceleration</option>
            <option value="decelerated">Constant Deceleration</option>
            <option value="harmonic">Simple Harmonic</option>
        </select>
        <button id="applyPresetBtn" disabled>Apply</button>
    </div>
    
    <div class="control-group">
        <input type="text" id="saveName" placeholder="Save name...">
        <button id="saveBtn">üíæ Save</button>
        <button id="exportCsvBtn">üìä Export CSV</button>
        <input type="file" id="importCsvInput" accept=".csv" style="display: none;">
        <button id="importCsvBtn">üìÇ Import CSV</button>
    </div>
    
    <div id="savedList" style="display: none;">
        <h3>Saved Setups:</h3>
        <ul id="savedItems"></ul>
    </div>
</div>

<div id="tooltip"></div>
</div>

<script>
// Constants
const NUM_POINTS = 17;
const NUM_SEGMENTS = NUM_POINTS - 1;
const GRAPH_PADDING = 35;
const POINT_RADIUS = 4;
const GRID_DIVISIONS = 10;
const TOOLTIP_DELAY = 3000; // 3 seconds

// Graph colors
const COLORS = {
    displacement: '#00aa00',
    velocity: '#0066cc',
    acceleration: '#cc0000'
};

// State
let points = {
    displacement: [],
    velocity: [],
    acceleration: []
};

let history = [];
let historyIndex = -1;
let isDragging = false;
let draggedPoint = null;
let draggedGraph = null;
let animationFrame = null;
let animationStartTime = null;
let isPlaying = false;
let tooltipTimeout = null;
let currentAnimationTime = 0;
let lastMousePosition = { x: 0, y: 0 };
let isShiftDragging = false;
let initialDragValue = null;
let animationPhase = 'playing'; // 'playing', 'waiting', 'returning'
let waitStartTime = null;

// Emoji dragging state
let isEmojiDragging = false;
let emojiDragStartTime = null;
let emojiDragPositions = [];
let emojiDragInterval = null;

// Canvas elements
const canvases = {
    displacement: document.getElementById('displacementCanvas'),
    velocity: document.getElementById('velocityCanvas'),
    acceleration: document.getElementById('accelerationCanvas')
};

const contexts = {};
for (let key in canvases) {
    contexts[key] = canvases[key].getContext('2d');
}

// UI elements
const playBtn = document.getElementById('playBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const emojiSelector = document.getElementById('emojiSelector');
const movingObject = document.getElementById('movingObject');
const tooltip = document.getElementById('tooltip');
const animationBox = document.getElementById('animationBox');
const velocityDisplay = document.getElementById('velocityDisplay');
const accelerationVector = document.getElementById('accelerationVector');
const accelerationCtx = accelerationVector.getContext('2d');
const rulerCanvas = document.getElementById('rulerCanvas');
const rulerCtx = rulerCanvas.getContext('2d');

// Save/Load UI elements
const presetSelector = document.getElementById('presetSelector');
const applyPresetBtn = document.getElementById('applyPresetBtn');
const saveName = document.getElementById('saveName');
const saveBtn = document.getElementById('saveBtn');
const exportCsvBtn = document.getElementById('exportCsvBtn');
const importCsvBtn = document.getElementById('importCsvBtn');
const importCsvInput = document.getElementById('importCsvInput');
const savedList = document.getElementById('savedList');
const savedItems = document.getElementById('savedItems');

// Initialize points
function initializePoints() {
    const defaultTime = 16; // Total time span
    
    for (let i = 0; i < NUM_POINTS; i++) {
        const t = (i / NUM_SEGMENTS) * defaultTime;
        
        points.displacement[i] = { x: t, y: 0 };
        points.velocity[i] = { x: t, y: 0 };
        points.acceleration[i] = { x: t, y: 0 };
    }
    
    saveState();
    updateAllGraphs();
    updateOriginPosition();
}

// Update origin position based on current displacement range
function updateOriginPosition() {
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    
    const boxWidth = animationBox.offsetWidth;
    const usableWidth = boxWidth - 60;
    
    let originPixel;
    
    if (minDisplacement >= 0) {
        originPixel = 20;
    } else if (maxDisplacement <= 0) {
        originPixel = boxWidth - 20;
    } else {
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
    }
    
    const originMarker = document.getElementById('originMarker');
    const originLabel = document.getElementById('originLabel');
    originMarker.style.left = originPixel + 'px';
    originLabel.style.left = (originPixel - 15) + 'px';
    
    // Recenter emoji at origin if not animating
    if (!isPlaying) {
        movingObject.style.left = originPixel + 'px';
    }
    
    // Draw ruler
    drawRuler();
}

// Draw ruler with meter ticks
function drawRuler() {
    const boxWidth = animationBox.offsetWidth;
    rulerCanvas.width = boxWidth;
    rulerCanvas.height = 20;
    
    rulerCtx.clearRect(0, 0, boxWidth, 20);
    
    // Get displacement range and scaling
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    const displacementRange = maxDisplacement - minDisplacement;
    
    if (displacementRange === 0) return;
    
    const usableWidth = boxWidth - 60;
    let originPixel;
    let pixelsPerUnit;
    
    if (minDisplacement >= 0) {
        originPixel = 20;
        pixelsPerUnit = usableWidth / (maxDisplacement || 1);
    } else if (maxDisplacement <= 0) {
        originPixel = boxWidth - 20;
        pixelsPerUnit = usableWidth / (Math.abs(minDisplacement) || 1);
    } else {
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    // Calculate tick spacing
    const targetTickSpacing = 40; // Target pixel spacing between ticks
    const unitsPerTick = Math.pow(10, Math.floor(Math.log10(targetTickSpacing / pixelsPerUnit)));
    const possibleSpacings = [1, 2, 5, 10].map(x => x * unitsPerTick);
    const tickSpacing = possibleSpacings.find(spacing => spacing * pixelsPerUnit >= targetTickSpacing) || possibleSpacings[3];
    
    // Draw ticks
    rulerCtx.strokeStyle = '#00aa00';
    rulerCtx.fillStyle = '#00aa00';
    rulerCtx.font = '9px Arial';
    rulerCtx.textAlign = 'center';
    rulerCtx.lineWidth = 1;
    
    // Start from a multiple of tickSpacing
    const startValue = Math.floor(minDisplacement / tickSpacing) * tickSpacing;
    const endValue = Math.ceil(maxDisplacement / tickSpacing) * tickSpacing;
    
    for (let value = startValue; value <= endValue; value += tickSpacing) {
        const pixelX = originPixel + value * pixelsPerUnit;
        
        if (pixelX >= 10 && pixelX <= boxWidth - 10) {
            // Draw tick
            rulerCtx.beginPath();
            rulerCtx.moveTo(pixelX, 15);
            rulerCtx.lineTo(pixelX, 20);
            rulerCtx.stroke();
            
            // Draw label
            rulerCtx.fillText(value.toFixed(0), pixelX, 12);
        }
    }
}

// Calculate velocity at time
function calculateVelocityAtTime(t) {
    // Ensure all points are sorted by time
    const velPoints = [...points.velocity].sort((a, b) => a.x - b.x);
    const accPoints = [...points.acceleration].sort((a, b) => a.x - b.x);
    
    // Handle edge cases
    if (t <= velPoints[0].x) {
        return velPoints[0].y;
    }
    if (t >= velPoints[velPoints.length - 1].x) {
        return velPoints[velPoints.length - 1].y;
    }
    
    // Find the segment containing time t
    for (let i = 0; i < velPoints.length - 1; i++) {
        const t1 = velPoints[i].x;
        const t2 = velPoints[i + 1].x;
        
        if (t >= t1 && t <= t2) {
            const v0 = velPoints[i].y;
            
            // Find acceleration at t1
            let a = 0;
            let minAccDist = Infinity;
            for (const ap of accPoints) {
                const dist = Math.abs(ap.x - t1);
                if (dist < minAccDist && dist < 0.1) { // Only match if very close
                    minAccDist = dist;
                    a = ap.y;
                }
            }
            
            const dt = t - t1;
            // v = v0 + a*t
            return v0 + a * dt;
        }
    }
    
    return velPoints[velPoints.length - 1].y;
}

// Calculate acceleration at time
function calculateAccelerationAtTime(t) {
    // Ensure all points are sorted by time
    const accPoints = [...points.acceleration].sort((a, b) => a.x - b.x);
    
    // Handle edge cases
    if (t <= accPoints[0].x) {
        return accPoints[0].y;
    }
    if (t >= accPoints[accPoints.length - 1].x) {
        return 0;
    }
    
    // Find the segment containing time t
    for (let i = 0; i < accPoints.length - 1; i++) {
        const t1 = accPoints[i].x;
        const t2 = accPoints[i + 1].x;
        
        if (t >= t1 && t <= t2) {
            return accPoints[i].y; // Constant acceleration in segment
        }
    }
    
    // If t is after all points, return 0
    return 0;
}

// Draw acceleration vector
function drawAccelerationVector(acceleration) {
    const canvas = accelerationVector;
    const ctx = accelerationCtx;
    
    // Clear the entire canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Always show the canvas (even for zero acceleration, we'll show a dot)
    canvas.style.display = 'block';
    
    // Set drawing properties
    ctx.strokeStyle = '#cc0000';
    ctx.fillStyle = '#cc0000';
    ctx.lineWidth = 3;
    
    // Canvas dimensions and center point
    const canvasWidth = 200;
    const canvasHeight = 30;
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    
    if (Math.abs(acceleration) < 0.01) {
        // Draw a small dot at center for zero acceleration
        ctx.beginPath();
        ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);
        ctx.fill();
        return;
    }
    
    // Calculate arrow dimensions
    const scaleFactor = 54; // 3x the previous value of 18
    const maxArrowLength = 90; // Maximum arrow length from center
    const arrowLength = Math.min(Math.abs(acceleration) * scaleFactor, maxArrowLength);
    const direction = acceleration > 0 ? 1 : -1; // 1 for right, -1 for left
    
    // Arrow parameters - start from center, go in one direction
    const arrowStartX = centerX;
    const arrowEndX = centerX + (direction * arrowLength);
    const headLength = Math.max(6, Math.min(12, arrowLength * 0.2)); // Ensure visible head
    const headWidth = headLength * 0.6;
    
    // Draw arrow shaft from center
    ctx.beginPath();
    ctx.moveTo(arrowStartX, centerY);
    ctx.lineTo(arrowEndX, centerY);
    ctx.stroke();
    
    // Draw arrow head (filled triangle)
    ctx.beginPath();
    ctx.moveTo(arrowEndX, centerY); // Tip of arrow
    ctx.lineTo(arrowEndX - direction * headLength, centerY - headWidth);
    ctx.lineTo(arrowEndX - direction * headLength, centerY + headWidth);
    ctx.closePath();
    ctx.fill();
    
    // Draw center dot to mark 0.0 position
    ctx.fillStyle = '#cc0000';
    ctx.beginPath();
    ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
    ctx.fill();
}

// Save state for undo/redo
function saveState() {
    const state = JSON.parse(JSON.stringify(points));
    
    // Remove any states after current index
    history = history.slice(0, historyIndex + 1);
    
    history.push(state);
    historyIndex++;
    
    // Limit history size
    if (history.length > 100) {
        history.shift();
        historyIndex--;
    }
    
    updateUndoRedoButtons();
}

// Update undo/redo button states
function updateUndoRedoButtons() {
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
}

// Undo
function undo() {
    if (historyIndex > 0) {
        // Stop animation if playing
        if (isPlaying) {
            stopAnimation();
        }
        
        historyIndex--;
        points = JSON.parse(JSON.stringify(history[historyIndex]));
        updateAllGraphs();
        updateOriginPosition();
        updateUndoRedoButtons();
    }
}

// Redo
function redo() {
    if (historyIndex < history.length - 1) {
        // Stop animation if playing
        if (isPlaying) {
            stopAnimation();
        }
        
        historyIndex++;
        points = JSON.parse(JSON.stringify(history[historyIndex]));
        updateAllGraphs();
        updateOriginPosition();
        updateUndoRedoButtons();
    }
}

// Get graph bounds
function getGraphBounds(graphType) {
    const pts = points[graphType];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    for (let pt of pts) {
        minX = Math.min(minX, pt.x);
        maxX = Math.max(maxX, pt.x);
        minY = Math.min(minY, pt.y);
        maxY = Math.max(maxY, pt.y);
    }
    
    // Add padding
    const xRange = maxX - minX || 1;
    const yRange = maxY - minY || 1;
    
    minX -= xRange * 0.1;
    maxX += xRange * 0.1;
    minY -= yRange * 0.1;
    maxY += yRange * 0.1;
    
    // Ensure minimum range
    if (maxX - minX < 1) {
        const center = (minX + maxX) / 2;
        minX = center - 0.5;
        maxX = center + 0.5;
    }
    
    if (maxY - minY < 1) {
        const center = (minY + maxY) / 2;
        minY = center - 0.5;
        maxY = center + 0.5;
    }
    
    return { minX, maxX, minY, maxY };
}

// Convert graph coordinates to canvas coordinates
function graphToCanvas(x, y, graphType, canvas) {
    const bounds = getGraphBounds(graphType);
    const canvasWidth = canvas.width - 2 * GRAPH_PADDING;
    const canvasHeight = canvas.height - 2 * GRAPH_PADDING;
    
    const canvasX = GRAPH_PADDING + ((x - bounds.minX) / (bounds.maxX - bounds.minX)) * canvasWidth;
    const canvasY = GRAPH_PADDING + ((bounds.maxY - y) / (bounds.maxY - bounds.minY)) * canvasHeight;
    
    return { x: canvasX, y: canvasY };
}

// Convert canvas coordinates to graph coordinates
function canvasToGraph(canvasX, canvasY, graphType, canvas) {
    const bounds = getGraphBounds(graphType);
    const canvasWidth = canvas.width - 2 * GRAPH_PADDING;
    const canvasHeight = canvas.height - 2 * GRAPH_PADDING;
    
    const x = bounds.minX + ((canvasX - GRAPH_PADDING) / canvasWidth) * (bounds.maxX - bounds.minX);
    const y = bounds.maxY - ((canvasY - GRAPH_PADDING) / canvasHeight) * (bounds.maxY - bounds.minY);
    
    return { x, y };
}

// Draw grid and axes
function drawGrid(ctx, graphType, canvas) {
    const bounds = getGraphBounds(graphType);
    
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    
    // Vertical grid lines
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const x = bounds.minX + (i / GRID_DIVISIONS) * (bounds.maxX - bounds.minX);
        const canvasPos = graphToCanvas(x, 0, graphType, canvas);
        
        ctx.beginPath();
        ctx.moveTo(canvasPos.x, GRAPH_PADDING);
        ctx.lineTo(canvasPos.x, canvas.height - GRAPH_PADDING);
        ctx.stroke();
    }
    
    // Horizontal grid lines
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const y = bounds.minY + (i / GRID_DIVISIONS) * (bounds.maxY - bounds.minY);
        const canvasPos = graphToCanvas(0, y, graphType, canvas);
        
        ctx.beginPath();
        ctx.moveTo(GRAPH_PADDING, canvasPos.y);
        ctx.lineTo(canvas.width - GRAPH_PADDING, canvasPos.y);
        ctx.stroke();
    }
    
    // Draw axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    
    // X-axis (if 0 is in view)
    if (bounds.minY <= 0 && bounds.maxY >= 0) {
        const yPos = graphToCanvas(0, 0, graphType, canvas).y;
        ctx.beginPath();
        ctx.moveTo(GRAPH_PADDING, yPos);
        ctx.lineTo(canvas.width - GRAPH_PADDING, yPos);
        ctx.stroke();
    }
    
    // Y-axis (if 0 is in view)
    if (bounds.minX <= 0 && bounds.maxX >= 0) {
        const xPos = graphToCanvas(0, 0, graphType, canvas).x;
        ctx.beginPath();
        ctx.moveTo(xPos, GRAPH_PADDING);
        ctx.lineTo(xPos, canvas.height - GRAPH_PADDING);
        ctx.stroke();
    }
    
    // Labels
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    
    // X-axis labels
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const x = bounds.minX + (i / GRID_DIVISIONS) * (bounds.maxX - bounds.minX);
        const canvasPos = graphToCanvas(x, 0, graphType, canvas);
        ctx.fillText(x.toFixed(1), canvasPos.x, canvas.height - GRAPH_PADDING + 5);
    }
    
    // Y-axis labels
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let i = 0; i <= GRID_DIVISIONS; i++) {
        const y = bounds.minY + (i / GRID_DIVISIONS) * (bounds.maxY - bounds.minY);
        const canvasPos = graphToCanvas(0, y, graphType, canvas);
        ctx.fillText(y.toFixed(1), GRAPH_PADDING - 5, canvasPos.y);
    }
}

// Draw graph
function drawGraph(graphType) {
    const canvas = canvases[graphType];
    const ctx = contexts[graphType];
    const pts = points[graphType];
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    drawGrid(ctx, graphType, canvas);
    
    // Draw lines
    ctx.strokeStyle = COLORS[graphType];
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < pts.length; i++) {
        const canvasPos = graphToCanvas(pts[i].x, pts[i].y, graphType, canvas);
        
        if (i === 0) {
            ctx.moveTo(canvasPos.x, canvasPos.y);
        } else {
            // For acceleration, draw step function
            if (graphType === 'acceleration') {
                const prevCanvasPos = graphToCanvas(pts[i-1].x, pts[i-1].y, graphType, canvas);
                ctx.lineTo(canvasPos.x, prevCanvasPos.y);
                ctx.lineTo(canvasPos.x, canvasPos.y);
            } else {
                ctx.lineTo(canvasPos.x, canvasPos.y);
            }
        }
    }
    
    ctx.stroke();
    
    // Draw playhead if animating
    if (isPlaying && currentAnimationTime >= 0) {
        const playheadCanvas = graphToCanvas(currentAnimationTime, 0, graphType, canvas);
        ctx.strokeStyle = '#666666';
        ctx.lineWidth = 0.5;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(playheadCanvas.x, GRAPH_PADDING);
        ctx.lineTo(playheadCanvas.x, canvas.height - GRAPH_PADDING);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Draw points
    for (let i = 0; i < pts.length; i++) {
        const canvasPos = graphToCanvas(pts[i].x, pts[i].y, graphType, canvas);
        
        ctx.fillStyle = COLORS[graphType];
        ctx.beginPath();
        ctx.arc(canvasPos.x, canvasPos.y, POINT_RADIUS, 0, 2 * Math.PI);
        ctx.fill();
        
        // Point border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

// Calculate kinematics for a segment
function calculateSegmentKinematics(segmentIndex) {
    if (segmentIndex < 0 || segmentIndex >= NUM_SEGMENTS) return null;
    
    const t1 = points.acceleration[segmentIndex].x;
    const t2 = points.acceleration[segmentIndex + 1].x;
    const dt = t2 - t1;
    
    const a = points.acceleration[segmentIndex].y;
    const u = points.velocity[segmentIndex].y;
    const v = points.velocity[segmentIndex + 1].y;
    const s1 = points.displacement[segmentIndex].y;
    const s2 = points.displacement[segmentIndex + 1].y;
    const s = s2 - s1;
    
    return {
        u: u,           // Initial velocity
        v: v,           // Final velocity
        s: s,           // Displacement
        a: a,           // Acceleration
        t: dt,          // Time duration
        t1: t1,         // Start time
        t2: t2          // End time
    };
}

// Update velocity from acceleration
function updateVelocityFromAcceleration() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.acceleration[a].x - points.acceleration[b].x
    );
    
    for (let i = 1; i < NUM_POINTS; i++) {
        const prevIdx = sortedIndices[i - 1];
        const currIdx = sortedIndices[i];
        
        const dt = points.acceleration[currIdx].x - points.acceleration[prevIdx].x;
        const a = points.acceleration[prevIdx].y;
        
        // v = u + at
        points.velocity[currIdx].y = points.velocity[prevIdx].y + a * dt;
        points.velocity[currIdx].x = points.acceleration[currIdx].x;
    }
}

// Update displacement from velocity
function updateDisplacementFromVelocity() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.velocity[a].x - points.velocity[b].x
    );
    
    for (let i = 1; i < NUM_POINTS; i++) {
        const prevIdx = sortedIndices[i - 1];
        const currIdx = sortedIndices[i];
        
        const dt = points.velocity[currIdx].x - points.velocity[prevIdx].x;
        const u = points.velocity[prevIdx].y;
        const v = points.velocity[currIdx].y;
        
        // For constant acceleration: s = ut + 0.5at¬≤ = (u + v)/2 * t
        const avgVelocity = (u + v) / 2;
        points.displacement[currIdx].y = points.displacement[prevIdx].y + avgVelocity * dt;
        points.displacement[currIdx].x = points.velocity[currIdx].x;
    }
}

// Update acceleration from velocity
function updateAccelerationFromVelocity() {
    // Sort points by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        points.velocity[a].x - points.velocity[b].x
    );
    
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const currIdx = sortedIndices[i];
        const nextIdx = sortedIndices[i + 1];
        
        const dt = points.velocity[nextIdx].x - points.velocity[currIdx].x;
        const dv = points.velocity[nextIdx].y - points.velocity[currIdx].y;
        
        // a = dv/dt
        points.acceleration[currIdx].y = dt > 0 ? dv / dt : 0;
        points.acceleration[currIdx].x = points.velocity[currIdx].x;
    }
    
    // Last acceleration point matches x coordinate
    points.acceleration[sortedIndices[NUM_SEGMENTS]].x = points.velocity[sortedIndices[NUM_SEGMENTS]].x;
}

// Update velocity from displacement
function updateVelocityFromDisplacement() {
    // Create sorted arrays of points with their original indices
    const sortedData = points.displacement.map((p, i) => ({ x: p.x, y: p.y, index: i }))
        .sort((a, b) => a.x - b.x);
    
    // Calculate velocities for each point
    for (let i = 0; i < sortedData.length; i++) {
        const curr = sortedData[i];
        const idx = curr.index;
        
        let velocity;
        
        if (i === 0 && sortedData.length > 1) {
            // First point: forward difference
            const next = sortedData[i + 1];
            const dt = next.x - curr.x;
            const ds = next.y - curr.y;
            velocity = dt > 0.001 ? ds / dt : 0;
        } else if (i === sortedData.length - 1 && sortedData.length > 1) {
            // Last point: backward difference
            const prev = sortedData[i - 1];
            const dt = curr.x - prev.x;
            const ds = curr.y - prev.y;
            velocity = dt > 0.001 ? ds / dt : 0;
        } else if (sortedData.length > 2) {
            // Middle points: central difference
            const prev = sortedData[i - 1];
            const next = sortedData[i + 1];
            const dt = next.x - prev.x;
            const ds = next.y - prev.y;
            velocity = dt > 0.001 ? ds / dt : 0;
        } else {
            velocity = 0;
        }
        
        // Update velocity at the same time as the displacement point
        points.velocity[idx].x = curr.x;
        points.velocity[idx].y = velocity;
    }
    
    // Smoothing pass to ensure kinematic consistency
    // This helps prevent jumps by ensuring accelerations are reasonable
    for (let iter = 0; iter < 3; iter++) {
        for (let i = 1; i < sortedData.length - 1; i++) {
            const prev = sortedData[i - 1];
            const curr = sortedData[i];
            const next = sortedData[i + 1];
            
            const dt1 = curr.x - prev.x;
            const dt2 = next.x - curr.x;
            
            if (dt1 > 0.001 && dt2 > 0.001) {
                // Check if this creates reasonable accelerations
                const v_prev = points.velocity[prev.index].y;
                const v_curr = points.velocity[curr.index].y;
                const v_next = points.velocity[next.index].y;
                
                const a1 = (v_curr - v_prev) / dt1;
                const a2 = (v_next - v_curr) / dt2;
                
                // If accelerations differ too much, smooth the velocity
                if (Math.abs(a2 - a1) > 50) { // Threshold for acceleration change
                    // Use kinematic constraint: s = s0 + v0*t + 0.5*a*t¬≤
                    const s_prev = prev.y;
                    const s_curr = curr.y;
                    const s_next = next.y;
                    
                    // Calculate what velocity should be for smooth acceleration
                    const ds1 = s_curr - s_prev;
                    const ds2 = s_next - s_curr;
                    
                    // Average acceleration
                    const avg_a = ((ds2 / dt2 - ds1 / dt1) / ((dt1 + dt2) / 2));
                    
                    // Recalculate middle velocity
                    const new_v = v_prev + avg_a * dt1;
                    
                    // Blend with current value for stability
                    points.velocity[curr.index].y = 0.7 * new_v + 0.3 * v_curr;
                }
            }
        }
    }
}

// Update all graphs based on which one was modified
function updateGraphsFrom(sourceGraph) {
    if (sourceGraph === 'acceleration') {
        updateVelocityFromAcceleration();
        updateDisplacementFromVelocity();
    } else if (sourceGraph === 'velocity') {
        updateAccelerationFromVelocity();
        updateDisplacementFromVelocity();
    } else if (sourceGraph === 'displacement') {
        updateVelocityFromDisplacement();
        updateAccelerationFromVelocity();
    }
    
    updateAllGraphs();
    updateOriginPosition();
}

// Update all graph displays
function updateAllGraphs() {
    drawGraph('displacement');
    drawGraph('velocity');
    drawGraph('acceleration');
}

// Find nearest point
function findNearestPoint(canvasX, canvasY, graphType, canvas) {
    const pts = points[graphType];
    let minDist = Infinity;
    let nearestIdx = -1;
    
    for (let i = 0; i < pts.length; i++) {
        const canvasPos = graphToCanvas(pts[i].x, pts[i].y, graphType, canvas);
        const dist = Math.sqrt(
            Math.pow(canvasX - canvasPos.x, 2) + 
            Math.pow(canvasY - canvasPos.y, 2)
        );
        
        if (dist < minDist && dist < POINT_RADIUS * 3) {
            minDist = dist;
            nearestIdx = i;
        }
    }
    
    return nearestIdx;
}

// Find segment at x position
function findSegmentAtX(x, graphType) {
    const pts = points[graphType];
    
    // Sort indices by x coordinate
    const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
        pts[a].x - pts[b].x
    );
    
    for (let i = 0; i < NUM_SEGMENTS; i++) {
        const idx1 = sortedIndices[i];
        const idx2 = sortedIndices[i + 1];
        
        if (x >= pts[idx1].x && x <= pts[idx2].x) {
            return i;
        }
    }
    
    return -1;
}

// Mouse event handlers
function handleMouseDown(e, graphType) {
    const canvas = canvases[graphType];
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    
    const pointIdx = findNearestPoint(canvasX, canvasY, graphType, canvas);
    
    if (pointIdx !== -1) {
        isDragging = true;
        draggedPoint = pointIdx;
        draggedGraph = graphType;
        isShiftDragging = e.shiftKey;
        initialDragValue = points[graphType][pointIdx].y;
        canvas.style.cursor = 'grabbing';
        
        // Clear tooltip timeout when starting to drag
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        tooltip.style.display = 'none';
    }
}

function handleMouseMove(e, graphType) {
    const canvas = canvases[graphType];
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    
    // Check if mouse has moved significantly
    const mouseMoved = Math.abs(e.clientX - lastMousePosition.x) > 5 || 
                     Math.abs(e.clientY - lastMousePosition.y) > 5;
    
    if (mouseMoved) {
        lastMousePosition = { x: e.clientX, y: e.clientY };
        // Clear any existing tooltip timeout and hide tooltip
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        tooltip.style.display = 'none';
    }
    
    // Handle dragging
    if (isDragging && draggedGraph === graphType) {
        // Stop animation when dragging
        if (isPlaying) {
            stopAnimation();
        }
        
        const graphPos = canvasToGraph(canvasX, canvasY, graphType, canvas);
        
        // Calculate delta for shift-drag
        const delta = graphPos.y - points[graphType][draggedPoint].y;
        
        // Update point position
        points[graphType][draggedPoint].x = Math.max(0, graphPos.x);
        points[graphType][draggedPoint].y = graphPos.y;
        
        // If shift is held, update all points to the right
        if (isShiftDragging) {
            for (let i = draggedPoint + 1; i < NUM_POINTS; i++) {
                points[graphType][i].y += delta;
            }
        }
        
        if (draggedPoint > 0) {
            const prevTime = points[graphType][draggedPoint - 1].x;
            points[graphType][draggedPoint].x = Math.max(
                points[graphType][draggedPoint].x,
                prevTime + 0.1
            );
        }
        if (draggedPoint < NUM_POINTS - 1) {
            const nextTime = points[graphType][draggedPoint + 1].x;
            points[graphType][draggedPoint].x = Math.min(
                points[graphType][draggedPoint].x,
                nextTime - 0.1
            );
        }
        
        // Synchronize time across all graphs - using the final adjusted time
        const finalTime = points[graphType][draggedPoint].x;
        points.displacement[draggedPoint].x = finalTime;
        points.velocity[draggedPoint].x = finalTime;
        points.acceleration[draggedPoint].x = finalTime;
        
        updateGraphsFrom(graphType);
        updateOriginPosition();
    }
    
    // Show tooltip for segments after delay
    if (!isDragging && mouseMoved) {
        tooltipTimeout = setTimeout(() => {
            const graphPos = canvasToGraph(canvasX, canvasY, graphType, canvas);
            const segmentIdx = findSegmentAtX(graphPos.x, graphType);
            
            if (segmentIdx !== -1) {
                const kinematics = calculateSegmentKinematics(segmentIdx);
                if (kinematics) {
                    const tooltipText = `Segment ${segmentIdx + 1} (t: ${kinematics.t1.toFixed(2)} ‚Üí ${kinematics.t2.toFixed(2)} s)\n` +
                                      `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                      `u = ${kinematics.u.toFixed(3)} m/s\n` +
                                      `v = ${kinematics.v.toFixed(3)} m/s\n` +
                                      `s = ${kinematics.s.toFixed(3)} m\n` +
                                      `a = ${kinematics.a.toFixed(3)} m/s¬≤\n` +
                                      `t = ${kinematics.t.toFixed(3)} s`;
                    
                    tooltip.textContent = tooltipText;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 10) + 'px';
                    tooltip.style.top = (e.clientY - 10) + 'px';
                }
            }
        }, TOOLTIP_DELAY);
    }
    
    // Update cursor
    const pointIdx = findNearestPoint(canvasX, canvasY, graphType, canvas);
    canvas.style.cursor = pointIdx !== -1 ? 'grab' : 'crosshair';
}

function handleMouseUp(e, graphType) {
    if (isDragging) {
        isDragging = false;
        draggedPoint = null;
        draggedGraph = null;
        isShiftDragging = false;
        initialDragValue = null;
        canvases[graphType].style.cursor = 'crosshair';
        saveState();
    }
}

function handleMouseLeave(e, graphType) {
    tooltip.style.display = 'none';
    if (tooltipTimeout) {
        clearTimeout(tooltipTimeout);
        tooltipTimeout = null;
    }
    if (!isDragging) {
        canvases[graphType].style.cursor = 'crosshair';
    }
}

// Animation functions
function calculateDisplacementAtTime(t) {
    // Ensure all points are sorted by time
    const dispPoints = [...points.displacement].sort((a, b) => a.x - b.x);
    const velPoints = [...points.velocity].sort((a, b) => a.x - b.x);
    const accPoints = [...points.acceleration].sort((a, b) => a.x - b.x);
    
    // Handle edge cases
    if (t <= dispPoints[0].x) {
        return dispPoints[0].y;
    }
    if (t >= dispPoints[dispPoints.length - 1].x) {
        return dispPoints[dispPoints.length - 1].y;
    }
    
    // Find the segment containing time t
    for (let i = 0; i < dispPoints.length - 1; i++) {
        const t1 = dispPoints[i].x;
        const t2 = dispPoints[i + 1].x;
        
        if (t >= t1 && t <= t2) {
            // Get displacement at start of segment
            const s0 = dispPoints[i].y;
            
            // Find velocity at t1 - use the velocity point closest to t1
            let v0 = 0;
            let minVelDist = Infinity;
            for (const vp of velPoints) {
                const dist = Math.abs(vp.x - t1);
                if (dist < minVelDist && dist < 0.1) { // Only match if very close
                    minVelDist = dist;
                    v0 = vp.y;
                }
            }
            
            // Find acceleration for this segment - use the acceleration point closest to t1
            let a = 0;
            let minAccDist = Infinity;
            for (const ap of accPoints) {
                const dist = Math.abs(ap.x - t1);
                if (dist < minAccDist && dist < 0.1) { // Only match if very close
                    minAccDist = dist;
                    a = ap.y;
                }
            }
            
            // Time within segment
            const dt = t - t1;
            
            // Calculate displacement using kinematic equation
            // s = s0 + v0*t + 0.5*a*t¬≤
            const displacement = s0 + v0 * dt + 0.5 * a * dt * dt;
            
            return displacement;
        }
    }
    
    // Fallback (should not reach here)
    return dispPoints[dispPoints.length - 1].y;
}

function startAnimation() {
    if (isPlaying) return;
    
    isPlaying = true;
    playBtn.textContent = '‚è∏ Pause';
    animationStartTime = performance.now();
    animationPhase = 'playing';
    waitStartTime = null;
    movingObject.style.transition = 'none';
    movingObject.style.opacity = '1';
    movingObject.style.cursor = 'default'; // Can't drag during animation
    
    // Get displacement range from sorted points
    const sortedDisp = [...points.displacement].sort((a, b) => a.x - b.x);
    const displacements = sortedDisp.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    const displacementRange = maxDisplacement - minDisplacement;
    
    // Calculate origin position and scaling
    let originPixel;
    let pixelsPerUnit;
    const boxWidth = animationBox.offsetWidth;
    const usableWidth = boxWidth - 60; // Leave margin for object
    
    if (minDisplacement >= 0) {
        // All positive: origin on left
        originPixel = 20;
        pixelsPerUnit = displacementRange > 0 ? usableWidth / displacementRange : 50;
    } else if (maxDisplacement <= 0) {
        // All negative: origin on right
        originPixel = boxWidth - 20;
        pixelsPerUnit = displacementRange > 0 ? usableWidth / displacementRange : 50;
    } else {
        // Mixed: position proportionally
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        
        // Origin position based on proportion
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    // Get time range from sorted points
    const times = sortedDisp.map(p => p.x);
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);
    const timeRange = maxTime - minTime;
    const totalDuration = timeRange > 0.1 ? timeRange * 1000 : 100; // Convert to milliseconds, minimum 100ms
    
    animate();
    
    function animate() {
        if (!isPlaying) return;
        
        const elapsed = performance.now() - animationStartTime;
        
        if (animationPhase === 'playing') {
            if (elapsed < totalDuration) {
                // Normal playback
                const progress = elapsed / totalDuration;
                const currentTime = minTime + progress * timeRange;
                // Clamp current time to valid range
                currentAnimationTime = Math.min(Math.max(currentTime, minTime), maxTime);
                
                // Calculate current displacement
                const currentDisplacement = calculateDisplacementAtTime(currentTime);
                
                // Convert displacement to pixel position
                const pixelOffset = currentDisplacement * pixelsPerUnit;
                let pixelPosition = originPixel + pixelOffset;
                
                // Clamp to box bounds
                pixelPosition = Math.max(10, Math.min(boxWidth - 50, pixelPosition));
                
                // Update object position
                movingObject.style.left = pixelPosition + 'px';
                
                // Update velocity display
                const currentVelocity = calculateVelocityAtTime(currentTime);
                if (Math.abs(currentVelocity) > 0.01) {
                    velocityDisplay.textContent = `${currentVelocity.toFixed(1)} m/s`;
                    velocityDisplay.style.display = 'block';
                    velocityDisplay.style.left = pixelPosition + 'px';
                } else {
                    velocityDisplay.style.display = 'none';
                }
                
                // Update acceleration vector
                const currentAcceleration = calculateAccelerationAtTime(currentTime);
                drawAccelerationVector(currentAcceleration);
                accelerationVector.style.left = pixelPosition + 'px';
                
                // Redraw graphs to show playhead
                updateAllGraphs();
            } else {
                // Finished playing, start waiting
                animationPhase = 'waiting';
                waitStartTime = performance.now();
                currentAnimationTime = maxTime;
                
                // Hide velocity display at end
                velocityDisplay.style.display = 'none';
                accelerationVector.style.display = 'none';
                
                updateAllGraphs();
            }
        } else if (animationPhase === 'waiting') {
            // Wait for 2 seconds
            if (performance.now() - waitStartTime >= 2000) {
                // Start return animation
                animationPhase = 'returning';
                movingObject.style.transition = 'opacity 0.1s, left 1s ease-in-out';
                movingObject.style.opacity = '0.25';
                // Small delay to ensure opacity is set before movement
                setTimeout(() => {
                    movingObject.style.left = originPixel + 'px';
                }, 100);
                
                // Hide velocity and acceleration displays
                velocityDisplay.style.display = 'none';
                accelerationVector.style.display = 'none';
                
                // Stop after transition completes
                setTimeout(() => {
                    stopAnimation();
                }, 1100);
            }
        }
        
        if (animationPhase !== 'returning') {
            animationFrame = requestAnimationFrame(animate);
        }
    }
}

function stopAnimation() {
    isPlaying = false;
    playBtn.textContent = '‚ñ∂Ô∏è Play';
    currentAnimationTime = 0;
    animationPhase = 'playing';
    waitStartTime = null;
    
    // Reset object
    movingObject.style.transition = 'none';
    movingObject.style.opacity = '1';
    movingObject.style.cursor = 'grab'; // Restore drag cursor
    
    // Hide velocity and acceleration displays
    velocityDisplay.style.display = 'none';
    accelerationVector.style.display = 'none';
    
    // Position at origin
    const originMarker = document.getElementById('originMarker');
    const originPixel = parseFloat(originMarker.style.left);
    movingObject.style.left = originPixel + 'px';
    
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    updateAllGraphs(); // Redraw without playhead
}

// Event listeners
for (let graphType in canvases) {
    const canvas = canvases[graphType];
    
    canvas.addEventListener('mousedown', (e) => handleMouseDown(e, graphType));
    canvas.addEventListener('mousemove', (e) => handleMouseMove(e, graphType));
    canvas.addEventListener('mouseup', (e) => handleMouseUp(e, graphType));
    canvas.addEventListener('mouseleave', (e) => handleMouseLeave(e, graphType));
}

// Global mouse up (in case mouse leaves canvas while dragging)
document.addEventListener('mouseup', () => {
    if (isDragging) {
        isDragging = false;
        draggedPoint = null;
        draggedGraph = null;
        isShiftDragging = false;
        initialDragValue = null;
        saveState();
        for (let canvas of Object.values(canvases)) {
            canvas.style.cursor = 'crosshair';
        }
    }
});

// Handle shift key release
document.addEventListener('keyup', (e) => {
    if (e.key === 'Shift' && isDragging) {
        isShiftDragging = false;
    }
});

// Button event listeners
playBtn.addEventListener('click', () => {
    if (isPlaying) {
        stopAnimation();
    } else {
        startAnimation();
    }
});

resetBtn.addEventListener('click', () => {
    stopAnimation();
    initializePoints();
});

undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

emojiSelector.addEventListener('change', (e) => {
    movingObject.textContent = e.target.value;
});

// Emoji dragging functions
function startEmojiDrag(e) {
    if (isPlaying) {
        stopAnimation();
    }
    
    isEmojiDragging = true;
    movingObject.classList.add('dragging');
    emojiDragStartTime = performance.now();
    emojiDragPositions = [];
    
    // Show recording indicator
    playBtn.textContent = '‚è∫ Recording... 0s';
    playBtn.disabled = true;
    
    // Get initial position and scaling info
    const boxWidth = animationBox.offsetWidth;
    const rect = animationBox.getBoundingClientRect();
    const initialMouseX = e.clientX - rect.left;
    
    // Calculate scaling from pixels to meters
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    
    const usableWidth = boxWidth - 60;
    let originPixel, pixelsPerUnit;
    
    if (minDisplacement >= 0) {
        originPixel = 20;
        pixelsPerUnit = (maxDisplacement > 0) ? usableWidth / maxDisplacement : 50;
    } else if (maxDisplacement <= 0) {
        originPixel = boxWidth - 20;
        pixelsPerUnit = (minDisplacement < 0) ? usableWidth / Math.abs(minDisplacement) : 50;
    } else {
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    // Record initial position
    const initialDisplacement = (initialMouseX - originPixel) / pixelsPerUnit;
    emojiDragPositions.push({
        time: 0,
        displacement: initialDisplacement,
        pixelX: initialMouseX
    });
    
    // Start recording positions at 1-second intervals
    let secondCount = 1;
    emojiDragInterval = setInterval(() => {
        if (secondCount > 16 || !isEmojiDragging) {
            if (secondCount > 16 && isEmojiDragging) {
                finishEmojiDrag();
            }
            clearInterval(emojiDragInterval);
            return;
        }
        
        // Record current mouse position
        const currentPos = emojiDragPositions[emojiDragPositions.length - 1];
        emojiDragPositions.push({
            time: secondCount,
            displacement: currentPos.displacement, // Will be updated by mouse move
            pixelX: currentPos.pixelX
        });
        
        // Update recording indicator
        playBtn.textContent = `‚è∫ Recording... ${secondCount}s`;
        
        secondCount++;
        
        // Update graphs with current drag data
        updateGraphsFromDrag();
    }, 1000);
    
    // Add global mouse move handler
    document.addEventListener('mousemove', handleEmojiDragMove);
    document.addEventListener('mouseup', handleEmojiDragEnd);
}

function handleEmojiDragMove(e) {
    if (!isEmojiDragging) return;
    
    const rect = animationBox.getBoundingClientRect();
    const mouseX = Math.max(20, Math.min(rect.width - 20, e.clientX - rect.left));
    
    // Update emoji position
    movingObject.style.left = mouseX + 'px';
    
    // Calculate displacement from origin
    const boxWidth = animationBox.offsetWidth;
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements, -20); // Ensure reasonable range
    const maxDisplacement = Math.max(...displacements, 20);
    
    const usableWidth = boxWidth - 60;
    let originPixel, pixelsPerUnit;
    
    if (minDisplacement >= 0) {
        originPixel = 20;
        pixelsPerUnit = usableWidth / (maxDisplacement || 50);
    } else if (maxDisplacement <= 0) {
        originPixel = boxWidth - 20;
        pixelsPerUnit = usableWidth / (Math.abs(minDisplacement) || 50);
    } else {
        const negativeRange = Math.abs(minDisplacement);
        const positiveRange = maxDisplacement;
        const totalRange = negativeRange + positiveRange;
        originPixel = 20 + (negativeRange / totalRange) * usableWidth;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    const displacement = (mouseX - originPixel) / pixelsPerUnit;
    
    // Update the latest position
    if (emojiDragPositions.length > 0) {
        emojiDragPositions[emojiDragPositions.length - 1].displacement = displacement;
        emojiDragPositions[emojiDragPositions.length - 1].pixelX = mouseX;
    }
    
    // Update velocity and acceleration displays
    if (emojiDragPositions.length >= 2) {
        const prev = emojiDragPositions[emojiDragPositions.length - 2];
        const curr = emojiDragPositions[emojiDragPositions.length - 1];
        const velocity = curr.displacement - prev.displacement; // 1 second interval
        
        if (Math.abs(velocity) > 0.01) {
            velocityDisplay.textContent = `${velocity.toFixed(1)} m/s`;
            velocityDisplay.style.display = 'block';
            velocityDisplay.style.left = mouseX + 'px';
        } else {
            velocityDisplay.style.display = 'none';
        }
        
        if (emojiDragPositions.length >= 3) {
            const prevPrev = emojiDragPositions[emojiDragPositions.length - 3];
            const prevVelocity = prev.displacement - prevPrev.displacement;
            const acceleration = velocity - prevVelocity;
            drawAccelerationVector(acceleration);
            accelerationVector.style.left = mouseX + 'px';
        }
    }
}

function handleEmojiDragEnd() {
    if (!isEmojiDragging) return;
    finishEmojiDrag();
}

function finishEmojiDrag() {
    isEmojiDragging = false;
    movingObject.classList.remove('dragging');
    clearInterval(emojiDragInterval);
    
    // Restore play button
    playBtn.textContent = '‚ñ∂Ô∏è Play';
    playBtn.disabled = false;
    
    // Remove event listeners
    document.removeEventListener('mousemove', handleEmojiDragMove);
    document.removeEventListener('mouseup', handleEmojiDragEnd);
    
    // Fill remaining time points if needed
    const lastTime = emojiDragPositions[emojiDragPositions.length - 1].time;
    const lastDisplacement = emojiDragPositions[emojiDragPositions.length - 1].displacement;
    
    for (let t = lastTime + 1; t <= 16 && emojiDragPositions.length < 17; t++) {
        emojiDragPositions.push({
            time: t,
            displacement: lastDisplacement,
            pixelX: emojiDragPositions[emojiDragPositions.length - 1].pixelX
        });
    }
    
    // Update graphs with final data
    updateGraphsFromDrag();
    saveState();
    
    // Hide displays
    velocityDisplay.style.display = 'none';
    accelerationVector.style.display = 'none';
    
    // Position emoji at final displacement
    const finalDisplacement = emojiDragPositions[emojiDragPositions.length - 1].displacement;
    const boxWidth = animationBox.offsetWidth;
    const originMarker = document.getElementById('originMarker');
    const originPixel = parseFloat(originMarker.style.left);
    
    // Recalculate pixels per unit based on updated range
    const displacements = points.displacement.map(p => p.y);
    const minDisplacement = Math.min(...displacements);
    const maxDisplacement = Math.max(...displacements);
    const usableWidth = boxWidth - 60;
    
    let pixelsPerUnit;
    if (minDisplacement >= 0) {
        pixelsPerUnit = (maxDisplacement > 0) ? usableWidth / maxDisplacement : 50;
    } else if (maxDisplacement <= 0) {
        pixelsPerUnit = (minDisplacement < 0) ? usableWidth / Math.abs(minDisplacement) : 50;
    } else {
        const totalRange = Math.abs(minDisplacement) + maxDisplacement;
        pixelsPerUnit = usableWidth / totalRange;
    }
    
    const finalPixelX = originPixel + finalDisplacement * pixelsPerUnit;
    movingObject.style.left = finalPixelX + 'px';
}

function updateGraphsFromDrag() {
    if (!emojiDragPositions || emojiDragPositions.length < 2) return;
    
    // Reset points
    for (let i = 0; i < NUM_POINTS; i++) {
        points.displacement[i] = { x: i, y: 0 };
        points.velocity[i] = { x: i, y: 0 };
        points.acceleration[i] = { x: i, y: 0 };
    }
    
    // Calculate velocities and accelerations with continuity
    let prevVelocity = 0;
    
    // If we have existing velocity data, use the velocity at time 0
    const existingVelAtZero = points.velocity.find(p => Math.abs(p.x) < 0.1);
    if (existingVelAtZero) {
        prevVelocity = existingVelAtZero.y;
    }
    
    const maxAcceleration = 30; // m/s¬≤ limit
    
    for (let i = 0; i < Math.min(emojiDragPositions.length, NUM_POINTS); i++) {
        const pos = emojiDragPositions[i];
        points.displacement[i].x = pos.time;
        points.displacement[i].y = pos.displacement;
        
        if (i === 0) {
            // First point - use initial velocity
            points.velocity[i].x = pos.time;
            points.velocity[i].y = prevVelocity;
            points.acceleration[i].x = pos.time;
            
            // If we have initial velocity and displacement, calculate the required acceleration
            if (emojiDragPositions.length > 1 && Math.abs(prevVelocity) > 0.01) {
                const nextPos = emojiDragPositions[1];
                const dt = nextPos.time - pos.time;
                const ds = nextPos.displacement - pos.displacement;
                const avgVel = ds / dt;
                const accel = 2 * (avgVel - prevVelocity) / dt;
                points.acceleration[i].y = Math.max(-maxAcceleration, Math.min(maxAcceleration, accel));
            } else {
                points.acceleration[i].y = 0;
            }
        } else {
            const prevPos = emojiDragPositions[i - 1];
            const dt = pos.time - prevPos.time;
            
            if (dt > 0) {
                // Calculate required average velocity for this segment
                const ds = pos.displacement - prevPos.displacement;
                const avgVelocity = ds / dt;
                
                // For constant acceleration: s = s0 + v0*t + 0.5*a*t¬≤
                // Also: v = v0 + a*t
                // Average velocity = (v0 + v) / 2 = v0 + 0.5*a*t
                // So: avgVelocity = v0 + 0.5*a*t
                // Therefore: a = 2*(avgVelocity - v0)/t
                
                let acceleration = 2 * (avgVelocity - prevVelocity) / dt;
                
                // Limit acceleration
                acceleration = Math.max(-maxAcceleration, Math.min(maxAcceleration, acceleration));
                
                // Recalculate final velocity with limited acceleration
                const finalVelocity = prevVelocity + acceleration * dt;
                
                // Set values
                points.velocity[i].x = pos.time;
                points.velocity[i].y = finalVelocity;
                points.acceleration[i - 1].y = acceleration; // Acceleration is constant in previous segment
                
                // Verify displacement with kinematic equation
                const calculatedDisplacement = prevPos.displacement + prevVelocity * dt + 0.5 * acceleration * dt * dt;
                
                // If limited acceleration causes too much error, adjust
                if (Math.abs(calculatedDisplacement - pos.displacement) > 0.5) {
                    // Use average velocity method instead
                    points.velocity[i].y = avgVelocity;
                    points.acceleration[i - 1].y = (avgVelocity - prevVelocity) / dt;
                }
                
                prevVelocity = points.velocity[i].y;
            }
        }
    }
    
    // Set last acceleration segment
    if (emojiDragPositions.length > 1) {
        points.acceleration[emojiDragPositions.length - 1].y = 
            points.acceleration[emojiDragPositions.length - 2].y;
    }
    
    // Fill remaining points with zero velocity and acceleration
    const lastValidIndex = Math.min(emojiDragPositions.length, NUM_POINTS);
    for (let i = lastValidIndex; i < NUM_POINTS; i++) {
        points.displacement[i].x = i;
        points.displacement[i].y = points.displacement[lastValidIndex - 1].y;
        points.velocity[i].x = i;
        points.velocity[i].y = 0;
        points.acceleration[i].x = i;
        points.acceleration[i].y = 0;
    }
    
    // Ensure the transition to zero velocity is smooth
    if (lastValidIndex > 0 && lastValidIndex < NUM_POINTS) {
        const lastVel = points.velocity[lastValidIndex - 1].y;
        if (Math.abs(lastVel) > 0.01) {
            // Add deceleration to bring to rest
            points.acceleration[lastValidIndex - 1].y = -lastVel; // Decelerate to 0 in 1 second
        }
    }
    
    updateAllGraphs();
    updateOriginPosition();
}

// Add mouse event listeners to emoji
movingObject.addEventListener('mousedown', (e) => {
    if (!isPlaying) {
        e.preventDefault();
        startEmojiDrag(e);
    }
});

// Handle window resize
window.addEventListener('resize', () => {
    rulerCanvas.width = animationBox.offsetWidth;
    updateOriginPosition();
});

// Initialize
function initialize() {
    // Set up ruler canvas
    rulerCanvas.width = animationBox.offsetWidth;
    rulerCanvas.height = 20;
    
    // Select random emoji
    const emojis = ['‚öΩ', 'üõ∏', 'üõπ', 'üöÅ', 'üì¶'];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    movingObject.textContent = randomEmoji;
    emojiSelector.value = randomEmoji;
    
    // Initialize points
    initializePoints();
    
    // Load saved setups
    loadSavedList();
}

// Preset Motions
const presets = {
    freefall: {
        name: "Free Fall",
        setup: () => {
            // Reset first
            initializePoints();
            
            // Set acceleration to -9.8 m/s¬≤
            for (let i = 0; i < NUM_POINTS; i++) {
                points.acceleration[i].y = -9.8;
            }
            
            // Initial position at 50m
            points.displacement[0].y = 50;
            points.velocity[0].y = 0;
            
            updateVelocityFromAcceleration();
            updateDisplacementFromVelocity();
        }
    },
    'freefall-up': {
        name: "Free Fall (Initial Upward)",
        setup: () => {
            initializePoints();
            
            // Set acceleration to -9.8 m/s¬≤
            for (let i = 0; i < NUM_POINTS; i++) {
                points.acceleration[i].y = -9.8;
            }
            
            // Initial velocity upward
            points.velocity[0].y = 30;
            points.displacement[0].y = 0;
            
            updateDisplacementFromVelocity();
        }
    },
    uniform: {
        name: "Uniform Motion",
        setup: () => {
            initializePoints();
            
            // Zero acceleration, constant velocity
            for (let i = 0; i < NUM_POINTS; i++) {
                points.acceleration[i].y = 0;
                points.velocity[i].y = 5;
            }
            
            updateDisplacementFromVelocity();
        }
    },
    accelerated: {
        name: "Constant Acceleration",
        setup: () => {
            initializePoints();
            
            // Positive acceleration
            for (let i = 0; i < NUM_POINTS; i++) {
                points.acceleration[i].y = 2;
            }
            
            points.velocity[0].y = 0;
            points.displacement[0].y = 0;
            
            updateVelocityFromAcceleration();
            updateDisplacementFromVelocity();
        }
    },
    decelerated: {
        name: "Constant Deceleration",
        setup: () => {
            initializePoints();
            
            // Negative acceleration
            for (let i = 0; i < NUM_POINTS; i++) {
                points.acceleration[i].y = -3;
            }
            
            points.velocity[0].y = 40;
            points.displacement[0].y = 0;
            
            updateVelocityFromAcceleration();
            updateDisplacementFromVelocity();
        }
    },
    harmonic: {
        name: "Simple Harmonic",
        setup: () => {
            initializePoints();
            
            // Create sinusoidal motion
            const amplitude = 20;
            const period = 8;
            const omega = 2 * Math.PI / period;
            
            // Sort by time to ensure proper ordering
            const sortedIndices = [...Array(NUM_POINTS).keys()].sort((a, b) => 
                points.displacement[a].x - points.displacement[b].x
            );
            
            for (const i of sortedIndices) {
                const t = points.displacement[i].x;
                points.displacement[i].y = amplitude * Math.sin(omega * t);
            }
            
            updateVelocityFromDisplacement();
            updateAccelerationFromVelocity();
        }
    }
};

// Apply preset
function applyPreset() {
    const selectedPreset = presetSelector.value;
    if (selectedPreset && presets[selectedPreset]) {
        presets[selectedPreset].setup();
        updateAllGraphs();
        updateOriginPosition();
        saveState();
        presetSelector.value = '';
    }
}

// Save/Load functionality
function saveSetup() {
    const name = saveName.value.trim();
    if (!name) {
        saveName.style.borderColor = '#ff0000';
        saveName.placeholder = 'Name required!';
        setTimeout(() => {
            saveName.style.borderColor = '#ccc';
            saveName.placeholder = 'Save name...';
        }, 2000);
        return;
    }
    
    const saves = JSON.parse(localStorage.getItem('kinematicsSaves') || '{}');
    saves[name] = {
        points: JSON.parse(JSON.stringify(points)),
        timestamp: new Date().toISOString()
    };
    
    localStorage.setItem('kinematicsSaves', JSON.stringify(saves));
    saveName.value = '';
    loadSavedList();
    
    // Show success feedback
    saveBtn.textContent = '‚úì Saved!';
    saveBtn.style.backgroundColor = '#4CAF50';
    setTimeout(() => {
        saveBtn.textContent = 'üíæ Save';
        saveBtn.style.backgroundColor = '#4CAF50';
    }, 1500);
}

function loadSavedList() {
    const saves = JSON.parse(localStorage.getItem('kinematicsSaves') || '{}');
    savedItems.innerHTML = '';
    
    if (Object.keys(saves).length === 0) {
        savedList.style.display = 'none';
        return;
    }
    
    savedList.style.display = 'block';
    
    Object.keys(saves).sort().forEach(name => {
        const li = document.createElement('li');
        li.className = 'saved-item';
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'saved-item-name';
        nameSpan.textContent = name;
        
        const actions = document.createElement('div');
        actions.className = 'saved-item-actions';
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.onclick = () => loadSetup(name);
        
        const duplicateBtn = document.createElement('button');
        duplicateBtn.textContent = 'Duplicate';
        duplicateBtn.onclick = () => duplicateSetup(name);
        
        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.onclick = () => renameSetup(name);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.style.backgroundColor = '#f44336';
        deleteBtn.onclick = () => {
            if (deleteBtn.textContent === 'Delete') {
                deleteBtn.textContent = 'Confirm?';
                deleteBtn.style.backgroundColor = '#d32f2f';
                setTimeout(() => {
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.style.backgroundColor = '#f44336';
                }, 3000);
            } else {
                deleteSetup(name);
            }
        };
        
        actions.appendChild(loadBtn);
        actions.appendChild(duplicateBtn);
        actions.appendChild(renameBtn);
        actions.appendChild(deleteBtn);
        
        li.appendChild(nameSpan);
        li.appendChild(actions);
        savedItems.appendChild(li);
    });
}

function loadSetup(name) {
    const saves = JSON.parse(localStorage.getItem('kinematicsSaves') || '{}');
    if (saves[name]) {
        points = JSON.parse(JSON.stringify(saves[name].points));
        updateAllGraphs();
        updateOriginPosition();
        saveState();
    }
}

function duplicateSetup(name) {
    const saves = JSON.parse(localStorage.getItem('kinematicsSaves') || '{}');
    if (saves[name]) {
        let newName = name + ' (copy)';
        let counter = 1;
        while (saves[newName]) {
            counter++;
            newName = name + ' (copy ' + counter + ')';
        }
        saves[newName] = {
            points: saves[name].points,
            timestamp: new Date().toISOString()
        };
        localStorage.setItem('kinematicsSaves', JSON.stringify(saves));
        loadSavedList();
    }
}

function renameSetup(oldName) {
    const saves = JSON.parse(localStorage.getItem('kinematicsSaves') || '{}');
    const savedItem = [...savedItems.children].find(li => 
        li.querySelector('.saved-item-name').textContent === oldName
    );
    
    if (!savedItem) return;
    
    const nameSpan = savedItem.querySelector('.saved-item-name');
    const originalName = nameSpan.textContent;
    
    // Create input field
    const input = document.createElement('input');
    input.type = 'text';
    input.value = originalName;
    input.style.width = '150px';
    input.style.padding = '2px 4px';
    
    // Replace span with input
    nameSpan.style.display = 'none';
    savedItem.insertBefore(input, nameSpan);
    input.focus();
    input.select();
    
    // Handle save
    const saveRename = () => {
        const newName = input.value.trim();
        if (newName && newName !== originalName && !saves[newName]) {
            saves[newName] = saves[originalName];
            delete saves[originalName];
            localStorage.setItem('kinematicsSaves', JSON.stringify(saves));
            loadSavedList();
        } else {
            // Revert
            input.remove();
            nameSpan.style.display = '';
        }
    };
    
    // Handle cancel
    const cancelRename = () => {
        input.remove();
        nameSpan.style.display = '';
    };
    
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') saveRename();
        if (e.key === 'Escape') cancelRename();
    });
    
    input.addEventListener('blur', saveRename);
}

function deleteSetup(name) {
    const saves = JSON.parse(localStorage.getItem('kinematicsSaves') || '{}');
    delete saves[name];
    localStorage.setItem('kinematicsSaves', JSON.stringify(saves));
    loadSavedList();
}

// CSV Export/Import
function exportToCsv() {
    let csv = 'Time,Displacement,Velocity,Acceleration\n';
    
    for (let i = 0; i < NUM_POINTS; i++) {
        csv += `${points.displacement[i].x},${points.displacement[i].y},${points.velocity[i].y},${points.acceleration[i].y}\n`;
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'kinematics_data.csv';
    a.click();
    URL.revokeObjectURL(url);
}

function importFromCsv(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        const csv = e.target.result;
        const lines = csv.split('\n');
        
        // Skip header
        if (lines.length < 2) return;
        
        // Reset points
        initializePoints();
        
        // Parse data
        for (let i = 1; i < lines.length && i <= NUM_POINTS; i++) {
            const parts = lines[i].split(',');
            if (parts.length >= 4) {
                const idx = i - 1;
                const t = parseFloat(parts[0]);
                const s = parseFloat(parts[1]);
                const v = parseFloat(parts[2]);
                const a = parseFloat(parts[3]);
                
                if (!isNaN(t) && !isNaN(s) && !isNaN(v) && !isNaN(a)) {
                    points.displacement[idx] = { x: t, y: s };
                    points.velocity[idx] = { x: t, y: v };
                    points.acceleration[idx] = { x: t, y: a };
                }
            }
        }
        
        updateAllGraphs();
        updateOriginPosition();
        saveState();
    };
    
    reader.readAsText(file);
    event.target.value = ''; // Reset input
}

// Event listeners for save/load
applyPresetBtn.addEventListener('click', applyPreset);
presetSelector.addEventListener('change', () => {
    applyPresetBtn.disabled = !presetSelector.value;
});
saveBtn.addEventListener('click', saveSetup);
exportCsvBtn.addEventListener('click', exportToCsv);
importCsvBtn.addEventListener('click', () => importCsvInput.click());
importCsvInput.addEventListener('change', importFromCsv);

// Keyboard shortcut for save
saveName.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        saveSetup();
    }
});

initialize();
</script>
</body>
</html>