<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Global Names Memorial - Speaking Every Name</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="A memorial honoring the diversity of human naming across all cultures, speaking names in multiple languages with native scripts.">

<style>
    :root {
        --primary-bg: #1a1a1a;
        --secondary-bg: #363636;
        --glass-bg: rgba(255, 255, 255, 0.1);
        --text-primary: #ffffff;
        --text-secondary: #cccccc;
        --accent: #4a90e2;
        --sacred: #ffd700;
        --taboo: #ff6b6b;
        --transition: #9b59b6;
        --cultural: #2ecc71;
    }

    * {
        box-sizing: border-box;
    }

    html {
        background: var(--primary-bg);
        min-height: 100%;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "Noto Sans Arabic", "Noto Sans Hebrew", "Noto Sans Ethiopic", "Noto Sans Tifinagh", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
        background-attachment: fixed;
        color: var(--text-primary);
        padding: 1rem;
        position: relative;
        overflow-x: hidden;
    }

    .container {
        background: var(--glass-bg);
        padding: 1.5rem;
        border-radius: 1.5rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        width: min(95vw, 800px);
        max-width: 800px;
        margin: auto;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
        margin: 0 0 0.25rem 0;
        font-size: clamp(1.8rem, 6vw, 2.5rem);
        text-transform: uppercase;
        letter-spacing: 3px;
        color: var(--text-primary);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    /* Name Display Section */
    .name-display-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 1rem;
        padding: 1.5rem;
        margin-bottom: 1rem;
        min-height: 180px;
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .name-main {
        font-size: clamp(1.6rem, 6vw, 2.2rem);
        margin: 0.4rem 0;
        line-height: 1.3;
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.3s ease;
        word-wrap: break-word;
        padding: 0.4rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "Noto Sans Arabic", "Noto Sans Hebrew", "Noto Sans Ethiopic", "Noto Sans Tifinagh", "Arial Unicode MS", sans-serif;
    }

    .name-main:hover {
        transform: scale(1.02);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .name-components {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        margin: 0.8rem 0;
    }

    .component {
        background: rgba(255, 255, 255, 0.08);
        padding: 0.25rem 0.6rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .component-label {
        color: var(--text-secondary);
        font-size: 0.75rem;
        margin-right: 0.25rem;
    }

    /* Meanings Section */
    .meanings-section {
        background: rgba(74, 144, 226, 0.1);
        border-radius: 0.6rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(74, 144, 226, 0.2);
        text-align: left;
    }

    .meanings-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 0.4rem;
        font-size: 0.9rem;
    }

    .meaning-item {
        font-size: 0.8rem;
        margin: 0.25rem 0;
        padding-left: 0.8rem;
    }

    .meaning-label {
        color: var(--text-secondary);
        font-style: italic;
        font-size: 0.75rem;
    }

    /* Old Names Section */
    .old-names-section {
        background: rgba(255, 215, 0, 0.08);
        border-radius: 0.6rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(255, 215, 0, 0.2);
        text-align: left;
    }

    .old-names-title {
        font-weight: bold;
        color: var(--sacred);
        margin-bottom: 0.4rem;
        font-size: 0.9rem;
    }

    /* Cultural Context */
    .cultural-context {
        background: rgba(74, 144, 226, 0.08);
        border-radius: 0.8rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(74, 144, 226, 0.2);
    }

    .culture-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.6rem;
        text-align: left;
    }

    .info-item {
        font-size: 0.85rem;
    }

    .info-label {
        color: var(--accent);
        font-weight: bold;
    }

    /* Special Indicators */
    .special-indicators {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        margin: 0.8rem 0;
        flex-wrap: wrap;
    }

    .indicator {
        padding: 0.2rem 0.6rem;
        border-radius: 1.5rem;
        font-size: 0.8rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .indicator-sacred {
        background: var(--sacred);
        color: var(--primary-bg);
    }

    .indicator-taboo {
        background: var(--taboo);
        color: white;
    }

    .indicator-transition {
        background: var(--transition);
        color: white;
    }

    .indicator-cultural {
        background: var(--cultural);
        color: white;
    }

    .indicator-mononym {
        background: #3498db;
        color: white;
    }

    .indicator-old-name {
        background: #8b4513;
        color: white;
    }

    /* Voice Status */
    .voice-status {
        color: var(--text-secondary);
        margin: 1rem 0;
        font-size: 0.9rem;
        font-style: italic;
        min-height: 1.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        opacity: 0.8;
    }

    .sign-language-note {
        background: rgba(255, 255, 255, 0.08);
        padding: 0.4rem 0.8rem;
        border-radius: 0.5rem;
        margin: 0.4rem 0;
        font-size: 0.85rem;
    }

    /* Controls */
    .controls {
        display: grid;
        gap: 0.6rem;
        margin-top: 1rem;
    }

    .control-row {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        background: rgba(255, 255, 255, 0.08);
        padding: 0.35rem 0.6rem;
        border-radius: 0.8rem;
        min-width: 100px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        font-size: 0.85rem;
    }

    button {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 0.5rem;
        cursor: pointer;
        padding: 0.6rem 1.2rem;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        min-width: 90px;
    }

    button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:active:not(:disabled) {
        transform: translateY(0);
    }

    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    button.primary {
        background: rgba(74, 144, 226, 0.8);
        border-color: rgba(74, 144, 226, 0.4);
    }

    button.primary:hover:not(:disabled) {
        background: rgba(74, 144, 226, 1);
    }

    /* Toggle Switches */
    .switch {
        position: relative;
        display: inline-block;
        width: 36px;
        height: 18px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.2);
        transition: .3s;
        border-radius: 18px;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: .3s;
        border-radius: 50%;
    }

    input:checked + .slider {
        background-color: rgba(255, 255, 255, 0.4);
    }

    input:checked + .slider:before {
        transform: translateX(18px);
    }

    /* Stats Display */
    .stats {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-top: 1rem;
        padding: 0.8rem;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 0.5rem;
        opacity: 0.7;
    }

    /* Loading Status */
    .loading-status {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 0.6rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: var(--text-secondary);
        font-size: 0.85rem;
    }

    .error-message {
        background: rgba(255, 107, 107, 0.15);
        border: 1px solid rgba(255, 107, 107, 0.4);
        color: #ff6b6b;
        padding: 0.8rem;
        font-size: 0.85rem;
    }

    /* Modal for Information */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
    }

    .modal-content {
        background: var(--secondary-bg);
        margin: 5% auto;
        padding: 2rem;
        border-radius: 1rem;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: var(--text-primary);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .close {
        color: var(--text-secondary);
        float: right;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
    }

    .close:hover {
        color: var(--text-primary);
    }

    /* Settings Modal Styles */
    .settings-modal-content {
        background: var(--secondary-bg);
        margin: 2% auto;
        padding: 2rem;
        border-radius: 1rem;
        width: 90%;
        max-width: 900px;
        max-height: 90vh;
        overflow-y: auto;
        color: var(--text-primary);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--accent);
    }

    .settings-tabs {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .settings-tab {
        padding: 0.8rem 1.5rem;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.3s;
        border-bottom: 3px solid transparent;
    }

    .settings-tab.active {
        color: var(--text-primary);
        border-bottom-color: var(--accent);
    }

    .voice-list {
        max-height: 500px;
        overflow-y: auto;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 0.5rem;
    }

    .voice-item {
        display: flex;
        align-items: center;
        padding: 0.8rem;
        margin: 0.5rem 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
        transition: all 0.2s;
    }

    .voice-item:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .voice-checkbox {
        width: 20px;
        height: 20px;
        margin-right: 1rem;
        cursor: pointer;
    }

    .voice-info {
        flex: 1;
        display: grid;
        grid-template-columns: 2fr 1fr 1fr 0.5fr;
        gap: 1rem;
        align-items: center;
    }

    .voice-name {
        font-weight: bold;
        color: var(--text-primary);
    }

    .voice-lang {
        color: var(--accent);
        font-size: 0.9rem;
    }

    .voice-gender {
        padding: 0.2rem 0.6rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 1rem;
        font-size: 0.85rem;
        text-align: center;
    }

    .voice-quality {
        display: flex;
        gap: 0.2rem;
    }

    .quality-star {
        color: var(--sacred);
        font-size: 0.9rem;
    }

    .voice-test-btn {
        padding: 0.4rem 1rem;
        background: var(--accent);
        border: none;
        border-radius: 0.5rem;
        color: white;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
    }

    .voice-test-btn:hover {
        background: #5ba0f2;
        transform: scale(1.05);
    }

    .voice-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        margin: 1rem 0;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
    }

    .stat-item {
        text-align: center;
    }

    .stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--accent);
    }

    .stat-label {
        font-size: 0.85rem;
        color: var(--text-secondary);
    }

    .settings-actions {
        display: flex;
        gap: 1rem;
        margin-top: 2rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .settings-key-hint {
        position: fixed;
        bottom: 1rem;
        left: 1rem;
        padding: 0.5rem 1rem;
        background: rgba(0, 0, 0, 0.8);
        color: var(--text-secondary);
        border-radius: 0.5rem;
        font-size: 0.85rem;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
    }

    .settings-key-hint.visible {
        opacity: 1;
    }

    /* Info Button */
    #infoButton {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        width: 40px;
        height: 40px;
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: rgba(255, 255, 255, 0.7);
        z-index: 100;
        padding: 0;
    }

    #infoButton:hover {
        color: var(--text-primary);
        transform: scale(1.1);
    }

    /* Acknowledgment Style */
    .acknowledgment {
        font-size: 1.1rem;
        line-height: 1.8;
        color: var(--text-primary);
        padding: 2rem;
        text-align: center;
        font-style: italic;
        background: rgba(255, 215, 0, 0.1);
        border-radius: 1rem;
        border: 1px solid rgba(255, 215, 0, 0.3);
    }

    /* Responsive Design */
    @media (max-width: 600px) {
        .container {
            padding: 1rem;
        }
        
        .name-display-section {
            padding: 1rem;
        }
        
        .control-group {
            min-width: 90px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }
        
        .culture-info {
            grid-template-columns: 1fr;
        }
        
        .switch {
            width: 32px;
            height: 16px;
        }
        
        .slider:before {
            height: 12px;
            width: 12px;
        }
        
        input:checked + .slider:before {
            transform: translateX(16px);
        }
    }

    /* Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .fade-in {
        animation: fadeIn 0.5s ease-out;
    }

    /* Special script displays */
    .script-display {
        font-size: 1.2rem;
        margin: 0.5rem 0;
        opacity: 0.8;
        line-height: 1.5;
    }

    .script-display.chinese,
    .script-display.traditional {
        font-family: "Noto Sans CJK SC", "Microsoft YaHei", "SimHei", sans-serif;
        font-size: 1.6rem;
    }

    .script-display.tibetan {
        font-family: "Noto Sans Tibetan", "Microsoft Himalaya", "Tibetan Machine Uni", serif;
        font-size: 1.4rem;
    }

    .script-display.burmese {
        font-family: "Noto Sans Myanmar", "Myanmar Text", "Padauk", sans-serif;
        font-size: 1.4rem;
    }

    .script-display.devanagari {
        font-family: "Noto Sans Devanagari", "Mangal", "Kokila", sans-serif;
        font-size: 1.5rem;
    }

    .script-display.cyrillic {
        font-family: "Noto Sans", "Arial", sans-serif;
        font-size: 1.4rem;
    }

    .script-display.greek {
        font-family: "Noto Sans Greek", "Arial", sans-serif;
        font-size: 1.4rem;
    }

    .script-display.armenian {
        font-family: "Noto Sans Armenian", "Sylfaen", sans-serif;
        font-size: 1.4rem;
    }

    .script-display.bengali {
        font-family: "Noto Sans Bengali", "Vrinda", "SolaimanLipi", sans-serif;
        font-size: 1.4rem;
    }

    .rtl {
        direction: rtl;
    }

    .click-notation {
        font-family: "Noto Sans", "DejaVu Sans", sans-serif;
        font-size: 1.3rem;
    }

    /* Loading indicator */
    .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--accent);
        animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>

</head>
<body>
    <button id="infoButton" title="About this work">?</button>
    
    <div class="container">
        <h1>Resurrective Necropolis</h1>
        
        <div id="loadingStatus" class="loading-status">
            <span class="loading"></span> Loading language data...
        </div>
        
        <div class="name-display-section">
            <div id="nameDisplay" class="name-main fade-in">Initializing...</div>
            <div id="scriptDisplay" class="script-display"></div>
            <div id="nameComponents" class="name-components"></div>
            <div id="specialIndicators" class="special-indicators"></div>
            <div id="culturalContext" class="cultural-context"></div>
            <div id="meaningsSection" class="meanings-section" style="display: none;"></div>
            <div id="oldNamesSection" class="old-names-section" style="display: none;"></div>
            <div id="voiceStatus" class="voice-status"></div>
            <div id="signLanguageNote" class="sign-language-note" style="display: none;"></div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <button id="initVoiceButton" class="primary">Initialize Voice System</button>
                <button id="toggleButton">Pause</button>
                <button id="speakButton">Speak Name</button>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <span style="font-size: 0.85rem;">Slow</span>
                    <label class="switch">
                        <input type="checkbox" id="speedToggle">
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.85rem;">Fast</span>
                </div>
                
                <div class="control-group">
                    <span style="font-size: 0.85rem;">Random</span>
                    <label class="switch">
                        <input type="checkbox" id="weightedToggle">
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.85rem;">Weight</span>
                </div>
                
                <div class="control-group">
                    <span style="font-size: 0.85rem;">Basic</span>
                    <label class="switch">
                        <input type="checkbox" id="detailToggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.85rem;">Detail</span>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <span style="font-size: 0.85rem;">Now</span>
                    <label class="switch">
                        <input type="checkbox" id="oldNamesToggle">
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.85rem;">Old</span>
                </div>
                
                <div class="control-group">
                    <span style="font-size: 0.85rem;">Separate</span>
                    <label class="switch">
                        <input type="checkbox" id="mixNamesToggle">
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.85rem;">Mix</span>
                </div>
                
                <div class="control-group">
                    <span style="font-size: 0.85rem;">Latin</span>
                    <label class="switch">
                        <input type="checkbox" id="nativeScriptToggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.85rem;">Native</span>
                </div>
            </div>
        </div>
        
        <div id="statsDisplay" class="stats">Initializing...</div>
    </div>
    
    <!-- Information Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>About This Memorial</h2>
            <div class="acknowledgment">
                This work recognizes the profound diversity of human naming across all cultures. 
                It acknowledges that names carry deep meaning—they can be sacred, earned through 
                life experiences, changed to reflect identity, or held in silence to honor the dead. 
                Some names are visual, some are whistled, some contain sounds unique to specific 
                languages. Every name represents a life, a story, a connection to family and culture.
                <br><br>
                By speaking these names—or respectfully acknowledging when they cannot be spoken—we 
                honor the universal human practice of remembering through naming.
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="settings-modal-content">
            <div class="settings-header">
                <h2>⚙️ Voice Settings</h2>
                <span class="close" onclick="closeSettings()">&times;</span>
            </div>
            
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="showSettingsTab('voices')">Voices</button>
                <button class="settings-tab" onclick="showSettingsTab('matching')">Voice Matching</button>
                <button class="settings-tab" onclick="showSettingsTab('advanced')">Advanced</button>
            </div>
            
            <div id="voicesTab" class="settings-content">
                <div class="voice-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalVoices">0</div>
                        <div class="stat-label">Total Voices</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="enabledVoices">0</div>
                        <div class="stat-label">Enabled</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="languageCount">0</div>
                        <div class="stat-label">Languages</div>
                    </div>
                </div>
                
                <div class="settings-actions">
                    <button onclick="selectAllVoices(true)">Enable All</button>
                    <button onclick="selectAllVoices(false)">Disable All</button>
                    <button onclick="selectQualityVoices()">Select High Quality</button>
                    <button onclick="resetVoiceSettings()">Reset to Default</button>
                </div>
                
                <div id="voiceList" class="voice-list">
                    <!-- Voice items will be populated here -->
                </div>
            </div>
            
            <div id="matchingTab" class="settings-content" style="display: none;">
                <h3>Voice Matching Settings</h3>
                <div style="padding: 1rem;">
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="matchGender" checked> 
                        Match voice gender to name gender
                    </label>
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="matchLanguage" checked> 
                        Match voice language to name origin
                    </label>
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="preferHighQuality" checked> 
                        Prefer high-quality voices
                    </label>
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="avoidNovelty" checked> 
                        Avoid novelty voices (Zarvox, Bells, etc.)
                    </label>
                </div>
            </div>
            
            <div id="advancedTab" class="settings-content" style="display: none;">
                <h3>Advanced Settings</h3>
                <div style="padding: 1rem;">
                    <button onclick="exportSettings()">Export Settings</button>
                    <button onclick="importSettings()">Import Settings</button>
                    <button onclick="clearAllSettings()">Clear All Settings</button>
                    <div style="margin-top: 2rem; padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem;">
                        <p>Press <strong>Q + W + E</strong> simultaneously to open settings</p>
                        <p>Press <strong>ESC</strong> to close</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings key hint -->
    <div id="settingsKeyHint" class="settings-key-hint">
        Press Q+W+E for voice settings
    </div>

    <script>
// Global Names Memorial - Version 3.2
// Features:
// - Expanded name databases (doubled names for all language families)
// - Native script display (Chinese, Tibetan, Cyrillic, Devanagari, etc.)
// - Mixed mode: combines historical and modern names
// - Intelligent voice matching based on gender and language family
// - Voice settings panel (press Q+W+E to open)
// - Persistent voice preferences saved in localStorage
// - Quality assessment and novelty voice filtering
// - Per-voice enable/disable controls
// - Voice testing capability

// Global state
const appState = {
    isRunning: false,
    isFast: false,
    isWeighted: false,
    showDetails: true,
    showOldNames: false,
    mixOldAndNew: false,
    showNativeScript: true,
    isVoiceInitialized: false,
    currentName: null,
    synth: window.speechSynthesis,
    voices: [],
    voiceSettings: {
        enabled: {},
        matchGender: true,
        matchLanguage: true,
        preferHighQuality: true,
        avoidNovelty: true
    },
    intervalId: null,
    SLOW_SPEED: 10000,
    FAST_SPEED: 5000,
    metadata: null,
    loadedFamilies: {},
    isInitialized: false,
    keysPressed: {}
};

// Voice Management System
const voiceManager = {
    NOVELTY_VOICES: [
        'trinoids', 'zarvox', 'albert', 'whisper', 'bahh', 'boing', 
        'bubbles', 'deranged', 'hysterical', 'cellos', 'pipe organ', 
        'organ', 'good news', 'bad news', 'bells', 'jester', 'princess', 
        'superstar', 'junior', 'wobble'
    ],
    
    // Gender detection based on voice name and properties
    detectGender(voice) {
        const name = voice.name.toLowerCase();
        
        // Check for explicit gender markers in name
        if (name.includes('female') || name.includes('woman') || 
            name.includes('girl') || name.includes('lady')) {
            return 'female';
        }
        if (name.includes('male') || name.includes('man') || 
            name.includes('boy') || name.includes('guy')) {
            return 'male';
        }
        
        // Common female voice names
        const femaleNames = ['samantha', 'victoria', 'kate', 'karen', 'nicole', 
                           'jennifer', 'kathy', 'susan', 'helen', 'claire', 
                           'fiona', 'moira', 'tessa', 'serena', 'ava',
                           'allison', 'sara', 'vicki', 'alice', 'monica',
                           'paulina', 'kanya', 'veena', 'luciana', 'mariana',
                           'milena', 'yuna', 'mei-jia', 'sin-ji', 'ting-ting'];
        
        // Common male voice names
        const maleNames = ['daniel', 'thomas', 'alex', 'fred', 'bruce', 
                         'lee', 'diego', 'jorge', 'juan', 'carlos',
                         'rishi', 'maged', 'yuri', 'xander', 'oliver',
                         'luca', 'magnus', 'oskar', 'damayanti'];
        
        for (const fname of femaleNames) {
            if (name.includes(fname)) return 'female';
        }
        
        for (const mname of maleNames) {
            if (name.includes(mname)) return 'male';
        }
        
        // Default to neutral
        return 'neutral';
    },
    
    // Quality assessment based on voice properties
    assessQuality(voice) {
        const name = voice.name.toLowerCase();
        
        // Check if it's a novelty voice
        if (this.NOVELTY_VOICES.some(nov => name.includes(nov))) {
            return 1; // Low quality
        }
        
        // Premium/Enhanced voices usually have these markers
        if (name.includes('premium') || name.includes('enhanced') || 
            name.includes('natural') || name.includes('neural')) {
            return 5;
        }
        
        // Local/offline voices are often lower quality
        if (voice.localService) {
            return voice.default ? 3 : 2;
        }
        
        // Online voices are usually better
        return 4;
    },
    
    // Get language family from language code
    getLanguageFamily(langCode) {
        const langMap = {
            'en': 'indoEuropean',
            'es': 'indoEuropean',
            'fr': 'indoEuropean',
            'de': 'indoEuropean',
            'it': 'indoEuropean',
            'pt': 'indoEuropean',
            'ru': 'indoEuropean',
            'hi': 'indoEuropean',
            'zh': 'sinoTibetan',
            'cmn': 'sinoTibetan',
            'yue': 'sinoTibetan',
            'bo': 'sinoTibetan',
            'my': 'sinoTibetan',
            'ar': 'afroasiatic',
            'he': 'afroasiatic',
            'ja': 'japanese',
            'ko': 'korean',
            'vi': 'austroasiatic',
            'th': 'taiKadai',
            'id': 'austronesian',
            'ms': 'austronesian',
            'tl': 'austronesian'
        };
        
        const primaryLang = langCode.split('-')[0].toLowerCase();
        return langMap[primaryLang] || 'unknown';
    },
    
    // Select best voice for a name
    selectVoice(nameData) {
        const settings = appState.voiceSettings;
        let availableVoices = appState.voices.filter(v => 
            settings.enabled[v.name] !== false
        );
        
        if (availableVoices.length === 0) {
            availableVoices = appState.voices;
        }
        
        // Filter out novelty voices if setting is enabled
        if (settings.avoidNovelty) {
            availableVoices = availableVoices.filter(v => 
                !this.NOVELTY_VOICES.some(nov => 
                    v.name.toLowerCase().includes(nov)
                )
            );
        }
        
        // Score each voice
        const scoredVoices = availableVoices.map(voice => {
            let score = 0;
            
            // Gender matching
            if (settings.matchGender && nameData.gender) {
                const voiceGender = this.detectGender(voice);
                if (voiceGender === nameData.gender) {
                    score += 10;
                } else if (voiceGender === 'neutral') {
                    score += 5;
                }
            }
            
            // Language matching
            if (settings.matchLanguage && nameData.familyId) {
                const voiceFamily = this.getLanguageFamily(voice.lang);
                if (voiceFamily === nameData.familyId) {
                    score += 15;
                }
            }
            
            // Quality preference
            if (settings.preferHighQuality) {
                score += this.assessQuality(voice) * 2;
            }
            
            // Prefer default voice
            if (voice.default) {
                score += 3;
            }
            
            return { voice, score };
        });
        
        // Sort by score and return best match
        scoredVoices.sort((a, b) => b.score - a.score);
        
        return scoredVoices[0]?.voice || appState.voices[0];
    }
};

// Load voice settings from localStorage
function loadVoiceSettings() {
    try {
        const saved = localStorage.getItem('memorialVoiceSettings');
        if (saved) {
            const settings = JSON.parse(saved);
            appState.voiceSettings = { ...appState.voiceSettings, ...settings };
            console.log('Loaded voice settings from localStorage');
        }
    } catch (error) {
        console.error('Failed to load voice settings:', error);
    }
}

// Save voice settings to localStorage
function saveVoiceSettings() {
    try {
        localStorage.setItem('memorialVoiceSettings', JSON.stringify(appState.voiceSettings));
        console.log('Saved voice settings to localStorage');
    } catch (error) {
        console.error('Failed to save voice settings:', error);
    }
}

// Settings Modal Functions
function openSettings() {
    const modal = document.getElementById('settingsModal');
    modal.style.display = 'block';
    
    // Load current settings into checkboxes
    document.getElementById('matchGender').checked = appState.voiceSettings.matchGender;
    document.getElementById('matchLanguage').checked = appState.voiceSettings.matchLanguage;
    document.getElementById('preferHighQuality').checked = appState.voiceSettings.preferHighQuality;
    document.getElementById('avoidNovelty').checked = appState.voiceSettings.avoidNovelty;
    
    populateVoiceList();
    updateVoiceStats();
}

function closeSettings() {
    const modal = document.getElementById('settingsModal');
    modal.style.display = 'none';
    saveVoiceSettings();
}

function showSettingsTab(tabName) {
    // Hide all tabs
    document.getElementById('voicesTab').style.display = 'none';
    document.getElementById('matchingTab').style.display = 'none';
    document.getElementById('advancedTab').style.display = 'none';
    
    // Show selected tab
    document.getElementById(tabName + 'Tab').style.display = 'block';
    
    // Update tab buttons
    document.querySelectorAll('.settings-tab').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Find the button that was clicked
    const buttons = document.querySelectorAll('.settings-tab');
    buttons.forEach(btn => {
        if (btn.textContent.toLowerCase().includes(tabName.toLowerCase())) {
            btn.classList.add('active');
        }
    });
}

function populateVoiceList() {
    const container = document.getElementById('voiceList');
    container.innerHTML = '';
    
    // Group voices by language
    const voicesByLang = {};
    appState.voices.forEach(voice => {
        const lang = voice.lang;
        if (!voicesByLang[lang]) {
            voicesByLang[lang] = [];
        }
        voicesByLang[lang].push(voice);
    });
    
    // Create voice items
    Object.entries(voicesByLang).sort().forEach(([lang, voices]) => {
        // Language header
        const header = document.createElement('div');
        header.style.padding = '0.5rem';
        header.style.marginTop = '1rem';
        header.style.color = 'var(--accent)';
        header.style.fontWeight = 'bold';
        header.textContent = `${lang} (${voices.length} voices)`;
        container.appendChild(header);
        
        voices.forEach(voice => {
            const item = document.createElement('div');
            item.className = 'voice-item';
            
            const isEnabled = appState.voiceSettings.enabled[voice.name] !== false;
            const gender = voiceManager.detectGender(voice);
            const quality = voiceManager.assessQuality(voice);
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'voice-checkbox';
            checkbox.checked = isEnabled;
            checkbox.onchange = () => toggleVoice(voice.name, checkbox.checked);
            
            // Create info div
            const infoDiv = document.createElement('div');
            infoDiv.className = 'voice-info';
            
            // Name and language
            const nameDiv = document.createElement('div');
            const nameSpan = document.createElement('div');
            nameSpan.className = 'voice-name';
            nameSpan.textContent = voice.name;
            const langSpan = document.createElement('div');
            langSpan.className = 'voice-lang';
            langSpan.textContent = voice.lang;
            nameDiv.appendChild(nameSpan);
            nameDiv.appendChild(langSpan);
            
            // Gender
            const genderDiv = document.createElement('div');
            genderDiv.className = 'voice-gender';
            genderDiv.textContent = gender;
            genderDiv.style.background = 
                gender === 'female' ? 'rgba(255, 105, 180, 0.2)' :
                gender === 'male' ? 'rgba(100, 149, 237, 0.2)' :
                'rgba(255, 255, 255, 0.1)';
            
            // Quality stars
            const qualityDiv = document.createElement('div');
            qualityDiv.className = 'voice-quality';
            qualityDiv.innerHTML = Array(quality).fill('★').join('');
            
            // Test button
            const testBtn = document.createElement('button');
            testBtn.className = 'voice-test-btn';
            testBtn.textContent = 'Test';
            testBtn.onclick = () => testVoice(voice.name);
            
            infoDiv.appendChild(nameDiv);
            infoDiv.appendChild(genderDiv);
            infoDiv.appendChild(qualityDiv);
            infoDiv.appendChild(testBtn);
            
            item.appendChild(checkbox);
            item.appendChild(infoDiv);
            container.appendChild(item);
        });
    });
}

function toggleVoice(voiceName, enabled) {
    appState.voiceSettings.enabled[voiceName] = enabled;
    updateVoiceStats();
    saveVoiceSettings();
}

function testVoice(voiceName) {
    const voice = appState.voices.find(v => v.name === voiceName);
    if (!voice) return;
    
    appState.synth.cancel();
    
    const testText = appState.currentName ? 
        appState.currentName.display : 
        'Testing voice: ' + voiceName;
    
    const utterance = new SpeechSynthesisUtterance(testText);
    utterance.voice = voice;
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;
    
    appState.synth.speak(utterance);
}

function updateVoiceStats() {
    const total = appState.voices.length;
    const enabled = appState.voices.filter(v => 
        appState.voiceSettings.enabled[v.name] !== false
    ).length;
    const languages = new Set(appState.voices.map(v => v.lang.split('-')[0])).size;
    
    document.getElementById('totalVoices').textContent = total;
    document.getElementById('enabledVoices').textContent = enabled;
    document.getElementById('languageCount').textContent = languages;
}

function selectAllVoices(enable) {
    appState.voices.forEach(voice => {
        appState.voiceSettings.enabled[voice.name] = enable;
    });
    populateVoiceList();
    updateVoiceStats();
    saveVoiceSettings();
}

function selectQualityVoices() {
    appState.voices.forEach(voice => {
        const quality = voiceManager.assessQuality(voice);
        appState.voiceSettings.enabled[voice.name] = quality >= 3;
    });
    populateVoiceList();
    updateVoiceStats();
    saveVoiceSettings();
}

function resetVoiceSettings() {
    appState.voiceSettings = {
        enabled: {},
        matchGender: true,
        matchLanguage: true,
        preferHighQuality: true,
        avoidNovelty: true
    };
    populateVoiceList();
    updateVoiceStats();
    saveVoiceSettings();
}

function exportSettings() {
    const data = JSON.stringify(appState.voiceSettings, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'memorial-voice-settings.json';
    a.click();
    URL.revokeObjectURL(url);
}

function importSettings() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const settings = JSON.parse(event.target.result);
                appState.voiceSettings = { ...appState.voiceSettings, ...settings };
                populateVoiceList();
                updateVoiceStats();
                saveVoiceSettings();
                alert('Settings imported successfully!');
            } catch (error) {
                alert('Failed to import settings: ' + error.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function clearAllSettings() {
    if (confirm('This will clear all voice settings. Are you sure?')) {
        localStorage.removeItem('memorialVoiceSettings');
        resetVoiceSettings();
    }
}

// Initialize the application
async function initializeApp() {
    const loadingStatus = document.getElementById('loadingStatus');
    
    try {
        console.log('Starting initialization...');
        
        // Load metadata
        loadingStatus.innerHTML = '<span class="loading"></span> Loading system metadata...';
        const metaResponse = await fetch('./languages/metadata.json');
        
        if (!metaResponse.ok) {
            throw new Error(`Failed to load metadata: ${metaResponse.status}`);
        }
        
        appState.metadata = await metaResponse.json();
        console.log('Metadata loaded:', appState.metadata);
        
        // Load ALL language families (or as many as possible)
        loadingStatus.innerHTML = '<span class="loading"></span> Loading language families...';
        
        // Try to load all families, not just preloadCommon
        let loadedCount = 0;
        let failedCount = 0;
        const failedFamilies = [];
        
        for (const family of appState.metadata.languageFamilies) {
            try {
                await loadLanguageFamily(family.id);
                loadedCount++;
                console.log(`✓ Loaded ${family.id} (${loadedCount}/${appState.metadata.languageFamilies.length})`);
                loadingStatus.innerHTML = `<span class="loading"></span> Loading language families... (${loadedCount}/${appState.metadata.languageFamilies.length})`;
            } catch (err) {
                failedCount++;
                failedFamilies.push(family.id);
                console.warn(`✗ Failed to load ${family.id}: ${err.message}`);
                // Continue loading others even if one fails
            }
        }
        
        console.log(`=== LOADING SUMMARY ===`);
        console.log(`Successfully loaded: ${loadedCount} families`);
        console.log(`Failed: ${failedCount} families`);
        if (failedFamilies.length > 0) {
            console.log(`Failed families: ${failedFamilies.join(', ')}`);
        }
        console.log(`Loaded families:`, Object.keys(appState.loadedFamilies));
        
        if (loadedCount === 0) {
            throw new Error('No language families could be loaded');
        }
        
        // Mark as initialized
        appState.isInitialized = true;
        
        // Hide loading status
        loadingStatus.style.display = 'none';
        
        // Update stats
        updateStats();
        
        // Update voice status
        updateVoiceStatus('');
        
        // Start the memorial
        appState.isRunning = true;
        startInterval();
        
        console.log('Initialization complete!');
        console.log('🎤 Press Q+W+E simultaneously to open voice settings');
        
    } catch (error) {
        console.error('Failed to initialize app:', error);
        loadingStatus.className = 'loading-status error-message';
        loadingStatus.innerHTML = `
            ⚠️ Failed to load language data. 
            <br>Error: ${error.message}
        `;
    }
}

// Load a language family
async function loadLanguageFamily(familyId) {
    // Check if already loaded
    if (appState.loadedFamilies[familyId]) {
        console.log(`${familyId} already loaded`);
        return appState.loadedFamilies[familyId];
    }
    
    // Find family info
    const familyInfo = appState.metadata.languageFamilies.find(f => f.id === familyId);
    if (!familyInfo) {
        throw new Error(`Unknown language family: ${familyId}`);
    }
    
    // Load the file
    const url = `./languages/${familyInfo.fileName}`;
    console.log(`Attempting to load ${familyId} from: ${url}`);
    
    const response = await fetch(url);
    console.log(`Response for ${familyId}: ${response.status} ${response.statusText}`);
    
    if (!response.ok) {
        throw new Error(`Failed to load ${familyId}: ${response.status} ${response.statusText}`);
    }
    
    try {
        const text = await response.text();
        console.log(`${familyId} file size: ${text.length} characters`);
        
        const data = JSON.parse(text);
        console.log(`${familyId} parsed successfully, has ${Object.keys(data).length} top-level keys`);
        
        appState.loadedFamilies[familyId] = data;
        return data;
    } catch (parseError) {
        console.error(`JSON parse error for ${familyId}:`, parseError);
        throw new Error(`JSON parse error for ${familyId}: ${parseError.message}`);
    }
}

// Voice system initialization
async function initializeVoiceSystem() {
    const status = document.getElementById('voiceStatus');
    const button = document.getElementById('initVoiceButton');
    
    status.innerHTML = '<span class="loading"></span> Initializing voice system...';
    
    try {
        // Check browser support
        if (!('speechSynthesis' in window)) {
            throw new Error('Speech synthesis not supported in this browser');
        }
        
        // Cancel any ongoing speech
        appState.synth.cancel();
        
        // Load voices
        let voices = appState.synth.getVoices();
        
        if (voices.length === 0) {
            // Wait for voices to load
            await new Promise((resolve) => {
                appState.synth.onvoiceschanged = () => {
                    voices = appState.synth.getVoices();
                    resolve();
                };
                // Timeout after 2 seconds
                setTimeout(resolve, 2000);
            });
        }
        
        appState.voices = voices;
        console.log(`Loaded ${voices.length} voices`);
        
        // Load saved settings for these voices
        loadVoiceSettings();
        
        // Initialize enabled state for new voices
        voices.forEach(voice => {
            if (appState.voiceSettings.enabled[voice.name] === undefined) {
                // Enable by default, unless it's a novelty voice
                const isNovelty = voiceManager.NOVELTY_VOICES.some(nov => 
                    voice.name.toLowerCase().includes(nov)
                );
                appState.voiceSettings.enabled[voice.name] = !isNovelty;
            }
        });
        
        saveVoiceSettings();
        
        if (voices.length === 0) {
            throw new Error('No voices available');
        }
        
        // Test voice with a simple utterance
        const testUtterance = new SpeechSynthesisUtterance('Voice system ready');
        testUtterance.volume = 0.3;
        
        // Use the voice selection system for the test
        const testVoice = voiceManager.selectVoice({ gender: 'neutral', familyId: 'indoEuropean' });
        if (testVoice) {
            testUtterance.voice = testVoice;
        }
        
        appState.synth.speak(testUtterance);
        
        appState.isVoiceInitialized = true;
        status.innerHTML = '✓ Voice system ready • Press Q+W+E for settings';
        button.style.display = 'none';
        
        console.log('Voice system initialized');
        console.log('Press Q+W+E to open voice settings');
        
    } catch (error) {
        console.error('Voice initialization failed:', error);
        status.innerHTML = `⚠️ ${error.message}`;
        button.textContent = 'Retry Voice';
    }
}

// Name generation
async function generateName() {
    if (!appState.isInitialized || !appState.metadata) {
        console.log('Not initialized yet');
        return null;
    }
    
    try {
        // Get loaded families
        const loadedFamilyIds = Object.keys(appState.loadedFamilies);
        if (loadedFamilyIds.length === 0) {
            console.log('No families loaded');
            return null;
        }
        
        let familyId;
        
        // Select family based on weighted or random
        if (appState.isWeighted) {
            // Weighted selection based on population percentage
            const weights = loadedFamilyIds.map(id => {
                const familyInfo = appState.metadata.languageFamilies.find(f => f.id === id);
                return familyInfo ? familyInfo.populationPercentage : 1;
            });
            
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < loadedFamilyIds.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    familyId = loadedFamilyIds[i];
                    break;
                }
            }
            
            if (!familyId) {
                familyId = loadedFamilyIds[0];
            }
        } else {
            // Random selection
            familyId = loadedFamilyIds[Math.floor(Math.random() * loadedFamilyIds.length)];
        }
        
        const familyData = appState.loadedFamilies[familyId];
        console.log(`Selected family: ${familyId}`);
        
        // Select gender
        const genders = ['male', 'female', 'neutral'];
        const gender = genders[Math.floor(Math.random() * genders.length)];
        
        // Determine if this should be an old name
        let useOldName = false;
        if (appState.mixOldAndNew && appState.showOldNames) {
            // Mix mode: 30% chance of old name
            useOldName = Math.random() < 0.3;
        } else if (appState.showOldNames && !appState.mixOldAndNew) {
            // Old names only mode
            useOldName = true;
        }
        
        // Get native script if available
        let nativeScript = null;
        if (appState.showNativeScript && familyData.nameComponents.nativeScript) {
            nativeScript = getNativeScriptName(familyData, gender, familyId);
        }
        
        if (useOldName && familyData.nameComponents.oldNames) {
            // Generate old name
            const oldNameData = generateOldName(familyData, gender);
            if (oldNameData) {
                return {
                    display: oldNameData.display,
                    spoken: oldNameData.display,
                    nativeScript: nativeScript,
                    given: oldNameData.given,
                    meaning: oldNameData.meaning,
                    category: oldNameData.category,
                    isOldName: true,
                    gender: gender,
                    familyId: familyId,
                    languageFamily: familyData.metadata.family,
                    writingSystems: familyData.metadata.writingSystems,
                    populationPercentage: appState.metadata.languageFamilies.find(f => f.id === familyId)?.populationPercentage
                };
            }
        }
        
        // Generate modern name
        const givenNames = familyData.nameComponents.given[gender] || 
                          familyData.nameComponents.given.neutral ||
                          [];
                          
        let familyNames = [];
        if (Array.isArray(familyData.nameComponents.family)) {
            familyNames = familyData.nameComponents.family;
        } else if (familyData.nameComponents.family) {
            familyNames = familyData.nameComponents.family.common || [];
        }
        
        if (givenNames.length === 0 || familyNames.length === 0) {
            console.log('No names available for', gender, 'in', familyId);
            return null;
        }
        
        const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
        const familyName = familyNames[Math.floor(Math.random() * familyNames.length)];
        
        // Build full name based on order
        let fullName;
        if (familyData.metadata.nameOrder === 'family_first') {
            fullName = `${familyName} ${givenName}`;
        } else {
            fullName = `${givenName} ${familyName}`;
        }
        
        return {
            display: fullName,
            spoken: fullName,
            nativeScript: nativeScript,
            given: givenName,
            family: familyName,
            gender: gender,
            familyId: familyId,
            languageFamily: familyData.metadata.family,
            writingSystems: familyData.metadata.writingSystems,
            populationPercentage: appState.metadata.languageFamilies.find(f => f.id === familyId)?.populationPercentage
        };
        
    } catch (error) {
        console.error('Error generating name:', error);
        return null;
    }
}

// Generate old name
function generateOldName(familyData, gender) {
    const oldNames = familyData.nameComponents.oldNames;
    if (!oldNames) return null;
    
    const genderOldNames = oldNames[gender === 'female' ? 'female' : 'male'];
    if (!genderOldNames) return null;
    
    // Get all categories
    const categories = Object.keys(genderOldNames);
    if (categories.length === 0) return null;
    
    // Select a category
    const category = categories[Math.floor(Math.random() * categories.length)];
    const namesInCategory = genderOldNames[category];
    
    // Get name and meaning
    const nameEntries = Object.entries(namesInCategory);
    if (nameEntries.length === 0) return null;
    
    const [name, meaning] = nameEntries[Math.floor(Math.random() * nameEntries.length)];
    
    return {
        display: name,
        given: name,
        meaning: meaning,
        category: category
    };
}

// Get native script version of name
function getNativeScriptName(familyData, gender, familyId) {
    const nativeScript = familyData.nameComponents.nativeScript;
    if (!nativeScript) return null;
    
    // Determine which script to use
    let scriptType = null;
    if (familyId === 'indoEuropean') {
        // Choose script based on random selection
        const scripts = ['cyrillic', 'devanagari', 'greek', 'armenian', 'bengali'];
        scriptType = scripts[Math.floor(Math.random() * scripts.length)];
    } else if (familyId === 'sinoTibetan') {
        const scripts = ['chinese', 'traditional', 'tibetan', 'burmese'];
        scriptType = scripts[Math.floor(Math.random() * scripts.length)];
    }
    
    if (!scriptType || !nativeScript[scriptType]) return null;
    
    const scriptData = nativeScript[scriptType];
    const givenNames = scriptData.given[gender] || scriptData.given.neutral || [];
    const familyNames = scriptData.family || [];
    
    if (givenNames.length === 0 || familyNames.length === 0) return null;
    
    const given = givenNames[Math.floor(Math.random() * givenNames.length)];
    const family = familyNames[Math.floor(Math.random() * familyNames.length)];
    
    // Format based on name order
    if (familyData.metadata.nameOrder === 'family_first') {
        return {
            full: `${family}${given}`,
            given: given,
            family: family,
            script: scriptType
        };
    } else {
        return {
            full: `${given} ${family}`,
            given: given,
            family: family,
            script: scriptType
        };
    }
}

// Display name
function displayName(nameData) {
    if (!nameData) {
        console.error('No name data to display');
        return;
    }
    
    // Clear all display areas
    const nameDisplay = document.getElementById('nameDisplay');
    const nativeScriptDisplay = document.getElementById('nativeScriptDisplay');
    const componentsDisplay = document.getElementById('componentsDisplay');
    const meaningsSection = document.getElementById('meaningsSection');
    const oldNamesSection = document.getElementById('oldNamesSection');
    const culturalContext = document.getElementById('culturalContext');
    const indicatorsDisplay = document.getElementById('indicatorsDisplay');
    
    // Clear everything first
    [meaningsSection, oldNamesSection, culturalContext].forEach(section => {
        if (section) {
            section.style.display = 'none';
            section.innerHTML = '';
        }
    });
    
    componentsDisplay.innerHTML = '';
    indicatorsDisplay.innerHTML = '';
    nativeScriptDisplay.innerHTML = '';
    
    // Display main name
    nameDisplay.textContent = nameData.display || '[Name]';
    
    // Display native script if available and enabled
    if (appState.showNativeScript && nameData.nativeScript) {
        const scriptLabel = document.createElement('div');
        scriptLabel.className = 'native-script';
        
        if (typeof nameData.nativeScript === 'string') {
            scriptLabel.textContent = nameData.nativeScript;
        } else if (nameData.nativeScript.full) {
            scriptLabel.textContent = nameData.nativeScript.full;
        }
        
        if (nameData.nativeScript.script) {
            const scriptType = document.createElement('span');
            scriptType.className = 'script-type';
            scriptType.textContent = ` (${nameData.nativeScript.script})`;
            scriptLabel.appendChild(scriptType);
        }
        
        nativeScriptDisplay.appendChild(scriptLabel);
    }
    
    // Show basic indicators
    if (nameData.isOldName) {
        const indicator = document.createElement('span');
        indicator.className = 'indicator indicator-old-name';
        indicator.textContent = '📜 Historical Name';
        indicatorsDisplay.appendChild(indicator);
    }
    
    if (appState.mixOldAndNew && nameData.isOldName) {
        const mixIndicator = document.createElement('span');
        mixIndicator.className = 'indicator indicator-transition';
        mixIndicator.textContent = '🔄 Mixed Mode';
        indicatorsDisplay.appendChild(mixIndicator);
    }
    
    // Get the family data for additional details
    const familyData = appState.loadedFamilies[nameData.familyId];
    
    // Show enhanced details if detailed view is enabled
    if (appState.showDetails) {
        
        // === NAME COMPONENTS SECTION ===
        if (!nameData.isOldName) {
            // Given name component
            if (nameData.given) {
                const givenDiv = document.createElement('div');
                givenDiv.className = 'component';
                givenDiv.innerHTML = '<span class="component-label">Given:</span> ' + nameData.given;
                componentsDisplay.appendChild(givenDiv);
            }
            
            // Family name component
            if (nameData.family) {
                const familyDiv = document.createElement('div');
                familyDiv.className = 'component';
                familyDiv.innerHTML = '<span class="component-label">Family:</span> ' + nameData.family;
                componentsDisplay.appendChild(familyDiv);
            }
            
            // Gender indicator
            if (nameData.gender) {
                const genderDiv = document.createElement('div');
                genderDiv.className = 'component';
                const genderEmoji = nameData.gender === 'female' ? '♀' : 
                                   nameData.gender === 'male' ? '♂' : '⚧';
                genderDiv.innerHTML = `<span class="component-label">Gender:</span> ${genderEmoji} ${nameData.gender}`;
                componentsDisplay.appendChild(genderDiv);
            }
        }
        
        // === MEANINGS & ETYMOLOGY SECTION ===
        if (familyData && familyData.nameComponents && familyData.nameComponents.meanings) {
            const meanings = familyData.nameComponents.meanings;
            let hasMeaning = false;
            let meaningHTML = '<div class="meanings-title">Name Meanings & Etymology:</div>';
            
            // Check for given name meaning
            if (nameData.given && meanings.given && meanings.given[nameData.given]) {
                meaningHTML += `
                    <div class="meaning-item">
                        <span class="meaning-label">Given name:</span> 
                        "${meanings.given[nameData.given]}"
                    </div>`;
                hasMeaning = true;
            }
            
            // Check for family name meaning
            if (nameData.family && meanings.family && meanings.family[nameData.family]) {
                meaningHTML += `
                    <div class="meaning-item">
                        <span class="meaning-label">Family name:</span> 
                        "${meanings.family[nameData.family]}"
                    </div>`;
                hasMeaning = true;
            }
            
            if (hasMeaning) {
                meaningsSection.style.display = 'block';
                meaningsSection.innerHTML = meaningHTML;
            }
        }
        
        // === OLD NAME DETAILS ===
        if (nameData.isOldName) {
            oldNamesSection.style.display = 'block';
            oldNamesSection.innerHTML = `
                <div class="old-names-title">Historical Name:</div>
                <div class="meaning-item">
                    <span class="meaning-label">Period:</span> ${formatCategory(nameData.category)}
                </div>
                <div class="meaning-item">
                    <span class="meaning-label">Name:</span> ${nameData.given}
                </div>
                ${nameData.meaning ? `
                <div class="meaning-item">
                    <span class="meaning-label">Meaning:</span> "${nameData.meaning}"
                </div>` : ''}
            `;
        }
        
        // === COMPREHENSIVE CULTURAL CONTEXT ===
        if (familyData) {
            let contextHTML = '<div class="culture-info">';
            let hasContext = false;
            
            // Language Family & Population
            contextHTML += `
                <div class="info-item">
                    <span class="info-label">Language Family:</span><br>
                    ${nameData.languageFamily || familyData.metadata.family}
                    ${nameData.populationPercentage ? ` (${nameData.populationPercentage}% of world)` : ''}
                </div>`;
            hasContext = true;
            
            // Writing Systems
            if (nameData.writingSystems && nameData.writingSystems.length > 0) {
                contextHTML += `
                    <div class="info-item">
                        <span class="info-label">Writing Systems:</span><br>
                        ${nameData.writingSystems.join(', ')}
                    </div>`;
            }
            
            // Name Order
            if (familyData.metadata.nameOrder) {
                const orderText = familyData.metadata.nameOrder === 'family_first' ? 
                    'Family name first' : 'Given name first';
                contextHTML += `
                    <div class="info-item">
                        <span class="info-label">Name Order:</span><br>
                        ${orderText}
                    </div>`;
            }
            
            // Patronymics/Matronymics
            if (familyData.metadata.hasPatronymics) {
                contextHTML += `
                    <div class="info-item">
                        <span class="info-label">Naming Pattern:</span><br>
                        Uses patronymics (father's name)
                    </div>`;
            }
            
            // Gender Markers
            if (familyData.metadata.hasGenderMarkers) {
                contextHTML += `
                    <div class="info-item">
                        <span class="info-label">Gender Markers:</span><br>
                        Names indicate gender
                    </div>`;
            }
            
            // Special Features
            if (familyData.specialFeatures) {
                // Death Taboo
                if (familyData.specialFeatures.deathTaboo && familyData.specialFeatures.deathTaboo.active) {
                    contextHTML += `
                        <div class="info-item" style="grid-column: span 2;">
                            <span class="info-label">⚠️ Death Taboo:</span><br>
                            ${familyData.specialFeatures.deathTaboo.description}
                            ${familyData.specialFeatures.deathTaboo.substitute ? 
                                `<br>Substitute: "${familyData.specialFeatures.deathTaboo.substitute}"` : ''}
                        </div>`;
                }
                
                // Sacred Names
                if (familyData.specialFeatures.sacredNames) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🔒 Sacred Names:</span><br>
                            ${familyData.specialFeatures.sacredNames.description}
                        </div>`;
                }
                
                // Birth Order Names
                if (familyData.specialFeatures.birthOrder) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">Birth Order:</span><br>
                            Special names for twins & birth order
                        </div>`;
                }
                
                // Seasonal Names
                if (familyData.specialFeatures.seasonalNames && familyData.specialFeatures.seasonalNames.active) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🌍 Seasonal Names:</span><br>
                            Names based on season of birth
                        </div>`;
                }
                
                // Clan/Totem Names
                if (familyData.specialFeatures.totems) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🦁 Clan Totems:</span><br>
                            ${familyData.specialFeatures.totems.description}
                        </div>`;
                }
                
                // Initiation Names
                if (familyData.specialFeatures.initiationNames) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🎭 Initiation Names:</span><br>
                            ${familyData.specialFeatures.initiationNames.description}
                        </div>`;
                }
                
                // Bush Names
                if (familyData.specialFeatures.bushNames) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🌿 Bush Names:</span><br>
                            ${familyData.specialFeatures.bushNames.description}
                        </div>`;
                }
            }
            
            // Special Rules
            if (familyData.specialRules) {
                // Teknonymy
                if (familyData.specialRules.teknonymy) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">Parent Naming:</span><br>
                            ${familyData.specialRules.teknonymy.description}
                        </div>`;
                }
                
                // Name Changes
                if (familyData.specialRules.nameChanges) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">Name Changes:</span><br>
                            Names change with life events
                        </div>`;
                }
                
                // Colonial Influence
                if (familyData.specialRules.colonialInfluence || familyData.specialRules.englishAdoption) {
                    const rule = familyData.specialRules.colonialInfluence || familyData.specialRules.englishAdoption;
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">Historical Context:</span><br>
                            ${rule.description}
                        </div>`;
                }
                
                // Revitalization
                if (familyData.specialRules.revitalization) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🌱 Revitalization:</span><br>
                            ${familyData.specialRules.revitalization.description}
                        </div>`;
                }
                
                // Click Pronunciation (Khoisan)
                if (familyData.specialRules.clickPronunciation) {
                    contextHTML += `
                        <div class="info-item">
                            <span class="info-label">🔊 Click Sounds:</span><br>
                            ${familyData.specialRules.clickPronunciation.description}
                        </div>`;
                }
            }
            
            contextHTML += '</div>';
            
            if (hasContext) {
                culturalContext.style.display = 'block';
                culturalContext.innerHTML = contextHTML;
            }
        }
    }
    
    // Update status
    updateStatus();
}

// Helper function to format category names
function formatCategory(category) {
    if (!category) return 'Unknown period';
    
    // Handle special formatting for different categories
    const formatted = category
        .replace(/_/g, ' ')
        .replace(/([A-Z])/g, ' $1')
        .trim()
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    
    return formatted;
}

function formatScriptName(script) {
    const scriptNames = {
        'chinese': 'Simplified Chinese',
        'traditional': 'Traditional Chinese',
        'cyrillic': 'Cyrillic',
        'devanagari': 'Devanagari',
        'greek': 'Greek',
        'armenian': 'Armenian',
        'bengali': 'Bengali',
        'tibetan': 'Tibetan',
        'burmese': 'Burmese',
        'arabic': 'Arabic',
        'hebrew': 'Hebrew'
    };
    return scriptNames[script] || script;
}

function formatCategory(category) {
    const categoryMap = {
        'ancient': 'Ancient period',
        'medieval': 'Medieval period',
        'slavic': 'Slavic tradition',
        'indic': 'Indian subcontinent',
        'germanic': 'Germanic tradition',
        'dynastic': 'Dynastic period',
        'literary': 'Literary figures',
        'historical': 'Historical figure',
        'legendary': 'Legendary/Mythological',
        'epic': 'Epic tradition',
        'royal': 'Royal/Noble',
        'traditional': 'Traditional'
    };
    
    return categoryMap[category] || category.charAt(0).toUpperCase() + category.slice(1);
}

function formatGender(gender) {
    const genderMap = {
        'male': 'Male',
        'female': 'Female',
        'neutral': 'Gender neutral'
    };
    
    return genderMap[gender] || gender;
}

// Speak name
function speakName(nameData) {
    if (!appState.isVoiceInitialized || !nameData || !appState.synth) {
        return;
    }
    
    try {
        // Cancel any ongoing speech
        appState.synth.cancel();
        
        const utterance = new SpeechSynthesisUtterance(nameData.spoken);
        
        // Use intelligent voice selection
        const selectedVoice = voiceManager.selectVoice(nameData);
        
        if (selectedVoice) {
            utterance.voice = selectedVoice;
            updateVoiceStatus(selectedVoice.name);
        }
        
        // Adjust parameters based on gender
        utterance.rate = 0.9;
        
        // Gender-based pitch adjustment
        const genderPitch = {
            'female': 1.2,
            'male': 0.9,
            'neutral': 1.0
        };
        utterance.pitch = genderPitch[nameData.gender] || 1.0;
        utterance.volume = 1.0;
        
        // Event handlers
        utterance.onend = () => {
            updateVoiceStatus('');
        };
        
        utterance.onerror = (event) => {
            console.error('Speech error:', event);
            updateVoiceStatus('');
        };
        
        // Speak
        appState.synth.speak(utterance);
        
    } catch (error) {
        console.error('Speech error:', error);
        updateVoiceStatus('');
    }
}

// Update voice status
function updateVoiceStatus(message) {
    const status = document.getElementById('voiceStatus');
    if (status) {
        status.textContent = message;
    }
}

// Update stats
function updateStats(currentName) {
    const stats = document.getElementById('statsDisplay');
    const loadedCount = Object.keys(appState.loadedFamilies).length;
    const totalCount = appState.metadata ? appState.metadata.languageFamilies.length : 0;
    
    let statsText = `${loadedCount} of ${totalCount} language families loaded • `;
    
    if (appState.isWeighted && currentName && currentName.populationPercentage !== undefined) {
        statsText += `Population weighted (${currentName.languageFamily}: ${currentName.populationPercentage}%) • `;
    } else if (appState.isWeighted) {
        statsText += `Population weighted • `;
    } else {
        statsText += `Random selection • `;
    }
    
    if (appState.mixOldAndNew) {
        statsText += `Mixed historical/modern • `;
    } else if (appState.showOldNames) {
        statsText += `Historical names only • `;
    }
    
    if (appState.showNativeScript) {
        statsText += `Native scripts enabled • `;
    }
    
    statsText += `${appState.isFast ? 'Fast' : 'Slow'} speed`;
    
    stats.innerHTML = statsText;
}

// Interval management
function startInterval() {
    if (!appState.isInitialized) {
        console.log('Cannot start - not initialized');
        return;
    }
    
    // Clear existing interval
    if (appState.intervalId) {
        clearInterval(appState.intervalId);
    }
    
    // Generate first name immediately
    generateAndDisplay();
    
    // Set up interval
    const speed = appState.isFast ? appState.FAST_SPEED : appState.SLOW_SPEED;
    appState.intervalId = setInterval(() => {
        if (appState.isRunning) {
            generateAndDisplay();
        }
    }, speed);
}

async function generateAndDisplay() {
    const nameData = await generateName();
    if (nameData) {
        displayName(nameData);
        updateStats(nameData);  // Pass the current name data
        
        if (appState.isRunning && appState.isVoiceInitialized) {
            // Small delay to ensure display updates first
            setTimeout(() => speakName(nameData), 100);
        }
    }
}

// Event handlers
document.getElementById('initVoiceButton').addEventListener('click', initializeVoiceSystem);

document.getElementById('toggleButton').addEventListener('click', () => {
    appState.isRunning = !appState.isRunning;
    document.getElementById('toggleButton').textContent = appState.isRunning ? 'Pause' : 'Resume';
    
    if (!appState.isRunning) {
        appState.synth.cancel();
    }
});

document.getElementById('speedToggle').addEventListener('change', (e) => {
    appState.isFast = e.target.checked;
    updateStats(appState.currentName);
    startInterval();
});

document.getElementById('weightedToggle').addEventListener('change', (e) => {
    appState.isWeighted = e.target.checked;
    updateStats(appState.currentName);
});

document.getElementById('detailToggle').addEventListener('change', (e) => {
    appState.showDetails = e.target.checked;
    if (appState.currentName) {
        displayName(appState.currentName);
    }
});

document.getElementById('oldNamesToggle').addEventListener('change', (e) => {
    appState.showOldNames = e.target.checked;
    // If turning off old names while in mix mode, also turn off mix mode
    if (!appState.showOldNames && appState.mixOldAndNew) {
        appState.mixOldAndNew = false;
        document.getElementById('mixNamesToggle').checked = false;
    }
    generateAndDisplay();
});

document.getElementById('mixNamesToggle').addEventListener('change', (e) => {
    appState.mixOldAndNew = e.target.checked;
    // If enabling mix mode, ensure old names are also enabled
    if (appState.mixOldAndNew && !appState.showOldNames) {
        appState.showOldNames = true;
        document.getElementById('oldNamesToggle').checked = true;
    }
    generateAndDisplay();
});

document.getElementById('nativeScriptToggle').addEventListener('change', (e) => {
    appState.showNativeScript = e.target.checked;
    if (appState.currentName) {
        displayName(appState.currentName);
    }
});

document.getElementById('speakButton').addEventListener('click', () => {
    if (appState.currentName) {
        speakName(appState.currentName);
    }
});

// Name click for Google Images
document.getElementById('nameDisplay').addEventListener('click', (e) => {
    const name = e.target.textContent;
    if (name && !name.includes('[') && !name.includes('Initializing')) {
        const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(name)}&tbm=isch`;
        window.open(searchUrl, '_blank', 'noopener,noreferrer');
    }
});

// Info modal handlers
document.getElementById('infoButton').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'block';
});

document.querySelector('.close').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'none';
});

window.addEventListener('click', (e) => {
    const modal = document.getElementById('infoModal');
    if (e.target === modal) {
        modal.style.display = 'none';
    }
});

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, starting initialization...');
    
    // Load voice settings from localStorage
    loadVoiceSettings();
    
    // Set initial toggle states
    document.getElementById('speedToggle').checked = appState.isFast;
    document.getElementById('weightedToggle').checked = appState.isWeighted;
    document.getElementById('detailToggle').checked = appState.showDetails;
    document.getElementById('oldNamesToggle').checked = appState.showOldNames;
    document.getElementById('mixNamesToggle').checked = appState.mixOldAndNew;
    document.getElementById('nativeScriptToggle').checked = appState.showNativeScript;
    
    // Add diagnostic function to window for debugging
    window.checkFiles = async function() {
        console.log('=== FILE CHECK DIAGNOSTIC ===');
        const files = [
            './languages/metadata.json',
            './languages/indo-european.json',
            './languages/sino-tibetan.json'
        ];
        
        for (const file of files) {
            try {
                const response = await fetch(file);
                if (response.ok) {
                    const text = await response.text();
                    console.log(`✓ ${file}: SUCCESS (${text.length} chars)`);
                    
                    // Check first 100 characters
                    console.log(`  First 100 chars: ${text.substring(0, 100)}`);
                    
                    try {
                        JSON.parse(text);
                        console.log(`  JSON: Valid`);
                    } catch (e) {
                        console.log(`  JSON: INVALID - ${e.message}`);
                        // Show where the error occurred
                        const errorPosition = parseInt(e.message.match(/position (\d+)/)?.[1] || 0);
                        if (errorPosition > 0) {
                            console.log(`  Error near: "${text.substring(Math.max(0, errorPosition - 20), errorPosition + 20)}"`);
                        }
                    }
                } else {
                    console.log(`✗ ${file}: HTTP ${response.status}`);
                }
            } catch (e) {
                console.log(`✗ ${file}: NETWORK ERROR - ${e.message}`);
            }
        }
        console.log('=== END DIAGNOSTIC ===');
    };
    
    // Also add function to check loaded families
    window.showLoaded = function() {
        console.log('=== LOADED FAMILIES ===');
        console.log('Count:', Object.keys(appState.loadedFamilies).length);
        console.log('IDs:', Object.keys(appState.loadedFamilies));
        for (const [id, data] of Object.entries(appState.loadedFamilies)) {
            const nameCount = data.nameComponents?.given?.male?.length || 0;
            console.log(`${id}: ${nameCount} male names`);
        }
    };
    
    console.log('Diagnostics available:');
    console.log('  checkFiles() - Check if files are accessible');
    console.log('  showLoaded() - Show loaded families');
    
    initializeApp();
});

// Key combination detection for Q+W+E
document.addEventListener('keydown', (e) => {
    appState.keysPressed[e.key.toLowerCase()] = true;
    
    // Check if Q, W, and E are all pressed
    if (appState.keysPressed['q'] && appState.keysPressed['w'] && appState.keysPressed['e']) {
        openSettings();
        // Reset keys to prevent repeated opening
        appState.keysPressed = {};
    }
    
    // Show hint when Q is pressed
    if (e.key.toLowerCase() === 'q') {
        const hint = document.getElementById('settingsKeyHint');
        hint.classList.add('visible');
        setTimeout(() => hint.classList.remove('visible'), 2000);
    }
});

document.addEventListener('keyup', (e) => {
    delete appState.keysPressed[e.key.toLowerCase()];
});

// ESC key to close modals
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        document.getElementById('settingsModal').style.display = 'none';
        document.getElementById('infoModal').style.display = 'none';
    }
});

// Handle checkbox changes in settings
document.addEventListener('change', (e) => {
    if (e.target.id === 'matchGender') {
        appState.voiceSettings.matchGender = e.target.checked;
        saveVoiceSettings();
    }
    if (e.target.id === 'matchLanguage') {
        appState.voiceSettings.matchLanguage = e.target.checked;
        saveVoiceSettings();
    }
    if (e.target.id === 'preferHighQuality') {
        appState.voiceSettings.preferHighQuality = e.target.checked;
        saveVoiceSettings();
    }
    if (e.target.id === 'avoidNovelty') {
        appState.voiceSettings.avoidNovelty = e.target.checked;
        saveVoiceSettings();
    }
});

// Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden && appState.isRunning && appState.synth) {
        appState.synth.cancel();
    }
});

// Handle page unload
window.addEventListener('beforeunload', () => {
    if (appState.synth) {
        appState.synth.cancel();
    }
});

// Monitor voice changes
if ('speechSynthesis' in window) {
    window.speechSynthesis.onvoiceschanged = () => {
        if (!appState.isVoiceInitialized) {
            console.log('Voices changed, available:', window.speechSynthesis.getVoices().length);
        }
    };
}
    </script>
</body>
</html>