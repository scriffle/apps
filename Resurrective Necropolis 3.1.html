<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Resurrective Necropolis</title>

<style>
    :root {
        --primary-bg: #0a0a0f;
        --secondary-bg: #1a1a2e;
        --accent: #4a90e2;
        --text-primary: #ffffff;
        --text-secondary: #b0b0c0;
        --sacred: #ffd700;
        --taboo: #dc143c;
        --transition: #9370db;
        --cultural: #2ecc71;
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Georgia', 'Times New Roman', serif;
        background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 1rem;
    }
    
    .container {
        max-width: 900px;
        width: 100%;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 1.5rem;
        padding: 2rem;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    h1 {
        text-align: center;
        font-size: 2.5rem;
        margin-bottom: 2rem;
        background: linear-gradient(45deg, var(--accent), var(--transition));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
    }
    
    /* Loading Status */
    .loading-status {
        text-align: center;
        padding: 2rem;
        color: var(--text-secondary);
        font-size: 1.1rem;
    }
    
    .error-message {
        color: var(--taboo);
        background: rgba(220, 20, 60, 0.1);
        padding: 1rem;
        border-radius: 0.5rem;
        border: 1px solid var(--taboo);
    }
    
    /* Info Button */
    #infoButton {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--accent);
        color: white;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        z-index: 1000;
        transition: all 0.3s ease;
    }
    
    #infoButton:hover {
        transform: scale(1.1);
        box-shadow: 0 0 20px var(--accent);
    }
    
    /* Modal */
    .modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
    }
    
    .modal-content {
        background: var(--secondary-bg);
        margin: 5% auto;
        padding: 2rem;
        border-radius: 1rem;
        width: 80%;
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        color: var(--text-primary);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .close {
        color: var(--text-secondary);
        float: right;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
    }
    
    .close:hover {
        color: var(--text-primary);
    }
    
    /* Settings Modal Styles */
    .settings-modal-content {
        background: var(--secondary-bg);
        margin: 2% auto;
        padding: 2rem;
        border-radius: 1rem;
        width: 90%;
        max-width: 900px;
        max-height: 90vh;
        overflow-y: auto;
        color: var(--text-primary);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--accent);
    }
    
    .settings-tabs {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .settings-tab {
        padding: 0.8rem 1.5rem;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.3s;
        border-bottom: 3px solid transparent;
    }
    
    .settings-tab.active {
        color: var(--text-primary);
        border-bottom-color: var(--accent);
    }
    
    .voice-list {
        max-height: 500px;
        overflow-y: auto;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 0.5rem;
    }
    
    .voice-item {
        display: flex;
        align-items: center;
        padding: 0.8rem;
        margin: 0.5rem 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
        transition: all 0.2s;
    }
    
    .voice-item:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    .voice-checkbox {
        width: 20px;
        height: 20px;
        margin-right: 1rem;
        cursor: pointer;
    }
    
    .voice-info {
        flex: 1;
        display: grid;
        grid-template-columns: 2fr 1fr 1fr 0.5fr;
        gap: 1rem;
        align-items: center;
    }
    
    .voice-name {
        font-weight: bold;
        color: var(--text-primary);
    }
    
    .voice-lang {
        color: var(--accent);
        font-size: 0.9rem;
    }
    
    .voice-gender {
        padding: 0.2rem 0.6rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 0.3rem;
        font-size: 0.85rem;
        text-align: center;
    }
    
    .voice-quality {
        color: var(--sacred);
        font-size: 1.2rem;
    }
    
    .voice-test-btn {
        padding: 0.3rem 0.8rem;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 0.3rem;
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.2s;
    }
    
    .voice-test-btn:hover {
        background: #5ba0f2;
        transform: translateY(-1px);
    }
    
    .settings-key-hint {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: var(--text-secondary);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        opacity: 0.7;
        transition: opacity 0.3s;
    }
    
    .settings-key-hint:hover {
        opacity: 1;
    }
    
    /* Stats */
    .stats {
        text-align: center;
        color: var(--text-secondary);
        margin: 1rem 0;
        font-size: 0.9rem;
        opacity: 0.8;
    }
    
    /* Name Display */
    .name-display-section {
        text-align: center;
        margin: 2rem 0;
        min-height: 300px;
    }
    
    .name-main {
        font-size: 3rem;
        font-weight: bold;
        margin: 1rem 0;
        min-height: 4rem;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.5s ease;
        cursor: pointer;
        text-decoration: none;
        color: var(--text-primary);
        line-height: 1.4;
        padding: 0.5rem;
        word-break: break-word;
        font-family: Georgia, 'Times New Roman', serif;
    }
    
    .name-main:hover {
        transform: scale(1.02);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }
    
    .name-components {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        margin: 0.8rem 0;
    }
    
    .component {
        background: rgba(255, 255, 255, 0.08);
        padding: 0.25rem 0.6rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        border: 1px solid rgba(255, 255, 255, 0.15);
    }
    
    .component-label {
        color: var(--text-secondary);
        font-size: 0.75rem;
        margin-right: 0.25rem;
    }
    
    /* Meanings Section */
    .meanings-section {
        background: rgba(74, 144, 226, 0.1);
        border-radius: 0.6rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(74, 144, 226, 0.2);
        text-align: left;
    }
    
    .meanings-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 0.4rem;
        font-size: 0.9rem;
    }
    
    .meaning-item {
        font-size: 0.8rem;
        margin: 0.25rem 0;
        padding-left: 0.8rem;
    }
    
    .meaning-label {
        color: var(--text-secondary);
        font-style: italic;
        font-size: 0.75rem;
    }
    
    /* Old Names Section */
    .old-names-section {
        background: rgba(255, 215, 0, 0.08);
        border-radius: 0.6rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(255, 215, 0, 0.2);
        text-align: left;
    }
    
    .old-names-title {
        font-weight: bold;
        color: var(--sacred);
        margin-bottom: 0.4rem;
        font-size: 0.9rem;
    }
    
    /* Cultural Context */
    .cultural-context {
        background: rgba(74, 144, 226, 0.08);
        border-radius: 0.8rem;
        padding: 0.8rem;
        margin: 0.8rem 0;
        border: 1px solid rgba(74, 144, 226, 0.2);
    }
    
    .culture-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.6rem;
        text-align: left;
    }
    
    .info-item {
        font-size: 0.85rem;
    }
    
    .info-label {
        color: var(--accent);
        font-weight: bold;
    }
    
    /* Special Indicators */
    .special-indicators {
        display: flex;
        gap: 0.4rem;
        justify-content: center;
        margin: 0.8rem 0;
        flex-wrap: wrap;
    }
    
    .indicator {
        padding: 0.2rem 0.6rem;
        border-radius: 1.5rem;
        font-size: 0.8rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .indicator-sacred {
        background: var(--sacred);
        color: var(--primary-bg);
    }
    
    .indicator-taboo {
        background: var(--taboo);
        color: white;
    }
    
    .indicator-transition {
        background: var(--transition);
        color: white;
    }
    
    .indicator-cultural {
        background: var(--cultural);
        color: white;
    }
    
    .indicator-mononym {
        background: #3498db;
        color: white;
    }
    
    .indicator-old-name {
        background: #8b4513;
        color: white;
    }
    
    /* Voice Status */
    .voice-status {
        color: var(--text-secondary);
        margin: 1rem 0;
        font-size: 0.9rem;
        font-style: italic;
        min-height: 1.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        opacity: 0.8;
    }
    
    .sign-language-note {
        background: rgba(255, 255, 255, 0.08);
        padding: 0.4rem 0.8rem;
        border-radius: 0.5rem;
        margin: 0.4rem 0;
        font-size: 0.85rem;
    }
    
    /* Collapsible Controls Section */
    .controls-wrapper {
        position: relative;
        margin-top: 1rem;
    }
    
    .collapse-toggle {
        display: flex;
        justify-content: center;
        margin-bottom: 0.5rem;
    }
    
    .collapse-button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-secondary);
        padding: 0.3rem 1rem;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 1.2rem;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
    }
    
    .collapse-button:hover {
        background: rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
    }
    
    .collapse-button .chevron {
        transition: transform 0.3s ease;
    }
    
    .collapse-button.collapsed .chevron {
        transform: rotate(-90deg);
    }
    
    .controls {
        display: grid;
        gap: 0.6rem;
        overflow: hidden;
        transition: all 0.3s ease;
    }
    
    .controls.collapsed {
        max-height: 0;
        opacity: 0;
        margin: 0;
        padding: 0;
    }
    
    .control-row {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
    }
    
    .control-group {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        background: rgba(255, 255, 255, 0.08);
        padding: 0.35rem 0.6rem;
        border-radius: 0.8rem;
        min-width: 100px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        font-size: 0.85rem;
    }
    
    button {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 0.5rem;
        cursor: pointer;
        padding: 0.6rem 1.2rem;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        min-width: 90px;
    }
    
    button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    button:active:not(:disabled) {
        transform: translateY(0);
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    button.primary {
        background: var(--accent);
        border-color: var(--accent);
    }
    
    button.primary:hover:not(:disabled) {
        background: #5ba0f2;
        border-color: #5ba0f2;
    }
    
    /* Switch Styles */
    .switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        margin: 0 0.5rem;
    }
    
    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.2);
        transition: .4s;
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    
    input:checked + .slider {
        background-color: var(--accent);
        border-color: var(--accent);
    }
    
    input:checked + .slider:before {
        transform: translateX(26px);
    }
    
    /* Animations */
    .fade-in {
        animation: fadeIn 0.5s ease-in;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    /* Native Scripts */
    .script-display {
        font-size: 1.8rem;
        margin: 1rem 0;
        opacity: 0.9;
        min-height: 2.5rem;
        font-weight: normal;
    }
    
    .chinese-script {
        font-family: "Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "Source Han Sans CN", "Noto Sans CJK SC", sans-serif;
        font-size: 2rem;
    }
    
    .tibetan-script {
        font-family: "Microsoft Himalaya", "Jomolhari", "Tibetan Machine Uni", "Noto Sans Tibetan", serif;
        font-size: 1.8rem;
    }
    
    .devanagari-script {
        font-family: "Nirmala UI", "Noto Sans Devanagari", "Mangal", "Sanskrit Text", sans-serif;
        font-size: 1.6rem;
    }
    
    .cyrillic-script {
        font-family: "Times New Roman", "Noto Sans", "DejaVu Sans", sans-serif;
        font-size: 1.6rem;
    }
    
    .arabic-script {
        font-family: "Noto Naskh Arabic", "Arabic Typesetting", "Traditional Arabic", "Simplified Arabic", sans-serif;
        font-size: 1.8rem;
        direction: rtl;
    }
    
    .hebrew-script {
        font-family: "David", "Times New Roman", "Noto Sans Hebrew", serif;
        font-size: 1.6rem;
        direction: rtl;
    }
    
    .greek-script {
        font-family: "Times New Roman", "Noto Sans", sans-serif;
        font-size: 1.5rem;
    }
    
    .armenian-script {
        font-family: "Noto Sans Armenian", "Sylfaen", sans-serif;
        font-size: 1.5rem;
    }
    
    .bengali-script {
        font-family: "Noto Sans Bengali", "Vrinda", "Shonar Bangla", sans-serif;
        font-size: 1.5rem;
    }
    
    .burmese-script {
        font-family: "Myanmar Text", "Noto Sans Myanmar", "Myanmar3", sans-serif;
        font-size: 1.5rem;
    }
    
    .thai-script {
        font-family: "Noto Sans Thai", "Tahoma", "Microsoft Sans Serif", sans-serif;
        font-size: 1.5rem;
    }
    
    .korean-script {
        font-family: "Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
        font-size: 1.5rem;
    }
    
    .japanese-script {
        font-family: "Yu Gothic", "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
        font-size: 1.5rem;
    }
    
    .mongolian-script {
        font-family: "Mongolian Baiti", "Noto Sans Mongolian", sans-serif;
        font-size: 1.4rem;
    }
    
    .rtl {
        direction: rtl;
    }
    
    .click-notation {
        font-family: "Noto Sans", "DejaVu Sans", sans-serif;
        font-size: 1.3rem;
    }
    
    /* Loading indicator */
    .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--accent);
        animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>

</head>
<body>
    <button id="infoButton" title="About this work">?</button>
    
    <div class="container">
        <h1>Resurrective Necropolis</h1>
        
        <div id="loadingStatus" class="loading-status">
            <span class="loading"></span> Loading language data...
        </div>
        
        <div class="name-display-section">
            <div id="nameDisplay" class="name-main fade-in">Initializing...</div>
            <div id="scriptDisplay" class="script-display"></div>
            <div id="nameComponents" class="name-components"></div>
            <div id="specialIndicators" class="special-indicators"></div>
            <div id="culturalContext" class="cultural-context"></div>
            <div id="meaningsSection" class="meanings-section" style="display: none;"></div>
            <div id="oldNamesSection" class="old-names-section" style="display: none;"></div>
            <div id="voiceStatus" class="voice-status"></div>
            <div id="signLanguageNote" class="sign-language-note" style="display: none;"></div>
        </div>
        
        <div class="controls-wrapper">
            <div class="collapse-toggle">
                <button id="collapseButton" class="collapse-button" title="Toggle Controls">
                    <span class="chevron">‚ñº</span>
                </button>
            </div>
            
            <div id="controlsSection" class="controls">
                <div class="control-row">
                    <button id="initVoiceButton" class="primary">Initialize Voice System</button>
                    <button id="toggleButton">Pause</button>
                    <button id="speakButton">Speak Name</button>
                </div>
                
                <div class="control-row">
                    <div class="control-group">
                        <span style="font-size: 0.85rem;">Slow</span>
                        <label class="switch">
                            <input type="checkbox" id="speedToggle">
                            <span class="slider"></span>
                        </label>
                        <span style="font-size: 0.85rem;">Fast</span>
                    </div>
                    
                    <div class="control-group">
                        <span style="font-size: 0.85rem;">Random</span>
                        <label class="switch">
                            <input type="checkbox" id="weightedToggle">
                            <span class="slider"></span>
                        </label>
                        <span style="font-size: 0.85rem;">Weighted</span>
                    </div>
                </div>
                
                <div class="control-row">
                    <div class="control-group">
                        <span>Show Details</span>
                        <label class="switch">
                            <input type="checkbox" id="detailToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <span>Old Names</span>
                        <label class="switch">
                            <input type="checkbox" id="oldNamesToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="control-row">
                    <div class="control-group">
                        <span>Mix Old/New</span>
                        <label class="switch">
                            <input type="checkbox" id="mixNamesToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <span>Native Scripts</span>
                        <label class="switch">
                            <input type="checkbox" id="nativeScriptToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="stats" class="stats"></div>
    </div>
    
    <!-- Info Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>About Resurrective Necropolis</h2>
            
            <p style="margin: 1rem 0; line-height: 1.6;">
                This memorial generates names from across human cultures, representing the vast diversity of our species through 24 language families covering 99%+ of humanity.
            </p>
            
            <h3 style="margin-top: 1.5rem; color: var(--accent);">Features</h3>
            <ul style="margin: 1rem 0; line-height: 1.8;">
                <li>Names from Indo-European, Sino-Tibetan, Austronesian, Afroasiatic, and 20 other language families</li>
                <li>Native script display (Chinese, Arabic, Devanagari, Cyrillic, etc.)</li>
                <li>Historical and sacred names from ancient cultures</li>
                <li>Gender diversity including cultural third genders</li>
                <li>Sign language names from Deaf communities</li>
                <li>Population-weighted or random selection</li>
                <li>Voice synthesis with intelligent language matching</li>
            </ul>
            
            <h3 style="margin-top: 1.5rem; color: var(--accent);">Keyboard Shortcuts</h3>
            <ul style="margin: 1rem 0; line-height: 1.8;">
                <li><strong>Space</strong> - Play/Pause</li>
                <li><strong>S</strong> - Speak current name</li>
                <li><strong>F</strong> - Toggle fast/slow</li>
                <li><strong>D</strong> - Toggle details</li>
                <li><strong>N</strong> - Next name immediately</li>
                <li><strong>Q+W+E</strong> - Voice settings</li>
            </ul>
            
            <p style="margin-top: 1.5rem; color: var(--text-secondary); font-style: italic;">
                Each name represents a life, a story, a thread in the tapestry of human existence.
            </p>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="settings-modal-content">
            <div class="settings-header">
                <h2>Voice Settings</h2>
                <span class="close" onclick="closeSettings()">&times;</span>
            </div>
            
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="showSettingsTab('voices')">Voices</button>
                <button class="settings-tab" onclick="showSettingsTab('matching')">Matching</button>
                <button class="settings-tab" onclick="showSettingsTab('advanced')">Advanced</button>
            </div>
            
            <div id="voicesTab" class="settings-content">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div>
                        <span>Total: <strong id="totalVoices">0</strong></span> | 
                        <span>Enabled: <strong id="enabledVoices">0</strong></span> | 
                        <span>Languages: <strong id="languageCount">0</strong></span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="selectAllVoices(true)">Enable All</button>
                        <button onclick="selectAllVoices(false)">Disable All</button>
                        <button onclick="selectQualityVoices()">Quality Only</button>
                        <button onclick="resetVoiceSettings()">Reset</button>
                    </div>
                </div>
                <div id="voiceList" class="voice-list"></div>
            </div>
            
            <div id="matchingTab" class="settings-content" style="display: none;">
                <h3>Voice Matching Settings</h3>
                <div style="padding: 1rem;">
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="matchGender" checked> 
                        Match voice gender to name gender
                    </label>
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="matchLanguage" checked> 
                        Match voice language to name origin
                    </label>
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="preferHighQuality" checked> 
                        Prefer high-quality voices
                    </label>
                    <label style="display: block; margin: 1rem 0;">
                        <input type="checkbox" id="avoidNovelty" checked> 
                        Avoid novelty voices (Zarvox, Bells, etc.)
                    </label>
                </div>
            </div>
            
            <div id="advancedTab" class="settings-content" style="display: none;">
                <h3>Advanced Settings</h3>
                <div style="padding: 1rem;">
                    <button onclick="exportSettings()">Export Settings</button>
                    <button onclick="importSettings()">Import Settings</button>
                    <button onclick="clearAllSettings()">Clear All Settings</button>
                    <div style="margin-top: 2rem; padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 0.5rem;">
                        <p>Press <strong>Q + W + E</strong> simultaneously to open settings</p>
                        <p>Press <strong>ESC</strong> to close</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings key hint -->
    <div id="settingsKeyHint" class="settings-key-hint">
        Press Q+W+E for voice settings
    </div>

    <script>
// Global Names Memorial - Version 3.2
// Features:
// - Expanded name databases (doubled names for all language families)
// - Native script display (Chinese, Tibetan, Cyrillic, Devanagari, etc.)
// - Old names and historical figures
// - Sacred and taboo name handling
// - Voice synthesis with intelligent matching
// - Sign language name support
// - Gender diversity support

// Application State
const appState = {
    // Timing
    SLOW_SPEED: 4000,
    FAST_SPEED: 2000,
    
    // State flags
    isInitialized: false,
    isRunning: false,
    isFast: false,
    isWeighted: false,
    showDetails: false,
    showOldNames: false,
    mixOldAndNew: false,
    showNativeScript: false,
    isVoiceInitialized: false,
    
    // Data
    metadata: null,
    loadedFamilies: {},
    currentName: null,
    intervalId: null,
    
    // Voice system
    synth: window.speechSynthesis,
    voices: [],
    voiceSettings: {
        enabled: {},
        matchGender: true,
        matchLanguage: true,
        preferHighQuality: true,
        avoidNovelty: true
    }
};

// Voice Manager
const voiceManager = {
    NOVELTY_VOICES: ['zarvox', 'bells', 'boing', 'bubbles', 'cellos', 'deranged', 'good news', 'bad news', 'hysterical', 'pipe organ', 'trinoids', 'whisper', 'wobble'],
    
    // Assess voice quality
    assessQuality(voice) {
        const name = voice.name.toLowerCase();
        
        // Novelty voices get lowest score
        if (this.NOVELTY_VOICES.some(nov => name.includes(nov))) {
            return 1;
        }
        
        // Premium/Enhanced voices
        if (name.includes('premium') || name.includes('enhanced')) {
            return 5;
        }
        
        // Natural/Neural voices
        if (name.includes('natural') || name.includes('neural')) {
            return 4;
        }
        
        // Desktop voices
        if (!voice.localService) {
            return voice.default ? 3 : 2;
        }
        
        // Online voices are usually better
        return 4;
    },
    
    // Get language family from language code
    getLanguageFamily(langCode) {
        const langMap = {
            'en': 'indoEuropean',
            'es': 'indoEuropean',
            'fr': 'indoEuropean',
            'de': 'indoEuropean',
            'it': 'indoEuropean',
            'pt': 'indoEuropean',
            'ru': 'indoEuropean',
            'hi': 'indoEuropean',
            'zh': 'sinoTibetan',
            'cmn': 'sinoTibetan',
            'yue': 'sinoTibetan',
            'bo': 'sinoTibetan',
            'my': 'sinoTibetan',
            'ar': 'afroasiatic',
            'he': 'afroasiatic',
            'ja': 'japanese',
            'ko': 'korean',
            'vi': 'austroasiatic',
            'th': 'taiKadai',
            'id': 'austronesian',
            'ms': 'austronesian',
            'tl': 'austronesian'
        };
        
        const primaryLang = langCode.split('-')[0].toLowerCase();
        return langMap[primaryLang] || 'unknown';
    },
    
    // Select best voice for a name
    selectVoice(nameData) {
        const settings = appState.voiceSettings;
        let availableVoices = appState.voices.filter(v => 
            settings.enabled[v.name] !== false
        );
        
        if (availableVoices.length === 0) {
            availableVoices = appState.voices;
        }
        
        // Filter out novelty voices if setting is enabled
        if (settings.avoidNovelty) {
            availableVoices = availableVoices.filter(v => 
                !this.NOVELTY_VOICES.some(nov => 
                    v.name.toLowerCase().includes(nov)
                )
            );
        }
        
        // Score each voice
        const scoredVoices = availableVoices.map(voice => {
            let score = 0;
            
            // Gender matching
            if (settings.matchGender && nameData.gender) {
                const voiceGender = this.detectGender(voice);
                if (voiceGender === nameData.gender) {
                    score += 10;
                } else if (voiceGender === 'neutral') {
                    score += 5;
                }
            }
            
            // Language matching
            if (settings.matchLanguage && nameData.familyId) {
                const voiceFamily = this.getLanguageFamily(voice.lang);
                if (voiceFamily === nameData.familyId) {
                    score += 15;
                }
            }
            
            // Quality preference
            if (settings.preferHighQuality) {
                score += this.assessQuality(voice) * 2;
            }
            
            // Default voice bonus
            if (voice.default) {
                score += 3;
            }
            
            return { voice, score };
        });
        
        // Sort by score and pick from top candidates
        scoredVoices.sort((a, b) => b.score - a.score);
        const topScore = scoredVoices[0].score;
        const topVoices = scoredVoices.filter(v => v.score >= topScore - 5);
        
        // Random selection from top candidates
        const selected = topVoices[Math.floor(Math.random() * topVoices.length)];
        return selected.voice;
    },
    
    // Detect voice gender from name
    detectGender(voice) {
        const name = voice.name.toLowerCase();
        const female = ['female', 'woman', 'girl', 'samantha', 'victoria', 'kate', 'karen', 'nora', 'moira', 'fiona', 'tessa', 'veena', 'paulina', 'amelie', 'satu', 'anna', 'ioana', 'milena', 'laura', 'alva', 'monica', 'zuzana', 'mariska', 'ewa', 'zosia', 'sara'];
        const male = ['male', 'man', 'boy', 'daniel', 'thomas', 'alex', 'fred', 'bruce', 'lee', 'diego', 'jorge', 'juan', 'carlos', 'henrik', 'magnus', 'oskar', 'damayanti', 'maged'];
        
        if (female.some(f => name.includes(f))) return 'female';
        if (male.some(m => name.includes(m))) return 'male';
        return 'neutral';
    }
};

// Settings Functions
function saveVoiceSettings() {
    localStorage.setItem('memorialVoiceSettings', JSON.stringify(appState.voiceSettings));
}

function loadVoiceSettings() {
    const saved = localStorage.getItem('memorialVoiceSettings');
    if (saved) {
        try {
            appState.voiceSettings = JSON.parse(saved);
        } catch (e) {
            console.error('Failed to load voice settings:', e);
        }
    }
}

function openSettings() {
    const modal = document.getElementById('settingsModal');
    modal.style.display = 'block';
    
    // Load current settings into checkboxes
    document.getElementById('matchGender').checked = appState.voiceSettings.matchGender;
    document.getElementById('matchLanguage').checked = appState.voiceSettings.matchLanguage;
    document.getElementById('preferHighQuality').checked = appState.voiceSettings.preferHighQuality;
    document.getElementById('avoidNovelty').checked = appState.voiceSettings.avoidNovelty;
    
    populateVoiceList();
    updateVoiceStats();
}

function closeSettings() {
    const modal = document.getElementById('settingsModal');
    modal.style.display = 'none';
    saveVoiceSettings();
}

function showSettingsTab(tabName) {
    // Hide all tabs
    document.getElementById('voicesTab').style.display = 'none';
    document.getElementById('matchingTab').style.display = 'none';
    document.getElementById('advancedTab').style.display = 'none';
    
    // Show selected tab
    document.getElementById(tabName + 'Tab').style.display = 'block';
    
    // Update tab buttons
    document.querySelectorAll('.settings-tab').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Find the button that was clicked
    const buttons = document.querySelectorAll('.settings-tab');
    buttons.forEach(btn => {
        if (btn.textContent.toLowerCase().includes(tabName.toLowerCase())) {
            btn.classList.add('active');
        }
    });
}

function populateVoiceList() {
    const container = document.getElementById('voiceList');
    container.innerHTML = '';
    
    // Group voices by language
    const voicesByLang = {};
    appState.voices.forEach(voice => {
        const lang = voice.lang;
        if (!voicesByLang[lang]) {
            voicesByLang[lang] = [];
        }
        voicesByLang[lang].push(voice);
    });
    
    // Create voice items
    Object.entries(voicesByLang).sort().forEach(([lang, voices]) => {
        const langHeader = document.createElement('div');
        langHeader.style.cssText = 'font-weight: bold; margin: 1rem 0 0.5rem 0; color: var(--accent);';
        langHeader.textContent = `${lang} (${voices.length})`;
        container.appendChild(langHeader);
        
        voices.sort((a, b) => a.name.localeCompare(b.name)).forEach(voice => {
            const item = document.createElement('div');
            item.className = 'voice-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'voice-checkbox';
            checkbox.checked = appState.voiceSettings.enabled[voice.name] !== false;
            checkbox.onchange = (e) => toggleVoice(voice.name, e.target.checked);
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'voice-info';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'voice-name';
            nameDiv.textContent = voice.name;
            
            const gender = voiceManager.detectGender(voice);
            const genderDiv = document.createElement('div');
            genderDiv.className = 'voice-gender';
            genderDiv.textContent = gender;
            genderDiv.style.background = 
                gender === 'female' ? 'rgba(255, 105, 180, 0.2)' :
                gender === 'male' ? 'rgba(100, 149, 237, 0.2)' :
                'rgba(255, 255, 255, 0.1)';
            
            const quality = voiceManager.assessQuality(voice);
            const qualityDiv = document.createElement('div');
            qualityDiv.className = 'voice-quality';
            qualityDiv.innerHTML = Array(quality).fill('‚òÖ').join('');
            
            const testBtn = document.createElement('button');
            testBtn.className = 'voice-test-btn';
            testBtn.textContent = 'Test';
            testBtn.onclick = () => testVoice(voice.name);
            
            infoDiv.appendChild(nameDiv);
            infoDiv.appendChild(genderDiv);
            infoDiv.appendChild(qualityDiv);
            infoDiv.appendChild(testBtn);
            
            item.appendChild(checkbox);
            item.appendChild(infoDiv);
            container.appendChild(item);
        });
    });
}

function toggleVoice(voiceName, enabled) {
    appState.voiceSettings.enabled[voiceName] = enabled;
    updateVoiceStats();
    saveVoiceSettings();
}

function testVoice(voiceName) {
    const voice = appState.voices.find(v => v.name === voiceName);
    if (!voice) return;
    
    appState.synth.cancel();
    
    const testText = appState.currentName ?
        appState.currentName.display : 
        'Testing voice: ' + voiceName;
    
    const utterance = new SpeechSynthesisUtterance(testText);
    utterance.voice = voice;
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;
    
    appState.synth.speak(utterance);
}

function updateVoiceStats() {
    const total = appState.voices.length;
    const enabled = appState.voices.filter(v => 
        appState.voiceSettings.enabled[v.name] !== false
    ).length;
    const languages = new Set(appState.voices.map(v => v.lang.split('-')[0])).size;
    
    document.getElementById('totalVoices').textContent = total;
    document.getElementById('enabledVoices').textContent = enabled;
    document.getElementById('languageCount').textContent = languages;
}

function selectAllVoices(enable) {
    appState.voices.forEach(voice => {
        appState.voiceSettings.enabled[voice.name] = enable;
    });
    populateVoiceList();
    updateVoiceStats();
    saveVoiceSettings();
}

function selectQualityVoices() {
    appState.voices.forEach(voice => {
        const quality = voiceManager.assessQuality(voice);
        appState.voiceSettings.enabled[voice.name] = quality >= 3;
    });
    populateVoiceList();
    updateVoiceStats();
    saveVoiceSettings();
}

function resetVoiceSettings() {
    appState.voiceSettings = {
        enabled: {},
        matchGender: true,
        matchLanguage: true,
        preferHighQuality: true,
        avoidNovelty: true
    };
    populateVoiceList();
    updateVoiceStats();
    saveVoiceSettings();
}

function exportSettings() {
    const data = JSON.stringify(appState.voiceSettings, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'memorial-voice-settings.json';
    a.click();
    URL.revokeObjectURL(url);
}

function importSettings() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const settings = JSON.parse(event.target.result);
                appState.voiceSettings = { ...appState.voiceSettings, ...settings };
                populateVoiceList();
                updateVoiceStats();
                saveVoiceSettings();
                alert('Settings imported successfully!');
            } catch (error) {
                alert('Failed to import settings: ' + error.message);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function clearAllSettings() {
    if (confirm('This will clear all voice settings. Are you sure?')) {
        localStorage.removeItem('memorialVoiceSettings');
        resetVoiceSettings();
    }
}

// Initialize the application
async function initializeApp() {
    const loadingStatus = document.getElementById('loadingStatus');
    
    try {
        console.log('Starting initialization...');
        
        // Load metadata
        loadingStatus.innerHTML = '<span class="loading"></span> Loading system metadata...';
        const metaResponse = await fetch('./languages/metadata.json');
        
        if (!metaResponse.ok) {
            throw new Error(`Failed to load metadata: ${metaResponse.status}`);
        }
        
        appState.metadata = await metaResponse.json();
        console.log('Metadata loaded:', appState.metadata);
        
        // Load ALL language families (or as many as possible)
        loadingStatus.innerHTML = '<span class="loading"></span> Loading language families...';
        
        // Try to load all families, not just preloadCommon
        let loadedCount = 0;
        let failedCount = 0;
        const failedFamilies = [];
        
        for (const family of appState.metadata.languageFamilies) {
            try {
                await loadLanguageFamily(family.id);
                loadedCount++;
                console.log(`‚úî Loaded ${family.id} (${loadedCount}/${appState.metadata.languageFamilies.length})`);
                loadingStatus.innerHTML = `<span class="loading"></span> Loading language families... (${loadedCount}/${appState.metadata.languageFamilies.length})`;
            } catch (err) {
                failedCount++;
                failedFamilies.push(family.id);
                console.warn(`‚úó Failed to load ${family.id}: ${err.message}`);
                // Continue loading others even if one fails
            }
        }
        
        console.log(`=== LOADING SUMMARY ===`);
        console.log(`Successfully loaded: ${loadedCount} families`);
        console.log(`Failed: ${failedCount} families`);
        if (failedFamilies.length > 0) {
            console.log(`Failed families: ${failedFamilies.join(', ')}`);
        }
        console.log(`Loaded families:`, Object.keys(appState.loadedFamilies));
        
        if (loadedCount === 0) {
            throw new Error('No language families could be loaded');
        }
        
        // Mark as initialized
        appState.isInitialized = true;
        
        // Hide loading status
        loadingStatus.style.display = 'none';
        
        // Update stats
        updateStats();
        
        // Update voice status
        updateVoiceStatus('');
        
        // Start the memorial
        appState.isRunning = true;
        startInterval();
        
        console.log('Initialization complete!');
        console.log('üí° Press Space to pause/resume');
        console.log('üé§ Press Q+W+E simultaneously to open voice settings');
        
    } catch (error) {
        console.error('Failed to initialize app:', error);
        loadingStatus.className = 'loading-status error-message';
        loadingStatus.innerHTML = `
            ‚ö†Ô∏è Failed to load language data. 
            <br>Error: ${error.message}
        `;
    }
}

// Load a language family
async function loadLanguageFamily(familyId) {
    // Check if already loaded
    if (appState.loadedFamilies[familyId]) {
        console.log(`${familyId} already loaded`);
        return appState.loadedFamilies[familyId];
    }
    
    // Find family info
    const familyInfo = appState.metadata.languageFamilies.find(f => f.id === familyId);
    if (!familyInfo) {
        throw new Error(`Unknown language family: ${familyId}`);
    }
    
    // Load the file
    const url = `./languages/${familyInfo.fileName}`;
    console.log(`Attempting to load ${familyId} from: ${url}`);
    
    const response = await fetch(url);
    console.log(`Response for ${familyId}: ${response.status} ${response.statusText}`);
    
    if (!response.ok) {
        throw new Error(`Failed to load ${familyId}: ${response.status} ${response.statusText}`);
    }
    
    try {
        const text = await response.text();
        console.log(`${familyId} file size: ${text.length} characters`);
        
        const data = JSON.parse(text);
        console.log(`${familyId} parsed successfully, has ${Object.keys(data).length} top-level keys`);
        
        appState.loadedFamilies[familyId] = data;
        return data;
    } catch (parseError) {
        console.error(`JSON parse error for ${familyId}:`, parseError);
        throw new Error(`JSON parse error for ${familyId}: ${parseError.message}`);
    }
}

// Voice system initialization
async function initializeVoiceSystem() {
    const status = document.getElementById('voiceStatus');
    const button = document.getElementById('initVoiceButton');
    
    status.innerHTML = '<span class="loading"></span> Initializing voice system...';
    
    try {
        // Check browser support
        if (!window.speechSynthesis) {
            throw new Error('Speech synthesis not supported');
        }
        
        // Load voices (with retry logic for Chrome)
        let attempts = 0;
        const loadVoices = () => {
            return new Promise((resolve) => {
                const voices = appState.synth.getVoices();
                if (voices.length > 0) {
                    resolve(voices);
                } else if (attempts < 10) {
                    attempts++;
                    setTimeout(() => loadVoices().then(resolve), 100);
                } else {
                    resolve([]);
                }
            });
        };
        
        // Force voice list update
        appState.synth.getVoices();
        
        // Try to load voices
        appState.voices = await loadVoices();
        
        if (appState.voices.length === 0) {
            // Try one more time with event listener
            await new Promise((resolve) => {
                appState.synth.onvoiceschanged = () => {
                    appState.voices = appState.synth.getVoices();
                    resolve();
                };
                setTimeout(resolve, 1000);
            });
        }
        
        if (appState.voices.length === 0) {
            throw new Error('No voices available');
        }
        
        // Load saved settings
        loadVoiceSettings();
        
        // Update status
        appState.isVoiceInitialized = true;
        status.innerHTML = `‚úì Voice system ready (${appState.voices.length} voices available)`;
        button.style.display = 'none';
        
        // Speak current name if there is one
        if (appState.currentName) {
            speakName(appState.currentName);
        }
        
        console.log(`Voice system initialized with ${appState.voices.length} voices`);
        
    } catch (error) {
        console.error('Voice initialization failed:', error);
        status.innerHTML = `‚ö†Ô∏è Voice system unavailable: ${error.message}`;
        button.textContent = 'Retry Voice Init';
    }
}

// Name generation functions
function selectLanguageFamily() {
    const families = Object.keys(appState.loadedFamilies);
    
    if (families.length === 0) {
        console.error('No language families loaded');
        return null;
    }
    
    if (!appState.isWeighted) {
        // Random selection
        return families[Math.floor(Math.random() * families.length)];
    }
    
    // Weighted selection based on population
    const weights = [];
    let totalWeight = 0;
    
    families.forEach(familyId => {
        const familyInfo = appState.metadata.languageFamilies.find(f => f.id === familyId);
        const weight = familyInfo?.populationPercentage || 1;
        weights.push({ familyId, weight });
        totalWeight += weight;
    });
    
    let random = Math.random() * totalWeight;
    for (const item of weights) {
        random -= item.weight;
        if (random <= 0) {
            return item.familyId;
        }
    }
    
    return families[0];
}

function generateOldName(familyData, gender) {
    const oldNames = familyData.nameComponents.oldNames;
    if (!oldNames) return null;
    
    // Determine which categories to use based on gender
    let categories = [];
    
    if (gender === 'male' || gender === 'neutral') {
        if (oldNames.historical?.male) categories.push({ type: 'historical', data: oldNames.historical.male });
        if (oldNames.religious?.male) categories.push({ type: 'religious', data: oldNames.religious.male });
        if (oldNames.royal?.male) categories.push({ type: 'royal', data: oldNames.royal.male });
        if (oldNames.legendary?.male) categories.push({ type: 'legendary', data: oldNames.legendary.male });
        if (oldNames.literary?.male) categories.push({ type: 'literary', data: oldNames.literary.male });
    }
    
    if (gender === 'female' || gender === 'neutral') {
        if (oldNames.historical?.female) categories.push({ type: 'historical', data: oldNames.historical.female });
        if (oldNames.religious?.female) categories.push({ type: 'religious', data: oldNames.religious.female });
        if (oldNames.royal?.female) categories.push({ type: 'royal', data: oldNames.royal.female });
        if (oldNames.legendary?.female) categories.push({ type: 'legendary', data: oldNames.legendary.female });
        if (oldNames.literary?.female) categories.push({ type: 'literary', data: oldNames.literary.female });
    }
    
    if (categories.length === 0) return null;
    
    // Pick a random category
    const category = categories[Math.floor(Math.random() * categories.length)];
    
    // Pick a random name from category
    const names = Object.keys(category.data);
    if (names.length === 0) return null;
    
    const name = names[Math.floor(Math.random() * names.length)];
    const meaning = category.data[name];
    
    return {
        display: name,
        given: name,
        meaning: meaning,
        category: category.type
    };
}

function getNativeScriptName(familyData, gender, familyId) {
    if (!familyData.nameComponents.nativeScript) return null;
    
    const scripts = familyData.nameComponents.nativeScript;
    const scriptTypes = Object.keys(scripts);
    if (scriptTypes.length === 0) return null;
    
    // Pick a random script type
    const scriptType = scriptTypes[Math.floor(Math.random() * scriptTypes.length)];
    const scriptData = scripts[scriptType];
    
    let names = [];
    if (scriptData.given?.[gender]) {
        names = scriptData.given[gender];
    } else if (scriptData.given?.neutral) {
        names = scriptData.given.neutral;
    } else if (scriptData.given?.male && gender === 'neutral') {
        names = [...(scriptData.given.male || []), ...(scriptData.given.female || [])];
    }
    
    if (names.length === 0) return null;
    
    const given = names[Math.floor(Math.random() * names.length)];
    
    // Get family name if available
    let family = '';
    if (scriptData.family && scriptData.family.length > 0) {
        family = scriptData.family[Math.floor(Math.random() * scriptData.family.length)];
    }
    
    // Determine name order
    const nameOrder = familyData.metadata?.nameOrder || 'given_first';
    
    return {
        given: given,
        family: family,
        display: nameOrder === 'family_first' ? 
            (family ? `${family} ${given}` : given) :
            (family ? `${given} ${family}` : given),
        scriptType: scriptType
    };
}

async function generateName() {
    try {
        // Decide if using old names
        const useOldName = appState.mixOldAndNew ? 
            Math.random() < 0.3 : 
            appState.showOldNames;
        
        // Select family
        const familyId = selectLanguageFamily();
        if (!familyId) return null;
        
        const familyData = appState.loadedFamilies[familyId];
        if (!familyData) return null;
        
        // Select gender
        const genders = ['male', 'female', 'neutral'];
        const gender = genders[Math.floor(Math.random() * genders.length)];
        
        // Get native script if enabled
        let nativeScript = null;
        if (appState.showNativeScript && familyData.nameComponents.nativeScript) {
            nativeScript = getNativeScriptName(familyData, gender, familyId);
        }
        
        if (useOldName && familyData.nameComponents.oldNames) {
            // Generate old name
            const oldNameData = generateOldName(familyData, gender);
            if (oldNameData) {
                return {
                    display: oldNameData.display,
                    spoken: oldNameData.display,
                    nativeScript: nativeScript,
                    given: oldNameData.given,
                    meaning: oldNameData.meaning,
                    category: oldNameData.category,
                    isOldName: true,
                    gender: gender,
                    familyId: familyId,
                    languageFamily: familyData.metadata.family,
                    writingSystems: familyData.metadata.writingSystems,
                    populationPercentage: appState.metadata.languageFamilies.find(f => f.id === familyId)?.populationPercentage
                };
            }
        }
        
        // Generate modern name
        const givenNames = familyData.nameComponents.given[gender] || 
                          familyData.nameComponents.given.neutral ||
                          [];
                          
        let familyNames = [];
        if (Array.isArray(familyData.nameComponents.family)) {
            familyNames = familyData.nameComponents.family;
        } else if (familyData.nameComponents.family) {
            familyNames = familyData.nameComponents.family[gender] ||
                         familyData.nameComponents.family.neutral ||
                         [];
        }
        
        if (givenNames.length === 0) return null;
        
        const given = givenNames[Math.floor(Math.random() * givenNames.length)];
        const family = familyNames.length > 0 ? 
            familyNames[Math.floor(Math.random() * familyNames.length)] : '';
        
        // Handle patronymics
        let patronymic = '';
        if (familyData.nameComponents.patronymics?.[gender]) {
            const patronymics = familyData.nameComponents.patronymics[gender];
            if (patronymics.length > 0 && Math.random() < 0.3) {
                patronymic = patronymics[Math.floor(Math.random() * patronymics.length)];
            }
        }
        
        // Determine name order
        const nameOrder = familyData.metadata?.nameOrder || 'given_first';
        
        // Build display name
        let displayParts = [];
        if (nameOrder === 'family_first') {
            if (family) displayParts.push(family);
            displayParts.push(given);
            if (patronymic) displayParts.push(patronymic);
        } else {
            displayParts.push(given);
            if (patronymic) displayParts.push(patronymic);
            if (family) displayParts.push(family);
        }
        
        const display = displayParts.join(' ');
        
        // Get meaning if available
        let meaning = '';
        if (familyData.meanings?.given?.[given]) {
            meaning = familyData.meanings.given[given];
        }
        
        // Check if sacred or taboo
        let isSacred = false;
        let isTaboo = false;
        
        if (familyData.specialNames?.sacred?.includes(given)) {
            isSacred = true;
        }
        if (familyData.specialNames?.taboo?.includes(given)) {
            isTaboo = true;
        }
        
        return {
            display: display,
            spoken: display,
            nativeScript: nativeScript,
            given: given,
            family: family,
            patronymic: patronymic,
            meaning: meaning,
            isSacred: isSacred,
            isTaboo: isTaboo,
            gender: gender,
            familyId: familyId,
            languageFamily: familyData.metadata.family,
            writingSystems: familyData.metadata.writingSystems,
            populationPercentage: appState.metadata.languageFamilies.find(f => f.id === familyId)?.populationPercentage
        };
        
    } catch (error) {
        console.error('Error generating name:', error);
        return null;
    }
}

// Display functions
function displayName(nameData) {
    if (!nameData) return;
    
    appState.currentName = nameData;
    
    const nameDisplay = document.getElementById('nameDisplay');
    const scriptDisplay = document.getElementById('scriptDisplay');
    const componentsDiv = document.getElementById('nameComponents');
    const indicatorsDiv = document.getElementById('specialIndicators');
    const contextDiv = document.getElementById('culturalContext');
    const meaningsDiv = document.getElementById('meaningsSection');
    const oldNamesDiv = document.getElementById('oldNamesSection');
    const signNote = document.getElementById('signLanguageNote');
    
    // Main name display
    nameDisplay.textContent = nameData.display;
    nameDisplay.className = 'name-main fade-in';
    
    // Native script display
    scriptDisplay.innerHTML = '';
    if (nameData.nativeScript && appState.showNativeScript) {
        scriptDisplay.textContent = nameData.nativeScript.display;
        
        // Apply appropriate script class
        const scriptClass = {
            'chinese': 'chinese-script',
            'traditional': 'chinese-script',
            'tibetan': 'tibetan-script',
            'devanagari': 'devanagari-script',
            'cyrillic': 'cyrillic-script',
            'arabic': 'arabic-script',
            'hebrew': 'hebrew-script',
            'greek': 'greek-script',
            'armenian': 'armenian-script',
            'bengali': 'bengali-script',
            'burmese': 'burmese-script',
            'thai': 'thai-script',
            'korean': 'korean-script',
            'japanese': 'japanese-script',
            'mongolian': 'mongolian-script'
        };
        
        const scriptType = nameData.nativeScript.scriptType;
        if (scriptClass[scriptType]) {
            scriptDisplay.className = `script-display ${scriptClass[scriptType]}`;
        }
        
        // Handle RTL scripts
        if (scriptType === 'arabic' || scriptType === 'hebrew') {
            scriptDisplay.classList.add('rtl');
        }
    }
    
    // Show components if details enabled
    if (appState.showDetails) {
        componentsDiv.innerHTML = '';
        
        if (nameData.given) {
            const comp = document.createElement('div');
            comp.className = 'component';
            comp.innerHTML = `<span class="component-label">Given:</span> ${nameData.given}`;
            componentsDiv.appendChild(comp);
        }
        
        if (nameData.patronymic) {
            const comp = document.createElement('div');
            comp.className = 'component';
            comp.innerHTML = `<span class="component-label">Patronymic:</span> ${nameData.patronymic}`;
            componentsDiv.appendChild(comp);
        }
        
        if (nameData.family) {
            const comp = document.createElement('div');
            comp.className = 'component';
            comp.innerHTML = `<span class="component-label">Family:</span> ${nameData.family}`;
            componentsDiv.appendChild(comp);
        }
    } else {
        componentsDiv.innerHTML = '';
    }
    
    // Special indicators
    indicatorsDiv.innerHTML = '';
    
    if (nameData.isSacred) {
        const indicator = document.createElement('div');
        indicator.className = 'indicator indicator-sacred';
        indicator.innerHTML = '‚ú® Sacred';
        indicatorsDiv.appendChild(indicator);
    }
    
    if (nameData.isTaboo) {
        const indicator = document.createElement('div');
        indicator.className = 'indicator indicator-taboo';
        indicator.innerHTML = '‚ö†Ô∏è Taboo';
        indicatorsDiv.appendChild(indicator);
    }
    
    if (nameData.isOldName) {
        const indicator = document.createElement('div');
        indicator.className = 'indicator indicator-old-name';
        indicator.innerHTML = `üìú ${nameData.category || 'Historical'}`;
        indicatorsDiv.appendChild(indicator);
    }
    
    if (!nameData.family && !nameData.patronymic) {
        const indicator = document.createElement('div');
        indicator.className = 'indicator indicator-mononym';
        indicator.innerHTML = '‚óâ Mononym';
        indicatorsDiv.appendChild(indicator);
    }
    
    // Cultural context
    if (appState.showDetails) {
        contextDiv.innerHTML = '';
        contextDiv.className = 'cultural-context';
        
        const cultureInfo = document.createElement('div');
        cultureInfo.className = 'culture-info';
        
        const items = [
            { label: 'Language Family:', value: nameData.languageFamily },
            { label: 'Gender:', value: nameData.gender },
            { label: 'Writing Systems:', value: nameData.writingSystems?.join(', ') }
        ];
        
        items.forEach(item => {
            if (item.value) {
                const div = document.createElement('div');
                div.className = 'info-item';
                div.innerHTML = `<span class="info-label">${item.label}</span> ${item.value}`;
                cultureInfo.appendChild(div);
            }
        });
        
        contextDiv.appendChild(cultureInfo);
    } else {
        contextDiv.innerHTML = '';
    }
    
    // Meanings section
    if (nameData.meaning && appState.showDetails) {
        meaningsDiv.style.display = 'block';
        meaningsDiv.innerHTML = `
            <div class="meanings-title">Meaning</div>
            <div class="meaning-item">${nameData.meaning}</div>
        `;
    } else {
        meaningsDiv.style.display = 'none';
    }
    
    // Old names section
    if (nameData.isOldName && appState.showDetails) {
        oldNamesDiv.style.display = 'block';
        oldNamesDiv.innerHTML = `
            <div class="old-names-title">Historical Context</div>
            <div class="meaning-item">
                <span class="meaning-label">${nameData.category}:</span> ${nameData.meaning || nameData.display}
            </div>
        `;
    } else {
        oldNamesDiv.style.display = 'none';
    }
    
    // Sign language note
    if (nameData.familyId === 'signLanguages') {
        signNote.style.display = 'block';
        signNote.innerHTML = 'üëê This name is from a sign language community';
    } else {
        signNote.style.display = 'none';
    }
}

// Voice functions
function updateVoiceStatus(message) {
    const status = document.getElementById('voiceStatus');
    if (message) {
        status.innerHTML = message;
        status.style.opacity = '1';
    } else {
        status.innerHTML = appState.isVoiceInitialized ? 
            '' : 
            'Voice system not initialized - click "Initialize Voice System" to enable';
        status.style.opacity = '0.8';
    }
}

function speakName(nameData) {
    if (!appState.isVoiceInitialized || !nameData) return;
    
    // Cancel any ongoing speech
    appState.synth.cancel();
    
    // Select appropriate voice
    const voice = voiceManager.selectVoice(nameData);
    
    if (!voice) {
        updateVoiceStatus('No suitable voice available');
        return;
    }
    
    // Create utterance
    const utterance = new SpeechSynthesisUtterance(nameData.spoken);
    utterance.voice = voice;
    utterance.rate = 0.9;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;
    
    // Update status
    const voiceInfo = `${voice.name} (${voice.lang})`;
    updateVoiceStatus(`Speaking with: ${voiceInfo}`);
    
    // Event handlers
    utterance.onend = () => {
        updateVoiceStatus('');
    };
    
    utterance.onerror = (event) => {
        console.error('Speech error:', event);
        updateVoiceStatus(`Speech error: ${event.error}`);
    };
    
    // Speak
    appState.synth.speak(utterance);
}

// Stats update
function updateStats(currentName = null) {
    const stats = document.getElementById('stats');
    
    const loadedCount = Object.keys(appState.loadedFamilies).length;
    const totalCount = appState.metadata?.languageFamilies?.length || 0;
    
    let statsText = `${loadedCount} of ${totalCount} language families loaded ‚Ä¢ `;
    
    if (appState.isWeighted && currentName && currentName.populationPercentage !== undefined) {
        statsText += `Population weighted (${currentName.languageFamily}: ${currentName.populationPercentage}%) ‚Ä¢ `;
    } else if (appState.isWeighted) {
        statsText += `Population weighted ‚Ä¢ `;
    } else {
        statsText += `Random selection ‚Ä¢ `;
    }
    
    if (appState.mixOldAndNew) {
        statsText += `Mixed historical/modern ‚Ä¢ `;
    } else if (appState.showOldNames) {
        statsText += `Historical names only ‚Ä¢ `;
    }
    
    if (appState.showNativeScript) {
        statsText += `Native scripts enabled ‚Ä¢ `;
    }
    
    statsText += `${appState.isFast ? 'Fast' : 'Slow'} speed`;
    
    stats.innerHTML = statsText;
}

// Interval management
function startInterval() {
    if (!appState.isInitialized) {
        console.log('Cannot start - not initialized');
        return;
    }
    
    // Clear existing interval
    if (appState.intervalId) {
        clearInterval(appState.intervalId);
    }
    
    // Generate first name immediately
    generateAndDisplay();
    
    // Set up interval
    const speed = appState.isFast ? appState.FAST_SPEED : appState.SLOW_SPEED;
    appState.intervalId = setInterval(() => {
        if (appState.isRunning) {
            generateAndDisplay();
        }
    }, speed);
}

async function generateAndDisplay() {
    const nameData = await generateName();
    if (nameData) {
        displayName(nameData);
        updateStats(nameData);  // Pass the current name data
        
        if (appState.isRunning && appState.isVoiceInitialized) {
            // Small delay to ensure display updates first
            setTimeout(() => speakName(nameData), 100);
        }
    }
}

// Collapsible controls handler
document.getElementById('collapseButton').addEventListener('click', () => {
    const button = document.getElementById('collapseButton');
    const controls = document.getElementById('controlsSection');
    
    button.classList.toggle('collapsed');
    controls.classList.toggle('collapsed');
});

// Event handlers
document.getElementById('initVoiceButton').addEventListener('click', initializeVoiceSystem);

document.getElementById('toggleButton').addEventListener('click', () => {
    appState.isRunning = !appState.isRunning;
    document.getElementById('toggleButton').textContent = appState.isRunning ? 'Pause' : 'Resume';
    
    if (!appState.isRunning) {
        appState.synth.cancel();
    }
});

document.getElementById('speedToggle').addEventListener('change', (e) => {
    appState.isFast = e.target.checked;
    updateStats(appState.currentName);
    startInterval();
});

document.getElementById('weightedToggle').addEventListener('change', (e) => {
    appState.isWeighted = e.target.checked;
    updateStats(appState.currentName);
});

document.getElementById('detailToggle').addEventListener('change', (e) => {
    appState.showDetails = e.target.checked;
    if (appState.currentName) {
        displayName(appState.currentName);
    }
});

document.getElementById('oldNamesToggle').addEventListener('change', (e) => {
    appState.showOldNames = e.target.checked;
    // If turning off old names while in mix mode, also turn off mix mode
    if (!appState.showOldNames && appState.mixOldAndNew) {
        appState.mixOldAndNew = false;
        document.getElementById('mixNamesToggle').checked = false;
    }
    generateAndDisplay();
});

document.getElementById('mixNamesToggle').addEventListener('change', (e) => {
    appState.mixOldAndNew = e.target.checked;
    // If enabling mix mode, ensure old names are also enabled
    if (appState.mixOldAndNew && !appState.showOldNames) {
        appState.showOldNames = true;
        document.getElementById('oldNamesToggle').checked = true;
    }
    generateAndDisplay();
});

document.getElementById('nativeScriptToggle').addEventListener('change', (e) => {
    appState.showNativeScript = e.target.checked;
    if (appState.currentName) {
        displayName(appState.currentName);
    }
});

document.getElementById('speakButton').addEventListener('click', () => {
    if (appState.currentName) {
        speakName(appState.currentName);
    }
});

// Name click for Google Images
document.getElementById('nameDisplay').addEventListener('click', (e) => {
    const name = e.target.textContent;
    if (name && !name.includes('[') && !name.includes('Initializing')) {
        const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(name)}&tbm=isch`;
        window.open(searchUrl, '_blank', 'noopener,noreferrer');
    }
});

// Info modal handlers
document.getElementById('infoButton').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'block';
});

document.querySelector('.close').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'none';
});

window.addEventListener('click', (e) => {
    const modal = document.getElementById('infoModal');
    if (e.target === modal) {
        modal.style.display = 'none';
    }
});

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, starting initialization...');
    
    // Load voice settings from localStorage
    loadVoiceSettings();
    
    // Set initial toggle states
    document.getElementById('speedToggle').checked = appState.isFast;
    document.getElementById('weightedToggle').checked = appState.isWeighted;
    document.getElementById('detailToggle').checked = appState.showDetails;
    document.getElementById('oldNamesToggle').checked = appState.showOldNames;
    document.getElementById('mixNamesToggle').checked = appState.mixOldAndNew;
    document.getElementById('nativeScriptToggle').checked = appState.showNativeScript;
    
    // Add diagnostic function to window for debugging
    window.checkFiles = async function() {
        console.log('=== FILE CHECK DIAGNOSTIC ===');
        const files = [
            './languages/metadata.json',
            './languages/indo-european.json',
            './languages/sino-tibetan.json'
        ];
        
        for (const file of files) {
            try {
                const response = await fetch(file);
                if (response.ok) {
                    const text = await response.text();
                    console.log(`‚úî ${file}: SUCCESS (${text.length} chars)`);
                    
                    // Check first 100 characters
                    console.log(`  First 100 chars: ${text.substring(0, 100)}`);
                    
                    try {
                        JSON.parse(text);
                        console.log(`  JSON: Valid`);
                    } catch (e) {
                        console.log(`  JSON: INVALID - ${e.message}`);
                        // Show where the error occurred
                        const errorPosition = parseInt(e.message.match(/position (\d+)/)?.[1] || 0);
                        if (errorPosition > 0) {
                            console.log(`  Error near: "${text.substring(Math.max(0, errorPosition - 20), errorPosition + 20)}"`);
                        }
                    }
                } else {
                    console.log(`‚úó ${file}: HTTP ${response.status}`);
                }
            } catch (e) {
                console.log(`‚úó ${file}: NETWORK ERROR - ${e.message}`);
            }
        }
        console.log('=== END DIAGNOSTIC ===');
    };
    
    // Also add function to check loaded families
    window.showLoaded = function() {
        console.log('=== LOADED FAMILIES ===');
        console.log('Count:', Object.keys(appState.loadedFamilies).length);
        console.log('IDs:', Object.keys(appState.loadedFamilies));
        for (const [id, data] of Object.entries(appState.loadedFamilies)) {
            const nameCount = data.nameComponents?.given?.male?.length || 0;
            console.log(`${id}: ${nameCount} male names`);
        }
    };
    
    console.log('Diagnostics available:');
    console.log('  checkFiles() - Check if files are accessible');
    console.log('  showLoaded() - Show loaded families');
    
    // Keyboard shortcuts
    const keysPressed = {};
    
    document.addEventListener('keydown', (e) => {
        keysPressed[e.key.toLowerCase()] = true;
        
        // Check for Q+W+E combination
        if (keysPressed['q'] && keysPressed['w'] && keysPressed['e']) {
            e.preventDefault();
            openSettings();
            return;
        }
        
        // Single key shortcuts
        switch(e.key.toLowerCase()) {
            case ' ':
                e.preventDefault();
                document.getElementById('toggleButton').click();
                break;
            case 's':
                if (!e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    document.getElementById('speakButton').click();
                }
                break;
            case 'f':
                e.preventDefault();
                document.getElementById('speedToggle').click();
                break;
            case 'd':
                e.preventDefault();
                document.getElementById('detailToggle').click();
                break;
            case 'n':
                e.preventDefault();
                generateAndDisplay();
                break;
            case 'escape':
                // Close any open modals
                document.getElementById('infoModal').style.display = 'none';
                document.getElementById('settingsModal').style.display = 'none';
                break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        delete keysPressed[e.key.toLowerCase()];
    });
    
    // Settings modal checkbox handlers
    document.getElementById('matchGender').addEventListener('change', (e) => {
        appState.voiceSettings.matchGender = e.target.checked;
        saveVoiceSettings();
    });
    
    document.getElementById('matchLanguage').addEventListener('change', (e) => {
        appState.voiceSettings.matchLanguage = e.target.checked;
        saveVoiceSettings();
    });
    
    document.getElementById('preferHighQuality').addEventListener('change', (e) => {
        appState.voiceSettings.preferHighQuality = e.target.checked;
        saveVoiceSettings();
    });
    
    document.getElementById('avoidNovelty').addEventListener('change', (e) => {
        appState.voiceSettings.avoidNovelty = e.target.checked;
        saveVoiceSettings();
    });
    
    // Initialize the app
    initializeApp();
});
    </script>
</body>
</html>