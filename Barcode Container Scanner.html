<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drinks Container Program</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            min-height: 100vh;
            color: #333;
            outline: none;
        }

        body.focus-lost {
            outline: 3px solid #e74c3c;
            outline-offset: -3px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .focus-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .focus-indicator.focused {
            background: #27ae60;
            color: white;
        }

        .focus-indicator.lost-focus {
            background: #e74c3c;
            color: white;
            animation: pulse 1s infinite;
        }

        /* Hide focus indicator when not on scanning tab */
        body:not(.scanning-active) .focus-indicator {
            display: none;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: #27ae60;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .tab {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            color: #4a5568;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
        }

        .tab.active {
            background: #27ae60;
            color: white;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
        }

        .content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            min-height: 500px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Scanning Mode Styles */
        .scanning-layout {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 300px);
            min-height: 400px;
        }

        .scanning-top {
            flex-shrink: 0;
        }

        .scan-status {
            text-align: center;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .scan-status.pending {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            animation: pendingPulse 2s infinite;
        }

        @keyframes pendingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .current-person {
            background: rgba(39, 174, 96, 0.1);
            border: 2px solid #27ae60;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .current-person h3 {
            color: #27ae60;
            margin-bottom: 10px;
        }

        .current-person .name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2d3748;
        }

        .current-person .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
        }

        .current-person .stat {
            text-align: center;
        }

        .current-person .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #27ae60;
        }

        .current-person .stat-label {
            color: #718096;
            font-size: 0.9rem;
        }

        .house-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            color: white;
            margin-left: 10px;
        }

        .house-yellow { background: #f1c40f; }
        .house-green { background: #27ae60; }
        .house-blue { background: #3498db; }
        .house-red { background: #e74c3c; }

        .recent-scans-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .recent-scans {
            flex: 1;
            overflow-y: auto;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
        }

        .scan-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            background: #f7fafc;
            border-left: 4px solid #27ae60;
        }

        .scan-item.person {
            border-left-color: #27ae60;
            background: #f0fff4;
        }

        .scan-item.container {
            border-left-color: #2ecc71;
            background: #ebfff0;
        }

        .scan-item.pending {
            border-left-color: #f39c12;
            background: #fff8e1;
            animation: pendingItemPulse 2s infinite;
        }

        .scan-item.invalid {
            border-left-color: #e74c3c;
            background: #fff5f5;
            opacity: 0.7;
        }

        @keyframes pendingItemPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .inline-learn {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .inline-learn h4 {
            color: #856404;
            margin-bottom: 15px;
        }

        .inline-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #229954;
            transform: translateY(-2px);
        }

        .btn.secondary {
            background: #718096;
        }

        .btn.secondary:hover {
            background: #4a5568;
        }

        .btn.primary {
            background: #2ecc71;
        }

        .btn.primary:hover {
            background: #27ae60;
        }

        .btn.small {
            padding: 6px 12px;
            font-size: 0.9rem;
        }

        .btn.tiny {
            padding: 4px 8px;
            font-size: 0.8rem;
        }

        .btn.danger {
            background: #e74c3c;
        }

        .btn.danger:hover {
            background: #c0392b;
        }

        .btn.warning {
            background: #f39c12;
        }

        .btn.warning:hover {
            background: #e67e22;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #27ae60;
        }

        .form-inline {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .form-inline .form-group {
            flex: 1;
        }

        /* Statistics Styles */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 2.5rem;
            margin-bottom: 5px;
        }

        .stat-card p {
            opacity: 0.9;
        }

        .leaderboard {
            background: #f7fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .leaderboard h3 {
            margin-bottom: 15px;
            color: #2d3748;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .leaderboard-item:nth-child(1) {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border: none;
        }

        .leaderboard-item:nth-child(2) {
            background: linear-gradient(135deg, #c0c0c0, #e8e8e8);
            border: none;
        }

        .leaderboard-item:nth-child(3) {
            background: linear-gradient(135deg, #cd7f32, #daa520);
            border: none;
        }

        .rank {
            font-weight: bold;
            font-size: 1.2rem;
            width: 30px;
        }

        /* Management Styles */
        .management-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .data-grid {
            display: grid;
            gap: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .data-card {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            position: relative;
        }

        .data-card h4 {
            color: #2d3748;
            margin-bottom: 10px;
        }

        .data-card .actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .edit-form {
            background: #fff;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-status {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .toggle-status.valid {
            background: #27ae60;
        }

        .toggle-status.invalid {
            background: #e74c3c;
        }

        .toggle-status:hover {
            transform: scale(1.05);
        }

        .returns-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            background: white;
        }

        .return-item {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            border-left: 3px solid #27ae60;
            font-size: 0.9rem;
        }

        .scans-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            background: white;
        }

        .scan-record {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            border-left: 3px solid #2ecc71;
            font-size: 0.9rem;
        }

        .search-results {
            max-height: 250px;
            overflow-y: auto;
        }

        .search-result-item {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-result-item:hover {
            background-color: #f7fafc;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-info {
            display: flex;
            flex-direction: column;
        }

        .search-result-name {
            font-weight: bold;
            color: #2d3748;
        }

        .search-result-details {
            font-size: 0.9rem;
            color: #718096;
        }

        .undo-redo {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        /* Hide undo/redo buttons when not on scanning tab */
        body:not(.scanning-active) .undo-redo {
            display: none;
        }

        .undo-redo button {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .undo-redo button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #718096;
        }

        .undo-redo button:hover:not(:disabled) {
            transform: scale(1.1);
            background: #229954;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .form-inline {
                flex-direction: column;
            }
            
            .current-person .stats {
                flex-direction: column;
                gap: 15px;
            }

            .data-card .actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body class="scanning-active">
    <div class="focus-indicator focused" id="focusIndicator">üéØ READY TO SCAN</div>
    
    <div class="container">
        <div class="header">
            <h1>Drinks Container Program</h1>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('scanning')">üì± Scanning</button>
            <button class="tab" onclick="switchTab('statistics')">üìä Statistics</button>
            <button class="tab" onclick="switchTab('management')">‚öôÔ∏è Management</button>
        </div>

        <div class="content">
            <!-- Scanning Tab -->
            <div id="scanning" class="tab-content active">
                <div class="scanning-layout">
                    <div class="scanning-top">
                        <div class="scan-status" id="scanStatus" onclick="forceFocus()" style="cursor: pointer;">
                            Ready to scan - Start by scanning a person or container
                        </div>
                        
                        <div class="scan-controls" id="scanControls" style="text-align: center; margin-top: 10px;">
                            <button class="btn small" onclick="showSearchReturner()" id="searchBtn">üîç Search Returner</button>
                            <button class="btn small secondary" onclick="clearCurrentPerson()" style="margin-left: 10px;">üîÑ Clear Session</button>
                        </div>

                        <div class="current-person" id="currentPerson" style="display: none;">
                            <h3>Current Returner</h3>
                            <div class="name">
                                <span id="currentPersonName"></span>
                                <span id="currentPersonHouse" class="house-badge"></span>
                            </div>
                            <div class="stats">
                                <div class="stat">
                                    <div class="stat-value" id="sessionCount">0</div>
                                    <div class="stat-label">This Session</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-value" id="totalCount">0</div>
                                    <div class="stat-label">Total Returns</div>
                                </div>
                            </div>
                        </div>

                        <div class="inline-learn" id="searchReturner" style="display: none;">
                            <h4 id="searchTitle">Search for Returner</h4>
                            <div class="form-group">
                                <input type="text" id="searchInput" placeholder="Type name to search..." 
                                       onkeyup="filterPeople()" style="width: 100%; margin-bottom: 10px;">
                            </div>
                            <div class="search-results" id="searchResults" style="max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; background: white;">
                                <!-- Search results will be populated here -->
                            </div>
                            <div style="margin-top: 15px;">
                                <button class="btn secondary" onclick="cancelSearch()">Cancel</button>
                                <button class="btn warning" onclick="discardPendingContainer()" id="discardBtn" style="display: none; margin-left: 10px;">üóëÔ∏è Discard Container</button>
                            </div>
                        </div>
                        
                        <div class="inline-learn" id="inlineLearn" style="display: none;">
                            <h4>Unknown Barcode: <span id="unknownBarcode"></span></h4>
                            <div class="inline-options">
                                <button class="btn primary" onclick="startLearnPerson()">üë§ Add as Person</button>
                                <button class="btn primary" onclick="startLearnContainer()">üì¶ Add as Container</button>
                                <button class="btn secondary" onclick="cancelLearn()">Cancel</button>
                            </div>
                            <div id="learnForm"></div>
                        </div>
                    </div>

                    <div class="recent-scans-container">
                        <h3 style="margin-bottom: 15px;">Recent Scans</h3>
                        <div class="recent-scans" id="recentScans">
                            <p style="text-align: center; color: #718096; font-style: italic;">No scans yet</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Statistics Tab -->
            <div id="statistics" class="tab-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3 id="totalContainers">0</h3>
                        <p>Total Containers</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="totalPeople">0</h3>
                        <p>Active Participants</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="todayContainers">0</h3>
                        <p>Today's Returns</p>
                    </div>
                </div>

                <div class="leaderboard">
                    <h3>üèÜ House Standings</h3>
                    <div id="houseLeaderboard"></div>
                </div>

                <div class="leaderboard">
                    <h3>üåü Top Returners</h3>
                    <div id="personLeaderboard"></div>
                </div>

                <div class="leaderboard">
                    <h3>üìÖ Daily Statistics</h3>
                    <div id="dailyStats"></div>
                </div>
            </div>

            <!-- Management Tab -->
            <div id="management" class="tab-content">
                <div class="management-controls">
                    <button class="btn" onclick="exportData()">üì§ Export CSV</button>
                    <button class="btn secondary" onclick="document.getElementById('importFile').click()">üì• Import CSV</button>
                    <input type="file" id="importFile" style="display: none;" accept=".csv" onchange="importData(event)">
                    <button class="btn warning" onclick="generateSampleData()">üé≤ Generate Sample Data</button>
                    <button class="btn secondary" onclick="clearData()">üóëÔ∏è Clear All Data</button>
                </div>

                <h3 style="margin-bottom: 15px;">People Database</h3>
                <div class="data-grid" id="peopleGrid"></div>

                <h3 style="margin: 20px 0 15px 0;">Container Database</h3>
                <div class="data-grid" id="containersGrid"></div>
            </div>
        </div>
    </div>

    <div class="undo-redo">
        <button id="undoBtn" onclick="performUndo()" title="Undo" disabled>‚Ü∂</button>
        <button id="redoBtn" onclick="performRedo()" title="Redo" disabled>‚Ü∑</button>
    </div>

    <audio id="beepSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+D..." type="audio/wav">
    </audio>

    <script>
        // Global state
        let people = new Map(); // barcode -> {forename, surname, house, returns: [{containerId, timestamp}]}
        let containers = new Map(); // barcode -> {description, valid, scans: [{timestamp, personId}]}
        let currentPerson = null;
        let sessionReturns = new Map(); // personId -> count for this session
        let pendingContainerScan = null; // NEW: Track container waiting for person assignment
        let scanBuffer = '';
        let scanTimeout = null;
        let unknownBarcode = null;
        let idleTimer = null;
        let focusCheckInterval = null;
        let hasFocus = true;
        const IDLE_TIMEOUT = 60000; // 1 minute
        
        // Undo/Redo system
        let actionHistory = [];
        let historyIndex = -1;
        const MAX_HISTORY = 100;

        // Initialize
        function init() {
            loadData();
            updateStatistics();
            updateUndoRedoButtons();
            
            // Set up barcode scanning
            document.addEventListener('keydown', handleKeyDown);
            
            // Set up visibility change handler to save data
            document.addEventListener('visibilitychange', saveData);
            window.addEventListener('beforeunload', saveData);
            
            // Initialize scan status with search button
            updateScanStatus('Ready to scan - Start by scanning a person or container');
            
            // Set up focus management
            setupFocusManagement();
        }

        // Focus management system
        function setupFocusManagement() {
            // Make body focusable
            document.body.setAttribute('tabindex', '-1');
            
            // Initial focus
            document.body.focus();
            
            // Focus check interval
            focusCheckInterval = setInterval(checkFocus, 500);
            
            // Focus event listeners
            window.addEventListener('focus', handleWindowFocus);
            window.addEventListener('blur', handleWindowBlur);
            document.addEventListener('click', handleDocumentClick);
            
            // Prevent input fields from stealing focus during scanning
            document.addEventListener('focusin', handleFocusIn);
        }

        function checkFocus() {
            const currentlyHasFocus = document.hasFocus();
            if (currentlyHasFocus !== hasFocus) {
                hasFocus = currentlyHasFocus;
                updateFocusIndicator();
            }
        }

        function handleWindowFocus() {
            hasFocus = true;
            updateFocusIndicator();
            document.body.focus();
            
            // Restore normal status if it was showing focus warning
            if (document.getElementById('scanStatus').textContent.includes('Click here to resume')) {
                if (pendingContainerScan) {
                    const container = containers.get(pendingContainerScan);
                    updateScanStatus(`Container "${container ? container.description : 'Unknown'}" needs assignment - Please scan a person or search`);
                } else {
                    updateScanStatus('Ready to scan - Focus restored');
                }
            }
        }

        function handleWindowBlur() {
            hasFocus = false;
            updateFocusIndicator();
            updateScanStatus('‚ö†Ô∏è App lost focus - Click here to resume scanning');
        }

        function handleDocumentClick(event) {
            // Return focus to body unless clicking on an input that needs it
            if (!event.target.matches('input[type="text"], textarea, select')) {
                setTimeout(() => {
                    document.body.focus();
                }, 10);
            }
        }

        function handleFocusIn(event) {
            // If focus goes to an input while we're in scanning mode, blur it after a delay
            if (event.target.matches('input[type="text"], textarea')) {
                // Only blur if not in search or edit mode
                const isSearchOpen = document.getElementById('searchReturner').style.display !== 'none';
                const isInlineLearnOpen = document.getElementById('inlineLearn').style.display !== 'none';
                const isInEditMode = document.querySelector('.edit-form') !== null;
                
                if (!isSearchOpen && !isInlineLearnOpen && !isInEditMode) {
                    setTimeout(() => {
                        event.target.blur();
                        document.body.focus();
                    }, 100);
                }
            }
        }

        function updateFocusIndicator() {
            const indicator = document.getElementById('focusIndicator');
            const body = document.body;
            
            if (hasFocus) {
                indicator.className = 'focus-indicator focused';
                indicator.textContent = 'üéØ READY TO SCAN';
                body.classList.remove('focus-lost');
            } else {
                indicator.className = 'focus-indicator lost-focus';
                indicator.textContent = '‚ö†Ô∏è CLICK TO ACTIVATE';
                body.classList.add('focus-lost');
            }
        }

        function forceFocus() {
            document.body.focus();
            handleWindowFocus();
        }

        function loadData() {
            try {
                // Load from localStorage
                const savedPeople = localStorage.getItem('drinksPeople');
                const savedContainers = localStorage.getItem('drinksContainers');
                
                if (savedPeople) {
                    const peopleData = JSON.parse(savedPeople);
                    people = new Map(peopleData);
                }
                
                if (savedContainers) {
                    const containersData = JSON.parse(savedContainers);
                    containers = new Map(containersData);
                }
                
                // If no data exists, load placeholder
                if (people.size === 0 && containers.size === 0) {
                    loadPlaceholderData();
                }
            } catch (error) {
                console.error('Error loading data:', error);
                loadPlaceholderData();
            }
        }

        function saveData() {
            try {
                localStorage.setItem('drinksPeople', JSON.stringify(Array.from(people.entries())));
                localStorage.setItem('drinksContainers', JSON.stringify(Array.from(containers.entries())));
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }

        function loadPlaceholderData() {
            // Single placeholder container for drinks
            containers.set('5449000000996', {
                description: 'Sample Coca-Cola Can 330ml',
                valid: true,
                scans: []
            });
        }

        // Auto-timeout functionality
        function resetIdleTimer() {
            if (idleTimer) {
                clearTimeout(idleTimer);
            }
            
            if (currentPerson) {
                idleTimer = setTimeout(() => {
                    clearCurrentPerson();
                }, IDLE_TIMEOUT);
            }
        }

        function clearCurrentPerson() {
            currentPerson = null;
            sessionReturns.clear();
            
            // Close any open panels
            document.getElementById('searchReturner').style.display = 'none';
            document.getElementById('inlineLearn').style.display = 'none';
            document.getElementById('searchInput').value = '';
            
            // Clear pending container state
            pendingContainerScan = null;
            
            document.getElementById('currentPerson').style.display = 'none';
            document.getElementById('recentScans').innerHTML = 
                '<p style="text-align: center; color: #718096; font-style: italic;">No scans yet</p>';
            
            updateScanStatus('Ready to scan - Start by scanning a person or container');
            
            if (idleTimer) {
                clearTimeout(idleTimer);
                idleTimer = null;
            }
            
            // Return focus to body for scanning
            setTimeout(() => {
                document.body.focus();
            }, 100);
        }

        // Input validation functions
        function validateBarcode(barcode) {
            return barcode && typeof barcode === 'string' && barcode.trim().length > 0;
        }

        function validatePersonData(forename, surname, house) {
            const validHouses = ['Yellow', 'Green', 'Blue', 'Red'];
            return forename && forename.trim().length > 0 &&
                   surname && surname.trim().length > 0 &&
                   validHouses.includes(house);
        }

        function validateContainerData(description) {
            return description && description.trim().length > 0;
        }

        // Barcode scanning with improved error handling and scanner key filtering
        function handleKeyDown(event) {
            // Only process if scanning tab is active
            if (!document.getElementById('scanning').classList.contains('active')) {
                return;
            }

            // Define keys that barcode scanners commonly send that we should filter out
            const scannerControlKeys = [
                'Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                'Home', 'End', 'PageUp', 'PageDown', 'Insert', 'Delete',
                'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
                'Escape', 'Backspace', 'Control', 'Alt', 'Shift', 'Meta',
                'CapsLock', 'NumLock', 'ScrollLock', 'Pause', 'PrintScreen'
            ];

            // Check if this is a scanner control key that should be filtered
            const isScannerControlKey = scannerControlKeys.includes(event.key) || 
                                       event.ctrlKey || event.altKey || event.metaKey;

            // Ignore if typing in input and we're in a legitimate input context
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                const isSearchOpen = document.getElementById('searchReturner').style.display !== 'none';
                const isInlineLearnOpen = document.getElementById('inlineLearn').style.display !== 'none';
                const isInEditMode = document.querySelector('.edit-form') !== null;
                
                // Only allow input if we're in a legitimate input context
                if (isSearchOpen || isInlineLearnOpen || isInEditMode) {
                    // Still prevent scanner control keys from affecting inputs
                    if (isScannerControlKey && event.key !== 'Backspace') {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    return;
                }
                
                // Otherwise, take focus back and process as scan
                event.target.blur();
                document.body.focus();
                
                // Prevent the key from affecting the blurred element
                if (isScannerControlKey) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }

            // Filter out scanner control keys from normal processing
            if (isScannerControlKey && event.key !== 'Enter') {
                event.preventDefault();
                event.stopPropagation();
                
                // Force focus back to body if focus moved
                if (document.activeElement !== document.body) {
                    document.body.focus();
                }
                return;
            }

            // Ensure we have focus for scanning
            if (!document.hasFocus()) {
                return;
            }

            if (scanTimeout) {
                clearTimeout(scanTimeout);
            }

            if (event.key === 'Enter' && scanBuffer.length > 0) {
                event.preventDefault();
                event.stopPropagation();
                processScan(scanBuffer.trim());
                scanBuffer = '';
                return;
            }

            // Only accept printable characters and digits for scanning
            if (event.key.length === 1 && !event.ctrlKey && !event.altKey && !event.metaKey) {
                // Additional validation - only accept alphanumeric and basic symbols
                const isValidScanChar = /^[a-zA-Z0-9\-_=+*#@!$%&]$/.test(event.key);
                
                if (isValidScanChar) {
                    event.preventDefault(); // Prevent any default behavior
                    scanBuffer += event.key;
                    updateScanStatus('Scanning...');
                }
            }

            scanTimeout = setTimeout(() => {
                if (scanBuffer.length > 0) {
                    processScan(scanBuffer.trim());
                }
                scanBuffer = '';
            }, 500);
        }

        function processScan(barcode) {
            if (!validateBarcode(barcode)) {
                updateScanStatus('Invalid barcode format');
                return;
            }
            
            playBeep();
            resetIdleTimer();
            
            // Check if it's a known person
            if (people.has(barcode)) {
                recordAction('scanPerson', { barcode });
                handlePersonScan(barcode);
                return;
            }
            
            // Check if it's a known container
            if (containers.has(barcode)) {
                recordAction('scanContainer', { barcode, personId: currentPerson });
                handleContainerScan(barcode);
                return;
            }
            
            // Unknown barcode
            handleUnknownScan(barcode);
        }

        function handlePersonScan(barcode) {
            try {
                const person = people.get(barcode);
                if (!person) {
                    updateScanStatus('Person data not found');
                    return;
                }
                
                currentPerson = barcode;
                
                // Initialize session count if needed
                if (!sessionReturns.has(barcode)) {
                    sessionReturns.set(barcode, 0);
                }
                
                // Update UI
                document.getElementById('currentPerson').style.display = 'block';
                document.getElementById('currentPersonName').textContent = `${person.forename} ${person.surname}`;
                
                const houseElement = document.getElementById('currentPersonHouse');
                houseElement.textContent = person.house;
                houseElement.className = `house-badge house-${person.house.toLowerCase()}`;
                
                document.getElementById('sessionCount').textContent = sessionReturns.get(barcode);
                document.getElementById('totalCount').textContent = person.returns ? person.returns.length : 0;
                
                updateScanStatus(`Scanning for ${person.forename} ${person.surname} - Ready for containers`);
                addRecentScan('person', `${person.forename} ${person.surname}`, person.house);
                resetIdleTimer();

                // NEW: Process pending container if there is one
                if (pendingContainerScan) {
                    setTimeout(() => {
                        recordAction('assignPendingContainer', {
                            containerBarcode: pendingContainerScan,
                            personBarcode: barcode
                        });
                        processContainerScanWithPerson(pendingContainerScan, barcode);
                        pendingContainerScan = null;
                        updateScanStatusForNormalOperation();
                    }, 500);
                }
            } catch (error) {
                console.error('Error handling person scan:', error);
                updateScanStatus('Error processing person scan');
            }
        }

        function handleContainerScan(barcode) {
            try {
                const container = containers.get(barcode);
                
                if (!container) {
                    updateScanStatus('Container data not found');
                    return;
                }

                // Initialize scans array if needed
                if (!container.scans) {
                    container.scans = [];
                }

                // NEW: Check if we have a current person
                if (!currentPerson) {
                    // No current person - set as pending and prompt for assignment
                    pendingContainerScan = barcode;
                    
                    // Record the scan but mark it as pending
                    const scanRecord = {
                        timestamp: new Date().toISOString(),
                        personId: null, // Will be updated when assigned
                        pending: true
                    };
                    container.scans.push(scanRecord);
                    
                    // Update UI for pending state
                    updateScanStatusPending(container.description);
                    addRecentScan('pending', container.description, 'Awaiting person assignment...');
                    
                    // Automatically show search interface
                    setTimeout(() => {
                        showSearchReturner();
                    }, 1000);
                    
                    return;
                }

                // Process normally with current person
                processContainerScanWithPerson(barcode, currentPerson);
                
            } catch (error) {
                console.error('Error handling container scan:', error);
                updateScanStatus('Error processing container scan');
            }
        }

        // NEW: Process container scan with assigned person
        function processContainerScanWithPerson(containerBarcode, personBarcode) {
            try {
                const container = containers.get(containerBarcode);
                const person = people.get(personBarcode);
                
                if (!container || !person) {
                    updateScanStatus('Error: Container or person not found');
                    return;
                }

                // Initialize arrays if needed
                if (!container.scans) container.scans = [];
                if (!person.returns) person.returns = [];

                // Update or add the scan record
                let scanRecord = container.scans.find(scan => 
                    scan.pending && Math.abs(new Date(scan.timestamp) - new Date()) < 30000 // Within 30 seconds
                );
                
                if (scanRecord) {
                    // Update existing pending scan
                    scanRecord.personId = personBarcode;
                    delete scanRecord.pending;
                } else {
                    // Add new scan record
                    scanRecord = {
                        timestamp: new Date().toISOString(),
                        personId: personBarcode
                    };
                    container.scans.push(scanRecord);
                }
                
                if (container.valid) {
                    // Add to person's returns
                    person.returns.push({
                        containerId: containerBarcode,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Update session count
                    sessionReturns.set(personBarcode, (sessionReturns.get(personBarcode) || 0) + 1);
                    
                    // Update UI
                    if (currentPerson === personBarcode) {
                        document.getElementById('sessionCount').textContent = sessionReturns.get(personBarcode);
                        document.getElementById('totalCount').textContent = person.returns.length;
                    }
                    
                    updateScanStatus(`‚úÖ Assigned: ${container.description} ‚Üí ${person.forename} ${person.surname}`);
                    addRecentScan('container', container.description, `${person.forename} ${person.surname} - Valid`);
                    updateStatistics();
                } else {
                    updateScanStatus(`‚ùå Invalid container: ${container.description}`);
                    addRecentScan('invalid', container.description, `${person.forename} ${person.surname} - Invalid`);
                }
                
                saveData();
                resetIdleTimer();
            } catch (error) {
                console.error('Error processing container scan with person:', error);
                updateScanStatus('Error processing container assignment');
            }
        }

        function handleUnknownScan(barcode) {
            unknownBarcode = barcode;
            document.getElementById('unknownBarcode').textContent = barcode;
            document.getElementById('inlineLearn').style.display = 'block';
            updateScanStatus('Unknown barcode - please classify');
        }

        function startLearnPerson() {
            const form = document.getElementById('learnForm');
            form.innerHTML = `
                <div class="form-inline">
                    <div class="form-group">
                        <label>Forename</label>
                        <input type="text" id="learnForename" placeholder="First name" maxlength="50">
                    </div>
                    <div class="form-group">
                        <label>Surname</label>
                        <input type="text" id="learnSurname" placeholder="Last name" maxlength="50">
                    </div>
                    <div class="form-group">
                        <label>House</label>
                        <select id="learnHouse">
                            <option value="Yellow">Yellow</option>
                            <option value="Green">Green</option>
                            <option value="Blue">Blue</option>
                            <option value="Red">Red</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>&nbsp;</label>
                        <button class="btn" onclick="savePerson()">Save Person</button>
                    </div>
                </div>
            `;
            
            // Focus and set up enter key handler
            const forenameInput = document.getElementById('learnForename');
            forenameInput.focus();
            
            // Add enter key handlers
            ['learnForename', 'learnSurname'].forEach(id => {
                document.getElementById(id).addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        savePerson();
                    }
                });
            });
        }

        function startLearnContainer() {
            const form = document.getElementById('learnForm');
            form.innerHTML = `
                <div class="form-inline">
                    <div class="form-group" style="flex: 2;">
                        <label>Description</label>
                        <input type="text" id="learnDescription" placeholder="e.g., Coca-Cola Can 330ml" maxlength="100">
                    </div>
                    <div class="form-group">
                        <label>&nbsp;</label>
                        <div class="checkbox-label">
                            <input type="checkbox" id="learnValid" checked>
                            <label for="learnValid">Valid Container</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>&nbsp;</label>
                        <button class="btn" onclick="saveContainer()">Save Container</button>
                    </div>
                </div>
            `;
            
            const descInput = document.getElementById('learnDescription');
            descInput.focus();
            
            descInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveContainer();
                }
            });
        }

        function savePerson() {
            try {
                const forename = document.getElementById('learnForename').value.trim();
                const surname = document.getElementById('learnSurname').value.trim();
                const house = document.getElementById('learnHouse').value;
                
                if (!validatePersonData(forename, surname, house)) {
                    alert('Please enter valid forename and surname');
                    return;
                }
                
                if (!unknownBarcode) {
                    alert('No barcode to save');
                    return;
                }
                
                const personData = {
                    forename,
                    surname,
                    house,
                    returns: []
                };
                
                recordAction('addPerson', {
                    barcode: unknownBarcode,
                    data: personData
                });
                
                people.set(unknownBarcode, personData);
                
                // Store the barcode before canceling
                const barcodeToScan = unknownBarcode;
                
                cancelLearn();
                handlePersonScan(barcodeToScan);
                updateManagementView();
                saveData();
            } catch (error) {
                console.error('Error saving person:', error);
                alert('Error saving person data');
            }
        }

        function saveContainer() {
            try {
                const description = document.getElementById('learnDescription').value.trim();
                const valid = document.getElementById('learnValid').checked;
                
                if (!validateContainerData(description)) {
                    alert('Please enter a valid description');
                    return;
                }
                
                if (!unknownBarcode) {
                    alert('No barcode to save');
                    return;
                }
                
                const containerData = {
                    description,
                    valid,
                    scans: []
                };
                
                recordAction('addContainer', {
                    barcode: unknownBarcode,
                    data: containerData
                });
                
                containers.set(unknownBarcode, containerData);
                
                // Store the barcode before canceling
                const barcodeToScan = unknownBarcode;
                
                cancelLearn();
                handleContainerScan(barcodeToScan);
                updateManagementView();
                saveData();
            } catch (error) {
                console.error('Error saving container:', error);
                alert('Error saving container data');
            }
        }

        function cancelLearn() {
            document.getElementById('inlineLearn').style.display = 'none';
            document.getElementById('learnForm').innerHTML = '';
            unknownBarcode = null;
            
            updateScanStatusForNormalOperation();
        }

        // NEW: Helper function to update scan status for normal operation
        function updateScanStatusForNormalOperation() {
            let statusMessage;
            
            if (pendingContainerScan) {
                const container = containers.get(pendingContainerScan);
                statusMessage = `Container "${container ? container.description : 'Unknown'}" needs assignment - Please scan a person or search`;
                updateScanStatusPending(container ? container.description : 'Unknown Container');
            } else if (currentPerson && people.has(currentPerson)) {
                const person = people.get(currentPerson);
                statusMessage = `Scanning for ${person.forename} ${person.surname} - Ready for containers`;
                updateScanStatus(statusMessage);
            } else {
                statusMessage = 'Ready to scan - Start by scanning a person or container';
                updateScanStatus(statusMessage);
            }
        }

        // NEW: Update scan status for pending container
        function updateScanStatusPending(containerDescription) {
            const statusElement = document.getElementById('scanStatus');
            statusElement.textContent = `Container "${containerDescription}" needs assignment - Please scan a person or search`;
            statusElement.classList.add('pending');
        }

        function addRecentScan(type, name, extra) {
            try {
                const recentScans = document.getElementById('recentScans');
                
                if (recentScans.firstChild && recentScans.firstChild.tagName === 'P') {
                    recentScans.innerHTML = '';
                }
                
                const scanItem = document.createElement('div');
                scanItem.className = `scan-item ${type}`;
                scanItem.innerHTML = `
                    <div>
                        <strong>${escapeHtml(name)}</strong>
                        <div style="font-size: 0.8rem; color: #718096;">${new Date().toLocaleTimeString()}</div>
                    </div>
                    <div>${escapeHtml(extra)}</div>
                `;
                
                recentScans.insertBefore(scanItem, recentScans.firstChild);
                
                // Keep only last 20 scans
                while (recentScans.children.length > 20) {
                    recentScans.removeChild(recentScans.lastChild);
                }
            } catch (error) {
                console.error('Error adding recent scan:', error);
            }
        }

        // Enhanced search functionality
        function showSearchReturner() {
            const searchTitle = document.getElementById('searchTitle');
            const discardBtn = document.getElementById('discardBtn');
            
            if (pendingContainerScan) {
                const container = containers.get(pendingContainerScan);
                const containerName = container ? container.description : 'Container';
                searchTitle.textContent = `Assign "${containerName}" to:`;
                discardBtn.style.display = 'inline-block';
            } else {
                searchTitle.textContent = 'Search for Returner';
                discardBtn.style.display = 'none';
            }
            
            document.getElementById('searchReturner').style.display = 'block';
            document.getElementById('searchInput').focus();
            filterPeople();
        }

        function cancelSearch() {
            document.getElementById('searchReturner').style.display = 'none';
            document.getElementById('searchInput').value = '';
            
            // Return focus to body for scanning
            setTimeout(() => {
                document.body.focus();
            }, 100);
        }

        // NEW: Discard pending container
        function discardPendingContainer() {
            if (pendingContainerScan) {
                const container = containers.get(pendingContainerScan);
                const containerName = container ? container.description : 'Container';
                
                // Remove the pending scan from container's scan history
                if (container && container.scans.length > 0) {
                    const lastScan = container.scans[container.scans.length - 1];
                    if (lastScan.pending) {
                        container.scans.pop();
                    }
                }
                
                updateScanStatus(`‚ùå Discarded: ${containerName} scan cancelled`);
                addRecentScan('invalid', containerName, 'Scan discarded');
                
                pendingContainerScan = null;
                saveData();
            }
            
            cancelSearch();
        }

        function filterPeople() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const resultsContainer = document.getElementById('searchResults');
            
            if (people.size === 0) {
                resultsContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #718096;">No people registered yet</p>';
                return;
            }

            const filteredPeople = Array.from(people.entries()).filter(([barcode, person]) => {
                const fullName = `${person.forename} ${person.surname}`.toLowerCase();
                const house = person.house.toLowerCase();
                return fullName.includes(searchTerm) || 
                       person.forename.toLowerCase().includes(searchTerm) ||
                       person.surname.toLowerCase().includes(searchTerm) ||
                       house.includes(searchTerm) ||
                       barcode.includes(searchTerm);
            });

            if (filteredPeople.length === 0) {
                resultsContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #718096;">No matching people found</p>';
                return;
            }

            resultsContainer.innerHTML = filteredPeople.map(([barcode, person]) => {
                const validReturns = person.returns ? person.returns.filter(ret => 
                    containers.has(ret.containerId) && containers.get(ret.containerId).valid
                ).length : 0;

                return `
                    <div class="search-result-item" onclick="selectPersonFromSearch('${barcode}')">
                        <div class="search-result-info">
                            <div class="search-result-name">${escapeHtml(person.forename)} ${escapeHtml(person.surname)}</div>
                            <div class="search-result-details">
                                ${escapeHtml(person.house)} House ‚Ä¢ ${validReturns} returns ‚Ä¢ Barcode: ${escapeHtml(barcode)}
                            </div>
                        </div>
                        <span class="house-badge house-${person.house.toLowerCase()}">${escapeHtml(person.house)}</span>
                    </div>
                `;
            }).join('');
        }

        function selectPersonFromSearch(barcode) {
            const wasPendingScan = pendingContainerScan;
            
            cancelSearch();
            handlePersonScan(barcode);
            recordAction('scanPerson', { barcode });
            
            // If there was a pending container scan, it will be processed automatically in handlePersonScan
        }

        // Inline editing functions
        function editPerson(barcode) {
            const person = people.get(barcode);
            if (!person) return;

            const card = document.querySelector(`[data-person="${barcode}"]`);
            if (!card) return;

            const editForm = document.createElement('div');
            editForm.className = 'edit-form';
            editForm.innerHTML = `
                <div class="form-group">
                    <label>Forename</label>
                    <input type="text" id="edit-forename-${barcode}" value="${escapeHtml(person.forename)}" maxlength="50">
                </div>
                <div class="form-group">
                    <label>Surname</label>
                    <input type="text" id="edit-surname-${barcode}" value="${escapeHtml(person.surname)}" maxlength="50">
                </div>
                <div class="form-group">
                    <label>House</label>
                    <select id="edit-house-${barcode}">
                        <option value="Yellow" ${person.house === 'Yellow' ? 'selected' : ''}>Yellow</option>
                        <option value="Green" ${person.house === 'Green' ? 'selected' : ''}>Green</option>
                        <option value="Blue" ${person.house === 'Blue' ? 'selected' : ''}>Blue</option>
                        <option value="Red" ${person.house === 'Red' ? 'selected' : ''}>Red</option>
                    </select>
                </div>
                <div class="actions">
                    <button class="btn small" onclick="savePersonEdit('${barcode}')">Save</button>
                    <button class="btn small secondary" onclick="cancelPersonEdit('${barcode}')">Cancel</button>
                </div>
            `;

            card.appendChild(editForm);
            document.getElementById(`edit-forename-${barcode}`).focus();
        }

        function savePersonEdit(barcode) {
            try {
                const forename = document.getElementById(`edit-forename-${barcode}`).value.trim();
                const surname = document.getElementById(`edit-surname-${barcode}`).value.trim();
                const house = document.getElementById(`edit-house-${barcode}`).value;

                if (!validatePersonData(forename, surname, house)) {
                    alert('Please enter valid data');
                    return;
                }

                const person = people.get(barcode);
                if (person) {
                    recordAction('editPerson', {
                        barcode,
                        oldData: { ...person },
                        newData: { forename, surname, house }
                    });

                    person.forename = forename;
                    person.surname = surname;
                    person.house = house;

                    updateManagementView();
                    updateStatistics();
                    saveData();
                }
            } catch (error) {
                console.error('Error saving person edit:', error);
                alert('Error saving changes');
            }
        }

        function cancelPersonEdit(barcode) {
            const card = document.querySelector(`[data-person="${barcode}"]`);
            if (card) {
                const editForm = card.querySelector('.edit-form');
                if (editForm) {
                    editForm.remove();
                }
            }
        }

        function editContainer(barcode) {
            const container = containers.get(barcode);
            if (!container) return;

            const card = document.querySelector(`[data-container="${barcode}"]`);
            if (!card) return;

            const editForm = document.createElement('div');
            editForm.className = 'edit-form';
            editForm.innerHTML = `
                <div class="form-group">
                    <label>Description</label>
                    <input type="text" id="edit-description-${barcode}" value="${escapeHtml(container.description)}" maxlength="100">
                </div>
                <div class="actions">
                    <button class="btn small" onclick="saveContainerEdit('${barcode}')">Save</button>
                    <button class="btn small secondary" onclick="cancelContainerEdit('${barcode}')">Cancel</button>
                </div>
            `;

            card.appendChild(editForm);
            document.getElementById(`edit-description-${barcode}`).focus();
        }

        function saveContainerEdit(barcode) {
            try {
                const description = document.getElementById(`edit-description-${barcode}`).value.trim();

                if (!validateContainerData(description)) {
                    alert('Please enter valid description');
                    return;
                }

                const container = containers.get(barcode);
                if (container) {
                    recordAction('editContainer', {
                        barcode,
                        oldData: { ...container },
                        newData: { description }
                    });

                    container.description = description;

                    updateManagementView();
                    saveData();
                }
            } catch (error) {
                console.error('Error saving container edit:', error);
                alert('Error saving changes');
            }
        }

        function cancelContainerEdit(barcode) {
            const card = document.querySelector(`[data-container="${barcode}"]`);
            if (card) {
                const editForm = card.querySelector('.edit-form');
                if (editForm) {
                    editForm.remove();
                }
            }
        }

        function toggleContainerStatus(barcode) {
            try {
                const container = containers.get(barcode);
                if (container) {
                    recordAction('toggleStatus', {
                        barcode,
                        oldStatus: container.valid
                    });

                    container.valid = !container.valid;
                    updateManagementView();
                    updateStatistics();
                    saveData();
                }
            } catch (error) {
                console.error('Error toggling container status:', error);
            }
        }

        function viewPersonReturns(barcode) {
            const person = people.get(barcode);
            if (!person || !person.returns) return;

            const card = document.querySelector(`[data-person="${barcode}"]`);
            if (!card) return;

            // Check if returns list already exists
            let returnsList = card.querySelector('.returns-list');
            if (returnsList) {
                returnsList.remove();
                return;
            }

            returnsList = document.createElement('div');
            returnsList.className = 'returns-list';
            returnsList.innerHTML = `
                <h5>Container Returns (${person.returns.length})</h5>
                ${person.returns.map(ret => {
                    const container = containers.get(ret.containerId);
                    const containerName = container ? container.description : 'Unknown Container';
                    return `
                        <div class="return-item">
                            <strong>${escapeHtml(containerName)}</strong><br>
                            <small>${new Date(ret.timestamp).toLocaleString()}</small>
                        </div>
                    `;
                }).join('')}
            `;

            card.appendChild(returnsList);
        }

        function viewContainerScans(barcode) {
            const container = containers.get(barcode);
            if (!container) return;

            // Initialize scans array if needed
            if (!container.scans) {
                container.scans = [];
            }

            const card = document.querySelector(`[data-container="${barcode}"]`);
            if (!card) return;

            // Check if scans list already exists
            let scansList = card.querySelector('.scans-list');
            if (scansList) {
                scansList.remove();
                return;
            }

            scansList = document.createElement('div');
            scansList.className = 'scans-list';
            scansList.innerHTML = `
                <h5>Scan History (${container.scans.length})</h5>
                ${container.scans.length > 0 ? container.scans.map(scan => {
                    const person = scan.personId ? people.get(scan.personId) : null;
                    const personName = person ? `${person.forename} ${person.surname}` : (scan.pending ? 'Pending assignment' : 'No person selected');
                    const statusClass = scan.pending ? 'pending' : '';
                    return `
                        <div class="scan-record ${statusClass}">
                            <strong>${escapeHtml(personName)}</strong><br>
                            <small>${new Date(scan.timestamp).toLocaleString()}</small>
                        </div>
                    `;
                }).join('') : '<p style="text-align: center; color: #718096;">No scans yet</p>'}
            `;

            card.appendChild(scansList);
        }

        // Delete functionality
        function deletePerson(barcode) {
            const person = people.get(barcode);
            if (!person) return;

            const returnCount = person.returns ? person.returns.length : 0;
            const confirmMessage = `Are you sure you want to delete ${person.forename} ${person.surname}?\n\nThis will permanently remove:\n‚Ä¢ Their profile\n‚Ä¢ ${returnCount} return records\n\nThis action cannot be undone.`;
            
            if (confirm(confirmMessage)) {
                try {
                    recordAction('deletePerson', {
                        barcode,
                        data: { ...person }
                    });

                    people.delete(barcode);
                    
                    // Clear current person if they were selected
                    if (currentPerson === barcode) {
                        clearCurrentPerson();
                    }

                    updateStatistics();
                    updateManagementView();
                    saveData();
                } catch (error) {
                    console.error('Error deleting person:', error);
                    alert('Error deleting person');
                }
            }
        }

        function deleteContainer(barcode) {
            const container = containers.get(barcode);
            if (!container) return;

            const scanCount = container.scans ? container.scans.length : 0;
            let usageCount = 0;
            
            // Count how many times this container was returned
            people.forEach(person => {
                if (person.returns) {
                    usageCount += person.returns.filter(ret => ret.containerId === barcode).length;
                }
            });

            const confirmMessage = `Are you sure you want to delete "${container.description}"?\n\nThis will permanently remove:\n‚Ä¢ The container definition\n‚Ä¢ ${scanCount} scan records\n‚Ä¢ ${usageCount} return records from people's histories\n\nThis action cannot be undone.`;
            
            if (confirm(confirmMessage)) {
                try {
                    recordAction('deleteContainer', {
                        barcode,
                        data: { ...container },
                        affectedReturns: []
                    });

                    // Remove container references from people's returns
                    people.forEach(person => {
                        if (person.returns) {
                            const originalLength = person.returns.length;
                            person.returns = person.returns.filter(ret => ret.containerId !== barcode);
                            if (person.returns.length < originalLength) {
                                // Store affected returns for undo functionality
                                const lastAction = actionHistory[actionHistory.length - 1];
                                if (lastAction && lastAction.type === 'deleteContainer') {
                                    lastAction.data.affectedReturns.push({
                                        personBarcode: Array.from(people.entries()).find(([_, p]) => p === person)[0],
                                        removedReturns: originalLength - person.returns.length
                                    });
                                }
                            }
                        }
                    });

                    containers.delete(barcode);
                    
                    updateStatistics();
                    updateManagementView();
                    saveData();
                } catch (error) {
                    console.error('Error deleting container:', error);
                    alert('Error deleting container');
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateScanStatus(message) {
            try {
                const statusElement = document.getElementById('scanStatus');
                statusElement.textContent = message;
                statusElement.classList.remove('pending'); // Remove pending class for normal status
            } catch (error) {
                console.error('Error updating scan status:', error);
            }
        }

        function playBeep() {
            try {
                const audio = document.getElementById('beepSound');
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(() => {});
                }
            } catch (error) {
                // Silent fail for audio
            }
        }

        // Statistics functions with error handling
        function updateStatistics() {
            try {
                // Total containers (valid only)
                let totalContainers = 0;
                people.forEach(person => {
                    if (person.returns) {
                        person.returns.forEach(ret => {
                            if (containers.has(ret.containerId) && containers.get(ret.containerId).valid) {
                                totalContainers++;
                            }
                        });
                    }
                });
                document.getElementById('totalContainers').textContent = totalContainers;
                
                // Total people
                document.getElementById('totalPeople').textContent = people.size;
                
                // Today's returns
                const today = new Date().toDateString();
                let todayCount = 0;
                people.forEach(person => {
                    if (person.returns) {
                        person.returns.forEach(ret => {
                            if (new Date(ret.timestamp).toDateString() === today && 
                                containers.has(ret.containerId) && 
                                containers.get(ret.containerId).valid) {
                                todayCount++;
                            }
                        });
                    }
                });
                document.getElementById('todayContainers').textContent = todayCount;
                
                // Update leaderboards
                updateHouseLeaderboard();
                updatePersonLeaderboard();
                updateDailyStats();
            } catch (error) {
                console.error('Error updating statistics:', error);
            }
        }

        function updateHouseLeaderboard() {
            try {
                const houses = { Yellow: 0, Green: 0, Blue: 0, Red: 0 };
                
                people.forEach(person => {
                    if (person.returns) {
                        const validReturns = person.returns.filter(ret => 
                            containers.has(ret.containerId) && containers.get(ret.containerId).valid
                        ).length;
                        if (houses.hasOwnProperty(person.house)) {
                            houses[person.house] += validReturns;
                        }
                    }
                });
                
                const sorted = Object.entries(houses)
                    .sort((a, b) => b[1] - a[1])
                    .filter(([_, count]) => count > 0);
                
                const leaderboard = document.getElementById('houseLeaderboard');
                if (sorted.length > 0) {
                    leaderboard.innerHTML = sorted.map((item, index) => `
                        <div class="leaderboard-item">
                            <div>
                                <span class="rank">#${index + 1}</span>
                                <span>${escapeHtml(item[0])}</span>
                            </div>
                            <strong>${item[1]} containers</strong>
                        </div>
                    `).join('');
                } else {
                    leaderboard.innerHTML = '<p style="text-align: center; color: #718096;">No returns yet</p>';
                }
            } catch (error) {
                console.error('Error updating house leaderboard:', error);
            }
        }

        function updatePersonLeaderboard() {
            try {
                const personStats = [];
                
                people.forEach((person, barcode) => {
                    if (person.returns) {
                        const validReturns = person.returns.filter(ret => 
                            containers.has(ret.containerId) && containers.get(ret.containerId).valid
                        ).length;
                        
                        if (validReturns > 0) {
                            personStats.push({
                                name: `${person.forename} ${person.surname}`,
                                house: person.house,
                                count: validReturns
                            });
                        }
                    }
                });
                
                personStats.sort((a, b) => b.count - a.count);
                
                const leaderboard = document.getElementById('personLeaderboard');
                if (personStats.length > 0) {
                    leaderboard.innerHTML = personStats.slice(0, 10).map((person, index) => `
                        <div class="leaderboard-item">
                            <div>
                                <span class="rank">#${index + 1}</span>
                                <span>${escapeHtml(person.name)}</span>
                                <span class="house-badge house-${person.house.toLowerCase()}">${escapeHtml(person.house)}</span>
                            </div>
                            <strong>${person.count} containers</strong>
                        </div>
                    `).join('');
                } else {
                    leaderboard.innerHTML = '<p style="text-align: center; color: #718096;">No returns yet</p>';
                }
            } catch (error) {
                console.error('Error updating person leaderboard:', error);
            }
        }

        function updateDailyStats() {
            try {
                const dailyStats = new Map();
                
                people.forEach(person => {
                    if (person.returns) {
                        person.returns.forEach(ret => {
                            if (containers.has(ret.containerId) && containers.get(ret.containerId).valid) {
                                const date = new Date(ret.timestamp).toLocaleDateString();
                                dailyStats.set(date, (dailyStats.get(date) || 0) + 1);
                            }
                        });
                    }
                });
                
                const sorted = Array.from(dailyStats.entries())
                    .sort((a, b) => new Date(b[0]) - new Date(a[0]))
                    .slice(0, 7);
                
                const statsDiv = document.getElementById('dailyStats');
                if (sorted.length > 0) {
                    statsDiv.innerHTML = sorted.map(([date, count]) => `
                        <div class="leaderboard-item">
                            <span>${escapeHtml(date)}</span>
                            <strong>${count} containers</strong>
                        </div>
                    `).join('');
                } else {
                    statsDiv.innerHTML = '<p style="text-align: center; color: #718096;">No returns yet</p>';
                }
            } catch (error) {
                console.error('Error updating daily stats:', error);
            }
        }

        // Management functions
        function updateManagementView() {
            try {
                // Update people grid
                const peopleGrid = document.getElementById('peopleGrid');
                if (people.size > 0) {
                    peopleGrid.innerHTML = Array.from(people.entries()).map(([barcode, person]) => {
                        const validReturns = person.returns ? person.returns.filter(r => 
                            containers.has(r.containerId) && containers.get(r.containerId).valid
                        ).length : 0;
                        
                        return `
                            <div class="data-card" data-person="${barcode}">
                                <h4>${escapeHtml(person.forename)} ${escapeHtml(person.surname)}</h4>
                                <p>Barcode: ${escapeHtml(barcode)}</p>
                                <p>House: <span class="house-badge house-${person.house.toLowerCase()}">${escapeHtml(person.house)}</span></p>
                                <p>Total Returns: ${validReturns}</p>
                                <div class="actions">
                                    <button class="btn small" onclick="editPerson('${barcode}')">‚úèÔ∏è Edit</button>
                                    <button class="btn small secondary" onclick="viewPersonReturns('${barcode}')">üìã View Returns</button>
                                    <button class="btn small danger" onclick="deletePerson('${barcode}')">üóëÔ∏è Delete</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    peopleGrid.innerHTML = '<p style="text-align: center; color: #718096;">No people registered yet</p>';
                }
                
                // Update containers grid
                const containersGrid = document.getElementById('containersGrid');
                if (containers.size > 0) {
                    containersGrid.innerHTML = Array.from(containers.entries()).map(([barcode, container]) => {
                        const scanCount = container.scans ? container.scans.length : 0;
                        const pendingCount = container.scans ? container.scans.filter(scan => scan.pending).length : 0;
                        return `
                            <div class="data-card" data-container="${barcode}">
                                <h4>${escapeHtml(container.description)}</h4>
                                <p>Barcode: ${escapeHtml(barcode)}</p>
                                <p>Status: <span class="toggle-status ${container.valid ? 'valid' : 'invalid'}" onclick="toggleContainerStatus('${barcode}')">${container.valid ? '‚úÖ Valid' : '‚ùå Invalid'}</span></p>
                                <p>Total Scans: ${scanCount}${pendingCount > 0 ? ` (${pendingCount} pending)` : ''}</p>
                                <div class="actions">
                                    <button class="btn small" onclick="editContainer('${barcode}')">‚úèÔ∏è Edit</button>
                                    <button class="btn small secondary" onclick="viewContainerScans('${barcode}')">üìã View Scans</button>
                                    <button class="btn small danger" onclick="deleteContainer('${barcode}')">üóëÔ∏è Delete</button>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    containersGrid.innerHTML = '<p style="text-align: center; color: #718096;">No containers registered yet</p>';
                }
            } catch (error) {
                console.error('Error updating management view:', error);
            }
        }

        // Enhanced Undo/Redo system with complete state management
        function recordAction(type, data) {
            try {
                // Remove any actions after current index
                actionHistory = actionHistory.slice(0, historyIndex + 1);
                
                // Capture complete application state for undo
                const currentState = {
                    currentPerson: currentPerson,
                    sessionReturns: new Map(sessionReturns),
                    pendingContainerScan: pendingContainerScan,
                    recentScansHTML: document.getElementById('recentScans').innerHTML,
                    scanStatus: document.getElementById('scanStatus').textContent,
                    scanStatusClass: document.getElementById('scanStatus').className,
                    currentPersonVisible: document.getElementById('currentPerson').style.display !== 'none',
                    currentPersonName: document.getElementById('currentPersonName').textContent,
                    currentPersonHouse: document.getElementById('currentPersonHouse').textContent,
                    currentPersonHouseClass: document.getElementById('currentPersonHouse').className,
                    sessionCount: document.getElementById('sessionCount').textContent,
                    totalCount: document.getElementById('totalCount').textContent
                };
                
                // Add new action with complete state
                actionHistory.push({
                    type,
                    data: JSON.parse(JSON.stringify(data)), // Deep copy
                    timestamp: new Date().toISOString(),
                    beforeState: currentState
                });
                
                // Limit history size
                if (actionHistory.length > MAX_HISTORY) {
                    actionHistory.shift();
                } else {
                    historyIndex++;
                }
                
                updateUndoRedoButtons();
            } catch (error) {
                console.error('Error recording action:', error);
            }
        }

        function performUndo() {
            if (historyIndex < 0) return;
            
            try {
                const action = actionHistory[historyIndex];
                
                // First, undo the data changes
                switch (action.type) {
                    case 'scanPerson':
                        // Can't really undo person selection, but clear if it's current
                        if (currentPerson === action.data.barcode) {
                            clearCurrentPerson();
                        }
                        break;
                        
                    case 'scanContainer':
                        if (action.data.personId && people.has(action.data.personId)) {
                            const person = people.get(action.data.personId);
                            if (person.returns && person.returns.length > 0) {
                                person.returns.pop();
                                sessionReturns.set(action.data.personId, 
                                    Math.max(0, (sessionReturns.get(action.data.personId) || 0) - 1));
                            }
                        }
                        // Remove scan from container
                        if (containers.has(action.data.barcode)) {
                            const container = containers.get(action.data.barcode);
                            if (container.scans && container.scans.length > 0) {
                                container.scans.pop();
                            }
                        }
                        break;

                    case 'assignPendingContainer':
                        // Undo the assignment - move back to pending state
                        if (containers.has(action.data.containerBarcode)) {
                            const container = containers.get(action.data.containerBarcode);
                            if (container.scans && container.scans.length > 0) {
                                const lastScan = container.scans[container.scans.length - 1];
                                if (lastScan.personId === action.data.personBarcode) {
                                    lastScan.personId = null;
                                    lastScan.pending = true;
                                }
                            }
                        }
                        if (people.has(action.data.personBarcode)) {
                            const person = people.get(action.data.personBarcode);
                            if (person.returns && person.returns.length > 0) {
                                person.returns.pop();
                                sessionReturns.set(action.data.personBarcode, 
                                    Math.max(0, (sessionReturns.get(action.data.personBarcode) || 0) - 1));
                            }
                        }
                        pendingContainerScan = action.data.containerBarcode;
                        break;
                        
                    case 'addPerson':
                        people.delete(action.data.barcode);
                        break;
                        
                    case 'addContainer':
                        containers.delete(action.data.barcode);
                        break;

                    case 'editPerson':
                        if (people.has(action.data.barcode)) {
                            const person = people.get(action.data.barcode);
                            Object.assign(person, action.data.oldData);
                        }
                        break;

                    case 'editContainer':
                        if (containers.has(action.data.barcode)) {
                            const container = containers.get(action.data.barcode);
                            Object.assign(container, action.data.oldData);
                        }
                        break;

                    case 'deletePerson':
                        people.set(action.data.barcode, action.data.data);
                        break;
                        
                    case 'deleteContainer':
                        containers.set(action.data.barcode, action.data.data);
                        // Restore affected returns (this is complex, simplified for now)
                        break;

                    case 'toggleStatus':
                        if (containers.has(action.data.barcode)) {
                            const container = containers.get(action.data.barcode);
                            container.valid = action.data.oldStatus;
                        }
                        break;
                }
                
                // Now restore the complete UI state from before the action
                if (action.beforeState) {
                    restoreApplicationState(action.beforeState);
                }
                
                historyIndex--;
                updateUndoRedoButtons();
                updateStatistics();
                updateManagementView();
                saveData();
                
            } catch (error) {
                console.error('Error performing undo:', error);
            }
        }

        function performRedo() {
            if (historyIndex >= actionHistory.length - 1) return;
            
            try {
                historyIndex++;
                const action = actionHistory[historyIndex];
                
                // Capture current state before redo
                const preRedoState = {
                    currentPerson: currentPerson,
                    sessionReturns: new Map(sessionReturns),
                    pendingContainerScan: pendingContainerScan,
                    recentScansHTML: document.getElementById('recentScans').innerHTML,
                    scanStatus: document.getElementById('scanStatus').textContent,
                    scanStatusClass: document.getElementById('scanStatus').className,
                    currentPersonVisible: document.getElementById('currentPerson').style.display !== 'none',
                    currentPersonName: document.getElementById('currentPersonName').textContent,
                    currentPersonHouse: document.getElementById('currentPersonHouse').textContent,
                    currentPersonHouseClass: document.getElementById('currentPersonHouse').className,
                    sessionCount: document.getElementById('sessionCount').textContent,
                    totalCount: document.getElementById('totalCount').textContent
                };
                
                switch (action.type) {
                    case 'scanPerson':
                        handlePersonScan(action.data.barcode);
                        break;
                        
                    case 'scanContainer':
                        if (action.data.personId) {
                            const currentPersonData = people.get(action.data.personId);
                            if (currentPersonData) {
                                currentPerson = action.data.personId;
                                // Restore session state
                                if (!sessionReturns.has(action.data.personId)) {
                                    sessionReturns.set(action.data.personId, 0);
                                }
                                // Update UI for current person
                                updateCurrentPersonDisplay(action.data.personId);
                                handleContainerScan(action.data.barcode);
                            }
                        } else {
                            handleContainerScan(action.data.barcode);
                        }
                        break;

                    case 'assignPendingContainer':
                        processContainerScanWithPerson(action.data.containerBarcode, action.data.personBarcode);
                        pendingContainerScan = null;
                        break;
                        
                    case 'addPerson':
                        people.set(action.data.barcode, action.data.data);
                        break;
                        
                    case 'addContainer':
                        containers.set(action.data.barcode, action.data.data);
                        break;

                    case 'editPerson':
                        if (people.has(action.data.barcode)) {
                            const person = people.get(action.data.barcode);
                            Object.assign(person, action.data.newData);
                        }
                        break;

                    case 'editContainer':
                        if (containers.has(action.data.barcode)) {
                            const container = containers.get(action.data.barcode);
                            Object.assign(container, action.data.newData);
                        }
                        break;

                    case 'deleteContainer':
                        containers.delete(action.data.barcode);
                        // Remove container references from people's returns
                        people.forEach(person => {
                            if (person.returns) {
                                person.returns = person.returns.filter(ret => ret.containerId !== action.data.barcode);
                            }
                        });
                        break;

                    case 'deletePerson':
                        people.delete(action.data.barcode);
                        break;

                    case 'toggleStatus':
                        if (containers.has(action.data.barcode)) {
                            const container = containers.get(action.data.barcode);
                            container.valid = !action.data.oldStatus;
                        }
                        break;
                }
                
                updateUndoRedoButtons();
                updateStatistics();
                updateManagementView();
                saveData();
            } catch (error) {
                console.error('Error performing redo:', error);
            }
        }

        // NEW: Function to restore complete application state
        function restoreApplicationState(state) {
            try {
                // Restore global state variables
                currentPerson = state.currentPerson;
                sessionReturns = new Map(state.sessionReturns);
                pendingContainerScan = state.pendingContainerScan;
                
                // Restore UI elements
                document.getElementById('recentScans').innerHTML = state.recentScansHTML;
                document.getElementById('scanStatus').textContent = state.scanStatus;
                document.getElementById('scanStatus').className = state.scanStatusClass;
                
                // Restore current person display
                const currentPersonDiv = document.getElementById('currentPerson');
                currentPersonDiv.style.display = state.currentPersonVisible ? 'block' : 'none';
                
                if (state.currentPersonVisible) {
                    document.getElementById('currentPersonName').textContent = state.currentPersonName;
                    document.getElementById('currentPersonHouse').textContent = state.currentPersonHouse;
                    document.getElementById('currentPersonHouse').className = state.currentPersonHouseClass;
                    document.getElementById('sessionCount').textContent = state.sessionCount;
                    document.getElementById('totalCount').textContent = state.totalCount;
                }
                
                // Clear any timeouts and reset them if needed
                if (idleTimer) {
                    clearTimeout(idleTimer);
                    idleTimer = null;
                }
                
                if (currentPerson) {
                    resetIdleTimer();
                }
                
            } catch (error) {
                console.error('Error restoring application state:', error);
            }
        }

        // NEW: Helper function to update current person display
        function updateCurrentPersonDisplay(personBarcode) {
            const person = people.get(personBarcode);
            if (!person) return;
            
            document.getElementById('currentPerson').style.display = 'block';
            document.getElementById('currentPersonName').textContent = `${person.forename} ${person.surname}`;
            
            const houseElement = document.getElementById('currentPersonHouse');
            houseElement.textContent = person.house;
            houseElement.className = `house-badge house-${person.house.toLowerCase()}`;
            
            document.getElementById('sessionCount').textContent = sessionReturns.get(personBarcode) || 0;
            document.getElementById('totalCount').textContent = person.returns ? person.returns.length : 0;
        }

        function updateUndoRedoButtons() {
            try {
                document.getElementById('undoBtn').disabled = historyIndex < 0;
                document.getElementById('redoBtn').disabled = historyIndex >= actionHistory.length - 1;
            } catch (error) {
                console.error('Error updating undo/redo buttons:', error);
            }
        }

        // Import/Export functions with error handling
        function exportData() {
            try {
                const data = [];
                
                // Export people with their individual returns
                people.forEach((person, personBarcode) => {
                    if (person.returns && person.returns.length > 0) {
                        person.returns.forEach(returnItem => {
                            const container = containers.get(returnItem.containerId);
                            data.push({
                                Type: 'Return',
                                PersonBarcode: personBarcode,
                                PersonName: `${person.forename} ${person.surname}`,
                                PersonForename: person.forename,
                                PersonSurname: person.surname,
                                House: person.house,
                                ContainerBarcode: returnItem.containerId,
                                ContainerDescription: container ? container.description : 'Unknown Container',
                                ContainerValid: container ? (container.valid ? 'Yes' : 'No') : 'Unknown',
                                Timestamp: new Date(returnItem.timestamp).toISOString(),
                                Date: new Date(returnItem.timestamp).toLocaleDateString(),
                                Time: new Date(returnItem.timestamp).toLocaleTimeString()
                            });
                        });
                    } else {
                        // Include people with no returns
                        data.push({
                            Type: 'Person',
                            PersonBarcode: personBarcode,
                            PersonName: `${person.forename} ${person.surname}`,
                            PersonForename: person.forename,
                            PersonSurname: person.surname,
                            House: person.house,
                            ContainerBarcode: '',
                            ContainerDescription: '',
                            ContainerValid: '',
                            Timestamp: '',
                            Date: '',
                            Time: ''
                        });
                    }
                });
                
                // Export container scans
                containers.forEach((container, containerBarcode) => {
                    if (container.scans && container.scans.length > 0) {
                        container.scans.forEach(scan => {
                            const person = scan.personId ? people.get(scan.personId) : null;
                            data.push({
                                Type: scan.pending ? 'PendingScan' : 'Scan',
                                PersonBarcode: scan.personId || '',
                                PersonName: person ? `${person.forename} ${person.surname}` : (scan.pending ? 'Pending Assignment' : 'No Person Selected'),
                                PersonForename: person ? person.forename : '',
                                PersonSurname: person ? person.surname : '',
                                House: person ? person.house : '',
                                ContainerBarcode: containerBarcode,
                                ContainerDescription: container.description,
                                ContainerValid: container.valid ? 'Yes' : 'No',
                                Timestamp: new Date(scan.timestamp).toISOString(),
                                Date: new Date(scan.timestamp).toLocaleDateString(),
                                Time: new Date(scan.timestamp).toLocaleTimeString()
                            });
                        });
                    }
                });
                
                const csv = Papa.unparse(data);
                downloadCSV(csv, 'export');
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data');
            }
        }

        function exportDetailedData() {
            // This function is no longer used but kept for compatibility
            exportData();
        }

        function exportSummaryData() {
            // This function is no longer used but kept for compatibility
            exportData();
        }

        function downloadCSV(csv, type) {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `drinks_container_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                Papa.parse(file, {
                    header: true,
                    complete: function(results) {
                        try {
                            let importedPeople = 0;
                            let importedContainers = 0;
                            let importedReturns = 0;
                            let importedScans = 0;
                            
                            // Create temporary maps to avoid duplicates
                            const tempPeople = new Map();
                            const tempContainers = new Map();
                            
                            // Process all rows to extract unique people and containers
                            results.data.forEach(row => {
                                // Skip empty rows
                                if (!row.Type) return;
                                
                                // Extract person data from any row that has person info
                                if (row.PersonBarcode && row.PersonForename && row.PersonSurname) {
                                    if (!tempPeople.has(row.PersonBarcode)) {
                                        tempPeople.set(row.PersonBarcode, {
                                            forename: row.PersonForename,
                                            surname: row.PersonSurname,
                                            house: row.House || 'Yellow',
                                            returns: []
                                        });
                                    }
                                }
                                
                                // Extract container data from any row that has container info
                                if (row.ContainerBarcode && row.ContainerDescription) {
                                    if (!tempContainers.has(row.ContainerBarcode)) {
                                        tempContainers.set(row.ContainerBarcode, {
                                            description: row.ContainerDescription,
                                            valid: row.ContainerValid === 'Yes',
                                            scans: []
                                        });
                                    }
                                }
                            });
                            
                            // Merge with existing data
                            tempPeople.forEach((person, barcode) => {
                                if (!people.has(barcode)) {
                                    people.set(barcode, person);
                                    importedPeople++;
                                } else {
                                    // Preserve existing returns if person already exists
                                    const existing = people.get(barcode);
                                    person.returns = existing.returns;
                                }
                            });
                            
                            tempContainers.forEach((container, barcode) => {
                                if (!containers.has(barcode)) {
                                    containers.set(barcode, container);
                                    importedContainers++;
                                } else {
                                    // Preserve existing scans if container already exists
                                    const existing = containers.get(barcode);
                                    container.scans = existing.scans;
                                }
                            });
                            
                            // Process Return and Scan records
                            results.data.forEach(row => {
                                if (row.Type === 'Return' && row.PersonBarcode && row.ContainerBarcode && row.Timestamp) {
                                    const person = people.get(row.PersonBarcode);
                                    const container = containers.get(row.ContainerBarcode);
                                    
                                    if (person && container) {
                                        // Parse timestamp - handle different date formats
                                        let timestamp;
                                        try {
                                            // First try ISO format (from our exports)
                                            if (row.Timestamp.includes('T')) {
                                                timestamp = new Date(row.Timestamp).toISOString();
                                            } else {
                                                // Handle DD/MM/YYYY, HH:MM:SS format
                                                const cleanTimestamp = row.Timestamp.replace(',', '');
                                                const parts = cleanTimestamp.split(' ');
                                                if (parts.length === 2) {
                                                    // Split date and time
                                                    const dateParts = parts[0].split('/');
                                                    const timePart = parts[1];
                                                    
                                                    // Convert DD/MM/YYYY to YYYY-MM-DD
                                                    if (dateParts.length === 3) {
                                                        const formattedDate = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
                                                        const dateTimeString = `${formattedDate}T${timePart}`;
                                                        timestamp = new Date(dateTimeString).toISOString();
                                                    } else {
                                                        throw new Error('Invalid date format');
                                                    }
                                                } else {
                                                    // Try parsing as is
                                                    timestamp = new Date(cleanTimestamp).toISOString();
                                                }
                                            }
                                        } catch (e) {
                                            console.warn('Failed to parse timestamp:', row.Timestamp, e);
                                            // Skip this record if we can't parse the timestamp
                                            return;
                                        }
                                        
                                        // Check if this return already exists
                                        const existingReturn = person.returns.find(ret => 
                                            ret.containerId === row.ContainerBarcode && 
                                            Math.abs(new Date(ret.timestamp) - new Date(timestamp)) < 1000 // Within 1 second
                                        );
                                        
                                        if (!existingReturn) {
                                            person.returns.push({
                                                containerId: row.ContainerBarcode,
                                                timestamp: timestamp
                                            });
                                            importedReturns++;
                                        }
                                    }
                                } else if ((row.Type === 'Scan' || row.Type === 'PendingScan') && row.ContainerBarcode && row.Timestamp) {
                                    const container = containers.get(row.ContainerBarcode);
                                    
                                    if (container) {
                                        // Parse timestamp - handle different date formats
                                        let timestamp;
                                        try {
                                            // First try ISO format (from our exports)
                                            if (row.Timestamp.includes('T')) {
                                                timestamp = new Date(row.Timestamp).toISOString();
                                            } else {
                                                // Handle DD/MM/YYYY, HH:MM:SS format
                                                const cleanTimestamp = row.Timestamp.replace(',', '');
                                                const parts = cleanTimestamp.split(' ');
                                                if (parts.length === 2) {
                                                    // Split date and time
                                                    const dateParts = parts[0].split('/');
                                                    const timePart = parts[1];
                                                    
                                                    // Convert DD/MM/YYYY to YYYY-MM-DD
                                                    if (dateParts.length === 3) {
                                                        const formattedDate = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
                                                        const dateTimeString = `${formattedDate}T${timePart}`;
                                                        timestamp = new Date(dateTimeString).toISOString();
                                                    } else {
                                                        throw new Error('Invalid date format');
                                                    }
                                                } else {
                                                    // Try parsing as is
                                                    timestamp = new Date(cleanTimestamp).toISOString();
                                                }
                                            }
                                        } catch (e) {
                                            console.warn('Failed to parse timestamp:', row.Timestamp, e);
                                            // Skip this record if we can't parse the timestamp
                                            return;
                                        }
                                        
                                        // Check if this scan already exists
                                        const existingScan = container.scans.find(scan => 
                                            Math.abs(new Date(scan.timestamp) - new Date(timestamp)) < 1000 && // Within 1 second
                                            scan.personId === (row.PersonBarcode || null)
                                        );
                                        
                                        if (!existingScan) {
                                            const scanData = {
                                                timestamp: timestamp,
                                                personId: row.PersonBarcode || null
                                            };
                                            if (row.Type === 'PendingScan') {
                                                scanData.pending = true;
                                            }
                                            container.scans.push(scanData);
                                            importedScans++;
                                        }
                                    }
                                }
                            });
                            
                            updateStatistics();
                            updateManagementView();
                            saveData();
                            
                            let message = `Import complete:\n‚Ä¢ ${importedPeople} new people\n‚Ä¢ ${importedContainers} new containers\n‚Ä¢ ${importedReturns} return records\n‚Ä¢ ${importedScans} scan records`;
                            alert(message);
                        } catch (error) {
                            console.error('Error processing import data:', error);
                            alert('Error processing import data: ' + error.message);
                        }
                    },
                    error: function(error) {
                        console.error('Error parsing CSV:', error);
                        alert('Error parsing CSV file');
                    }
                });
            } catch (error) {
                console.error('Error importing data:', error);
                alert('Error importing data');
            }
            
            event.target.value = '';
        }

        function clearData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                try {
                    people.clear();
                    containers.clear();
                    sessionReturns.clear();
                    currentPerson = null;
                    pendingContainerScan = null; // Clear pending state
                    actionHistory = [];
                    historyIndex = -1;
                    
                    // Clear timeout
                    if (idleTimer) {
                        clearTimeout(idleTimer);
                        idleTimer = null;
                    }
                    
                    document.getElementById('currentPerson').style.display = 'none';
                    document.getElementById('recentScans').innerHTML = 
                        '<p style="text-align: center; color: #718096; font-style: italic;">No scans yet</p>';
                    
                    // Load placeholder data
                    loadPlaceholderData();
                    
                    updateStatistics();
                    updateManagementView();
                    updateUndoRedoButtons();
                    updateScanStatus('Ready to scan - Start by scanning a person or container');
                    saveData();
                } catch (error) {
                    console.error('Error clearing data:', error);
                    alert('Error clearing data');
                }
            }
        }

        // Generate sample data function
        function generateSampleData() {
            if (!confirm('This will add sample data to your current database. Continue?')) {
                return;
            }
            
            try {
                // Sample people data
                const samplePeople = [
                    { barcode: '1001', forename: 'Alice', surname: 'Johnson', house: 'Yellow' },
                    { barcode: '1002', forename: 'Bob', surname: 'Smith', house: 'Green' },
                    { barcode: '1003', forename: 'Charlie', surname: 'Brown', house: 'Blue' },
                    { barcode: '1004', forename: 'Diana', surname: 'Wilson', house: 'Red' },
                    { barcode: '1005', forename: 'Eva', surname: 'Martinez', house: 'Yellow' }
                ];
                
                // Sample container data
                const sampleContainers = [
                    { barcode: '5449000000996', description: 'Coca-Cola Can 330ml', valid: true },
                    { barcode: '5449000050205', description: 'Sprite Can 330ml', valid: true },
                    { barcode: '5449000133328', description: 'Fanta Orange Can 330ml', valid: true },
                    { barcode: '5000112628098', description: 'Pepsi Can 330ml', valid: true },
                    { barcode: '5000112628081', description: '7UP Can 330ml', valid: true },
                    { barcode: '9300650135048', description: 'Solo Lemon 375ml', valid: true },
                    { barcode: '9310488003011', description: 'Mount Franklin Water 600ml', valid: true },
                    { barcode: '9415297000017', description: 'L&P Soft Drink 355ml', valid: true },
                    { barcode: '8710398606501', description: 'Lipton Ice Tea 500ml', valid: true },
                    { barcode: '9300830039432', description: 'V Energy Drink 250ml', valid: false } // One invalid container
                ];
                
                // Add people
                samplePeople.forEach(person => {
                    if (!people.has(person.barcode)) {
                        people.set(person.barcode, {
                            forename: person.forename,
                            surname: person.surname,
                            house: person.house,
                            returns: []
                        });
                    }
                });
                
                // Add containers
                sampleContainers.forEach(container => {
                    if (!containers.has(container.barcode)) {
                        containers.set(container.barcode, {
                            description: container.description,
                            valid: container.valid,
                            scans: []
                        });
                    }
                });
                
                // Generate random returns (up to 100)
                const numReturns = Math.floor(Math.random() * 51) + 50; // 50-100 returns
                const peopleArray = Array.from(people.keys());
                const validContainersArray = Array.from(containers.entries())
                    .filter(([_, container]) => container.valid)
                    .map(([barcode, _]) => barcode);
                
                // Generate returns over the past 7 days
                const now = new Date();
                for (let i = 0; i < numReturns; i++) {
                    // Random person
                    const personBarcode = peopleArray[Math.floor(Math.random() * peopleArray.length)];
                    const person = people.get(personBarcode);
                    
                    // Random valid container
                    const containerBarcode = validContainersArray[Math.floor(Math.random() * validContainersArray.length)];
                    const container = containers.get(containerBarcode);
                    
                    // Random timestamp within last 7 days
                    const daysAgo = Math.random() * 7;
                    const timestamp = new Date(now.getTime() - (daysAgo * 24 * 60 * 60 * 1000));
                    
                    // Add return to person
                    person.returns.push({
                        containerId: containerBarcode,
                        timestamp: timestamp.toISOString()
                    });
                    
                    // Add scan to container
                    container.scans.push({
                        timestamp: timestamp.toISOString(),
                        personId: personBarcode
                    });
                }
                
                // Sort returns and scans by timestamp
                people.forEach(person => {
                    if (person.returns) {
                        person.returns.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    }
                });
                
                containers.forEach(container => {
                    if (container.scans) {
                        container.scans.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    }
                });
                
                // Add a few invalid container scans for testing
                const invalidContainers = Array.from(containers.entries())
                    .filter(([_, container]) => !container.valid);
                
                if (invalidContainers.length > 0) {
                    for (let i = 0; i < 5; i++) {
                        const personBarcode = peopleArray[Math.floor(Math.random() * peopleArray.length)];
                        const [containerBarcode, container] = invalidContainers[0];
                        
                        const timestamp = new Date(now.getTime() - (Math.random() * 7 * 24 * 60 * 60 * 1000));
                        
                        container.scans.push({
                            timestamp: timestamp.toISOString(),
                            personId: personBarcode
                        });
                    }
                }
                
                updateStatistics();
                updateManagementView();
                saveData();
                
                alert(`Sample data generated:\n‚Ä¢ ${samplePeople.length} people\n‚Ä¢ ${sampleContainers.length} containers\n‚Ä¢ ${numReturns} returns`);
                
            } catch (error) {
                console.error('Error generating sample data:', error);
                alert('Error generating sample data');
            }
        }

        // Tab switching with simplified visibility control
        function switchTab(tabName) {
            try {
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                event.target.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(tabName).classList.add('active');
                
                // Update body class to control visibility of scanning-specific elements
                if (tabName === 'scanning') {
                    document.body.classList.add('scanning-active');
                } else {
                    document.body.classList.remove('scanning-active');
                }
                
                if (tabName === 'statistics') {
                    updateStatistics();
                } else if (tabName === 'management') {
                    updateManagementView();
                }
            } catch (error) {
                console.error('Error switching tabs:', error);
            }
        }

        // Initialize on load
        window.addEventListener('load', init);
        
        // Handle errors globally
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
        });
    </script>
</body>
</html>