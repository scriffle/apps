<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouCantFakeThis - Educational Review Platform</title>
  <style>
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
      --bg: #f8fafc;
      --bg-card: #ffffff;
      --text: #1e293b;
      --text-muted: #64748b;
      --border: #e2e8f0;
      --unfilled: #fffacd;
      --filled: #add8e6;
      --correct: #90ee90;
      --incorrect: #ffcccb;
      --radius: 8px;
      --shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: var(--gradient);
      color: white;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 48px;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      font-weight: 700;
      font-size: 1.1rem;
      white-space: nowrap;
    }

    .header-info {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 0.85rem;
      opacity: 0.95;
    }

    .header-info span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /* Round Navigation Pills */
    .round-pills {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .round-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      border: 2px solid transparent;
      transition: all 0.2s;
      cursor: default;
      min-width: 32px;
    }

    .round-pill.locked {
      background: #e5e7eb;
      color: #9ca3af;
      border-color: #d1d5db;
    }

    .round-pill.available {
      background: #dbeafe;
      color: #1e40af;
      border-color: #93c5fd;
      cursor: pointer;
    }

    .round-pill.available:hover {
      background: #bfdbfe;
      border-color: #60a5fa;
    }

    .round-pill.current {
      background: #fef3c7;
      color: #92400e;
      border-color: #f59e0b;
      box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3);
    }

    .round-pill.complete {
      background: #d1fae5;
      color: #065f46;
      border-color: #34d399;
      cursor: pointer;
    }

    .round-pill.complete:hover {
      background: #a7f3d0;
      border-color: #10b981;
    }

    .round-pill .pill-check {
      margin-left: 3px;
      font-size: 0.7rem;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn {
      padding: 6px 12px;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .btn-primary {
      background: white;
      color: var(--primary);
    }

    .btn-primary:hover {
      background: #f1f5f9;
    }

    .btn-secondary {
      background: rgba(255,255,255,0.2);
      color: white;
    }

    .btn-secondary:hover {
      background: rgba(255,255,255,0.3);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: #059669;
    }

    .btn-danger {
      background: var(--error);
      color: white;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Navigation Breadcrumb */
    .nav-bar {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      padding: 8px 16px;
    }

    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
      font-size: 0.9rem;
    }

    .breadcrumb-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .breadcrumb-item select {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: white;
      font-size: 0.85rem;
      cursor: pointer;
      max-width: 180px;
    }

    .breadcrumb-item select:disabled {
      background: #f1f5f9;
      cursor: not-allowed;
    }

    .breadcrumb-sep {
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    /* Custom Dropdown (for topic selector with tooltips) */
    .custom-dropdown {
      position: relative;
      display: inline-block;
    }

    .custom-dropdown-trigger {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: white;
      font-size: 0.85rem;
      cursor: pointer;
      max-width: 220px;
      min-width: 150px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .custom-dropdown-trigger:hover {
      border-color: var(--primary);
    }

    .custom-dropdown-trigger .dropdown-arrow {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .custom-dropdown-trigger .dropdown-text {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .custom-dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 100%;
      max-width: 300px;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      display: none;
    }

    .custom-dropdown.open .custom-dropdown-menu {
      display: block;
    }

    .custom-dropdown-option {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.85rem;
      border-bottom: 1px solid var(--bg-secondary);
    }

    .custom-dropdown-option:last-child {
      border-bottom: none;
    }

    .custom-dropdown-option:hover {
      background: var(--bg-secondary);
    }

    .custom-dropdown-option.selected {
      background: var(--primary);
      color: white;
    }

    .custom-dropdown-option.disabled {
      color: var(--text-muted);
      cursor: not-allowed;
      background: var(--bg-secondary);
    }

    .custom-dropdown-option.disabled:hover {
      background: var(--bg-secondary);
    }

    .custom-dropdown-option .option-name {
      font-weight: 500;
    }

    .custom-dropdown-option .option-status {
      font-size: 0.75rem;
      color: var(--warning);
      margin-left: 4px;
    }

    /* Dropdown tooltip */
    .dropdown-tooltip {
      position: fixed;
      background: var(--text);
      color: white;
      padding: 6px 10px;
      border-radius: var(--radius);
      font-size: 0.8rem;
      max-width: 220px;
      z-index: 2000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .dropdown-tooltip.show {
      opacity: 1;
    }

    /* Tabs */
    .tabs-container {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      padding: 0 16px;
      display: none;
    }

    .tabs-container.active {
      display: block;
    }

    .tabs {
      display: flex;
      gap: 4px;
      overflow-x: auto;
    }

    .tab {
      padding: 10px 16px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--text-muted);
      border-bottom: 2px solid transparent;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .tab:hover {
      color: var(--text);
    }

    .tab.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .tab-icon {
      font-weight: 600;
    }

    .tab-progress {
      display: flex;
      gap: 3px;
      margin-left: 4px;
    }

    .progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
    }

    .progress-dot.complete {
      background: #10b981;
    }

    .progress-dot.current {
      background: #f59e0b;
      box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3);
    }

    /* Tab pulse animation - invitation to click next */
    @keyframes tabPulse {
      0% { background-color: transparent; }
      50% { background-color: rgba(255, 255, 200, 0.8); }
      100% { background-color: transparent; }
    }

    .tab.pulse {
      animation: tabPulse 1.2s ease-in-out infinite;
    }

    /* Content Area */
    .content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .welcome-screen, .state-select-screen, .topic-content, .review-screen {
      max-width: 900px;
      margin: 0 auto;
    }

    /* State Selection */
    .state-select-screen {
      text-align: center;
      padding: 40px 20px;
    }

    .state-select-screen h1 {
      font-size: 1.8rem;
      margin-bottom: 8px;
    }

    .state-select-screen p {
      color: var(--text-muted);
      margin-bottom: 24px;
    }

    .state-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      max-width: 600px;
      margin: 0 auto;
    }

    .state-card {
      background: var(--bg-card);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .state-card:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow);
    }

    .state-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .state-card .icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }

    .state-card .name {
      font-weight: 600;
      font-size: 1.1rem;
    }

    .state-card .region {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    /* Welcome Screen */
    .welcome-screen {
      text-align: center;
      padding: 40px 20px;
    }

    .welcome-screen h2 {
      font-size: 1.5rem;
      margin-bottom: 8px;
    }

    .welcome-screen p {
      color: var(--text-muted);
    }

    /* Topic Content */
    .topic-content {
      display: none;
    }

    .topic-content.active {
      display: block;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--primary);
    }

    .section-instructions {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin-bottom: 16px;
    }

    .sentence {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px 16px;
      margin-bottom: 12px;
      line-height: 1.8;
      font-size: 0.95rem;
    }

    .cloze-dropdown {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 0.9rem;
      cursor: pointer;
      background: var(--unfilled);
      transition: all 0.2s;
      min-width: 120px;
      max-width: 200px;
    }

    .cloze-dropdown.filled {
      background: var(--filled);
    }

    .cloze-dropdown.correct {
      background: var(--correct);
      border-color: var(--success);
    }

    .cloze-dropdown.incorrect {
      background: var(--incorrect);
      border-color: var(--error);
    }

    .cloze-dropdown.readonly {
      cursor: help;
      opacity: 0.85;
    }

    .cloze-dropdown.readonly:focus {
      outline: 2px solid var(--primary);
      outline-offset: 1px;
    }

    /* Dropdown Tooltip */
    .dropdown-tooltip {
      position: fixed;
      background: #1f2937;
      color: #f9fafb;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      max-width: 280px;
      line-height: 1.4;
      z-index: 3000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(4px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .dropdown-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .dropdown-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 20px;
      border: 6px solid transparent;
      border-top-color: #1f2937;
    }

    .dropdown-tooltip.arrow-top::after {
      top: -12px;
      border-top-color: transparent;
      border-bottom-color: #1f2937;
    }

    /* Selection popup menu */
    .selection-menu {
      position: fixed;
      background: #1f2937;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 3001;
      opacity: 0;
      transform: translateY(4px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      pointer-events: none;
      overflow: hidden;
    }

    .selection-menu.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .selection-menu-item {
      display: block;
      padding: 8px 14px;
      color: #f9fafb;
      font-size: 0.8rem;
      cursor: pointer;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      white-space: nowrap;
    }

    .selection-menu-item:hover {
      background: #374151;
    }

    .selection-menu-item:first-child {
      border-radius: 6px 6px 0 0;
    }

    .selection-menu-item:last-child {
      border-radius: 0 0 6px 6px;
    }

    .feedback-inline {
      display: none;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 4px;
      padding: 8px 12px;
      margin-top: 8px;
      font-size: 0.85rem;
    }

    .feedback-inline.show {
      display: block;
    }

    .feedback-inline .error-label {
      color: var(--error);
      font-weight: 600;
      margin-bottom: 4px;
    }

    .feedback-inline .error-what {
      color: var(--error);
      font-weight: 500;
      margin-bottom: 4px;
    }

    .feedback-inline .fix {
      color: var(--text);
      margin-top: 4px;
    }

    .feedback-inline .action {
      color: var(--text-muted);
      font-style: italic;
      margin-top: 4px;
    }

    /* Collapsible sections */
    .collapsible {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: 8px;
      overflow: hidden;
    }

    .collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: var(--bg-secondary);
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      user-select: none;
    }

    .collapsible-header:hover {
      background: var(--border);
    }

    .collapsible-icon {
      transition: transform 0.2s;
      font-size: 0.75rem;
    }

    .collapsible.open .collapsible-icon {
      transform: rotate(90deg);
    }

    .collapsible-content {
      display: none;
      padding: 10px 12px;
      font-size: 0.85rem;
      background: var(--bg-card);
      border-top: 1px solid var(--border);
    }

    .collapsible.open .collapsible-content {
      display: block;
    }

    .collapsible-content p {
      margin: 0 0 6px 0;
    }

    .collapsible-content p:last-child {
      margin-bottom: 0;
    }

    .collapsible-formula {
      font-family: monospace;
      background: var(--bg-secondary);
      padding: 2px 6px;
      border-radius: 3px;
    }

    /* Dot point reference */
    .dot-point-ref {
      margin-bottom: 16px;
    }

    .dot-point-ref .collapsible-header {
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    .dot-point-ref .collapsible-content {
      color: var(--text-secondary);
      font-size: 0.8rem;
      line-height: 1.4;
    }

    /* Inline Controls (after sentences) */
    .inline-controls {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px 16px;
      margin-top: 16px;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
    }

    .control-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .control-center {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 0.9rem;
    }

    .score-display {
      font-weight: 600;
    }

    .attempt-display {
      color: var(--text-muted);
    }

    .control-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .feedback-summary {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 8px;
      text-align: center;
    }

    .feedback-summary.success {
      color: var(--success);
    }

    .feedback-summary.error {
      color: var(--error);
    }

    /* Review Tab Content Styles */
    .review-email-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 20px;
    }

    .review-email-header {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 12px;
      color: var(--primary);
    }

    .review-email-fields {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .review-email-field {
      flex: 1;
      min-width: 180px;
    }

    .review-email-field label {
      display: block;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .review-email-field input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.9rem;
    }

    .review-email-field input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .review-email-field.review-email-button {
      flex: 0 0 auto;
      min-width: auto;
    }

    .review-email-field.review-email-button button {
      white-space: nowrap;
    }

    .review-round-header {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-muted);
      margin: 16px 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--border);
    }

    .review-section-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: 6px;
    }

    .review-section-item.success {
      border-left: 3px solid var(--success);
    }

    .review-section-item.warning {
      border-left: 3px solid var(--warning);
    }

    .review-section-icon {
      font-size: 1rem;
      width: 20px;
      text-align: center;
    }

    .review-section-item.success .review-section-icon {
      color: var(--success);
    }

    .review-section-item.warning .review-section-icon {
      color: var(--warning);
    }

    .review-section-name {
      font-weight: 500;
      min-width: 150px;
    }

    .review-section-status {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .review-concept-item {
      padding: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-left: 3px solid var(--warning);
      border-radius: var(--radius);
      margin-bottom: 8px;
    }

    .review-concept-name {
      font-weight: 500;
      margin-bottom: 4px;
    }

    .review-concept-count {
      font-weight: normal;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .review-concept-detail {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .review-concept-wrong {
      font-size: 0.85rem;
      color: var(--error);
    }

    .review-actions-inline {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .review-complete-banner {
      width: 100%;
      text-align: center;
      margin-bottom: 12px;
    }

    .review-complete-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--success);
    }

    .review-complete-stats {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .tab.review-tab {
      margin-left: auto;
      background: var(--bg-secondary);
    }

    /* Help Panel */
    .help-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      width: 90%;
      max-width: 480px;
      max-height: 80vh;
      background: var(--bg-card);
      border-radius: var(--radius);
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      z-index: 1001;
      display: none;
      flex-direction: column;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
    }

    .help-panel.open {
      display: flex;
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .help-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .help-header h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .help-content {
      padding: 16px;
      overflow-y: auto;
    }

    .help-section {
      margin-bottom: 16px;
    }

    .help-section:last-child {
      margin-bottom: 0;
    }

    .help-section h4 {
      font-size: 0.9rem;
      margin-bottom: 4px;
      color: var(--primary);
    }

    .help-section p {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin: 0;
      line-height: 1.4;
    }

    .help-section ul {
      margin: 0;
      padding-left: 0;
      list-style: none;
    }

    .help-section li {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .help-color {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid var(--border);
    }

    .help-color.unfilled { background: #fffacd; }
    .help-color.filled { background: #add8e6; }
    .help-color.correct { background: #90ee90; }
    .help-color.incorrect { background: #ffcccb; }

    /* Utilities Panel */
    .utilities-panel {
      position: fixed;
      top: 0;
      right: -320px;
      width: 320px;
      height: 100%;
      background: var(--bg-card);
      box-shadow: -4px 0 20px rgba(0,0,0,0.1);
      transition: right 0.3s;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }

    .utilities-panel.open {
      right: 0;
    }

    .utilities-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .utilities-header h3 {
      font-size: 1.1rem;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-muted);
    }

    .utilities-content {
      padding: 16px;
      flex: 1;
      overflow-y: auto;
    }

    .utility-section {
      margin-bottom: 20px;
    }

    .utility-section h4 {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .utility-btn {
      width: 100%;
      padding: 10px 12px;
      margin-bottom: 8px;
      text-align: left;
    }

    .utility-btn.confirm {
      background: var(--warning);
      color: white;
    }

    .utility-input-group {
      margin-bottom: 12px;
    }

    .utility-input-group label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .utility-input-group input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.9rem;
      box-sizing: border-box;
    }

    .utility-input-group input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .utility-input-group input.invalid {
      border-color: var(--error);
    }

    .input-error {
      display: block;
      font-size: 0.8rem;
      color: var(--error);
      margin-top: 4px;
      min-height: 1em;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      z-index: 999;
      display: none;
    }

    .overlay.show {
      display: block;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--text);
      color: white;
      padding: 12px 24px;
      border-radius: var(--radius);
      font-size: 0.9rem;
      z-index: 2000;
      opacity: 0;
      transition: all 0.3s;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Responsive */
    @media (max-width: 600px) {
      .header {
        padding: 8px 12px;
      }
      
      .header-info {
        display: none;
      }

      .breadcrumb-item select {
        max-width: 120px;
      }

      .tabs {
        gap: 0;
      }

      .tab {
        padding: 8px 12px;
        font-size: 0.8rem;
      }

      .tab-label {
        display: none;
      }

      .control-row {
        flex-direction: column;
        align-items: stretch;
      }

      .control-center {
        justify-content: center;
      }

      .control-right {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">üìö YouCantFakeThis</div>
      <div class="header-info" id="headerInfo">
        <div class="round-pills" id="roundPills"></div>
        <span id="totalScoreDisplay"></span>
      </div>
    </div>
    <div class="header-right">
      <button class="btn btn-secondary" id="helpBtn">?</button>
      <button class="btn btn-secondary" id="utilitiesBtn">‚öôÔ∏è</button>
    </div>
  </header>

  <!-- Help Panel -->
  <div class="help-panel" id="helpPanel">
    <div class="help-header">
      <h3>How It Works</h3>
      <button class="close-btn" id="closeHelp">&times;</button>
    </div>
    <div class="help-content">
      <div class="help-section">
        <h4>Purpose</h4>
        <p>Master curriculum content through spaced repetition. The same concepts appear across 3 rounds with different wording - you prove understanding, not memorisation.</p>
      </div>
      
      <div class="help-section">
        <h4>How to Use</h4>
        <p>Select your curriculum, subject, and topic from the dropdowns. Complete each tab by filling in all dropdowns, then click Submit. Get 100% on all tabs to advance to the next round.</p>
      </div>
      
      <div class="help-section">
        <h4>Dropdowns</h4>
        <ul>
          <li><span class="help-color unfilled"></span> Yellow = not yet answered</li>
          <li><span class="help-color filled"></span> Blue = answered, not submitted</li>
          <li><span class="help-color correct"></span> Green = correct</li>
          <li><span class="help-color incorrect"></span> Red = incorrect</li>
        </ul>
      </div>
      
      <div class="help-section">
        <h4>Progress Dots</h4>
        <p>Three dots under each tab show round completion. Filled dots = rounds complete for that section.</p>
      </div>
      
      <div class="help-section">
        <h4>Efficiency Score</h4>
        <p>Measures how many retries you needed. 100% = all correct first try. Each resubmission lowers it slightly.</p>
      </div>
      
      <div class="help-section">
        <h4>Review Tab</h4>
        <p>Shows your progress across all rounds and highlights concepts that needed extra work.</p>
      </div>
      
      <div class="help-section">
        <h4>Email Results</h4>
        <p>Send your progress to a teacher. Their email is saved for future use.</p>
      </div>
    </div>
  </div>

  <!-- Navigation -->
  <nav class="nav-bar" id="navBar" style="display:none;">
    <div class="breadcrumb" id="breadcrumb"></div>
  </nav>

  <!-- Tabs -->
  <div class="tabs-container" id="tabsContainer">
    <div class="tabs" id="tabs"></div>
  </div>

  <!-- Main Content -->
  <main class="main">
    <div class="content" id="content">
      <!-- State Selection Screen -->
      <div class="state-select-screen" id="stateSelectScreen">
        <h1>Welcome to YouCantFakeThis</h1>
        <p>Select your curriculum to get started</p>
        <div class="state-grid" id="stateGrid"></div>
      </div>

      <!-- Welcome Screen (after state selected) -->
      <div class="welcome-screen" id="welcomeScreen" style="display:none;">
        <h2>Select a Topic</h2>
        <p>Use the navigation above to choose a subject, unit, area of study, and topic.</p>
      </div>

      <!-- Topic Content -->
      <div class="topic-content" id="topicContent"></div>

      <!-- Loading -->
      <div class="loading" id="loadingScreen" style="display:none;">
        <div class="spinner"></div>
        <p>Loading...</p>
      </div>
    </div>
  </main>

  <!-- Utilities Panel -->
  <div class="overlay" id="overlay"></div>
  <div class="utilities-panel" id="utilitiesPanel">
    <div class="utilities-header">
      <h3>Settings</h3>
      <button class="close-btn" id="closeUtilities">&times;</button>
    </div>
    <div class="utilities-content">
      <div class="utility-section">
        <h4>Your Details</h4>
        <div class="utility-input-group">
          <label for="settingsName">Your Name</label>
          <input type="text" id="settingsName" placeholder="Enter your name">
        </div>
        <div class="utility-input-group">
          <label for="settingsEmail">Teacher's Email</label>
          <input type="email" id="settingsEmail" placeholder="teacher@school.edu">
          <span class="input-error" id="emailError"></span>
        </div>
        <button class="btn utility-btn" id="saveDetailsBtn">Save Details</button>
      </div>
      <div class="utility-section">
        <h4>Current Topic</h4>
        <button class="btn utility-btn" id="resetTopicBtn">Reset Topic Progress</button>
      </div>
      <div class="utility-section">
        <h4>Curriculum</h4>
        <button class="btn utility-btn" id="changeCurriculumBtn">Change Curriculum</button>
        <p style="font-size:0.8rem;color:var(--text-muted);margin-top:4px;">Changing curriculum will clear all progress</p>
      </div>
      <div class="utility-section">
        <h4>Data</h4>
        <button class="btn utility-btn" id="exportBtn">Export Progress</button>
        <button class="btn utility-btn" id="clearAllBtn">Clear All Data</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>
  
  <!-- Dropdown Tooltip -->
  <div class="dropdown-tooltip" id="dropdownTooltip"></div>
  
  <!-- Selection Menu -->
  <div class="selection-menu" id="selectionMenu">
    <button class="selection-menu-item" data-service="google">Google AI</button>
    <button class="selection-menu-item" data-service="chatgpt">ChatGPT</button>
  </div>

  <script>
    // ==================== APP STATE ====================
    const APP = {
      // Data
      states: null,
      studyManifest: null,
      topicManifest: null,
      topicData: null,
      
      // Current selections
      currentState: null,
      currentSubject: null,
      currentUnit: null,
      currentAOS: null,
      currentTopic: null,
      
      // Topic state
      currentRound: 1,
      highestRoundReached: 1,
      currentTab: null,
      tabStates: {},
      errorTracking: {},
      
      // UI state
      submitted: false,
      
      // Tooltip state
      tooltipTimeout: null,
      tooltipTarget: null,
      lastMousePos: { x: 0, y: 0 },
      
      // Selection menu state
      selectionMenuTimeout: null,
      selectionMenuHideTimeout: null,
      
      // Base path for JSON files (adjust as needed)
      basePath: './'
    };

    // ==================== LOCAL STORAGE ====================
    const Storage = {
      prefix: 'ycft_',
      
      get(key) {
        try {
          const item = localStorage.getItem(this.prefix + key);
          return item ? JSON.parse(item) : null;
        } catch { return null; }
      },
      
      set(key, value) {
        try {
          localStorage.setItem(this.prefix + key, JSON.stringify(value));
        } catch (e) {
          console.error('Storage error:', e);
        }
      },
      
      remove(key) {
        localStorage.removeItem(this.prefix + key);
      },
      
      getTopicKey(topicId) {
        return `${APP.currentState}_${APP.currentSubject}_${topicId}`;
      },
      
      saveTopicProgress(topicId, data) {
        this.set(`topic_${this.getTopicKey(topicId)}`, data);
      },
      
      loadTopicProgress(topicId) {
        return this.get(`topic_${this.getTopicKey(topicId)}`);
      },
      
      clearTopicProgress(topicId) {
        this.remove(`topic_${this.getTopicKey(topicId)}`);
      },
      
      clearAll() {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith(this.prefix)) {
            keys.push(key);
          }
        }
        keys.forEach(k => localStorage.removeItem(k));
      }
    };

    // ==================== UTILITIES ====================
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), duration);
    }

    function showLoading(show) {
      document.getElementById('loadingScreen').style.display = show ? 'block' : 'none';
    }

    async function fetchJSON(path) {
      const fullPath = APP.basePath + path;
      try {
        const response = await fetch(fullPath);
        
        if (!response.ok) {
          const errorMsg = `Failed to load: ${path} (HTTP ${response.status})`;
          console.error(errorMsg);
          showToast(errorMsg, 5000);
          return null;
        }
        
        const text = await response.text();
        
        try {
          return JSON.parse(text);
        } catch (parseError) {
          const errorMsg = `JSON parse error in: ${path}`;
          console.error(errorMsg, parseError.message);
          showToast(`${errorMsg} - ${parseError.message}`, 5000);
          return null;
        }
        
      } catch (networkError) {
        const errorMsg = `Network error loading: ${path}`;
        console.error(errorMsg, networkError);
        showToast(`${errorMsg} - Check file exists and server is running`, 5000);
        return null;
      }
    }

    // ==================== DROPDOWN TOOLTIP ====================
    function initDropdownTooltips() {
      const container = document.getElementById('topicContent');
      
      // Track mouse movement to detect stillness
      container.addEventListener('mousemove', handleTooltipMouseMove);
      container.addEventListener('mouseleave', hideDropdownTooltip);
      
      // Hide on any click (dropdown interaction)
      container.addEventListener('mousedown', hideDropdownTooltip);
    }
    
    function handleTooltipMouseMove(e) {
      const dropdown = e.target.closest('.cloze-dropdown');
      
      // Clear any pending tooltip
      clearTimeout(APP.tooltipTimeout);
      hideDropdownTooltip();
      
      // If not over a dropdown, nothing to do
      if (!dropdown) {
        APP.tooltipTarget = null;
        return;
      }
      
      // Check if tooltip text exists
      const tooltipText = dropdown.dataset.tooltip;
      if (!tooltipText) {
        APP.tooltipTarget = null;
        return;
      }
      
      // Check conditions for showing tooltip:
      // 1. After submit has been pressed, OR
      // 2. Dropdown has been opened AND is not currently filled with a selection
      const tabState = getTabState();
      const hasBeenOpened = dropdown.dataset.opened === 'true';
      const isFilled = dropdown.classList.contains('filled');
      const isSubmitted = tabState.submitted;
      
      const shouldShowTooltip = isSubmitted || (hasBeenOpened && !isFilled);
      
      if (!shouldShowTooltip) {
        APP.tooltipTarget = null;
        return;
      }
      
      // Track current position and target
      APP.lastMousePos = { x: e.clientX, y: e.clientY };
      APP.tooltipTarget = dropdown;
      
      // Set timeout to show tooltip after delay (mouse must stay still)
      APP.tooltipTimeout = setTimeout(() => {
        // Verify mouse is still over the same dropdown
        if (APP.tooltipTarget === dropdown) {
          showDropdownTooltip(dropdown, tooltipText);
        }
      }, 800); // 800ms delay
    }
    
    function showDropdownTooltip(dropdown, text) {
      const tooltip = document.getElementById('dropdownTooltip');
      tooltip.textContent = text;
      
      // Position above the dropdown
      const rect = dropdown.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      
      // Calculate position
      let left = rect.left;
      let top = rect.top - 8; // 8px gap above dropdown
      
      // Show tooltip to measure it
      tooltip.style.left = left + 'px';
      tooltip.style.top = '0px';
      tooltip.classList.add('visible');
      
      // Now measure and adjust
      const actualHeight = tooltip.offsetHeight;
      top = rect.top - actualHeight - 8;
      
      // Keep within viewport horizontally
      const maxLeft = window.innerWidth - tooltip.offsetWidth - 10;
      if (left > maxLeft) left = maxLeft;
      if (left < 10) left = 10;
      
      // If no room above, show below
      if (top < 10) {
        top = rect.bottom + 8;
        tooltip.style.setProperty('--arrow-position', 'top');
        // Move arrow to top
        tooltip.style.cssText = `left: ${left}px; top: ${top}px;`;
        tooltip.classList.add('visible', 'arrow-top');
      } else {
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.remove('arrow-top');
      }
    }
    
    function hideDropdownTooltip() {
      clearTimeout(APP.tooltipTimeout);
      const tooltip = document.getElementById('dropdownTooltip');
      tooltip.classList.remove('visible', 'arrow-top');
    }

    // ==================== SELECTION MENU ====================
    function initSelectionMenu() {
      // Listen for selection changes
      document.addEventListener('selectionchange', handleSelectionChange);
      
      // Hide menu on click elsewhere
      document.addEventListener('mousedown', (e) => {
        const menu = document.getElementById('selectionMenu');
        if (!menu.contains(e.target)) {
          hideSelectionMenu();
        }
      });
      
      // Hide menu on scroll
      document.addEventListener('scroll', hideSelectionMenu, true);
      
      // Handle menu item clicks
      document.getElementById('selectionMenu').addEventListener('click', (e) => {
        const item = e.target.closest('.selection-menu-item');
        if (item) {
          const service = item.dataset.service;
          handleSelectionMenuClick(service);
        }
      });
    }
    
    function handleSelectionChange() {
      // Clear any pending show timeout
      clearTimeout(APP.selectionMenuTimeout);
      clearTimeout(APP.selectionMenuHideTimeout);
      
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();
      
      // Hide menu if selection is too short or empty
      if (selectedText.length < 3) {
        // Small delay before hiding to prevent flicker
        APP.selectionMenuHideTimeout = setTimeout(hideSelectionMenu, 100);
        return;
      }
      
      // Get selection position
      if (selection.rangeCount === 0) return;
      
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      
      // Don't show if selection is collapsed or has no size
      if (rect.width === 0 && rect.height === 0) {
        hideSelectionMenu();
        return;
      }
      
      // Show menu after 1 second delay
      APP.selectionMenuTimeout = setTimeout(() => {
        // Re-check selection is still valid
        const currentSelection = window.getSelection();
        const currentText = currentSelection.toString().trim();
        if (currentText.length >= 3) {
          showSelectionMenu(rect);
        }
      }, 1000);
    }
    
    function showSelectionMenu(selectionRect) {
      const menu = document.getElementById('selectionMenu');
      
      // Position above the selection, centered
      let left = selectionRect.left + (selectionRect.width / 2) - (menu.offsetWidth / 2);
      let top = selectionRect.top - menu.offsetHeight - 8;
      
      // Keep within viewport
      const maxLeft = window.innerWidth - menu.offsetWidth - 10;
      if (left > maxLeft) left = maxLeft;
      if (left < 10) left = 10;
      
      // If no room above, show below
      if (top < 10) {
        top = selectionRect.bottom + 8;
      }
      
      menu.style.left = left + 'px';
      menu.style.top = top + 'px';
      menu.classList.add('visible');
      
      // Auto-hide after 5 seconds
      clearTimeout(APP.selectionMenuHideTimeout);
      APP.selectionMenuHideTimeout = setTimeout(hideSelectionMenu, 5000);
    }
    
    function hideSelectionMenu() {
      clearTimeout(APP.selectionMenuTimeout);
      clearTimeout(APP.selectionMenuHideTimeout);
      const menu = document.getElementById('selectionMenu');
      menu.classList.remove('visible');
    }
    
    function handleSelectionMenuClick(service) {
      // Get current selection at time of click
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();
      
      if (selectedText.length < 3) {
        hideSelectionMenu();
        return;
      }
      
      const query = encodeURIComponent(selectedText + ' please explain this');
      
      let url;
      if (service === 'google') {
        url = `https://www.google.com/search?q=${query}&safe=active&ssui=on`;
      } else if (service === 'chatgpt') {
        url = `https://chatgpt.com/?q=${query}`;
      }
      
      if (url) {
        window.open(url, '_blank');
      }
      
      hideSelectionMenu();
    }

    function shuffleArray(arr) {
      const shuffled = [...arr];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // ==================== INITIALIZATION ====================
    async function init() {
      // Load states
      APP.states = await fetchJSON('states.json');
      if (!APP.states) {
        document.getElementById('stateGrid').innerHTML = '<p style="color:var(--error)">Failed to load curriculum data. Please check that states.json exists.</p>';
        return;
      }
      
      // Check for saved state
      const savedState = Storage.get('currentState');
      if (savedState) {
        await selectState(savedState, true);
      } else {
        renderStateSelection();
      }
      
      // Setup event listeners
      setupEventListeners();
      
      // Initialize selection menu
      initSelectionMenu();
      
      // EASTER EGG: Debug mode with q+w+e (all correct) or w+e+r (2/3 correct)
      const debugKeys = new Set();
      document.addEventListener('keydown', e => {
        debugKeys.add(e.key.toLowerCase());
        if (debugKeys.has('q') && debugKeys.has('w') && debugKeys.has('e')) {
          activateDebugMode();
        }
        if (debugKeys.has('w') && debugKeys.has('e') && debugKeys.has('r')) {
          activatePartialDebugMode();
        }
      });
      document.addEventListener('keyup', e => debugKeys.delete(e.key.toLowerCase()));
    }

    function setupEventListeners() {
      // Utilities panel
      document.getElementById('utilitiesBtn').onclick = () => toggleUtilities(true);
      document.getElementById('closeUtilities').onclick = () => toggleUtilities(false);
      document.getElementById('overlay').onclick = () => { toggleUtilities(false); toggleHelp(false); };
      
      // Help panel
      document.getElementById('helpBtn').onclick = () => toggleHelp(true);
      document.getElementById('closeHelp').onclick = () => toggleHelp(false);
      
      // User details
      document.getElementById('saveDetailsBtn').onclick = saveUserDetails;
      document.getElementById('settingsEmail').addEventListener('input', validateEmailInput);
      
      // Utility buttons
      document.getElementById('resetTopicBtn').onclick = resetTopic;
      document.getElementById('changeCurriculumBtn').onclick = changeCurriculum;
      document.getElementById('exportBtn').onclick = exportProgress;
      document.getElementById('clearAllBtn').onclick = clearAllData;
      
      // Keyboard shortcuts
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape') { toggleUtilities(false); toggleHelp(false); }
        if (e.key === 'Enter' && e.ctrlKey) submitAnswers();
      });
    }

    function toggleUtilities(open) {
      document.getElementById('utilitiesPanel').classList.toggle('open', open);
      document.getElementById('overlay').classList.toggle('show', open);
      
      // Load saved values when opening
      if (open) {
        document.getElementById('settingsName').value = Storage.get('studentName') || '';
        document.getElementById('settingsEmail').value = Storage.get('teacherEmail') || '';
        document.getElementById('emailError').textContent = '';
        document.getElementById('settingsEmail').classList.remove('invalid');
      }
    }
    
    function toggleHelp(open) {
      document.getElementById('helpPanel').classList.toggle('open', open);
      document.getElementById('overlay').classList.toggle('show', open);
    }
    
    function validateEmailInput() {
      const emailInput = document.getElementById('settingsEmail');
      const errorSpan = document.getElementById('emailError');
      const email = emailInput.value.trim();
      
      if (email && !isValidEmail(email)) {
        emailInput.classList.add('invalid');
        errorSpan.textContent = 'Enter a valid email address';
        return false;
      } else {
        emailInput.classList.remove('invalid');
        errorSpan.textContent = '';
        return true;
      }
    }
    
    function isValidEmail(email) {
      return email.includes('@') && email.includes('.') && email.indexOf('@') < email.lastIndexOf('.');
    }
    
    function saveUserDetails() {
      const nameInput = document.getElementById('settingsName');
      const emailInput = document.getElementById('settingsEmail');
      const name = nameInput.value.trim();
      const email = emailInput.value.trim();
      
      // Validate email if provided
      if (email && !isValidEmail(email)) {
        validateEmailInput();
        emailInput.focus();
        return;
      }
      
      // Save values
      Storage.set('studentName', name);
      Storage.set('teacherEmail', email);
      
      // Sync with Review tab fields if visible
      const reviewNameInput = document.getElementById('reviewStudentName');
      const reviewEmailInput = document.getElementById('reviewTeacherEmail');
      if (reviewNameInput) reviewNameInput.value = name;
      if (reviewEmailInput) reviewEmailInput.value = email;
      
      showToast('Details saved');
    }

    // ==================== STATE SELECTION ====================
    function renderStateSelection() {
      const grid = document.getElementById('stateGrid');
      grid.innerHTML = APP.states.states.map(state => `
        <div class="state-card ${state.active ? '' : 'disabled'}" 
             data-state-id="${state.id}" 
             onclick="${state.active ? `selectState('${state.id}')` : ''}">
          <div class="icon">${state.icon}</div>
          <div class="name">${state.name}</div>
          <div class="region">${state.region}</div>
          ${!state.active ? '<div style="font-size:0.8rem;color:var(--warning);margin-top:4px;">Coming Soon</div>' : ''}
        </div>
      `).join('');
    }

    async function selectState(stateId, isReload = false) {
      const state = APP.states.states.find(s => s.id === stateId);
      if (!state || !state.active) return;
      
      APP.currentState = stateId;
      Storage.set('currentState', stateId);
      
      // Load study manifest
      showLoading(true);
      APP.studyManifest = await fetchJSON(state.path);
      showLoading(false);
      
      if (!APP.studyManifest) {
        showToast('Failed to load curriculum data');
        return;
      }
      
      // Hide state selection, show navigation
      document.getElementById('stateSelectScreen').style.display = 'none';
      document.getElementById('navBar').style.display = 'block';
      document.getElementById('welcomeScreen').style.display = 'block';
      
      // Render breadcrumb
      renderBreadcrumb();
      
      // Restore previous selections if reloading
      if (isReload) {
        const savedSubject = Storage.get('currentSubject');
        if (savedSubject) {
          await selectSubject(savedSubject);
        }
      }
    }

    // ==================== NAVIGATION ====================
    function renderBreadcrumb() {
      const bc = document.getElementById('breadcrumb');
      
      // State display
      const state = APP.states.states.find(s => s.id === APP.currentState);
      const isAustralian = state.id.includes('AU');
      
      let html = `
        <div class="breadcrumb-item">
          <span><span id="stateFlag" data-original="${state.icon}" data-au="${isAustralian}">${state.icon}</span> ${state.name}</span>
        </div>
        <span class="breadcrumb-sep">‚Ä∫</span>
        <div class="breadcrumb-item">
          <select id="subjectSelect" onchange="selectSubject(this.value)">
            <option value="">Select Subject</option>
            ${APP.studyManifest.subjects.map(s => 
              `<option value="${s.id}" ${s.status !== 'available' ? 'disabled' : ''} ${APP.currentSubject === s.id ? 'selected' : ''}>
                ${s.icon} ${s.name}${s.status !== 'available' ? ' (Coming Soon)' : ''}
              </option>`
            ).join('')}
          </select>
        </div>
      `;
      
      // Unit select
      if (APP.currentSubject && APP.topicManifest) {
        html += `
          <span class="breadcrumb-sep">‚Ä∫</span>
          <div class="breadcrumb-item">
            <select id="unitSelect" onchange="selectUnit(this.value)">
              <option value="">Select Unit</option>
              ${APP.topicManifest.units.map(u => 
                `<option value="${u.id}" ${APP.currentUnit === u.id ? 'selected' : ''}>${u.code}</option>`
              ).join('')}
            </select>
          </div>
        `;
      }
      
      // AOS select
      if (APP.currentUnit) {
        const unit = APP.topicManifest.units.find(u => u.id === APP.currentUnit);
        if (unit) {
          html += `
            <span class="breadcrumb-sep">‚Ä∫</span>
            <div class="breadcrumb-item">
              <select id="aosSelect" onchange="selectAOS(this.value)">
                <option value="">Select AOS</option>
                ${unit.areasOfStudy.map(a => 
                  `<option value="${a.id}" ${APP.currentAOS === a.id ? 'selected' : ''}>${a.code}</option>`
                ).join('')}
              </select>
            </div>
          `;
        }
      }
      
      // Topic select (custom dropdown with tooltips)
      if (APP.currentAOS) {
        const unit = APP.topicManifest.units.find(u => u.id === APP.currentUnit);
        const aos = unit?.areasOfStudy.find(a => a.id === APP.currentAOS);
        if (aos) {
          const selectedTopic = aos.topics.find(t => t.id === APP.currentTopic);
          const displayText = selectedTopic 
            ? `${selectedTopic.code}. ${selectedTopic.name}` 
            : 'Select Topic';
          
          html += `
            <span class="breadcrumb-sep">‚Ä∫</span>
            <div class="breadcrumb-item">
              <div class="custom-dropdown" id="topicDropdown">
                <div class="custom-dropdown-trigger" onclick="toggleTopicDropdown()">
                  <span class="dropdown-text">${displayText}</span>
                  <span class="dropdown-arrow">‚ñº</span>
                </div>
                <div class="custom-dropdown-menu">
                  <div class="custom-dropdown-option ${!APP.currentTopic ? 'selected' : ''}" 
                       data-value="" 
                       onclick="selectTopicOption('')">
                    <span class="option-name">Select Topic</span>
                  </div>
                  ${aos.topics.map(t => `
                    <div class="custom-dropdown-option ${t.status !== 'available' ? 'disabled' : ''} ${APP.currentTopic === t.id ? 'selected' : ''}" 
                         data-value="${t.id}"
                         data-subtitle="${t.subtitle || ''}"
                         onclick="${t.status === 'available' ? `selectTopicOption('${t.id}')` : ''}"
                         onmouseenter="showOptionTooltip(event, '${(t.subtitle || '').replace(/'/g, "\\'")}')"
                         onmouseleave="hideOptionTooltip()">
                      <span class="option-name">${t.code}. ${t.name}</span>
                      ${t.status !== 'available' ? '<span class="option-status">(Coming Soon)</span>' : ''}
                    </div>
                  `).join('')}
                </div>
              </div>
            </div>
          `;
        }
      }
      
      bc.innerHTML = html;
      
      // Close dropdown when clicking outside
      document.addEventListener('click', closeTopicDropdownOnClickOutside);
    }

    async function selectSubject(subjectId) {
      if (!subjectId) return;
      
      APP.currentSubject = subjectId;
      APP.currentUnit = null;
      APP.currentAOS = null;
      APP.currentTopic = null;
      
      // Return to welcome screen if a topic was loaded
      returnToTopicSelection();
      
      Storage.set('currentSubject', subjectId);
      
      // Load topic manifest
      const subject = APP.studyManifest.subjects.find(s => s.id === subjectId);
      if (!subject) return;
      
      showLoading(true);
      APP.topicManifest = await fetchJSON(`${APP.currentState}/${subject.path}`);
      showLoading(false);
      
      if (!APP.topicManifest) {
        showToast('Failed to load subject data');
        return;
      }
      
      // Update theme colors
      if (APP.topicManifest.colorTheme) {
        document.documentElement.style.setProperty('--primary', APP.topicManifest.colorTheme.primary);
        document.documentElement.style.setProperty('--secondary', APP.topicManifest.colorTheme.secondary);
        document.documentElement.style.setProperty('--gradient', APP.topicManifest.colorTheme.gradient);
        document.querySelector('.header').style.background = APP.topicManifest.colorTheme.gradient;
      }
      
      renderBreadcrumb();
    }

    function selectUnit(unitId) {
      APP.currentUnit = unitId || null;
      APP.currentAOS = null;
      APP.currentTopic = null;
      
      // Return to welcome screen if a topic was loaded
      returnToTopicSelection();
      
      renderBreadcrumb();
    }

    function selectAOS(aosId) {
      APP.currentAOS = aosId || null;
      APP.currentTopic = null;
      
      // Return to welcome screen if a topic was loaded
      returnToTopicSelection();
      
      renderBreadcrumb();
    }

    // Custom dropdown functions
    let optionTooltipTimeout = null;
    
    function toggleTopicDropdown() {
      const dropdown = document.getElementById('topicDropdown');
      if (dropdown) {
        dropdown.classList.toggle('open');
      }
    }
    
    function closeTopicDropdown() {
      const dropdown = document.getElementById('topicDropdown');
      if (dropdown) {
        dropdown.classList.remove('open');
      }
      hideOptionTooltip();
    }
    
    function closeTopicDropdownOnClickOutside(e) {
      const dropdown = document.getElementById('topicDropdown');
      if (dropdown && !dropdown.contains(e.target)) {
        dropdown.classList.remove('open');
        hideOptionTooltip();
      }
    }
    
    function selectTopicOption(topicId) {
      closeTopicDropdown();
      selectTopicFromMenu(topicId);
    }
    
    function showOptionTooltip(event, subtitle) {
      if (!subtitle) return;
      
      // Clear any pending tooltip
      if (optionTooltipTimeout) {
        clearTimeout(optionTooltipTimeout);
      }
      
      const tooltip = document.getElementById('dropdownTooltip');
      const option = event.target.closest('.custom-dropdown-option');
      
      // Store which option we're hovering
      tooltip.dataset.targetOption = option?.dataset.value || '';
      
      // Show tooltip after delay
      optionTooltipTimeout = setTimeout(() => {
        // Check if still hovering same option
        if (tooltip.dataset.targetOption !== (option?.dataset.value || '')) return;
        
        tooltip.textContent = subtitle;
        
        const rect = option.getBoundingClientRect();
        tooltip.style.left = (rect.right + 8) + 'px';
        tooltip.style.top = rect.top + 'px';
        
        // Check if tooltip would go off screen right
        const tooltipRect = tooltip.getBoundingClientRect();
        if (rect.right + 8 + 220 > window.innerWidth) {
          // Position to the left instead
          tooltip.style.left = (rect.left - 228) + 'px';
        }
        
        tooltip.classList.add('show');
      }, 800);
    }
    
    function hideOptionTooltip() {
      if (optionTooltipTimeout) {
        clearTimeout(optionTooltipTimeout);
        optionTooltipTimeout = null;
      }
      
      const tooltip = document.getElementById('dropdownTooltip');
      tooltip.classList.remove('show');
      tooltip.dataset.targetOption = '';
    }

    async function selectTopicFromMenu(topicId) {
      APP.currentTopic = topicId || null;
      
      // Auto-load the topic if one is selected
      if (topicId) {
        await loadSelectedTopic();
      } else {
        returnToTopicSelection();
      }
    }
    
    function returnToTopicSelection() {
      // Only do something if a topic is currently loaded
      if (APP.topicData) {
        // Clear topic state
        APP.topicData = null;
        APP.currentTab = null;
        APP.tabStates = {};
        APP.errorTracking = {};
        
        // Hide topic-related UI
        document.getElementById('topicContent').classList.remove('active');
        document.getElementById('tabsContainer').classList.remove('active');
        
        // Show welcome screen
        document.getElementById('welcomeScreen').style.display = 'block';
        
        // Update header
        document.getElementById('roundPills').innerHTML = '';
        document.getElementById('totalScoreDisplay').textContent = '';
      }
    }

    async function loadSelectedTopic() {
      if (!APP.currentTopic) return;
      
      const unit = APP.topicManifest.units.find(u => u.id === APP.currentUnit);
      const aos = unit?.areasOfStudy.find(a => a.id === APP.currentAOS);
      const topic = aos?.topics.find(t => t.id === APP.currentTopic);
      
      if (!topic || topic.status !== 'available') {
        showToast('Topic not available');
        return;
      }
      
      // Load topic data
      showLoading(true);
      const subject = APP.studyManifest.subjects.find(s => s.id === APP.currentSubject);
      APP.topicData = await fetchJSON(`${APP.currentState}/${APP.currentSubject}/${topic.filename}`);
      showLoading(false);
      
      if (!APP.topicData) {
        showToast('Failed to load topic');
        return;
      }
      
      // Validate topic data structure
      if (!APP.topicData.metadata || !APP.topicData.metadata.id) {
        showToast('Invalid topic file: missing metadata');
        console.error('Topic data missing metadata:', APP.topicData);
        APP.topicData = null;
        return;
      }
      
      if (!APP.topicData.tabs || !Array.isArray(APP.topicData.tabs) || APP.topicData.tabs.length === 0) {
        showToast('Invalid topic file: missing tabs');
        console.error('Topic data missing tabs:', APP.topicData);
        APP.topicData = null;
        return;
      }
      
      if (!APP.topicData.content) {
        showToast('Invalid topic file: missing content');
        console.error('Topic data missing content:', APP.topicData);
        APP.topicData = null;
        return;
      }
      
      // Load saved progress
      const savedProgress = Storage.loadTopicProgress(APP.topicData.metadata.id);
      if (savedProgress) {
        APP.currentRound = savedProgress.currentRound || 1;
        APP.highestRoundReached = savedProgress.highestRoundReached || savedProgress.currentRound || 1;
        APP.tabStates = savedProgress.tabStates || {};
        APP.errorTracking = savedProgress.errorTracking || {};
      } else {
        APP.currentRound = 1;
        APP.highestRoundReached = 1;
        APP.tabStates = {};
        APP.errorTracking = {};
      }
      
      // Initialize tab states for current round
      APP.topicData.tabs.forEach(tab => {
        const key = `round${APP.currentRound}_${tab.id}`;
        if (!APP.tabStates[key]) {
          APP.tabStates[key] = {
            selections: {},
            results: {},
            submitted: false,
            attempts: 0,
            bestScore: 0,
            complete: false,
            opened: {}
          };
        }
      });
      
      // Set first tab
      APP.currentTab = APP.topicData.tabs[0].id;
      
      // Render
      document.getElementById('welcomeScreen').style.display = 'none';
      document.getElementById('tabsContainer').classList.add('active');
      
      renderTabs();
      renderContent();
      updateHeader();
    }

    // ==================== TABS ====================
    function renderTabs() {
      const tabsEl = document.getElementById('tabs');
      
      // Content tabs
      let html = APP.topicData.tabs.map(tab => {
        const isActive = tab.id === APP.currentTab;
        
        // Calculate progress dots
        const dots = [1, 2, 3].map(round => {
          const key = `round${round}_${tab.id}`;
          const state = APP.tabStates[key];
          if (state?.complete) return 'complete';
          if (round === APP.currentRound && tab.id === APP.currentTab) return 'current';
          return '';
        });
        
        return `
          <button class="tab ${isActive ? 'active' : ''}" onclick="switchTab('${tab.id}')">
            <span class="tab-icon">${tab.icon}</span>
            <span class="tab-label">${tab.label}</span>
            <div class="tab-progress">
              ${dots.map(d => `<div class="progress-dot ${d}"></div>`).join('')}
            </div>
          </button>
        `;
      }).join('');
      
      // Add Review tab at the end
      const isReviewActive = APP.currentTab === '_review';
      html += `
        <button class="tab review-tab ${isReviewActive ? 'active' : ''}" onclick="switchTab('_review')">
          <span class="tab-icon">üìã</span>
          <span class="tab-label">Review</span>
        </button>
      `;
      
      tabsEl.innerHTML = html;
    }

    function switchTab(tabId) {
      // Stop any pulsing invitation
      stopTabPulse();
      
      // Hide any visible tooltip
      hideDropdownTooltip();
      
      APP.currentTab = tabId;
      APP.submitted = false;
      renderTabs();
      
      if (tabId === '_review') {
        renderReviewContent();
      } else {
        renderContent();
      }
      updateControlPanel();
    }

    // ==================== CONTENT RENDERING ====================
    function renderContent() {
      // If on review tab, render review content instead
      if (APP.currentTab === '_review') {
        renderReviewContent();
        return;
      }
      
      const container = document.getElementById('topicContent');
      container.classList.add('active');
      
      const roundKey = `round${APP.currentRound}`;
      const tabContent = APP.topicData.content[roundKey]?.[APP.currentTab];
      
      if (!tabContent) {
        container.innerHTML = '<p>Content not available for this section.</p>';
        return;
      }
      
      const tabState = getTabState();
      
      // Dot point reference (collapsible)
      const dotPoint = APP.topicData.metadata?.dotPoint;
      let html = '';
      
      if (dotPoint) {
        html += `
          <div class="dot-point-ref collapsible" onclick="this.classList.toggle('open')">
            <div class="collapsible-header">
              <span>Curriculum Reference</span>
              <span class="collapsible-icon">‚ñ∂</span>
            </div>
            <div class="collapsible-content">${dotPoint}</div>
          </div>
        `;
      }
      
      html += `
        <div class="section-title">${tabContent.title}</div>
        <div class="section-instructions">${tabContent.instructions}</div>
      `;
      
      tabContent.sentences.forEach((sentence, sIdx) => {
        html += `<div class="sentence" data-sentence="${sIdx}">`;
        
        // Parse sentence and insert dropdowns
        let text = sentence.text;
        const questionIds = Object.keys(sentence.questions);
        
        questionIds.forEach(qId => {
          const q = sentence.questions[qId];
          const placeholder = `{{${qId}}}`;
          
          // Build options
          const options = shuffleOptionsWithCorrect(q.correct, q.distractors, `${sIdx}_${qId}`);
          const selected = tabState.selections[qId] || '';
          const result = tabState.results[qId];
          const hasBeenOpened = tabState.opened?.[qId] || false;
          
          let selectClass = 'cloze-dropdown';
          if (selected) selectClass += ' filled';
          if (result === true) selectClass += ' correct';
          if (result === false) selectClass += ' incorrect';
          if (tabState.complete) selectClass += ' readonly';
          
          const optionsHtml = options.map(opt => 
            `<option value="${opt}" ${selected === opt ? 'selected' : ''}>${opt}</option>`
          ).join('');
          
          // Escape tooltip text for HTML attribute
          const tooltipText = (q.tooltip || '').replace(/"/g, '&quot;');
          
          const dropdown = `
            <select class="${selectClass}" 
                    data-question="${qId}" 
                    data-concept="${q.concept}"
                    data-correct="${q.correct}"
                    data-tooltip="${tooltipText}"
                    data-opened="${hasBeenOpened}"
                    onchange="handleSelection(this)"
                    onclick="markDropdownOpened(this)"
                    onfocus="markDropdownOpened(this)">
              <option value="">Select...</option>
              ${optionsHtml}
            </select>
          `;
          
          text = text.replace(placeholder, dropdown);
        });
        
        html += text;
        
        // Add inline feedback for incorrect answers
        questionIds.forEach(qId => {
          const q = sentence.questions[qId];
          const result = tabState.results[qId];
          const selected = tabState.selections[qId];
          
          if (result === false && selected) {
            const concept = APP.topicData.concepts[q.concept];
            const wrongFeedback = concept?.wrong?.[selected];
            
            html += `
              <div class="feedback-inline show" data-feedback="${qId}">
                <div class="error-label">‚úó ${concept?.name || q.concept}</div>
                ${wrongFeedback?.error ? `<div class="error-what">${wrongFeedback.error}</div>` : ''}
                <div class="fix">${wrongFeedback?.fix || concept?.correct || 'Review this concept.'}</div>
                ${wrongFeedback?.action ? `<div class="action">‚Üí ${wrongFeedback.action}</div>` : ''}
              </div>
            `;
          }
        });
        
        html += '</div>';
      });
      
      // Add inline control panel after sentences
      html += `
        <div class="inline-controls">
          <div class="control-row">
            <div class="control-left">
              <button class="btn btn-secondary" id="resetSectionBtn" onclick="resetSection()">Reset Section</button>
            </div>
            <div class="control-center">
              <span class="score-display" id="scoreDisplay">Score: 0/0</span>
              <span class="attempt-display" id="attemptDisplay">Attempt 1</span>
            </div>
            <div class="control-right">
              <button class="btn btn-success" id="submitBtn" onclick="submitAnswers()">Submit</button>
            </div>
          </div>
          <div class="feedback-summary" id="feedbackSummary"></div>
        </div>
      `;
      
      container.innerHTML = html;
      
      // Initialize tooltip listeners for dropdowns
      initDropdownTooltips();
      
      updateControlPanel();
    }

    function shuffleOptionsWithCorrect(correct, distractors, seed) {
      // Use seed for consistent shuffling within session
      const all = [correct, ...distractors];
      return shuffleArray(all);
    }

    function handleSelection(select) {
      // Hide tooltip immediately on interaction
      hideDropdownTooltip();
      
      const qId = select.dataset.question;
      const tabState = getTabState();
      
      // If tab is complete (readonly), revert to the saved value
      if (tabState.complete) {
        const savedValue = tabState.selections[qId] || '';
        if (select.value !== savedValue) {
          select.value = savedValue;
          showToast('This section is complete - view only');
        }
        return;
      }
      
      tabState.selections[qId] = select.value;
      
      // Update visual state
      if (select.value) {
        select.classList.add('filled');
      } else {
        // Reset to unfilled state - remove all styling classes
        select.classList.remove('filled', 'correct', 'incorrect');
        delete tabState.results[qId];
        
        // Hide feedback if any
        const feedback = document.querySelector(`[data-feedback="${qId}"]`);
        if (feedback) feedback.remove();
      }
      
      // Clear previous result if reselecting (and has a value)
      if (tabState.submitted && select.value) {
        select.classList.remove('correct', 'incorrect');
        delete tabState.results[qId];
        
        // Hide feedback
        const feedback = document.querySelector(`[data-feedback="${qId}"]`);
        if (feedback) feedback.remove();
      }
      
      saveProgress();
      updateControlPanel();
    }

    function markDropdownOpened(select) {
      const qId = select.dataset.question;
      const tabState = getTabState();
      
      // Initialize opened tracking if needed
      if (!tabState.opened) {
        tabState.opened = {};
      }
      
      // Mark this dropdown as having been opened
      if (!tabState.opened[qId]) {
        tabState.opened[qId] = true;
        select.dataset.opened = 'true';
        saveProgress();
      }
    }

    // ==================== SUBMISSION ====================
    function submitAnswers() {
      const tabState = getTabState();
      const roundKey = `round${APP.currentRound}`;
      const tabContent = APP.topicData.content[roundKey]?.[APP.currentTab];
      
      if (!tabContent) return;
      
      tabState.attempts++;
      tabState.submitted = true;
      
      let correct = 0;
      let total = 0;
      
      // Grade all questions
      tabContent.sentences.forEach(sentence => {
        Object.entries(sentence.questions).forEach(([qId, q]) => {
          total++;
          const selected = tabState.selections[qId];
          const isCorrect = selected === q.correct;
          
          tabState.results[qId] = isCorrect;
          
          if (isCorrect) {
            correct++;
          } else {
            // Track error
            trackError(q.concept, selected);
          }
        });
      });
      
      // Update score
      const score = correct;
      if (score > tabState.bestScore) {
        tabState.bestScore = score;
      }
      
      // Check if complete
      const isComplete = correct === total;
      if (isComplete) {
        tabState.complete = true;
      }
      
      saveProgress();
      renderContent();
      updateControlPanel();
      
      // Update tabs immediately to show green dot if complete
      renderTabs();
      
      // Show feedback summary
      const summary = document.getElementById('feedbackSummary');
      if (isComplete) {
        summary.textContent = 'All correct.';
        summary.className = 'feedback-summary success';
        
        // Check round completion and pulse next tab after brief delay
        checkRoundComplete();
        setTimeout(() => pulseNextTab(), 400);
      } else {
        summary.textContent = `${correct}/${total} correct. Review the feedback below.`;
        summary.className = 'feedback-summary error';
      }
    }
    
    function pulseNextTab() {
      // Stop any existing pulse
      stopTabPulse();
      
      const tabs = APP.topicData.tabs;
      const currentTabIndex = tabs.findIndex(t => t.id === APP.currentTab);
      
      // Check if all rounds complete (topic finished)
      let allRoundsComplete = true;
      for (let r = 1; r <= 3; r++) {
        tabs.forEach(tab => {
          const key = `round${r}_${tab.id}`;
          if (!APP.tabStates[key]?.complete) {
            allRoundsComplete = false;
          }
        });
      }
      
      if (allRoundsComplete) {
        // Pulse the Review tab
        pulseTab('_review');
        return;
      }
      
      // Find next incomplete tab in current round
      for (let i = currentTabIndex + 1; i < tabs.length; i++) {
        const key = `round${APP.currentRound}_${tabs[i].id}`;
        if (!APP.tabStates[key]?.complete) {
          pulseTab(tabs[i].id);
          return;
        }
      }
      
      // Check from beginning of current round
      for (let i = 0; i < currentTabIndex; i++) {
        const key = `round${APP.currentRound}_${tabs[i].id}`;
        if (!APP.tabStates[key]?.complete) {
          pulseTab(tabs[i].id);
          return;
        }
      }
      
      // Current round complete - pulse first tab (will be next round after checkRoundComplete)
      pulseTab(tabs[0].id);
    }
    
    function pulseTab(tabId) {
      const tabsContainer = document.getElementById('tabs');
      const tabButtons = tabsContainer.querySelectorAll('.tab');
      
      tabButtons.forEach(btn => {
        // Match by tab id - check onclick attribute or data
        const isReviewTab = btn.classList.contains('review-tab');
        const btnTabId = isReviewTab ? '_review' : btn.getAttribute('onclick')?.match(/switchTab\('(.+)'\)/)?.[1];
        
        if (btnTabId === tabId) {
          btn.classList.add('pulse');
          
          // Auto-scroll to make pulsing tab visible
          btn.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
        }
      });
    }
    
    function stopTabPulse() {
      document.querySelectorAll('.tab.pulse').forEach(el => {
        el.classList.remove('pulse');
      });
    }

    function trackError(conceptId, wrongAnswer) {
      if (!APP.errorTracking[conceptId]) {
        APP.errorTracking[conceptId] = {
          count: 0,
          rounds: [],
          wrongAnswers: []
        };
      }
      
      APP.errorTracking[conceptId].count++;
      if (!APP.errorTracking[conceptId].rounds.includes(APP.currentRound)) {
        APP.errorTracking[conceptId].rounds.push(APP.currentRound);
      }
      APP.errorTracking[conceptId].wrongAnswers.push(wrongAnswer);
    }

    function checkRoundComplete() {
      // Check if all tabs in current round are complete
      const allComplete = APP.topicData.tabs.every(tab => {
        const key = `round${APP.currentRound}_${tab.id}`;
        return APP.tabStates[key]?.complete;
      });
      
      if (allComplete) {
        if (APP.currentRound < 3) {
          showToast(`Round ${APP.currentRound} complete. Moving to Round ${APP.currentRound + 1}`);
          APP.currentRound++;
          
          // Update highest round reached
          if (APP.currentRound > APP.highestRoundReached) {
            APP.highestRoundReached = APP.currentRound;
          }
          
          // Initialize new round tab states
          APP.topicData.tabs.forEach(tab => {
            const key = `round${APP.currentRound}_${tab.id}`;
            if (!APP.tabStates[key]) {
              APP.tabStates[key] = {
                selections: {},
                results: {},
                submitted: false,
                attempts: 0,
                bestScore: 0,
                complete: false,
                opened: {}
              };
            }
          });
          
          saveProgress();
          renderTabs();
          renderContent();
          updateHeader();
        } else {
          // All 3 rounds complete
          APP.highestRoundReached = 3;
          showToast('Topic complete. View your review.');
          switchTab('_review');
        }
      }
    }

    // ==================== CONTROL PANEL ====================
    function updateControlPanel() {
      const tabState = getTabState();
      const roundKey = `round${APP.currentRound}`;
      const tabContent = APP.topicData.content[roundKey]?.[APP.currentTab];
      
      if (!tabContent) return;
      
      // Get all question IDs for this tab
      const questionIds = [];
      tabContent.sentences.forEach(s => {
        Object.keys(s.questions).forEach(qId => questionIds.push(qId));
      });
      const total = questionIds.length;
      
      // Count filled dropdowns (only for questions in this tab)
      let filled = 0;
      questionIds.forEach(qId => {
        if (tabState.selections[qId]) filled++;
      });
      
      // Count correct (only for questions in this tab)
      let correct = 0;
      questionIds.forEach(qId => {
        if (tabState.results[qId] === true) correct++;
      });
      
      document.getElementById('scoreDisplay').textContent = `Score: ${correct}/${total}`;
      document.getElementById('attemptDisplay').textContent = `Attempt ${tabState.attempts || 1}`;
      
      // Update submit button - disable if not all dropdowns are filled
      const submitBtn = document.getElementById('submitBtn');
      const allFilled = filled === total;
      
      if (tabState.complete) {
        submitBtn.textContent = '‚úì Complete';
        submitBtn.disabled = true;
      } else if (!allFilled) {
        submitBtn.textContent = tabState.submitted ? 'Resubmit' : 'Submit';
        submitBtn.disabled = true;
      } else if (tabState.submitted) {
        submitBtn.textContent = 'Resubmit';
        submitBtn.disabled = false;
      } else {
        submitBtn.textContent = 'Submit';
        submitBtn.disabled = false;
      }
    }

    function updateHeader() {
      renderRoundPills();
      
      // Calculate total score
      let totalCorrect = 0;
      let totalQuestions = 0;
      
      Object.entries(APP.tabStates).forEach(([key, state]) => {
        if (key.startsWith('round')) {
          totalCorrect += state.bestScore || 0;
          // Count questions for that tab
          const [, round, tab] = key.match(/round(\d)_(.+)/) || [];
          if (round && tab) {
            const content = APP.topicData.content[`round${round}`]?.[tab];
            if (content) {
              content.sentences.forEach(s => {
                totalQuestions += Object.keys(s.questions).length;
              });
            }
          }
        }
      });
      
      if (totalQuestions > 0) {
        const pct = Math.round(totalCorrect / totalQuestions * 100);
        document.getElementById('totalScoreDisplay').textContent = `Total: ${totalCorrect}/${totalQuestions} (${pct}%)`;
      }
    }
    
    function renderRoundPills() {
      const container = document.getElementById('roundPills');
      if (!container || !APP.topicData) return;
      
      let html = '';
      
      for (let round = 1; round <= 3; round++) {
        // Check if this round is complete (all tabs complete)
        const roundComplete = APP.topicData.tabs.every(tab => {
          const key = `round${round}_${tab.id}`;
          return APP.tabStates[key]?.complete;
        });
        
        // Determine pill state
        let pillClass = 'round-pill';
        let clickable = false;
        let label = `R${round}`;
        
        if (round === APP.currentRound) {
          // Current round - highlighted, not clickable
          pillClass += ' current';
        } else if (roundComplete) {
          // Completed round - green with checkmark, clickable
          pillClass += ' complete';
          clickable = true;
          label = `R${round}<span class="pill-check">‚úì</span>`;
        } else if (round <= APP.highestRoundReached) {
          // Unlocked but not complete - available to navigate
          pillClass += ' available';
          clickable = true;
        } else {
          // Future round - locked
          pillClass += ' locked';
        }
        
        if (clickable) {
          html += `<button class="${pillClass}" onclick="switchRound(${round})">${label}</button>`;
        } else {
          html += `<span class="${pillClass}">${label}</span>`;
        }
      }
      
      container.innerHTML = html;
    }
    
    function switchRound(round) {
      if (round === APP.currentRound) return;
      
      // Allow switching to any round up to and including highestRoundReached
      if (round > APP.highestRoundReached) {
        showToast('Complete current round first');
        return;
      }
      
      APP.currentRound = round;
      
      // Initialize tab states for this round if needed
      APP.topicData.tabs.forEach(tab => {
        const key = `round${APP.currentRound}_${tab.id}`;
        if (!APP.tabStates[key]) {
          APP.tabStates[key] = {
            selections: {},
            results: {},
            submitted: false,
            attempts: 0,
            bestScore: 0,
            complete: false,
            opened: {}
          };
        }
      });
      
      // Switch to first content tab (not review)
      APP.currentTab = APP.topicData.tabs[0].id;
      
      saveProgress();
      renderTabs();
      renderContent();
      updateHeader();
      updateControlPanel();
      
      showToast(`Viewing Round ${round}`);
    }

    // ==================== RESET FUNCTIONS ====================
    function resetSection() {
      const btn = document.getElementById('resetSectionBtn');
      
      if (btn.classList.contains('confirm')) {
        // Actually reset
        const tabState = getTabState();
        tabState.selections = {};
        tabState.results = {};
        tabState.submitted = false;
        tabState.complete = false;
        tabState.opened = {}; // Clear opened tracking for fresh start
        // Keep attempts count
        
        saveProgress();
        renderContent();
        updateControlPanel();
        
        btn.textContent = 'Reset Section';
        btn.classList.remove('confirm');
        
        document.getElementById('feedbackSummary').textContent = '';
        showToast('Section reset');
      } else {
        // Ask for confirmation
        btn.textContent = 'Confirm Reset?';
        btn.classList.add('confirm');
        
        setTimeout(() => {
          btn.textContent = 'Reset Section';
          btn.classList.remove('confirm');
        }, 3000);
      }
    }

    function resetTopic() {
      const btn = document.getElementById('resetTopicBtn');
      
      if (btn.classList.contains('confirm')) {
        if (APP.topicData) {
          Storage.clearTopicProgress(APP.topicData.metadata.id);
          APP.currentRound = 1;
          APP.tabStates = {};
          APP.errorTracking = {};
          
          // Reinitialize
          APP.topicData.tabs.forEach(tab => {
            const key = `round1_${tab.id}`;
            APP.tabStates[key] = {
              selections: {},
              results: {},
              submitted: false,
              attempts: 0,
              bestScore: 0,
              complete: false
            };
          });
          
          APP.currentTab = APP.topicData.tabs[0].id;
          
          renderTabs();
          renderContent();
          updateHeader();
          updateControlPanel();
          
          document.getElementById('feedbackSummary').textContent = '';
        }
        
        btn.textContent = 'Reset Topic Progress';
        btn.classList.remove('confirm');
        toggleUtilities(false);
        showToast('Topic progress reset');
      } else {
        btn.textContent = 'Confirm Reset?';
        btn.classList.add('confirm');
        
        setTimeout(() => {
          btn.textContent = 'Reset Topic Progress';
          btn.classList.remove('confirm');
        }, 3000);
      }
    }

    function changeCurriculum() {
      const btn = document.getElementById('changeCurriculumBtn');
      
      if (btn.classList.contains('confirm')) {
        Storage.clearAll();
        location.reload();
      } else {
        btn.textContent = 'Confirm? All progress will be cleared';
        btn.classList.add('confirm');
        
        setTimeout(() => {
          btn.textContent = 'Change Curriculum';
          btn.classList.remove('confirm');
        }, 3000);
      }
    }

    function clearAllData() {
      const btn = document.getElementById('clearAllBtn');
      
      if (btn.classList.contains('confirm')) {
        Storage.clearAll();
        location.reload();
      } else {
        btn.textContent = 'Confirm? All data will be cleared';
        btn.classList.add('confirm');
        
        setTimeout(() => {
          btn.textContent = 'Clear All Data';
          btn.classList.remove('confirm');
        }, 3000);
      }
    }

    function exportProgress() {
      const data = {
        exported: new Date().toISOString(),
        currentState: APP.currentState,
        currentSubject: APP.currentSubject,
        topicProgress: {}
      };
      
      // Gather all topic progress
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('ycft_topic_')) {
          data.topicProgress[key] = JSON.parse(localStorage.getItem(key));
        }
      }
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `youcantfakethis-progress-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast('Progress exported');
    }

    // ==================== REVIEW TAB ====================
    function renderReviewContent() {
      const container = document.getElementById('topicContent');
      container.classList.add('active');
      
      // Gather stats for all submitted sections
      let totalAttempts = 0;
      let totalRetries = 0;
      let sectionsSubmitted = 0;
      let sectionsComplete = 0;
      let totalSections = APP.topicData.tabs.length * 3; // tabs √ó rounds
      let totalQuestions = 0;
      
      const sectionData = [];
      
      // Collect data for each tab across all rounds
      APP.topicData.tabs.forEach(tab => {
        for (let round = 1; round <= 3; round++) {
          const key = `round${round}_${tab.id}`;
          const state = APP.tabStates[key];
          
          // Count questions in this section
          const content = APP.topicData.content[`round${round}`]?.[tab.id];
          let questionCount = 0;
          if (content) {
            content.sentences.forEach(s => {
              questionCount += Object.keys(s.questions).length;
            });
          }
          
          // Always count total questions (for efficiency calculation)
          totalQuestions += questionCount;
          
          if (state && state.attempts > 0) {
            sectionsSubmitted++;
            totalAttempts += state.attempts;
            totalRetries += Math.max(0, state.attempts - 1);
            
            if (state.complete) {
              sectionsComplete++;
            }
            
            // Count current wrong answers
            let wrongCount = 0;
            if (state.results) {
              Object.values(state.results).forEach(r => {
                if (r === false) wrongCount++;
              });
            }
            
            sectionData.push({
              tab: tab,
              round: round,
              attempts: state.attempts,
              complete: state.complete,
              wrongCount: wrongCount,
              questionCount: questionCount
            });
          }
        }
      });
      
      // Calculate efficiency: questions / (questions + retries) * 100
      // 100% = all correct first try, decreases with each retry needed
      const efficiencyScore = totalQuestions > 0 
        ? Math.round((totalQuestions / (totalQuestions + totalRetries)) * 100) 
        : 0;
      
      // Check if topic is complete
      let allComplete = sectionsComplete === totalSections;
      
      // Get saved details for email section
      const savedName = Storage.get('studentName') || '';
      const savedEmail = Storage.get('teacherEmail') || '';
      
      // Get curriculum details for email
      const metadata = APP.topicData.metadata;
      const unitInfo = APP.topicManifest?.units?.find(u => u.id === metadata.unit);
      const aosInfo = unitInfo?.areasOfStudy?.find(a => a.id === metadata.aos);
      
      // Build HTML - Start with email section
      let html = `
        <div class="review-email-section">
          <div class="review-email-header">Send Results to Teacher</div>
          <div class="review-email-fields">
            <div class="review-email-field">
              <label for="reviewStudentName">Your Name</label>
              <input type="text" id="reviewStudentName" value="${savedName.replace(/"/g, '&quot;')}" 
                     placeholder="Enter your name" onchange="syncStudentName(this)">
            </div>
            <div class="review-email-field">
              <label for="reviewTeacherEmail">Teacher's Email</label>
              <input type="email" id="reviewTeacherEmail" value="${savedEmail.replace(/"/g, '&quot;')}" 
                     placeholder="teacher@school.edu" onchange="syncTeacherEmail(this)">
            </div>
            <div class="review-email-field review-email-button">
              <button class="btn btn-primary" onclick="sendReviewEmail()">
                üìß ${allComplete ? 'Email Results' : 'Email Progress'}
              </button>
            </div>
          </div>
        </div>
        
        <div class="section-title">Performance Review</div>
        <div class="section-instructions">
          ${sectionsSubmitted > 0 
            ? `${sectionsComplete}/${totalSections} sections complete | Efficiency: ${efficiencyScore}%`
            : 'Submit answers in the content tabs to see your progress here.'}
        </div>
      `;
      
      if (sectionsSubmitted === 0) {
        html += `
          <div style="text-align:center; color:var(--text-muted); padding:40px 20px;">
            No sections submitted yet. Complete the exercises in each tab, then return here to review your progress.
          </div>
        `;
        container.innerHTML = html;
        return;
      }
      
      // Group by round
      for (let round = 1; round <= 3; round++) {
        const roundSections = sectionData.filter(s => s.round === round);
        if (roundSections.length === 0) continue;
        
        html += `<div class="review-round-header">Round ${round}</div>`;
        
        roundSections.forEach(section => {
          let statusClass = section.complete ? 'success' : 'warning';
          let statusIcon = section.complete ? '‚úì' : '‚óã';
          let statusText = '';
          
          if (section.complete) {
            if (section.attempts === 1) {
              statusText = 'Complete on first try';
            } else {
              statusText = `Complete | ${section.attempts} attempts | ${section.attempts - 1} retries`;
            }
          } else {
            statusText = `In progress | ${section.wrongCount} still incorrect | ${section.attempts} attempts`;
          }
          
          html += `
            <div class="review-section-item ${statusClass}">
              <span class="review-section-icon">${statusIcon}</span>
              <span class="review-section-name">${section.tab.icon} ${section.tab.label}</span>
              <span class="review-section-status">${statusText}</span>
            </div>
          `;
        });
      }
      
      // Concept errors section
      const sortedErrors = Object.entries(APP.errorTracking || {})
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);
      
      if (sortedErrors.length > 0) {
        html += `<div class="review-round-header" style="margin-top:24px;">Concepts That Needed Work</div>`;
        
        sortedErrors.forEach(([conceptId, data]) => {
          const concept = APP.topicData.concepts?.[conceptId];
          const conceptName = concept?.name || conceptId.replace(/_/g, ' ');
          const wrongAnswers = [...new Set(data.wrongAnswers.filter(a => a))].join(', ');
          const hasPersistent = data.count >= 2 && concept?.persistent;
          
          html += `
            <div class="review-concept-item">
              <div class="review-concept-name">
                ${conceptName} 
                ${concept?.formula ? `<span class="collapsible-formula">${concept.formula}</span>` : ''}
                <span class="review-concept-count">(${data.count} mistake${data.count > 1 ? 's' : ''})</span>
              </div>
              ${wrongAnswers ? `<div class="review-concept-wrong">Tried: ${wrongAnswers}</div>` : ''}
          `;
          
          // Collapsible: Correct understanding
          if (concept?.correct) {
            html += `
              <div class="collapsible" style="margin-top:8px;" onclick="event.stopPropagation(); this.classList.toggle('open')">
                <div class="collapsible-header">
                  <span>Correct understanding</span>
                  <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                  <p>${concept.correct}</p>
                </div>
              </div>
            `;
          }
          
          // Collapsible: Persistent gap (only if 2+ errors)
          if (hasPersistent) {
            html += `
              <div class="collapsible" style="margin-top:4px; border-color:var(--warning);" onclick="event.stopPropagation(); this.classList.toggle('open')">
                <div class="collapsible-header" style="background:#fef3c7;">
                  <span>Needs attention (${data.count}+ errors)</span>
                  <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                  <p><strong>Gap:</strong> ${concept.persistent.gap}</p>
                  <p><strong>Action:</strong> ${concept.persistent.action}</p>
                </div>
              </div>
            `;
          }
          
          html += `</div>`;
        });
      } else {
        html += `
          <div style="text-align:center; color:var(--success); padding:20px; margin-top:20px;">
            No errors recorded. Well done.
          </div>
        `;
      }
      
      // Actions
      html += `<div class="review-actions-inline">`;
      
      if (allComplete) {
        html += `
          <div class="review-complete-banner">
            <div class="review-complete-title">Topic Complete</div>
            <div class="review-complete-stats">Final Efficiency: ${efficiencyScore}% | Total Retries: ${totalRetries}</div>
          </div>
          <button class="btn btn-primary" onclick="selectNextTopic()">Next Topic</button>
          <button class="btn btn-success" onclick="showEmailResults()">Email Results</button>
        `;
      } else {
        html += `
          <button class="btn btn-secondary" onclick="showEmailResults()">Email Progress</button>
        `;
      }
      
      html += `</div>`;
      
      container.innerHTML = html;
    }
    
    // ==================== TOPIC COMPLETE FUNCTIONS ====================
    function selectNextTopic() {
      // Close review and reset to topic selection
      document.getElementById('topicContent').classList.remove('active');
      document.getElementById('tabsContainer').classList.remove('active');
      document.getElementById('welcomeScreen').style.display = 'block';
      
      // Clear current topic state
      APP.topicData = null;
      APP.currentTab = null;
      APP.tabStates = {};
      APP.errorTracking = {};
      
      // Reset topic dropdown
      const topicSelect = document.getElementById('topicSelect');
      if (topicSelect) {
        topicSelect.value = '';
      }
      APP.currentTopic = null;
      
      showToast('Select your next topic above');
    }
    
    function showEmailResults() {
      const container = document.getElementById('topicContent');
      const savedEmail = Storage.get('teacherEmail') || '';
      const savedName = Storage.get('studentName') || '';
      
      // Calculate summary stats
      let totalQuestions = 0;
      let totalAttempts = 0;
      let totalErrors = 0;
      let completedSections = 0;
      
      for (let r = 1; r <= 3; r++) {
        APP.topicData.tabs.forEach(tab => {
          const content = APP.topicData.content[`round${r}`]?.[tab.id];
          if (content) {
            let tabTotal = 0;
            content.sentences.forEach(s => {
              tabTotal += Object.keys(s.questions).length;
            });
            totalQuestions += tabTotal;
            
            const key = `round${r}_${tab.id}`;
            const state = APP.tabStates[key];
            if (state && state.attempts > 0) {
              totalAttempts += state.attempts;
              totalErrors += Math.max(0, state.attempts - 1);
              if (state.complete) completedSections++;
            }
          }
        });
      }
      
      const efficiencyScore = totalQuestions > 0 
        ? Math.round((totalQuestions / (totalQuestions + totalErrors)) * 100) 
        : 0;
      
      const totalSections = APP.topicData.tabs.length * 3;
      const isComplete = completedSections === totalSections;
      
      // Build email panel HTML
      const emailPanelHtml = `
        <div class="email-panel" id="emailPanel">
          <h3>${isComplete ? 'Send Results' : 'Send Progress'} to Teacher</h3>
          
          <div style="margin:16px 0;">
            <label style="display:block; font-size:0.85rem; color:var(--text-muted); margin-bottom:4px;">
              Teacher's Email Address
            </label>
            <input type="email" id="teacherEmailInput" value="${savedEmail}" 
                   placeholder="teacher@school.edu"
                   style="width:100%; padding:8px 12px; border:1px solid var(--border); border-radius:var(--radius); font-size:0.95rem;">
          </div>
          
          <div style="margin:16px 0;">
            <label style="display:block; font-size:0.85rem; color:var(--text-muted); margin-bottom:4px;">
              Your Name
            </label>
            <input type="text" id="studentNameInput" value="${savedName}" 
                   placeholder="Your name"
                   style="width:100%; padding:8px 12px; border:1px solid var(--border); border-radius:var(--radius); font-size:0.95rem;">
          </div>
          
          <div style="background:var(--bg-secondary); padding:12px; border-radius:var(--radius); font-size:0.85rem; margin:16px 0;">
            <strong>Preview:</strong><br>
            Topic: ${APP.topicData.metadata.topicName}<br>
            Status: ${isComplete ? 'Complete' : 'In Progress'}<br>
            Sections: ${completedSections}/${totalSections}<br>
            Efficiency: ${efficiencyScore}%<br>
            Attempts: ${totalAttempts} | Retries: ${totalErrors}
          </div>
          
          <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button class="btn btn-secondary" onclick="closeEmailPanel()">Cancel</button>
            <button class="btn btn-primary" onclick="sendEmail()">Send Email</button>
          </div>
        </div>
      `;
      
      // Add styles if not already added
      if (!document.getElementById('emailPanelStyles')) {
        const styles = document.createElement('style');
        styles.id = 'emailPanelStyles';
        styles.textContent = `
          .email-panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 20px;
            margin: 20px 0;
            box-shadow: var(--shadow);
          }
          .email-panel h3 {
            margin-bottom: 12px;
            color: var(--primary);
          }
        `;
        document.head.appendChild(styles);
      }
      
      // Insert email panel at end of content area or replace existing
      const existingPanel = document.getElementById('emailPanel');
      if (existingPanel) {
        existingPanel.remove();
      }
      
      const actionsDiv = container.querySelector('.review-actions-inline');
      if (actionsDiv) {
        actionsDiv.insertAdjacentHTML('beforebegin', emailPanelHtml);
      } else {
        container.insertAdjacentHTML('beforeend', emailPanelHtml);
      }
      document.getElementById('teacherEmailInput').focus();
    }
    
    function closeEmailPanel() {
      const panel = document.getElementById('emailPanel');
      if (panel) panel.remove();
    }
    
    function sendEmail() {
      const emailInput = document.getElementById('teacherEmailInput');
      const nameInput = document.getElementById('studentNameInput');
      const email = emailInput.value.trim();
      const studentName = nameInput.value.trim();
      
      if (!email) {
        showToast('Please enter teacher\'s email address');
        emailInput.focus();
        return;
      }
      
      if (!email.includes('@')) {
        showToast('Please enter a valid email address');
        emailInput.focus();
        return;
      }
      
      if (!studentName) {
        showToast('Please enter your name');
        nameInput.focus();
        return;
      }
      
      // Save for future use
      Storage.set('teacherEmail', email);
      Storage.set('studentName', studentName);
      
      // Calculate stats for email
      let totalQuestions = 0;
      let totalAttempts = 0;
      let totalErrors = 0;
      let completedSections = 0;
      const totalSections = APP.topicData.tabs.length * 3;
      
      for (let r = 1; r <= 3; r++) {
        APP.topicData.tabs.forEach(tab => {
          const content = APP.topicData.content[`round${r}`]?.[tab.id];
          if (content) {
            content.sentences.forEach(s => {
              totalQuestions += Object.keys(s.questions).length;
            });
            
            const key = `round${r}_${tab.id}`;
            const state = APP.tabStates[key];
            if (state && state.attempts > 0) {
              totalAttempts += state.attempts;
              totalErrors += Math.max(0, state.attempts - 1);
              if (state.complete) completedSections++;
            }
          }
        });
      }
      
      const efficiencyScore = totalQuestions > 0 
        ? Math.round((totalQuestions / (totalQuestions + totalErrors)) * 100) 
        : 0;
      
      const isComplete = completedSections === totalSections;
      
      // Build concepts needing review list
      const conceptsList = Object.entries(APP.errorTracking)
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5)
        .map(([conceptId, data]) => {
          const concept = APP.topicData.concepts?.[conceptId];
          return `- ${concept?.name || conceptId.replace(/_/g, ' ')}: ${data.count} mistake(s)`;
        })
        .join('\n');
      
      // Create email body
      const subject = `YouCantFakeThis: ${studentName} - ${APP.topicData.metadata.topicName} ${isComplete ? '(Complete)' : '(In Progress)'}`;
      const body = `Student: ${studentName}
Topic: ${APP.topicData.metadata.topicName}
Subject: ${APP.topicData.metadata.subject}
Curriculum: ${APP.topicData.metadata.curriculum}

STATUS: ${isComplete ? 'COMPLETE' : 'In Progress'}

PERFORMANCE SUMMARY
-------------------
Sections Completed: ${completedSections}/${totalSections}
Efficiency Score: ${efficiencyScore}%
Total Attempts: ${totalAttempts}
Retries Needed: ${totalErrors}

${conceptsList ? `CONCEPTS NEEDING REVIEW\n-------------------\n${conceptsList}` : 'No errors recorded.'}

---
Sent from YouCantFakeThis Educational Platform
${new Date().toLocaleString()}`;
      
      // Open email client
      const mailtoLink = `mailto:${encodeURIComponent(email)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      window.open(mailtoLink, '_blank');
      
      closeEmailPanel();
      showToast('Opening email client...');
    }

    // Sync functions for Review tab email fields
    function syncStudentName(input) {
      Storage.set('studentName', input.value.trim());
      // Also update Settings field if visible
      const settingsInput = document.getElementById('settingsName');
      if (settingsInput) settingsInput.value = input.value;
    }

    function syncTeacherEmail(input) {
      Storage.set('teacherEmail', input.value.trim());
      // Also update Settings field if visible
      const settingsInput = document.getElementById('settingsEmail');
      if (settingsInput) settingsInput.value = input.value;
    }

    function sendReviewEmail() {
      const nameInput = document.getElementById('reviewStudentName');
      const emailInput = document.getElementById('reviewTeacherEmail');
      const studentName = nameInput.value.trim();
      const email = emailInput.value.trim();
      
      // Validate
      if (!studentName) {
        showToast('Please enter your name');
        nameInput.focus();
        return;
      }
      
      if (!email) {
        showToast('Please enter teacher\'s email address');
        emailInput.focus();
        return;
      }
      
      if (!isValidEmail(email)) {
        showToast('Please enter a valid email address');
        emailInput.focus();
        return;
      }
      
      // Save for future use (sync with settings)
      Storage.set('studentName', studentName);
      Storage.set('teacherEmail', email);
      
      // Get curriculum details
      const metadata = APP.topicData.metadata;
      const unitInfo = APP.topicManifest?.units?.find(u => u.id === metadata.unit);
      const aosInfo = unitInfo?.areasOfStudy?.find(a => a.id === metadata.aos);
      
      // Calculate stats
      let totalQuestions = 0;
      let totalAttempts = 0;
      let totalErrors = 0;
      let completedSections = 0;
      const totalSections = APP.topicData.tabs.length * 3;
      
      for (let r = 1; r <= 3; r++) {
        APP.topicData.tabs.forEach(tab => {
          const content = APP.topicData.content[`round${r}`]?.[tab.id];
          if (content) {
            content.sentences.forEach(s => {
              totalQuestions += Object.keys(s.questions).length;
            });
            
            const key = `round${r}_${tab.id}`;
            const state = APP.tabStates[key];
            if (state && state.attempts > 0) {
              totalAttempts += state.attempts;
              totalErrors += Math.max(0, state.attempts - 1);
              if (state.complete) completedSections++;
            }
          }
        });
      }
      
      const efficiencyScore = totalQuestions > 0 
        ? Math.round((totalQuestions / (totalQuestions + totalErrors)) * 100) 
        : 0;
      
      const isComplete = completedSections === totalSections;
      
      // Build concepts needing review list
      const conceptsList = Object.entries(APP.errorTracking)
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5)
        .map(([conceptId, data]) => {
          const concept = APP.topicData.concepts?.[conceptId];
          return `- ${concept?.name || conceptId.replace(/_/g, ' ')}: ${data.count} error(s)`;
        })
        .join('\n');
      
      // Create email
      const subject = `YouCantFakeThis: ${studentName} - ${metadata.topicName} ${isComplete ? '(Complete)' : '(In Progress)'}`;
      const body = `Student: ${studentName}

CURRICULUM DETAILS
------------------
Study: ${APP.studyManifest?.subjects?.find(s => s.id === metadata.subject)?.name || metadata.subject}
Unit: ${unitInfo?.code || metadata.unit} - ${unitInfo?.name || ''}
Area of Study: ${aosInfo?.code || metadata.aos} - ${aosInfo?.name || ''}
Topic: ${metadata.topicName}

STATUS: ${isComplete ? 'COMPLETE ‚úì' : 'In Progress'}

PERFORMANCE SUMMARY
-------------------
Sections Completed: ${completedSections}/${totalSections}
Efficiency Score: ${efficiencyScore}%
Total Attempts: ${totalAttempts}
Retries Needed: ${totalErrors}

${conceptsList ? `CONCEPTS NEEDING REVIEW\n----------------------\n${conceptsList}` : 'No errors recorded - all correct on first try!'}

---
Sent from YouCantFakeThis Educational Platform
${new Date().toLocaleString()}`;
      
      // Open email client
      const mailtoLink = `mailto:${encodeURIComponent(email)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      window.open(mailtoLink, '_blank');
      
      showToast('Opening email client...');
    }

    // ==================== HELPERS ====================
    function getTabState() {
      // Review tab doesn't have a state - return a dummy state
      if (APP.currentTab === '_review') {
        return {
          selections: {},
          results: {},
          submitted: false,
          attempts: 0,
          bestScore: 0,
          complete: false,
          opened: {}
        };
      }
      
      const key = `round${APP.currentRound}_${APP.currentTab}`;
      if (!APP.tabStates[key]) {
        APP.tabStates[key] = {
          selections: {},
          results: {},
          submitted: false,
          attempts: 0,
          bestScore: 0,
          complete: false,
          opened: {}
        };
      }
      return APP.tabStates[key];
    }

    function saveProgress() {
      if (APP.topicData) {
        Storage.saveTopicProgress(APP.topicData.metadata.id, {
          currentRound: APP.currentRound,
          highestRoundReached: APP.highestRoundReached,
          tabStates: APP.tabStates,
          errorTracking: APP.errorTracking
        });
      }
    }

    // EASTER EGG: Debug mode - all correct
    function activateDebugMode() {
      const tabState = getTabState();
      
      // Don't fill if tab is already complete
      if (tabState.complete) {
        showToast('Tab already complete');
        return;
      }
      
      console.log('Debug mode activated');
      showToast('Debug mode: Auto-filling correct answers');
      
      // Fill all dropdowns with correct answers
      document.querySelectorAll('.cloze-dropdown:not(.readonly)').forEach(select => {
        const correct = select.dataset.correct;
        if (correct) {
          select.value = correct;
          select.classList.add('filled');
          
          tabState.selections[select.dataset.question] = correct;
        }
      });
      
      saveProgress();
      updateControlPanel();
    }
    
    // EASTER EGG: Debug mode - 2/3 correct, 1/3 wrong
    function activatePartialDebugMode() {
      const tabState = getTabState();
      
      // Don't fill if tab is already complete
      if (tabState.complete) {
        showToast('Tab already complete');
        return;
      }
      
      console.log('Partial debug mode activated');
      showToast('Debug mode: 2/3 correct, 1/3 wrong');
      
      const dropdowns = document.querySelectorAll('.cloze-dropdown:not(.readonly)');
      let index = 0;
      
      dropdowns.forEach(select => {
        const correct = select.dataset.correct;
        if (correct) {
          // Every 3rd dropdown gets a wrong answer
          if (index % 3 === 2) {
            // Pick a wrong answer from the options
            const options = Array.from(select.options)
              .map(o => o.value)
              .filter(v => v && v !== correct);
            
            if (options.length > 0) {
              const wrongAnswer = options[Math.floor(Math.random() * options.length)];
              select.value = wrongAnswer;
              tabState.selections[select.dataset.question] = wrongAnswer;
            }
          } else {
            select.value = correct;
            tabState.selections[select.dataset.question] = correct;
          }
          
          select.classList.add('filled');
          index++;
        }
      });
      
      saveProgress();
      updateControlPanel();
    }

    // ==================== INIT ====================
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>