<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Global Names Memorial - Speaking Every Name</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
    :root {
        --primary-bg: #1a1a1a;
        --secondary-bg: #363636;
        --glass-bg: rgba(255, 255, 255, 0.1);
        --text-primary: #ffffff;
        --text-secondary: #cccccc;
        --accent: #4a90e2;
        --sacred: #ffd700;
        --taboo: #ff6b6b;
        --transition: #9b59b6;
        --cultural: #2ecc71;
    }

    * {
        box-sizing: border-box;
    }

    html {
        background: var(--primary-bg);
        min-height: 100%;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "Noto Sans Arabic", "Noto Sans Hebrew", "Noto Sans Ethiopic", "Noto Sans Tifinagh", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
        background-attachment: fixed;
        color: var(--text-primary);
        padding: 1rem;
        position: relative;
        overflow-x: hidden;
    }

    .container {
        background: var(--glass-bg);
        padding: 2rem;
        border-radius: 1.5rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        width: min(95vw, 800px);
        max-width: 800px;
        margin: auto;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
        margin: 0 0 0.5rem 0;
        font-size: clamp(1.8rem, 6vw, 2.5rem);
        text-transform: uppercase;
        letter-spacing: 3px;
        color: var(--text-primary);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .subtitle {
        font-size: clamp(0.9rem, 3vw, 1.1rem);
        color: var(--text-secondary);
        margin-bottom: 2rem;
        font-style: italic;
    }

    /* Name Display Section */
    .name-display-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 1rem;
        padding: 2rem;
        margin-bottom: 1.5rem;
        min-height: 200px;
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .name-main {
        font-size: clamp(1.8rem, 7vw, 2.5rem);
        margin: 0.5rem 0;
        line-height: 1.4;
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.3s ease;
        word-wrap: break-word;
        padding: 0.5rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "Noto Sans Arabic", "Noto Sans Hebrew", "Noto Sans Ethiopic", "Noto Sans Tifinagh", "Arial Unicode MS", sans-serif;
    }

    .name-main:hover {
        transform: scale(1.02);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .name-components {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        justify-content: center;
        margin: 1rem 0;
    }

    .component {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.3rem 0.8rem;
        border-radius: 0.5rem;
        font-size: 0.9rem;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .component-label {
        color: var(--text-secondary);
        font-size: 0.8rem;
        margin-right: 0.3rem;
    }

    /* Meanings Section */
    .meanings-section {
        background: rgba(74, 144, 226, 0.15);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(74, 144, 226, 0.3);
        text-align: left;
    }

    .meanings-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 0.5rem;
        font-size: 1rem;
    }

    .meaning-item {
        font-size: 0.85rem;
        margin: 0.3rem 0;
        padding-left: 1rem;
    }

    .meaning-label {
        color: var(--text-secondary);
        font-style: italic;
    }

    /* Old Names Section */
    .old-names-section {
        background: rgba(255, 215, 0, 0.1);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(255, 215, 0, 0.3);
        text-align: left;
    }

    .old-names-title {
        font-weight: bold;
        color: var(--sacred);
        margin-bottom: 0.5rem;
        font-size: 1rem;
    }

    /* Cultural Context */
    .cultural-context {
        background: rgba(74, 144, 226, 0.1);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(74, 144, 226, 0.3);
    }

    .culture-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 0.8rem;
        text-align: left;
    }

    .info-item {
        font-size: 0.9rem;
    }

    .info-label {
        color: var(--accent);
        font-weight: bold;
    }

    /* Special Indicators */
    .special-indicators {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        margin: 1rem 0;
        flex-wrap: wrap;
    }

    .indicator {
        padding: 0.3rem 0.8rem;
        border-radius: 2rem;
        font-size: 0.85rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 0.3rem;
    }

    .indicator-sacred {
        background: var(--sacred);
        color: var(--primary-bg);
    }

    .indicator-taboo {
        background: var(--taboo);
        color: white;
    }

    .indicator-transition {
        background: var(--transition);
        color: white;
    }

    .indicator-cultural {
        background: var(--cultural);
        color: white;
    }

    .indicator-mononym {
        background: #3498db;
        color: white;
    }

    .indicator-old-name {
        background: #8b4513;
        color: white;
    }

    /* Voice Status */
    .voice-status {
        color: var(--text-secondary);
        margin: 1rem 0;
        font-size: 0.9rem;
        font-style: italic;
        min-height: 1.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .sign-language-note {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }

    /* Controls */
    .controls {
        display: grid;
        gap: 1rem;
        margin-top: 2rem;
    }

    .control-row {
        display: flex;
        gap: 0.8rem;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        padding: 0.6rem 1rem;
        border-radius: 1rem;
        min-width: 160px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    button {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 0.5rem;
        cursor: pointer;
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
        transition: all 0.3s ease;
        min-width: 100px;
    }

    button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:active:not(:disabled) {
        transform: translateY(0);
    }

    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    button.primary {
        background: var(--accent);
        border-color: var(--accent);
    }

    button.primary:hover:not(:disabled) {
        background: #5ba0f2;
    }

    /* Toggle Switches */
    .switch {
        position: relative;
        display: inline-block;
        width: 52px;
        height: 26px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.2);
        transition: .4s;
        border-radius: 26px;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .slider {
        background-color: var(--accent);
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    /* Stats Display */
    .stats {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-top: 1.5rem;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
    }

    /* Loading Status */
    .loading-status {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-secondary);
        font-size: 0.9rem;
    }

    .error-message {
        background: rgba(255, 107, 107, 0.2);
        border: 1px solid rgba(255, 107, 107, 0.5);
        color: #ff6b6b;
    }

    /* Modal for Information */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
    }

    .modal-content {
        background: var(--secondary-bg);
        margin: 5% auto;
        padding: 2rem;
        border-radius: 1rem;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: var(--text-primary);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .close {
        color: var(--text-secondary);
        float: right;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
    }

    .close:hover {
        color: var(--text-primary);
    }

    /* Info Button */
    #infoButton {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        width: 40px;
        height: 40px;
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: rgba(255, 255, 255, 0.7);
        z-index: 100;
        padding: 0;
    }

    #infoButton:hover {
        color: var(--text-primary);
        transform: scale(1.1);
    }

    /* Acknowledgment Style */
    .acknowledgment {
        font-size: 1.1rem;
        line-height: 1.8;
        color: var(--text-primary);
        padding: 2rem;
        text-align: center;
        font-style: italic;
        background: rgba(255, 215, 0, 0.1);
        border-radius: 1rem;
        border: 1px solid rgba(255, 215, 0, 0.3);
    }

    /* Responsive Design */
    @media (max-width: 600px) {
        .container {
            padding: 1.5rem;
        }
        
        .name-display-section {
            padding: 1.5rem;
        }
        
        .control-group {
            min-width: 140px;
        }
        
        .culture-info {
            grid-template-columns: 1fr;
        }
    }

    /* Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .fade-in {
        animation: fadeIn 0.5s ease-out;
    }

    /* Special script displays */
    .script-display {
        font-size: 1.2rem;
        margin: 0.5rem 0;
        opacity: 0.8;
    }

    .rtl {
        direction: rtl;
    }

    .click-notation {
        font-family: "Noto Sans", "DejaVu Sans", sans-serif;
        font-size: 1.3rem;
    }

    /* Loading indicator */
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--accent);
        animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>

</head>
<body>
    <button id="infoButton" title="About this work">?</button>
    
    <div class="container">
        <h1>Resurrective Necropolis</h1>
        
        <div id="loadingStatus" class="loading-status">
            <span class="loading"></span> Loading language data...
        </div>
        
        <div class="name-display-section">
            <div id="nameDisplay" class="name-main fade-in">Initializing...</div>
            <div id="scriptDisplay" class="script-display"></div>
            <div id="nameComponents" class="name-components"></div>
            <div id="specialIndicators" class="special-indicators"></div>
            <div id="culturalContext" class="cultural-context"></div>
            <div id="meaningsSection" class="meanings-section" style="display: none;"></div>
            <div id="oldNamesSection" class="old-names-section" style="display: none;"></div>
            <div id="voiceStatus" class="voice-status"></div>
            <div id="signLanguageNote" class="sign-language-note" style="display: none;"></div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <button id="initVoiceButton" class="primary">Initialize Voice System</button>
                <button id="toggleButton">Pause</button>
                <button id="speakButton">Speak Name</button>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <span>Slow</span>
                    <label class="switch">
                        <input type="checkbox" id="speedToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Fast</span>
                </div>
                
                <div class="control-group">
                    <span>Random</span>
                    <label class="switch">
                        <input type="checkbox" id="weightedToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Weighted</span>
                </div>
                
                <div class="control-group">
                    <span>Basic</span>
                    <label class="switch">
                        <input type="checkbox" id="detailToggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span>Detailed</span>
                </div>
                
                <div class="control-group">
                    <span>Current</span>
                    <label class="switch">
                        <input type="checkbox" id="oldNamesToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Historical</span>
                </div>
            </div>
        </div>
        
        <div id="statsDisplay" class="stats">Initializing...</div>
    </div>
    
    <!-- Information Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>About This Memorial</h2>
            <div class="acknowledgment">
                This work recognizes the profound diversity of human naming across all cultures. 
                It acknowledges that names carry deep meaning—they can be sacred, earned through 
                life experiences, changed to reflect identity, or held in silence to honor the dead. 
                Some names are visual, some are whistled, some contain sounds unique to specific 
                languages. Every name represents a life, a story, a connection to family and culture.
                <br><br>
                By speaking these names—or respectfully acknowledging when they cannot be spoken—we 
                honor the universal human practice of remembering through naming.
            </div>
        </div>
    </div>

    <script>
// Simplified and fixed version

// Global state
const appState = {
    isRunning: false,
    isFast: false,
    isWeighted: false,
    showDetails: true,
    showOldNames: false,
    isVoiceInitialized: false,
    currentName: null,
    synth: window.speechSynthesis,
    voices: [],
    intervalId: null,
    SLOW_SPEED: 10000,
    FAST_SPEED: 5000,
    metadata: null,
    loadedFamilies: {},
    isInitialized: false
};

// Initialize the application
async function initializeApp() {
    const loadingStatus = document.getElementById('loadingStatus');
    
    try {
        console.log('Starting initialization...');
        
        // Load metadata
        loadingStatus.innerHTML = '<span class="loading"></span> Loading system metadata...';
        const metaResponse = await fetch('./languages/metadata.json');
        
        if (!metaResponse.ok) {
            throw new Error(`Failed to load metadata: ${metaResponse.status}`);
        }
        
        appState.metadata = await metaResponse.json();
        console.log('Metadata loaded:', appState.metadata);
        
        // Load ALL language families (or as many as possible)
        loadingStatus.innerHTML = '<span class="loading"></span> Loading language families...';
        
        // Try to load all families, not just preloadCommon
        let loadedCount = 0;
        let failedCount = 0;
        
        for (const family of appState.metadata.languageFamilies) {
            try {
                await loadLanguageFamily(family.id);
                loadedCount++;
                console.log(`Loaded ${family.id} (${loadedCount}/${appState.metadata.languageFamilies.length})`);
                loadingStatus.innerHTML = `<span class="loading"></span> Loading language families... (${loadedCount}/${appState.metadata.languageFamilies.length})`;
            } catch (err) {
                failedCount++;
                console.warn(`Failed to load ${family.id}:`, err.message);
                // Continue loading others even if one fails
            }
        }
        
        console.log(`Successfully loaded ${loadedCount} families, ${failedCount} failed`);
        
        if (loadedCount === 0) {
            throw new Error('No language families could be loaded');
        }
        
        // Mark as initialized
        appState.isInitialized = true;
        
        // Hide loading status
        loadingStatus.style.display = 'none';
        
        // Update stats
        updateStats();
        
        // Update voice status
        updateVoiceStatus('Click "Initialize Voice System" to enable speech');
        
        // Start the memorial
        appState.isRunning = true;
        startInterval();
        
        console.log('Initialization complete!');
        
    } catch (error) {
        console.error('Failed to initialize app:', error);
        loadingStatus.className = 'loading-status error-message';
        loadingStatus.innerHTML = `
            ⚠️ Failed to load language data. 
            <br>Error: ${error.message}
        `;
    }
}

// Load a language family
async function loadLanguageFamily(familyId) {
    // Check if already loaded
    if (appState.loadedFamilies[familyId]) {
        return appState.loadedFamilies[familyId];
    }
    
    // Find family info
    const familyInfo = appState.metadata.languageFamilies.find(f => f.id === familyId);
    if (!familyInfo) {
        throw new Error(`Unknown language family: ${familyId}`);
    }
    
    // Load the file
    const url = `./languages/${familyInfo.fileName}`;
    const response = await fetch(url);
    
    if (!response.ok) {
        throw new Error(`Failed to load ${familyId}: ${response.status}`);
    }
    
    const data = await response.json();
    appState.loadedFamilies[familyId] = data;
    
    return data;
}

// Voice system initialization
async function initializeVoiceSystem() {
    const status = document.getElementById('voiceStatus');
    const button = document.getElementById('initVoiceButton');
    
    status.innerHTML = '<span class="loading"></span> Initializing voice system...';
    
    try {
        // Check browser support
        if (!('speechSynthesis' in window)) {
            throw new Error('Speech synthesis not supported in this browser');
        }
        
        // Cancel any ongoing speech
        appState.synth.cancel();
        
        // Load voices
        let voices = appState.synth.getVoices();
        
        if (voices.length === 0) {
            // Wait for voices to load
            await new Promise((resolve) => {
                appState.synth.onvoiceschanged = () => {
                    voices = appState.synth.getVoices();
                    resolve();
                };
                // Timeout after 2 seconds
                setTimeout(resolve, 2000);
            });
        }
        
        appState.voices = voices;
        console.log(`Loaded ${voices.length} voices`);
        
        if (voices.length === 0) {
            throw new Error('No voices available');
        }
        
        // Test voice with a simple utterance
        const testUtterance = new SpeechSynthesisUtterance('Voice system ready');
        testUtterance.volume = 0.3;
        appState.synth.speak(testUtterance);
        
        appState.isVoiceInitialized = true;
        status.innerHTML = `✓ Voice system ready (${voices.length} voices)`;
        button.style.display = 'none';
        
        console.log('Voice system initialized');
        
    } catch (error) {
        console.error('Voice initialization failed:', error);
        status.innerHTML = `⚠️ ${error.message}. Names will display without audio.`;
        button.textContent = 'Retry Voice';
    }
}

// Name generation
async function generateName() {
    if (!appState.isInitialized || !appState.metadata) {
        console.log('Not initialized yet');
        return null;
    }
    
    try {
        // Get loaded families
        const loadedFamilyIds = Object.keys(appState.loadedFamilies);
        if (loadedFamilyIds.length === 0) {
            console.log('No families loaded');
            return null;
        }
        
        let familyId;
        
        // Select family based on weighted or random
        if (appState.isWeighted) {
            // Weighted selection based on population percentage
            const weights = loadedFamilyIds.map(id => {
                const familyInfo = appState.metadata.languageFamilies.find(f => f.id === id);
                return familyInfo ? familyInfo.populationPercentage : 1;
            });
            
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < loadedFamilyIds.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    familyId = loadedFamilyIds[i];
                    break;
                }
            }
            
            if (!familyId) {
                familyId = loadedFamilyIds[0];
            }
        } else {
            // Random selection
            familyId = loadedFamilyIds[Math.floor(Math.random() * loadedFamilyIds.length)];
        }
        
        const familyData = appState.loadedFamilies[familyId];
        console.log(`Selected family: ${familyId}`);
        
        // Select gender
        const genders = ['male', 'female', 'neutral'];
        const gender = genders[Math.floor(Math.random() * genders.length)];
        
        // Get names
        const givenNames = familyData.nameComponents.given[gender] || 
                          familyData.nameComponents.given.neutral ||
                          [];
                          
        let familyNames = [];
        if (Array.isArray(familyData.nameComponents.family)) {
            familyNames = familyData.nameComponents.family;
        } else if (familyData.nameComponents.family) {
            familyNames = familyData.nameComponents.family.common || [];
        }
        
        if (givenNames.length === 0 || familyNames.length === 0) {
            console.log('No names available for', gender, 'in', familyId);
            return null;
        }
        
        const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
        const familyName = familyNames[Math.floor(Math.random() * familyNames.length)];
        
        // Build full name based on order
        let fullName;
        if (familyData.metadata.nameOrder === 'family_first') {
            fullName = `${familyName} ${givenName}`;
        } else {
            fullName = `${givenName} ${familyName}`;
        }
        
        return {
            display: fullName,
            spoken: fullName,
            given: givenName,
            family: familyName,
            gender: gender,
            familyId: familyId,
            languageFamily: familyData.metadata.family,
            writingSystems: familyData.metadata.writingSystems,
            populationPercentage: appState.metadata.languageFamilies.find(f => f.id === familyId)?.populationPercentage
        };
        
    } catch (error) {
        console.error('Error generating name:', error);
        return null;
    }
}

// Display name
function displayName(nameData) {
    if (!nameData) return;
    
    const nameDisplay = document.getElementById('nameDisplay');
    const componentsDisplay = document.getElementById('nameComponents');
    const contextDisplay = document.getElementById('culturalContext');
    
    // Clear previous displays
    componentsDisplay.innerHTML = '';
    contextDisplay.innerHTML = '';
    
    // Display main name
    nameDisplay.textContent = nameData.display;
    nameDisplay.className = 'name-main fade-in';
    
    // Show components if detailed view
    if (appState.showDetails) {
        // Components
        if (nameData.given) {
            const givenDiv = document.createElement('div');
            givenDiv.className = 'component';
            givenDiv.innerHTML = '<span class="component-label">Given:</span> ' + nameData.given;
            componentsDisplay.appendChild(givenDiv);
        }
        
        if (nameData.family) {
            const familyDiv = document.createElement('div');
            familyDiv.className = 'component';
            familyDiv.innerHTML = '<span class="component-label">Family:</span> ' + nameData.family;
            componentsDisplay.appendChild(familyDiv);
        }
        
        // Cultural context
        const info = document.createElement('div');
        info.className = 'culture-info';
        
        info.innerHTML = `
            <div class="info-item">
                <span class="info-label">Language Family:</span> ${nameData.languageFamily}
            </div>
            <div class="info-item">
                <span class="info-label">Writing System:</span> ${nameData.writingSystems.join(', ')}
            </div>
            <div class="info-item">
                <span class="info-label">Gender:</span> ${nameData.gender}
            </div>
        `;
        
        contextDisplay.appendChild(info);
    }
    
    // Store current name
    appState.currentName = nameData;
}

// Speak name
function speakName(nameData) {
    if (!appState.isVoiceInitialized || !nameData || !appState.synth) {
        return;
    }
    
    try {
        // Cancel any ongoing speech
        appState.synth.cancel();
        
        const utterance = new SpeechSynthesisUtterance(nameData.spoken);
        
        // Select a voice
        if (appState.voices.length > 0) {
            // Try to find a suitable voice based on language
            let voice = appState.voices.find(v => v.lang.startsWith('en'));
            if (!voice) {
                voice = appState.voices[0];
            }
            utterance.voice = voice;
        }
        
        // Adjust parameters
        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        // Event handlers
        utterance.onstart = () => {
            updateVoiceStatus('Speaking: ' + nameData.spoken);
        };
        
        utterance.onend = () => {
            updateVoiceStatus('Ready');
        };
        
        utterance.onerror = (event) => {
            console.error('Speech error:', event);
            updateVoiceStatus('Speech error');
        };
        
        // Speak
        appState.synth.speak(utterance);
        
    } catch (error) {
        console.error('Speech error:', error);
        updateVoiceStatus('Speech error occurred');
    }
}

// Update voice status
function updateVoiceStatus(message) {
    const status = document.getElementById('voiceStatus');
    status.textContent = message;
}

// Update stats
function updateStats() {
    const stats = document.getElementById('statsDisplay');
    const loadedCount = Object.keys(appState.loadedFamilies).length;
    const totalCount = appState.metadata ? appState.metadata.languageFamilies.length : 0;
    
    stats.innerHTML = `
        ${loadedCount} of ${totalCount} language families loaded • 
        ${appState.isWeighted ? 'Population weighted' : 'Random selection'} • 
        ${appState.isFast ? 'Fast' : 'Slow'} speed
    `;
}

// Interval management
function startInterval() {
    if (!appState.isInitialized) {
        console.log('Cannot start - not initialized');
        return;
    }
    
    // Clear existing interval
    if (appState.intervalId) {
        clearInterval(appState.intervalId);
    }
    
    // Generate first name immediately
    generateAndDisplay();
    
    // Set up interval
    const speed = appState.isFast ? appState.FAST_SPEED : appState.SLOW_SPEED;
    appState.intervalId = setInterval(() => {
        if (appState.isRunning) {
            generateAndDisplay();
        }
    }, speed);
}

async function generateAndDisplay() {
    const nameData = await generateName();
    if (nameData) {
        displayName(nameData);
        
        if (appState.isRunning && appState.isVoiceInitialized) {
            // Small delay to ensure display updates first
            setTimeout(() => speakName(nameData), 100);
        }
    }
}

// Event handlers
document.getElementById('initVoiceButton').addEventListener('click', initializeVoiceSystem);

document.getElementById('toggleButton').addEventListener('click', () => {
    appState.isRunning = !appState.isRunning;
    document.getElementById('toggleButton').textContent = appState.isRunning ? 'Pause' : 'Resume';
    
    if (!appState.isRunning) {
        appState.synth.cancel();
    }
});

document.getElementById('speedToggle').addEventListener('change', (e) => {
    appState.isFast = e.target.checked;
    startInterval();
});

document.getElementById('weightedToggle').addEventListener('change', (e) => {
    appState.isWeighted = e.target.checked;
    updateStats();
});

document.getElementById('detailToggle').addEventListener('change', (e) => {
    appState.showDetails = e.target.checked;
    if (appState.currentName) {
        displayName(appState.currentName);
    }
});

document.getElementById('oldNamesToggle').addEventListener('change', (e) => {
    appState.showOldNames = e.target.checked;
    generateAndDisplay();
});

document.getElementById('speakButton').addEventListener('click', () => {
    if (appState.currentName) {
        speakName(appState.currentName);
    }
});

// Name click for Google Images
document.getElementById('nameDisplay').addEventListener('click', (e) => {
    const name = e.target.textContent;
    if (name && !name.includes('[') && !name.includes('Initializing')) {
        const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(name)}&tbm=isch`;
        window.open(searchUrl, '_blank', 'noopener,noreferrer');
    }
});

// Info modal handlers
document.getElementById('infoButton').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'block';
});

document.querySelector('.close').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'none';
});

window.addEventListener('click', (e) => {
    const modal = document.getElementById('infoModal');
    if (e.target === modal) {
        modal.style.display = 'none';
    }
});

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, starting initialization...');
    initializeApp();
});

// Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden && appState.isRunning && appState.synth) {
        appState.synth.cancel();
    }
});

// Handle page unload
window.addEventListener('beforeunload', () => {
    if (appState.synth) {
        appState.synth.cancel();
    }
});

// Monitor voice changes
if ('speechSynthesis' in window) {
    window.speechSynthesis.onvoiceschanged = () => {
        if (!appState.isVoiceInitialized) {
            console.log('Voices changed, available:', window.speechSynthesis.getVoices().length);
        }
    };
}
    </script>
</body>
</html>