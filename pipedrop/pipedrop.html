<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drop the Pipe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 100%;
            transition: all 0.5s ease;
            position: relative;
            z-index: 10;
        }

        .container.waiting-mode {
            max-width: 300px;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
            font-size: 28px;
        }

        .setup-view {
            display: block;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .setup-view.hidden {
            display: none;
        }

        .waiting-view {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .waiting-view.active {
            display: block;
            opacity: 1;
        }

        .waiting-text {
            font-size: 32px;
            color: #667eea;
            font-weight: 300;
            margin: 40px 0;
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.4;
            }
            50% {
                opacity: 1;
            }
        }

        .stop-waiting-btn {
            padding: 10px 20px;
            border: 2px solid #ef4444;
            background: transparent;
            color: #ef4444;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 30px;
        }

        .stop-waiting-btn:hover {
            background: #ef4444;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3);
        }

        .control-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="number"] {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .test-audio-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            width: 100%;
        }

        .test-audio-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }

        .test-audio-btn:active {
            transform: translateY(0);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 30px 0;
            gap: 15px;
        }

        .status-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .status-dot.inactive {
            background: #ef4444;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
        }

        .status-text {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        .toggle-btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .info-text {
            margin-top: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            color: #555;
            font-size: 14px;
            line-height: 1.5;
        }

        .error-message {
            color: #ef4444;
            font-size: 14px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .flash-effect {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.2), transparent);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 9999;
        }

        .flash-effect.flash {
            opacity: 1;
        }

        /* Flying Pipe Emoji */
        .flying-pipe {
            position: fixed;
            font-size: 48px;
            z-index: 9998;
            pointer-events: none;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
        }

        @keyframes flyRight {
            from {
                left: -100px;
                transform: rotate(0deg);
            }
            to {
                left: calc(100% + 100px);
                transform: rotate(360deg);
            }
        }

        @keyframes flyLeft {
            from {
                right: -100px;
                transform: rotate(0deg);
            }
            to {
                right: calc(100% + 100px);
                transform: rotate(-360deg);
            }
        }

        @keyframes flyUp {
            from {
                bottom: -100px;
                transform: rotate(0deg);
            }
            to {
                bottom: calc(100% + 100px);
                transform: rotate(360deg);
            }
        }

        @keyframes flyDown {
            from {
                top: -100px;
                transform: rotate(0deg);
            }
            to {
                top: calc(100% + 100px);
                transform: rotate(-360deg);
            }
        }

        /* Debug Panel Styles */
        .debug-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 400px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #0f0;
            display: none;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .debug-panel.active {
            display: block;
        }

        .debug-header {
            color: #0ff;
            font-size: 14px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-close {
            color: #f00;
            cursor: pointer;
            font-size: 20px;
            padding: 0 5px;
        }

        .debug-close:hover {
            color: #ff0;
        }

        .debug-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-radius: 5px;
        }

        .debug-section-title {
            color: #ff0;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .debug-item {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
        }

        .debug-label {
            color: #0ff;
        }

        .debug-value {
            color: #0f0;
            word-break: break-all;
        }

        .debug-value.error {
            color: #f00;
        }

        .debug-value.warning {
            color: #ff0;
        }

        .debug-value.success {
            color: #0f0;
        }

        .debug-log {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
            margin-top: 5px;
        }

        .debug-log-entry {
            margin: 2px 0;
            font-size: 11px;
            border-left: 2px solid #0f0;
            padding-left: 5px;
        }

        .debug-log-entry.error {
            border-left-color: #f00;
            color: #f00;
        }

        .debug-log-entry.info {
            border-left-color: #0ff;
            color: #0ff;
        }

        .debug-countdown {
            font-size: 16px;
            color: #ff0;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="flash-effect" id="flashEffect"></div>
    
    <!-- Debug Panel -->
    <div class="debug-panel" id="debugPanel">
        <div class="debug-header">
            <span>ðŸ”§ DEBUG CONSOLE</span>
            <span class="debug-close" onclick="toggleDebugPanel()">âœ•</span>
        </div>
        
        <div class="debug-section">
            <div class="debug-section-title">Audio Status</div>
            <div class="debug-item">
                <span class="debug-label">File:</span>
                <span class="debug-value" id="debugAudioFile">pipedrop.mp3</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Loaded:</span>
                <span class="debug-value" id="debugAudioLoaded">false</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Ready State:</span>
                <span class="debug-value" id="debugReadyState">0</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Network State:</span>
                <span class="debug-value" id="debugNetworkState">0</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Duration:</span>
                <span class="debug-value" id="debugDuration">N/A</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Volume:</span>
                <span class="debug-value" id="debugVolume">1.0</span>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-section-title">Timer Status</div>
            <div class="debug-item">
                <span class="debug-label">Active:</span>
                <span class="debug-value" id="debugTimerActive">false</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Interval (min):</span>
                <span class="debug-value" id="debugInterval">60</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Next Play (ms):</span>
                <span class="debug-value" id="debugNextPlay">N/A</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Time Until Next:</span>
                <span class="debug-value" id="debugTimeRemaining">N/A</span>
            </div>
            <div class="debug-countdown" id="debugCountdown">--:--:--</div>
        </div>

        <div class="debug-section">
            <div class="debug-section-title">Playback Stats</div>
            <div class="debug-item">
                <span class="debug-label">Total Plays:</span>
                <span class="debug-value" id="debugTotalPlays">0</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Last Play:</span>
                <span class="debug-value" id="debugLastPlay">Never</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Avg Interval:</span>
                <span class="debug-value" id="debugAvgInterval">N/A</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Session Start:</span>
                <span class="debug-value" id="debugSessionStart">N/A</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Flying Pipes:</span>
                <span class="debug-value" id="debugFlyingPipes">0</span>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-section-title">System Info</div>
            <div class="debug-item">
                <span class="debug-label">Page Visible:</span>
                <span class="debug-value" id="debugPageVisible">true</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Audio Context:</span>
                <span class="debug-value" id="debugAudioContext">N/A</span>
            </div>
            <div class="debug-item">
                <span class="debug-label">Browser:</span>
                <span class="debug-value" id="debugBrowser">N/A</span>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-section-title">Event Log</div>
            <div class="debug-log" id="debugLog"></div>
        </div>
    </div>

    <div class="container" id="container">
        <div class="setup-view" id="setupView">
            <h1>Drop the Pipe</h1>
            
            <div class="control-group">
                <label for="interval">Average interval (minutes):</label>
                <div class="input-group">
                    <input type="number" id="interval" min="1" max="1440" value="60" step="1">
                    <span style="color: #666;">min</span>
                </div>
                <button class="test-audio-btn" onclick="testAudio()">ðŸ”Š Test Audio</button>
            </div>

            <div class="status-indicator">
                <div class="status-dot inactive" id="statusDot"></div>
                <span class="status-text" id="statusText">Inactive</span>
            </div>

            <button class="toggle-btn" id="toggleBtn" onclick="startTimer()">
                Start Timer
            </button>

            <div class="error-message" id="errorMessage">
                Error: Could not load pipedrop.mp3. Please ensure the file is available on the server.
            </div>

            <div class="info-text">
                The sound will play at random intervals, averaging your specified time. The actual time between plays will vary to maintain unpredictability. Press 'P' to launch a pipe emoji!
            </div>
        </div>

        <div class="waiting-view" id="waitingView">
            <div class="waiting-text">... waiting</div>
            <button class="stop-waiting-btn" onclick="stopTimer()">stop waiting</button>
        </div>
    </div>

    <script>
        let isActive = false;
        let timeoutId = null;
        let pipeTimeoutId = null;
        let audio = null;
        let audioLoaded = false;
        let debugMode = false;
        let keysPressed = {};
        let flyingPipeCount = 0;
        
        // Debug tracking variables
        let debugData = {
            totalPlays: 0,
            lastPlayTime: null,
            sessionStart: null,
            playIntervals: [],
            nextPlayTime: null,
            scheduledInterval: null,
            audioEvents: [],
            errors: []
        };

        // Load saved interval from localStorage
        window.addEventListener('load', () => {
            const savedInterval = localStorage.getItem('pipeDropInterval');
            if (savedInterval) {
                document.getElementById('interval').value = savedInterval;
            }
            
            debugLog('Page loaded, initializing app...');
            initAudio();
            initPipeTimer();
            
            // Request notification permission for better background support
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    debugLog(`Notification permission: ${permission}`);
                });
            }
        });

        // Save interval to localStorage when changed
        document.getElementById('interval').addEventListener('change', (e) => {
            localStorage.setItem('pipeDropInterval', e.target.value);
            debugLog(`Interval saved to localStorage: ${e.target.value} minutes`);
        });

        // Test audio function
        function testAudio() {
            debugLog('Testing audio with tone generator...');
            
            // Create audio context
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create oscillator for beep
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800; // 800Hz tone
            oscillator.type = 'sine';
            
            // Envelope for smooth sound
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.15);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
            
            // Visual feedback
            const btn = event.target;
            btn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
            setTimeout(() => {
                btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            }, 200);
            
            debugLog('Test tone played successfully');
        }

        // Flying pipe emoji functions
        function launchPipeEmoji() {
            const pipe = document.createElement('div');
            pipe.className = 'flying-pipe';
            pipe.textContent = 'ðŸš°';
            
            // Random direction and position
            const directions = ['right', 'left', 'up', 'down'];
            const direction = directions[Math.floor(Math.random() * directions.length)];
            const duration = 3 + Math.random() * 4; // 3-7 seconds
            
            switch(direction) {
                case 'right':
                    pipe.style.top = Math.random() * window.innerHeight + 'px';
                    pipe.style.animation = `flyRight ${duration}s linear forwards`;
                    break;
                case 'left':
                    pipe.style.top = Math.random() * window.innerHeight + 'px';
                    pipe.style.animation = `flyLeft ${duration}s linear forwards`;
                    break;
                case 'up':
                    pipe.style.left = Math.random() * window.innerWidth + 'px';
                    pipe.style.animation = `flyUp ${duration}s linear forwards`;
                    break;
                case 'down':
                    pipe.style.left = Math.random() * window.innerWidth + 'px';
                    pipe.style.animation = `flyDown ${duration}s linear forwards`;
                    break;
            }
            
            document.body.appendChild(pipe);
            flyingPipeCount++;
            
            debugLog(`Pipe emoji launched! Direction: ${direction}, Duration: ${duration.toFixed(2)}s`);
            if (debugMode) {
                document.getElementById('debugFlyingPipes').textContent = flyingPipeCount;
            }
            
            // Remove after animation
            setTimeout(() => {
                pipe.remove();
                flyingPipeCount--;
                if (debugMode) {
                    document.getElementById('debugFlyingPipes').textContent = flyingPipeCount;
                }
            }, duration * 1000);
        }

        // Initialize pipe timer
        function initPipeTimer() {
            schedulePipeEmoji();
        }

        // Schedule next pipe emoji
        function schedulePipeEmoji() {
            // Average 10 minutes, using exponential distribution
            const averageMinutes = 10;
            const lambda = 1 / averageMinutes;
            const random = Math.random();
            const minutes = -Math.log(1 - random) / lambda;
            const cappedMinutes = Math.min(minutes, averageMinutes * 3);
            const ms = cappedMinutes * 60 * 1000;
            
            debugLog(`Next pipe emoji scheduled in ${(ms/60000).toFixed(2)} minutes`);
            
            pipeTimeoutId = setTimeout(() => {
                launchPipeEmoji();
                schedulePipeEmoji(); // Schedule next one
            }, ms);
        }

        // Debug logging function
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = { time: timestamp, message, type };
            debugData.audioEvents.push(entry);
            
            // Keep only last 50 entries
            if (debugData.audioEvents.length > 50) {
                debugData.audioEvents.shift();
            }
            
            // Update debug panel if visible
            if (debugMode) {
                updateDebugLog();
            }
            
            console.log(`[${type.toUpperCase()}] ${timestamp}: ${message}`);
        }

        // Update debug panel
        function updateDebugPanel() {
            if (!debugMode) return;
            
            // Audio Status
            document.getElementById('debugAudioLoaded').textContent = audioLoaded;
            document.getElementById('debugAudioLoaded').className = `debug-value ${audioLoaded ? 'success' : 'error'}`;
            
            if (audio) {
                document.getElementById('debugReadyState').textContent = `${audio.readyState} (${getReadyStateText(audio.readyState)})`;
                document.getElementById('debugNetworkState').textContent = `${audio.networkState} (${getNetworkStateText(audio.networkState)})`;
                document.getElementById('debugDuration').textContent = audio.duration ? `${audio.duration.toFixed(2)}s` : 'N/A';
                document.getElementById('debugVolume').textContent = audio.volume;
            }
            
            // Timer Status
            document.getElementById('debugTimerActive').textContent = isActive;
            document.getElementById('debugTimerActive').className = `debug-value ${isActive ? 'success' : 'error'}`;
            document.getElementById('debugInterval').textContent = document.getElementById('interval').value;
            
            if (debugData.scheduledInterval) {
                document.getElementById('debugNextPlay').textContent = `${debugData.scheduledInterval}ms`;
            }
            
            // Playback Stats
            document.getElementById('debugTotalPlays').textContent = debugData.totalPlays;
            document.getElementById('debugLastPlay').textContent = debugData.lastPlayTime ? 
                new Date(debugData.lastPlayTime).toLocaleTimeString() : 'Never';
            
            if (debugData.playIntervals.length > 0) {
                const avg = debugData.playIntervals.reduce((a, b) => a + b, 0) / debugData.playIntervals.length;
                document.getElementById('debugAvgInterval').textContent = `${(avg / 60000).toFixed(2)} min`;
            }
            
            document.getElementById('debugSessionStart').textContent = debugData.sessionStart ? 
                new Date(debugData.sessionStart).toLocaleTimeString() : 'N/A';
            
            document.getElementById('debugFlyingPipes').textContent = flyingPipeCount;
            
            // System Info
            document.getElementById('debugPageVisible').textContent = !document.hidden;
            document.getElementById('debugPageVisible').className = `debug-value ${!document.hidden ? 'success' : 'warning'}`;
            
            const audioContextState = window.AudioContext || window.webkitAudioContext ? 'Available' : 'Not Available';
            document.getElementById('debugAudioContext').textContent = audioContextState;
            
            const browser = navigator.userAgent.match(/(Chrome|Safari|Firefox|Edge)/)?.[0] || 'Unknown';
            document.getElementById('debugBrowser').textContent = browser;
        }

        function updateDebugLog() {
            const logContainer = document.getElementById('debugLog');
            logContainer.innerHTML = debugData.audioEvents
                .slice(-20)
                .reverse()
                .map(entry => `<div class="debug-log-entry ${entry.type}">[${entry.time}] ${entry.message}</div>`)
                .join('');
        }

        function updateCountdown() {
            if (!isActive || !debugData.nextPlayTime) {
                document.getElementById('debugCountdown').textContent = '--:--:--';
                document.getElementById('debugTimeRemaining').textContent = 'N/A';
                return;
            }
            
            const now = Date.now();
            const remaining = Math.max(0, debugData.nextPlayTime - now);
            
            const hours = Math.floor(remaining / 3600000);
            const minutes = Math.floor((remaining % 3600000) / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            document.getElementById('debugCountdown').textContent = 
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('debugTimeRemaining').textContent = `${(remaining / 1000).toFixed(1)}s`;
        }

        function getReadyStateText(state) {
            const states = ['HAVE_NOTHING', 'HAVE_METADATA', 'HAVE_CURRENT_DATA', 'HAVE_FUTURE_DATA', 'HAVE_ENOUGH_DATA'];
            return states[state] || 'UNKNOWN';
        }

        function getNetworkStateText(state) {
            const states = ['NETWORK_EMPTY', 'NETWORK_IDLE', 'NETWORK_LOADING', 'NETWORK_NO_SOURCE'];
            return states[state] || 'UNKNOWN';
        }

        // Initialize audio with debug tracking
        function initAudio() {
            debugLog('Initializing audio...');
            audio = new Audio('pipedrop.mp3');
            audio.volume = 1.0; // Changed from 0.7 to 1.0
            
            // Track all audio events
            ['loadstart', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 
             'progress', 'suspend', 'abort', 'error', 'emptied', 'stalled', 
             'play', 'pause', 'ended', 'waiting'].forEach(eventName => {
                audio.addEventListener(eventName, (e) => {
                    debugLog(`Audio event: ${eventName}`, eventName === 'error' ? 'error' : 'info');
                    updateDebugPanel();
                });
            });
            
            audio.addEventListener('canplaythrough', () => {
                audioLoaded = true;
                debugLog('Audio loaded successfully!', 'success');
                document.getElementById('errorMessage').classList.remove('show');
                updateDebugPanel();
            });
            
            audio.addEventListener('error', (e) => {
                audioLoaded = false;
                const errorMsg = `Audio load error: ${e.target.error?.message || 'Unknown error'}`;
                debugLog(errorMsg, 'error');
                debugData.errors.push({ time: Date.now(), error: errorMsg });
                document.getElementById('errorMessage').classList.add('show');
                if (isActive) {
                    stopTimer();
                }
                updateDebugPanel();
            });
            
            // Preload the audio
            debugLog('Starting audio preload...');
            audio.load();
        }

        // Calculate next random interval using exponential distribution
        function getRandomInterval(averageMinutes) {
            const lambda = 1 / averageMinutes;
            const random = Math.random();
            const minutes = -Math.log(1 - random) / lambda;
            const cappedMinutes = Math.min(minutes, averageMinutes * 3);
            const ms = cappedMinutes * 60 * 1000;
            
            debugLog(`Calculated next interval: ${(ms/60000).toFixed(2)} minutes`);
            return ms;
        }

        function playSound() {
            if (!audioLoaded || !isActive) {
                debugLog(`Play aborted: audioLoaded=${audioLoaded}, isActive=${isActive}`, 'warning');
                return;
            }
            
            debugLog('Playing sound!', 'success');
            debugData.totalPlays++;
            
            // Track intervals
            if (debugData.lastPlayTime) {
                const interval = Date.now() - debugData.lastPlayTime;
                debugData.playIntervals.push(interval);
                if (debugData.playIntervals.length > 10) {
                    debugData.playIntervals.shift();
                }
            }
            debugData.lastPlayTime = Date.now();
            
            // Clone and play
            const audioClone = audio.cloneNode();
            audioClone.volume = audio.volume;
            audioClone.play().catch(err => {
                debugLog(`Audio play failed: ${err.message}`, 'error');
            });
            
            // Flash effect
            const flashEffect = document.getElementById('flashEffect');
            flashEffect.classList.add('flash');
            setTimeout(() => {
                flashEffect.classList.remove('flash');
            }, 300);
            
            updateDebugPanel();
            
            // Schedule next play
            scheduleNextPlay();
        }

        function scheduleNextPlay() {
            if (!isActive) {
                debugLog('Schedule aborted: timer inactive', 'warning');
                return;
            }
            
            const intervalMinutes = parseInt(document.getElementById('interval').value) || 60;
            const nextInterval = getRandomInterval(intervalMinutes);
            
            debugData.scheduledInterval = nextInterval;
            debugData.nextPlayTime = Date.now() + nextInterval;
            
            debugLog(`Next play scheduled in ${(nextInterval/60000).toFixed(2)} minutes`);
            
            timeoutId = setTimeout(() => {
                playSound();
            }, nextInterval);
            
            updateDebugPanel();
        }

        function startTimer() {
            if (!audioLoaded) {
                debugLog('Start failed: Audio not loaded', 'error');
                document.getElementById('errorMessage').classList.add('show');
                return;
            }
            
            debugLog('Starting timer...', 'success');
            isActive = true;
            debugData.sessionStart = Date.now();
            
            // Switch to waiting view
            document.getElementById('setupView').classList.add('hidden');
            document.getElementById('waitingView').classList.add('active');
            document.getElementById('container').classList.add('waiting-mode');
            
            // Schedule first play
            scheduleNextPlay();
            updateDebugPanel();
        }

        function stopTimer() {
            debugLog('Stopping timer...', 'warning');
            isActive = false;
            debugData.nextPlayTime = null;
            debugData.scheduledInterval = null;
            
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            
            // Switch back to setup view
            document.getElementById('setupView').classList.remove('hidden');
            document.getElementById('waitingView').classList.remove('active');
            document.getElementById('container').classList.remove('waiting-mode');
            
            updateDebugPanel();
        }

        function toggleDebugPanel() {
            debugMode = !debugMode;
            document.getElementById('debugPanel').classList.toggle('active');
            if (debugMode) {
                updateDebugPanel();
                updateDebugLog();
            }
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            keysPressed[e.key.toLowerCase()] = true;
            
            // Check for Q+W+E combination for debug panel
            if (keysPressed['q'] && keysPressed['w'] && keysPressed['e']) {
                toggleDebugPanel();
            }
            
            // Check for P key for pipe emoji
            if (e.key.toLowerCase() === 'p') {
                launchPipeEmoji();
            }
        });

        document.addEventListener('keyup', (e) => {
            delete keysPressed[e.key.toLowerCase()];
        });

        // Update countdown every 100ms when debug panel is open
        setInterval(() => {
            if (debugMode) {
                updateCountdown();
            }
        }, 100);

        // Update debug panel every second
        setInterval(() => {
            if (debugMode) {
                updateDebugPanel();
            }
        }, 1000);

        // Try to keep the page active in background
        document.addEventListener('visibilitychange', () => {
            debugLog(`Page visibility changed: ${document.hidden ? 'hidden' : 'visible'}`);
            if (!document.hidden && isActive && !timeoutId) {
                debugLog('Restarting timer after visibility change');
                scheduleNextPlay();
            }
            updateDebugPanel();
        });

        // Prevent timer from being paused by using Web Audio API trick
        if (window.AudioContext || window.webkitAudioContext) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const ctx = new AudioContext();
            
            // Create silent audio to keep context active
            const silentSource = ctx.createConstantSource();
            silentSource.connect(ctx.destination);
            silentSource.start();
            debugLog('Audio context hack applied for background playback');
        }
    </script>
</body>
</html>