<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0f0a1e">
  <title>Fake My Learning</title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-deep: #0f0a1e;
      --bg-card: #1a1230;
      --bg-elevated: #251a40;
      --text-primary: #f0e6ff;
      --text-secondary: #c4b5d8;
      --text-muted: #9a8bb5;
      --text-dim: #6b5a8a;
      --learner-glow: #22c55e;
      --learner-dim: #1a8a47;
      --learner-bg: rgba(34, 197, 94, 0.15);
      --faker-glow: #ef4444;
      --faker-bg: rgba(239, 68, 68, 0.15);
      --twist-glow: #f59e0b;
      --twist-bg: rgba(245, 158, 11, 0.15);
      --accent: #a855f7;
      --accent-bright: #c084fc;
      --accent-glow: rgba(168, 85, 247, 0.4);
      --border: rgba(168, 85, 247, 0.3);
      --radius: 16px;
      --radius-sm: 8px;
      --touch-min: 48px;
      --transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-deep);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      min-height: 100dvh;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(168, 85, 247, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(239, 68, 68, 0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(34, 197, 94, 0.04) 0%, transparent 60%);
      pointer-events: none;
      z-index: 0;
    }

    .app {
      position: relative;
      z-index: 1;
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 480px;
      width: 100%;
      margin: 0 auto;
      padding: 16px;
      padding-bottom: env(safe-area-inset-bottom, 16px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    .screen {
      display: none;
      flex-direction: column;
      flex: 1;
      animation: fadeIn 0.3s ease;
      position: relative;
    }

    .screen.active {
      display: flex;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    @keyframes glow {
      0%, 100% { filter: drop-shadow(0 0 10px currentColor); }
      50% { filter: drop-shadow(0 0 20px currentColor); }
    }

    @keyframes revealPop {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }

    h1 {
      font-size: clamp(2rem, 8vw, 3rem);
      font-weight: 700;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      line-height: 1.1;
      color: var(--text-primary);
      text-align: center;
    }

    h2 {
      font-size: clamp(1.4rem, 5vw, 2rem);
      font-weight: 700;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--text-primary);
    }

    h3 {
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: var(--text-primary);
    }

    p {
      font-size: 1rem;
      line-height: 1.5;
      color: var(--text-secondary);
    }

    button {
      font-family: inherit;
      color: var(--text-primary);
      background: transparent;
      border: none;
      cursor: pointer;
    }

    .btn {
      font-family: inherit;
      font-weight: 600;
      font-size: 1rem;
      min-height: var(--touch-min);
      padding: 14px 28px;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all var(--transition);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: var(--text-primary);
      width: 100%;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent) 0%, #9333ea 100%);
      color: #ffffff;
      box-shadow: 0 4px 20px var(--accent-glow);
    }

    .btn-primary:hover, .btn-primary:focus {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px var(--accent-glow);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover, .btn-secondary:focus {
      background: var(--bg-card);
      border-color: var(--accent);
    }

    .btn-ghost {
      background: transparent;
      color: var(--text-secondary);
    }

    .btn-ghost:hover {
      color: var(--text-primary);
      background: rgba(255,255,255,0.05);
    }

    .btn-lg {
      min-height: 54px;
      font-size: 1.1rem;
      padding: 14px 28px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn-sm {
      min-height: 36px;
      padding: 8px 16px;
      font-size: 0.875rem;
      width: auto;
    }

    .btn-danger {
      background: var(--faker-bg);
      border: 1px solid var(--faker-glow);
      color: var(--faker-glow);
    }

    .btn-danger:hover {
      background: rgba(239, 68, 68, 0.3);
    }

    .input, .textarea {
      font-family: inherit;
      font-size: 1rem;
      padding: 12px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      transition: all var(--transition);
      width: 100%;
    }

    .textarea {
      min-height: 180px;
      resize: vertical;
      line-height: 1.8;
    }

    .input:focus, .textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-glow);
    }

    .input::placeholder, .textarea::placeholder {
      color: var(--text-muted);
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
    }

    .options-row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
    }

    .option-btn {
      flex: 1;
      min-width: 60px;
      font-family: inherit;
      background: var(--bg-card);
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 12px;
      color: var(--text-primary);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition);
      min-height: var(--touch-min);
    }

    .option-btn.selected {
      border-color: var(--accent);
      background: rgba(168, 85, 247, 0.25);
      color: #ffffff;
    }

    .option-btn:hover:not(:disabled) {
      border-color: var(--accent);
      color: #ffffff;
    }

    .option-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .close-btn {
      position: absolute;
      top: 0;
      right: 0;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: var(--text-muted);
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all var(--transition);
      z-index: 10;
    }

    .close-btn:hover {
      color: var(--text-primary);
    }

    .cancel-confirm {
      display: none;
      position: absolute;
      top: 50px;
      right: 8px;
      background: var(--bg-card);
      border: 2px solid var(--faker-glow);
      border-radius: var(--radius);
      padding: 16px;
      z-index: 20;
      animation: fadeIn 0.2s ease;
      max-width: 280px;
    }

    .cancel-confirm.show {
      display: block;
    }

    .cancel-confirm p {
      margin-bottom: 12px;
      color: var(--text-primary);
      font-weight: 500;
    }

    .cancel-confirm-btns {
      display: flex;
      gap: 8px;
    }

    .cancel-confirm-btns .btn {
      flex: 1;
    }

    .role-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 12px;
      min-height: 0;
      overflow: visible;
    }

    .role-player-name {
      font-size: clamp(1.8rem, 8vw, 2.5rem);
      font-weight: 700;
      color: var(--accent-bright);
      text-transform: uppercase;
      letter-spacing: 0.03em;
      margin-bottom: 16px;
      text-shadow: 0 0 20px var(--accent-glow);
    }

    .next-player-btn {
      position: sticky;
      bottom: 0;
      background: linear-gradient(to top, var(--bg-deep) 80%, transparent);
      padding: 16px 0;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      margin-top: auto;
      z-index: 5;
      display: none;
    }

    .next-player-btn.visible {
      display: block;
    }

    #screen-role {
      overflow-y: auto;
      max-height: 100%;
    }

    .hold-reveal-wrapper {
      position: relative;
      padding: 40px 30px;
      border: 3px dashed var(--border);
      border-radius: var(--radius);
      cursor: pointer;
      transition: all var(--transition);
      touch-action: manipulation;
      min-width: 260px;
    }

    @media (max-height: 600px) {
      .hold-reveal-wrapper {
        padding: 20px 16px;
      }
      
      .role-player-name {
        font-size: clamp(1.5rem, 8vw, 2rem);
        margin-bottom: 8px;
      }
      
      .role-container {
        padding: 8px;
        justify-content: flex-start;
        padding-top: 0;
      }
      
      .progress-dots {
        margin-bottom: 12px;
      }
      
      .hold-icon {
        font-size: 2rem;
        margin-bottom: 8px;
      }
      
      .secret-word.small {
        font-size: clamp(1.5rem, 7vw, 2rem);
        margin: 8px 0;
      }
      
      .role-badge {
        padding: 6px 16px;
        font-size: 1.1rem;
        margin: 8px 0;
      }
      
      .next-player-btn {
        padding: 12px 0;
      }
    }
    
    @media (max-height: 500px) {
      .role-player-name {
        font-size: 1.5rem;
        margin-bottom: 4px;
      }
      
      .hold-reveal-wrapper {
        padding: 12px;
        min-width: 220px;
      }
      
      .hold-icon {
        font-size: 1.5rem;
        margin-bottom: 4px;
      }
      
      .hold-prompt h3 {
        font-size: 1.1rem;
      }
      
      .hold-prompt p {
        font-size: 0.8rem;
      }
    }

    .hold-reveal-wrapper:hover {
      border-color: var(--accent);
      background: rgba(168, 85, 247, 0.05);
    }

    .hold-reveal-wrapper.holding {
      border-color: var(--accent);
      background: rgba(168, 85, 247, 0.1);
      transform: scale(0.98);
      border-style: solid;
    }

    .hold-reveal-wrapper.holding .hold-prompt {
      display: none;
    }

    .hold-reveal-wrapper.holding .role-content {
      display: block;
    }

    .hold-prompt {
      display: block;
    }

    .role-content {
      display: none;
    }

    .hold-icon {
      font-size: 2.5rem;
      margin-bottom: 12px;
    }

    .role-revealed {
      animation: revealPop 0.2s ease;
    }

    .role-badge {
      display: inline-block;
      padding: 8px 24px;
      border-radius: 999px;
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      margin: 12px 0;
      text-transform: uppercase;
    }

    .role-badge.learner {
      background: rgba(34, 197, 94, 0.1);
      color: var(--learner-dim);
      border: 2px solid var(--learner-dim);
      opacity: 0.8;
    }

    .role-badge.faker {
      background: var(--faker-bg);
      color: var(--faker-glow);
      border: 2px solid var(--faker-glow);
      animation: glow 2s ease infinite;
    }

    .secret-word {
      font-size: clamp(1.8rem, 8vw, 2.5rem);
      font-weight: 700;
      color: #ffffff;
      text-transform: uppercase;
      margin: 16px 0;
      text-shadow: 0 0 30px var(--accent-bright), 0 0 60px var(--accent);
      word-break: break-word;
    }

    .secret-word.small {
      font-size: clamp(1.4rem, 6vw, 1.8rem);
      margin: 10px 0;
    }

    .role-definition {
      font-size: 1rem;
      color: var(--text-secondary);
      margin-top: 8px;
      font-style: italic;
      background: rgba(168, 85, 247, 0.1);
      padding: 12px 16px;
      border-radius: var(--radius-sm);
      border-left: 3px solid var(--accent);
      text-align: left;
      max-width: 300px;
    }

    .pass-device {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .pass-device-name {
      font-size: clamp(1.8rem, 8vw, 2.5rem);
      font-weight: 700;
      color: var(--accent);
      margin: 24px 0;
    }

    .pass-icon {
      font-size: 4rem;
      margin-bottom: 16px;
      animation: pulse 2s ease infinite;
    }

    .confirm-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--bg-card);
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition);
      margin-bottom: 8px;
      min-height: 56px;
    }

    .confirm-option:hover {
      border-color: var(--accent);
    }

    .confirm-option.selected {
      border-color: var(--faker-glow);
      background: var(--faker-bg);
    }

    .confirm-option .player-name {
      flex: 1;
      font-weight: 600;
      color: var(--text-primary);
    }

    .selection-counter {
      text-align: center;
      padding: 12px;
      background: var(--bg-card);
      border-radius: var(--radius-sm);
      margin-bottom: 16px;
      font-weight: 600;
    }

    .selection-counter.complete {
      background: var(--learner-bg);
      color: var(--learner-glow);
    }

    .result-reveal {
      text-align: center;
      padding: 32px;
      border-radius: var(--radius);
      margin: 24px 0;
      animation: revealPop 0.5s ease;
    }

    .result-reveal.correct {
      background: var(--learner-bg);
      border: 2px solid var(--learner-glow);
    }

    .result-reveal.wrong {
      background: var(--faker-bg);
      border: 2px solid var(--faker-glow);
    }

    .result-reveal.partial {
      background: var(--twist-bg);
      border: 2px solid var(--twist-glow);
    }

    .result-name {
      font-size: 1.4rem;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .twist-box {
      background: var(--twist-bg);
      border: 2px solid var(--twist-glow);
      border-radius: var(--radius);
      padding: 24px;
      text-align: center;
      margin: 20px 0;
      animation: revealPop 0.5s ease;
    }

    .twist-box h3 {
      color: var(--twist-glow);
      margin-bottom: 8px;
    }

    .winner-announcement {
      text-align: center;
      padding: 40px 20px;
    }

    .winner-icon {
      font-size: 5rem;
      margin-bottom: 16px;
    }

    .winner-text {
      font-size: clamp(1.4rem, 6vw, 2rem);
      font-weight: 700;
    }

    .faker-list {
      margin: 16px 0;
    }

    .faker-item {
      padding: 8px 16px;
      background: var(--faker-bg);
      border: 1px solid var(--faker-glow);
      border-radius: var(--radius-sm);
      color: var(--faker-glow);
      margin-bottom: 8px;
      font-weight: 600;
    }

    .rules-box {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin: 16px 0;
    }

    .rules-box ol {
      padding-left: 20px;
      color: var(--text-secondary);
    }

    .rules-box li {
      margin-bottom: 12px;
      line-height: 1.5;
    }

    .rules-box strong {
      color: var(--text-primary);
    }

    .form-section {
      margin-bottom: 24px;
    }

    .form-label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .form-hint {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .player-count-badge {
      display: inline-block;
      background: var(--accent);
      color: #ffffff;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 0.875rem;
      font-weight: 600;
      margin-left: 8px;
    }

    .all-words-list {
      margin: 16px 0;
    }

    .all-words-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 12px;
      border-bottom: 1px solid var(--border);
      color: var(--text-primary);
      gap: 12px;
    }

    .all-words-item:last-child {
      border-bottom: none;
    }

    .all-words-item .player {
      font-weight: 600;
      min-width: 80px;
    }

    .all-words-item .term {
      color: var(--twist-glow);
      text-align: right;
      flex: 1;
    }

    .spacer { flex: 1; }
    .spacer-sm { height: 16px; }
    .spacer-md { height: 24px; }
    .spacer-lg { height: 32px; }

    .text-center { text-align: center; }
    .text-muted { color: var(--text-muted); }
    .text-success { color: var(--learner-glow); }
    .text-danger { color: var(--faker-glow); }
    .text-warning { color: var(--twist-glow); }
    .mb-1 { margin-bottom: 8px; }
    .mb-2 { margin-bottom: 16px; }
    .mb-3 { margin-bottom: 24px; }
    .mt-auto { margin-top: auto; }

    .logo-container {
      text-align: center;
      margin-bottom: 32px;
    }

    .logo-fake {
      color: var(--faker-glow);
    }

    .logo-learning {
      color: var(--learner-glow);
    }

    .tagline {
      font-size: 0.875rem;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-top: 8px;
    }

    .progress-dots {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      max-width: 100%;
      padding: 0 8px;
    }

    .progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
      flex-shrink: 0;
    }

    /* Scale down dots when there are many players (via JS class) */
    .progress-dots.compact .progress-dot {
      width: 6px;
      height: 6px;
    }
    
    .progress-dots.compact {
      gap: 4px;
    }

    .progress-dot.active {
      background: var(--accent);
    }

    .progress-dot.done {
      background: var(--learner-glow);
    }

    .selected-list-display {
      background: var(--bg-card);
      border: 1px solid var(--border);
      padding: 16px;
      border-radius: var(--radius);
      margin-bottom: 20px;
      text-align: center;
    }

    .selected-list-display .label {
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .selected-list-display .name {
      color: var(--twist-glow);
      font-weight: 600;
      font-size: 1.1rem;
      margin-top: 4px;
    }

    .selected-list-display .count {
      color: var(--text-muted);
      font-size: 0.85rem;
      margin-top: 4px;
    }

    .resume-banner {
      background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-elevated) 100%);
      border: 1px solid var(--accent);
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 16px;
    }

    .resume-content {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .resume-icon {
      font-size: 1.5rem;
    }

    .resume-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .resume-text strong {
      color: var(--text-primary);
    }

    .resume-info {
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .resume-actions {
      display: flex;
      gap: 8px;
    }

    .resume-actions .btn {
      flex: 1;
    }

    .teacher-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent) 0%, #9333ea 100%);
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 4px 15px var(--accent-glow);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .teacher-btn:hover {
      transform: scale(1.1);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      padding: 20px;
      overflow-y: auto;
    }

    .modal.active {
      display: block;
    }

    .modal-content {
      max-width: 480px;
      margin: 20px auto;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 25px;
      position: relative;
    }

    .modal-content h2 {
      margin-bottom: 20px;
      text-align: center;
    }

    .close-modal {
      position: absolute;
      top: 15px;
      right: 20px;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.8rem;
      cursor: pointer;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-modal:hover {
      color: var(--text-primary);
    }

    .pin-input {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
    }

    .pin-input input {
      width: 50px;
      height: 60px;
      text-align: center;
      font-size: 1.5rem;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg-elevated);
      color: var(--text-primary);
    }

    .pin-input input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .tab-container {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
    }

    .tab-btn {
      flex: 1;
      padding: 12px;
      border: 2px solid var(--border);
      background: transparent;
      color: var(--text-secondary);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition);
      font-size: 0.9rem;
      font-weight: 600;
    }

    .tab-btn.active {
      border-color: var(--accent);
      background: rgba(168, 85, 247, 0.2);
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .word-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: var(--bg-elevated);
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      margin-bottom: 10px;
      cursor: pointer;
      transition: all var(--transition);
    }

    .word-list-item:hover {
      border-color: var(--accent);
    }

    .word-list-item.selected {
      border-color: var(--accent);
      background: rgba(168, 85, 247, 0.15);
    }

    .word-list-item .list-info {
      flex: 1;
    }

    .word-list-item .list-name {
      font-weight: 600;
      color: var(--text-primary);
    }

    .word-list-item .list-count {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .word-list-item .list-actions {
      display: flex;
      gap: 8px;
    }

    .word-list-item .list-actions button {
      padding: 8px 12px;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .word-list-item .edit-btn {
      background: var(--accent);
      color: white;
    }

    .word-list-item .delete-btn {
      background: var(--faker-glow);
      color: white;
    }

    .no-lists {
      text-align: center;
      color: var(--text-muted);
      padding: 40px 20px;
    }

    .info-box {
      background: var(--bg-elevated);
      padding: 15px;
      border-radius: var(--radius-sm);
      margin-bottom: 15px;
      font-size: 0.9rem;
      color: var(--text-secondary);
      border-left: 3px solid var(--accent);
    }

    .info-box code {
      background: var(--bg-deep);
      padding: 2px 6px;
      border-radius: 4px;
      color: var(--twist-glow);
    }

    .error-message {
      color: var(--faker-glow);
      text-align: center;
      margin: 10px 0;
      font-size: 0.9rem;
    }

    .success-message {
      color: var(--learner-glow);
      text-align: center;
      margin: 10px 0;
      font-size: 0.9rem;
    }

    .summary-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin: 16px 0;
    }

    .summary-section h3 {
      color: var(--text-muted);
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 12px;
    }

    .summary-word {
      font-size: clamp(1.6rem, 6vw, 2.2rem);
      font-weight: 700;
      color: var(--twist-glow);
      text-align: center;
      margin-bottom: 12px;
      word-break: break-word;
    }

    .summary-definition {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
      line-height: 1.5;
    }

    .mode-warning {
      color: var(--twist-glow);
      font-size: 0.85rem;
      margin: 5px 0;
      padding: 8px 12px;
      background: var(--twist-bg);
      border-radius: var(--radius-sm);
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Screen: Home -->
    <div id="screen-home" class="screen active">
      <div class="spacer"></div>
      <div class="logo-container">
        <h1><span class="logo-fake">Fake</span> <span class="logo-learning">My Learning</span></h1>
        <p class="tagline">Can you spot who's faking it?</p>
      </div>
      <p class="text-center mb-3">An educational party game where learners know the term and fakers must bluff their way through.</p>
      <div class="spacer"></div>
      <div id="home-list-status"></div>
      
      <!-- Resume Banner (hidden by default) -->
      <div id="resume-banner" class="resume-banner" style="display: none;">
        <div class="resume-content">
          <span class="resume-icon">‚è∏Ô∏è</span>
          <div class="resume-text">
            <strong>Unfinished Game</strong>
            <span class="resume-info"></span>
          </div>
        </div>
        <div class="resume-actions">
          <button class="btn btn-sm btn-primary" onclick="resumeGame()">Resume</button>
          <button class="btn btn-sm btn-ghost" onclick="discardSavedGame()">Discard</button>
        </div>
      </div>
      
      <div class="spacer-md"></div>
      <button class="btn btn-primary btn-lg" onclick="showScreen('setup')" id="new-game-btn" disabled>New Game</button>
      <div class="spacer-md"></div>
      <button class="btn btn-ghost" onclick="showModal('how-to-play-modal')">How to Play</button>
      <div class="spacer-lg"></div>
    </div>

    <!-- Screen: Setup -->
    <div id="screen-setup" class="screen">
      <h2 class="mb-2">Game Setup</h2>
      
      <div id="setup-list-display" class="selected-list-display">
        <div class="label">Active Word List</div>
        <div class="name" id="setup-list-name">None selected</div>
        <div class="count" id="setup-list-count"></div>
      </div>

      <div class="form-section">
        <label class="form-label">
          Player Names
          <span class="player-count-badge" id="player-count-badge">0 players</span>
        </label>
        <textarea 
          id="players-textarea" 
          class="textarea" 
          placeholder="Enter one name per line:&#10;Alice&#10;Bob&#10;Charlie&#10;Diana"
          oninput="updatePlayerCount()"
        ></textarea>
        <p class="form-hint" id="player-hint">Enter each player's name on a new line. Minimum 4, maximum 24 players.</p>
      </div>

      <div class="form-section">
        <label class="form-label">Number of Fakers</label>
        <div class="options-row" id="faker-options">
          <button class="option-btn selected" data-fakers="1" onclick="selectFakers(1)">1</button>
        </div>
        <p class="form-hint" id="faker-hint">Add more players to unlock additional faker options.</p>
      </div>

      <div id="mode-warnings"></div>

      <div class="spacer"></div>
      
      <button class="btn btn-primary btn-lg" onclick="startGame()" id="btn-start" disabled>Start Game</button>
      <div class="spacer-md"></div>
      <button class="btn btn-ghost" onclick="showScreen('home')">‚Üê Cancel</button>
    </div>

    <!-- Screen: Pass Device -->
    <div id="screen-pass" class="screen">
      <button class="close-btn" onclick="showCancelConfirm('pass')">‚úï</button>
      <div id="cancel-confirm-pass" class="cancel-confirm">
        <p>Cancel game and return to setup?</p>
        <div class="cancel-confirm-btns">
          <button class="btn btn-sm btn-secondary" onclick="hideCancelConfirm('pass')">Keep Playing</button>
          <button class="btn btn-sm btn-danger" onclick="cancelGame()">Cancel</button>
        </div>
      </div>
      
      <div class="progress-dots" id="progress-dots"></div>
      <div class="pass-device">
        <div class="pass-icon">üì±</div>
        <p class="text-muted">Pass the device to</p>
        <div class="pass-device-name" id="pass-player-name">Player Name</div>
        <p class="text-muted mb-3">Hold so others can't see the screen</p>
        <button class="btn btn-primary btn-lg" onclick="showRoleScreen()">Ready</button>
      </div>
    </div>

    <!-- Screen: Role Reveal -->
    <div id="screen-role" class="screen">
      <button class="close-btn" onclick="showCancelConfirm('role')">‚úï</button>
      <div id="cancel-confirm-role" class="cancel-confirm">
        <p>Cancel game and return to setup?</p>
        <div class="cancel-confirm-btns">
          <button class="btn btn-sm btn-secondary" onclick="hideCancelConfirm('role')">Keep Playing</button>
          <button class="btn btn-sm btn-danger" onclick="cancelGame()">Cancel</button>
        </div>
      </div>
      
      <div class="progress-dots" id="progress-dots-role"></div>
      <div class="role-container">
        <p class="role-player-name" id="role-player-label">Player Name</p>
        
        <div id="hold-reveal-wrapper" class="hold-reveal-wrapper">
          <div class="hold-prompt">
            <div class="hold-icon">üëÜ</div>
            <h3>Hold to Reveal</h3>
            <p class="text-muted">Press and hold to see your role.<br>Release to hide.</p>
          </div>
          
          <div class="role-content">
            <p class="text-muted">You are a</p>
            <div class="role-badge" id="role-badge">LEARNER</div>
            <div id="role-word-container">
              <p>The term is:</p>
              <div class="secret-word small" id="role-word">TERM</div>
              <p class="role-definition" id="role-definition">Definition here</p>
            </div>
            <div id="role-faker-container" style="display: none;">
              <p class="mb-2">You <strong>do NOT</strong> know the term.</p>
              <p>Listen carefully and try to blend in.</p>
            </div>
          </div>
        </div>
      </div>
      <div class="next-player-btn" id="next-player-container">
        <button class="btn btn-secondary btn-lg" onclick="nextPlayer()">Done ‚Äî Next Player</button>
      </div>
    </div>

    <!-- Screen: Discussion -->
    <div id="screen-discussion" class="screen">
      <div class="spacer"></div>
      <div class="text-center">
        <h2 class="mb-2">Time to Discuss</h2>
        <p class="text-muted mb-2">Put the device aside</p>
      </div>
      
      <div class="rules-box">
        <ol>
          <li><strong>Go around the group in order.</strong> Each player says something short that indicates they know the term. Fakers have to bluff. Don't say the term!</li>
          <li>After <strong>two or three rounds</strong>, discuss who you think is faking it and make a group decision.</li>
          <li>Return to the app to confirm.</li>
        </ol>
      </div>

      <p class="text-center text-muted">Starting with: <strong id="starting-player">First Player</strong></p>
      
      <div class="spacer"></div>
      <button class="btn btn-primary btn-lg" onclick="showConfirmation()">We've Decided ‚Äî Reveal Faker</button>
    </div>

    <!-- Screen: Confirmation -->
    <div id="screen-confirm" class="screen">
      <h2 class="mb-2">Who Did You Choose?</h2>
      <p class="text-muted mb-2" id="confirm-instruction">Select who the group decided is faking it:</p>
      
      <div class="selection-counter" id="selection-counter">Select 1 player</div>
      
      <div id="confirm-options" class="mb-3"></div>
      
      <div class="spacer"></div>
      <button class="btn btn-primary btn-lg" onclick="revealResults()" id="btn-reveal" disabled>Reveal the Truth</button>
    </div>

    <!-- Screen: Results -->
    <div id="screen-results" class="screen">
      <div class="spacer"></div>
      
      <div class="text-center">
        <p class="text-muted" id="result-label">You chose...</p>
        <div id="result-chosen-names"></div>
      </div>
      
      <div class="result-reveal" id="result-reveal">
        <p id="result-verdict">They were...</p>
        <div id="result-roles"></div>
      </div>

      <div class="winner-announcement" id="winner-announcement">
        <div class="winner-icon" id="winner-icon">üéâ</div>
        <div class="winner-text" id="winner-text">Learners Win</div>
      </div>

      <div id="actual-fakers-section" style="display: none;">
        <p class="text-center text-muted mb-1">The actual faker(s):</p>
        <div class="faker-list" id="actual-fakers-list"></div>
      </div>
      
      <div class="spacer"></div>
      <button class="btn btn-primary btn-lg" onclick="showSummary()">See Game Summary</button>
    </div>

    <!-- Screen: Summary -->
    <div id="screen-summary" class="screen">
      <h2 class="mb-2">Game Summary</h2>
      
      <div class="summary-section">
        <h3>The Term Was</h3>
        <div class="summary-word" id="summary-word">TERM</div>
        <div class="summary-definition" id="summary-definition">Definition here</div>
      </div>

      <div id="summary-all-words" style="display: none;" class="summary-section">
        <h3>All Terms Assigned</h3>
        <div class="all-words-list" id="all-words-list"></div>
      </div>

      <div id="twist-reveal" class="twist-box" style="display: none;">
        <h3>üåÄ Plot Twist</h3>
        <p id="twist-text">Twist description here</p>
      </div>

      <div class="spacer"></div>
      <button class="btn btn-primary btn-lg" onclick="playAgain()">Play Again</button>
      <div class="spacer-md"></div>
      <button class="btn btn-secondary" onclick="newPlayers()">New Players</button>
    </div>
  </div>

  <!-- Teacher Button -->
  <button class="teacher-btn" onclick="openTeacherModal()">‚öôÔ∏è</button>

  <!-- How to Play Modal -->
  <div id="how-to-play-modal" class="modal">
    <div class="modal-content">
      <button class="close-modal" onclick="hideModal('how-to-play-modal')">√ó</button>
      <h2>How to Play</h2>
      
      <div class="card mb-2">
        <h3 class="mb-1">Overview</h3>
        <p>Fake My Learning is an educational game where most players know a term and its definition. One or more players are Fakers who don't know the term and must bluff.</p>
      </div>
      
      <div class="card mb-2">
        <h3 class="mb-1">Setup</h3>
        <p>Teacher adds word lists (tap ‚öôÔ∏è), then enter player names.</p>
      </div>

      <div class="card mb-2">
        <h3 class="mb-1">Learn Your Role</h3>
        <p>Pass the device around. Each player <strong>holds</strong> to see if they're a <span class="text-success">Learner</span> or <span class="text-danger">Faker</span>. Release to hide.</p>
      </div>

      <div class="card mb-2">
        <h3 class="mb-1">Give Clues</h3>
        <p>Take turns saying ONE word related to the term. Fakers must bluff.</p>
      </div>

      <div class="card mb-2">
        <h3 class="mb-1">Win Conditions</h3>
        <p><strong class="text-success">Learners win</strong> by identifying all Fakers</p>
        <p><strong class="text-danger">Fakers win</strong> by staying hidden</p>
      </div>
      
      <button class="btn btn-primary" onclick="hideModal('how-to-play-modal')" style="margin-top: 20px;">Got It</button>
    </div>
  </div>

  <!-- PIN Setup Modal -->
  <div id="pin-setup-modal" class="modal">
    <div class="modal-content">
      <h2>Teacher Setup</h2>
      <p class="text-center text-muted mb-2">Create a 4-digit PIN to protect teacher settings</p>
      
      <div class="pin-input">
        <input type="tel" maxlength="1" id="setup-pin-1" oninput="pinInputHandler(this, 'setup-pin-2')">
        <input type="tel" maxlength="1" id="setup-pin-2" oninput="pinInputHandler(this, 'setup-pin-3')">
        <input type="tel" maxlength="1" id="setup-pin-3" oninput="pinInputHandler(this, 'setup-pin-4')">
        <input type="tel" maxlength="1" id="setup-pin-4" oninput="pinInputHandler(this, null)">
      </div>
      
      <div id="pin-setup-error" class="error-message"></div>
      
      <button class="btn btn-primary" onclick="saveNewPin()">Set PIN</button>
    </div>
  </div>

  <!-- PIN Entry Modal -->
  <div id="pin-entry-modal" class="modal">
    <div class="modal-content">
      <button class="close-modal" onclick="hideModal('pin-entry-modal')">√ó</button>
      <h2>Teacher Access</h2>
      <p class="text-center text-muted mb-2">Enter your 4-digit PIN</p>
      
      <div class="pin-input">
        <input type="tel" maxlength="1" id="entry-pin-1" oninput="pinInputHandler(this, 'entry-pin-2')">
        <input type="tel" maxlength="1" id="entry-pin-2" oninput="pinInputHandler(this, 'entry-pin-3')">
        <input type="tel" maxlength="1" id="entry-pin-3" oninput="pinInputHandler(this, 'entry-pin-4')">
        <input type="tel" maxlength="1" id="entry-pin-4" oninput="pinInputHandler(this, null)">
      </div>
      
      <div id="pin-entry-error" class="error-message"></div>
      
      <button class="btn btn-primary" onclick="verifyPin()">Enter</button>
    </div>
  </div>

  <!-- Teacher Settings Modal -->
  <div id="teacher-modal" class="modal">
    <div class="modal-content">
      <button class="close-modal" onclick="hideModal('teacher-modal')">√ó</button>
      <h2>Teacher Settings</h2>
      
      <div class="tab-container">
        <button class="tab-btn active" onclick="switchTab('lists-tab')">Word Lists</button>
        <button class="tab-btn" onclick="switchTab('create-tab')">Create New</button>
      </div>

      <div id="lists-tab" class="tab-content active">
        <div id="word-lists-container"></div>
      </div>

      <div id="create-tab" class="tab-content">
        <div class="form-section">
          <label class="form-label">List Name</label>
          <input type="text" class="input" id="list-name-input" placeholder="e.g., Biology Unit 3">
        </div>
        
        <div class="info-box">
          <strong>Format:</strong> One term per line<br>
          <code>Term, Definition</code><br><br>
          <strong>Example:</strong><br>
          <code>Photosynthesis, Process by which plants convert sunlight to energy</code>
        </div>

        <div class="form-section">
          <label class="form-label">Terms & Definitions</label>
          <textarea class="textarea" id="list-content-input" placeholder="Photosynthesis, Process by which plants convert sunlight to energy&#10;Mitosis, Cell division resulting in two identical cells" style="min-height: 200px;"></textarea>
        </div>

        <div id="list-edit-error" class="error-message"></div>
        <div id="list-edit-success" class="success-message"></div>

        <button class="btn btn-primary" onclick="saveWordList()" id="save-list-btn">Save List</button>
        <div class="spacer-sm"></div>
        <button class="btn btn-secondary" onclick="cancelEdit()" id="cancel-edit-btn" style="display: none;">Cancel Edit</button>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    const STORAGE_KEYS = {
      PIN: 'fml_teacher_pin',
      WORD_LISTS: 'fml_word_lists',
      SELECTED_LIST: 'fml_selected_list',
      GAME_STATE: 'fml_game_state',
      PLAYER_NAMES: 'fml_player_names'
    };

    let gameState = {
      players: [],
      settings: {
        fakerCount: 1
      },
      gameMode: "NORMAL",
      secretWord: null,
      secretDefinition: null,
      allTerms: [],
      currentPlayerIndex: 0,
      phase: "home",
      chosenFakers: [],
      editingListId: null
    };

    function init() {
      try {
        validateWordDatabase();
        setupHoldToReveal();
        restorePlayerNames();
        checkForUnfinishedGame();
        updateHomeScreen();
      } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize game. Try refreshing the page.');
      }
    }

    // === Game State Persistence ===
    function saveGameState() {
      try {
        const stateToSave = {
          players: gameState.players,
          settings: gameState.settings,
          gameMode: gameState.gameMode,
          secretWord: gameState.secretWord,
          secretDefinition: gameState.secretDefinition,
          allTerms: gameState.allTerms,
          currentPlayerIndex: gameState.currentPlayerIndex,
          phase: gameState.phase,
          chosenFakers: gameState.chosenFakers,
          savedAt: Date.now()
        };
        localStorage.setItem(STORAGE_KEYS.GAME_STATE, JSON.stringify(stateToSave));
      } catch (error) {
        console.error('Failed to save game state:', error);
      }
    }

    function loadGameState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.GAME_STATE);
        return saved ? JSON.parse(saved) : null;
      } catch (error) {
        console.error('Failed to load game state:', error);
        return null;
      }
    }

    function clearGameState() {
      try {
        localStorage.removeItem(STORAGE_KEYS.GAME_STATE);
      } catch (error) {
        console.error('Failed to clear game state:', error);
      }
    }

    function checkForUnfinishedGame() {
      const saved = loadGameState();
      if (saved && saved.players && saved.players.length > 0) {
        // Check if game is old (more than 2 hours)
        const twoHours = 2 * 60 * 60 * 1000;
        if (Date.now() - saved.savedAt > twoHours) {
          clearGameState();
          return;
        }
        
        // Show resume banner
        const banner = document.getElementById('resume-banner');
        if (banner) {
          const playerCount = saved.players.length;
          const phase = saved.phase || 'unknown';
          banner.querySelector('.resume-info').textContent = 
            `${playerCount} players ‚Äî ${phase} phase`;
          banner.style.display = 'block';
        }
      }
    }

    function resumeGame() {
      const saved = loadGameState();
      if (!saved) return;
      
      // Restore game state
      gameState.players = saved.players;
      gameState.settings = saved.settings;
      gameState.gameMode = saved.gameMode;
      gameState.secretWord = saved.secretWord;
      gameState.secretDefinition = saved.secretDefinition;
      gameState.allTerms = saved.allTerms;
      gameState.currentPlayerIndex = saved.currentPlayerIndex;
      gameState.chosenFakers = saved.chosenFakers || [];
      
      // Hide resume banner
      const banner = document.getElementById('resume-banner');
      if (banner) banner.style.display = 'none';
      
      // Navigate to appropriate screen
      const phase = saved.phase || 'pass';
      if (phase === 'pass' || phase === 'role') {
        showPassDevice();
      } else if (phase === 'discussion') {
        showScreen('discussion');
      } else if (phase === 'confirm') {
        showConfirmation();
      } else {
        showPassDevice();
      }
    }

    function discardSavedGame() {
      clearGameState();
      const banner = document.getElementById('resume-banner');
      if (banner) banner.style.display = 'none';
    }

    function savePlayerNames() {
      try {
        const textarea = document.getElementById('players-textarea');
        if (textarea && textarea.value.trim()) {
          localStorage.setItem(STORAGE_KEYS.PLAYER_NAMES, textarea.value);
        }
      } catch (error) {
        console.error('Failed to save player names:', error);
      }
    }

    function restorePlayerNames() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.PLAYER_NAMES);
        if (saved) {
          const textarea = document.getElementById('players-textarea');
          if (textarea) {
            textarea.value = saved;
            updatePlayerCount();
          }
        }
      } catch (error) {
        console.error('Failed to restore player names:', error);
      }
    }

    // === Validation ===
    function validateWordDatabase() {
      try {
        const lists = getWordLists();
        // Filter out any corrupted lists
        const validLists = lists.filter(list => 
          list && list.id && list.name && Array.isArray(list.words)
        );
        if (validLists.length !== lists.length) {
          saveWordLists(validLists);
          console.warn('Cleaned up corrupted word lists');
        }
      } catch (error) {
        console.error('Word database validation failed:', error);
        // Reset to empty if completely corrupted
        localStorage.removeItem(STORAGE_KEYS.WORD_LISTS);
      }
    }

    function showError(message) {
      // Use alert for now, could be enhanced with a nicer modal
      alert(message);
    }

    let holdRevealState = { hasRevealed: false, isHolding: false, endProcessed: false };
    let holdAbortController = null;
    let isTransitioning = false;  // Prevent double-tap on navigation buttons
    
    function setupHoldToReveal() {
      // Clean up any existing listeners first
      cleanupHoldToReveal();
      
      const wrapper = document.getElementById('hold-reveal-wrapper');
      holdAbortController = new AbortController();
      const signal = holdAbortController.signal;
      
      const startHold = (e) => {
        e.preventDefault();
        wrapper.classList.add('holding');
        holdRevealState.isHolding = true;
        holdRevealState.hasRevealed = true;
        holdRevealState.endProcessed = false; // Reset for new hold
      };
      
      const endHold = (e) => {
        // Prevent double-firing from touchend + mouseup
        if (holdRevealState.endProcessed || !holdRevealState.isHolding) {
          return;
        }
        holdRevealState.endProcessed = true;
        holdRevealState.isHolding = false;
        
        wrapper.classList.remove('holding');
        if (holdRevealState.hasRevealed) {
          document.getElementById('next-player-container').classList.add('visible');
        }
      };
      
      wrapper.addEventListener('touchstart', startHold, { passive: false, signal });
      wrapper.addEventListener('touchend', endHold, { signal });
      wrapper.addEventListener('touchcancel', endHold, { signal });
      
      wrapper.addEventListener('mousedown', startHold, { signal });
      wrapper.addEventListener('mouseup', endHold, { signal });
      wrapper.addEventListener('mouseleave', endHold, { signal });
      
      document.addEventListener('mouseup', endHold, { signal });
      
      wrapper.addEventListener('contextmenu', (e) => e.preventDefault(), { signal });
    }
    
    function cleanupHoldToReveal() {
      if (holdAbortController) {
        holdAbortController.abort();
        holdAbortController = null;
      }
    }
    
    function resetHoldToReveal() {
      holdRevealState.hasRevealed = false;
      holdRevealState.isHolding = false;
      holdRevealState.endProcessed = false;
      document.getElementById('hold-reveal-wrapper').classList.remove('holding');
      document.getElementById('next-player-container').classList.remove('visible');
    }

    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(`screen-${screenId}`).classList.add('active');
      gameState.phase = screenId;
      
      if (screenId === 'setup') {
        updateSetupScreen();
      } else if (screenId === 'home') {
        updateHomeScreen();
        checkForUnfinishedGame();
      }
      
      // Save game state during active play phases
      const playPhases = ['pass', 'role', 'discussion', 'confirm'];
      if (playPhases.includes(screenId)) {
        saveGameState();
      }
    }

    function showModal(modalId) {
      document.getElementById(modalId).classList.add('active');
    }

    function hideModal(modalId) {
      document.getElementById(modalId).classList.remove('active');
      if (modalId === 'pin-entry-modal') {
        clearPinInputs('entry-pin');
      }
    }

    function showCancelConfirm(screen) {
      document.getElementById(`cancel-confirm-${screen}`).classList.add('show');
    }

    function hideCancelConfirm(screen) {
      document.getElementById(`cancel-confirm-${screen}`).classList.remove('show');
    }

    function cancelGame() {
      hideCancelConfirm('pass');
      hideCancelConfirm('role');
      
      // Reset all game state
      gameState.players = [];
      gameState.secretWord = null;
      gameState.secretDefinition = null;
      gameState.allTerms = [];
      gameState.currentPlayerIndex = 0;
      gameState.chosenFakers = [];
      gameState.gameMode = "NORMAL";
      
      // Reset UI state
      isTransitioning = false;
      resetHoldToReveal();
      
      // Clear saved game (don't commit word - game was cancelled)
      clearGameState();
      
      showScreen('setup');
    }

    function clearPinInputs(prefix) {
      for (let i = 1; i <= 4; i++) {
        const input = document.getElementById(`${prefix}-${i}`);
        if (input) input.value = '';
      }
    }

    function pinInputHandler(current, nextId) {
      if (current.value.length === 1 && nextId) {
        document.getElementById(nextId).focus();
      }
    }

    function getPin(prefix) {
      let pin = '';
      for (let i = 1; i <= 4; i++) {
        pin += document.getElementById(`${prefix}-${i}`).value;
      }
      return pin;
    }

    function isPinSet() {
      return localStorage.getItem(STORAGE_KEYS.PIN) !== null;
    }

    function saveNewPin() {
      const pin = getPin('setup-pin');
      if (pin.length !== 4 || !/^\d{4}$/.test(pin)) {
        document.getElementById('pin-setup-error').textContent = 'Please enter a 4-digit PIN';
        return;
      }
      
      localStorage.setItem(STORAGE_KEYS.PIN, pin);
      hideModal('pin-setup-modal');
      showModal('teacher-modal');
      renderWordLists();
    }

    function verifyPin() {
      const pin = getPin('entry-pin');
      const storedPin = localStorage.getItem(STORAGE_KEYS.PIN);
      
      if (pin === storedPin) {
        hideModal('pin-entry-modal');
        showModal('teacher-modal');
        renderWordLists();
      } else {
        document.getElementById('pin-entry-error').textContent = 'Incorrect PIN. Try again.';
        clearPinInputs('entry-pin');
        document.getElementById('entry-pin-1').focus();
      }
    }

    function openTeacherModal() {
      if (!isPinSet()) {
        showModal('pin-setup-modal');
        document.getElementById('setup-pin-1').focus();
      } else {
        showModal('pin-entry-modal');
        document.getElementById('entry-pin-1').focus();
      }
    }

    function getWordLists() {
      const lists = localStorage.getItem(STORAGE_KEYS.WORD_LISTS);
      return lists ? JSON.parse(lists) : [];
    }

    function saveWordLists(lists) {
      localStorage.setItem(STORAGE_KEYS.WORD_LISTS, JSON.stringify(lists));
    }

    function getSelectedList() {
      const id = localStorage.getItem(STORAGE_KEYS.SELECTED_LIST);
      if (!id) return null;
      const lists = getWordLists();
      return lists.find(l => l.id === id) || null;
    }

    function selectWordList(id) {
      localStorage.setItem(STORAGE_KEYS.SELECTED_LIST, id);
      renderWordLists();
      updateHomeScreen();
      updateSetupScreen();
    }

    function parseWordList(content) {
      const lines = content.split('\n').filter(line => line.trim());
      const words = [];
      
      for (const line of lines) {
        const commaIndex = line.indexOf(',');
        if (commaIndex === -1) continue;
        
        const term = line.substring(0, commaIndex).trim();
        const definition = line.substring(commaIndex + 1).trim();
        
        if (term && definition) {
          words.push({ term, definition });
        }
      }
      
      return words;
    }

    function saveWordList() {
      const name = document.getElementById('list-name-input').value.trim();
      const content = document.getElementById('list-content-input').value;
      const errorEl = document.getElementById('list-edit-error');
      const successEl = document.getElementById('list-edit-success');
      
      errorEl.textContent = '';
      successEl.textContent = '';

      if (!name) {
        errorEl.textContent = 'Please enter a list name';
        return;
      }

      const words = parseWordList(content);
      if (words.length === 0) {
        errorEl.textContent = 'Please add at least one valid term (format: Term, Definition)';
        return;
      }

      const lists = getWordLists();
      
      if (gameState.editingListId) {
        const index = lists.findIndex(l => l.id === gameState.editingListId);
        if (index !== -1) {
          lists[index].name = name;
          lists[index].words = words;
        }
        gameState.editingListId = null;
        document.getElementById('cancel-edit-btn').style.display = 'none';
        document.getElementById('save-list-btn').textContent = 'Save List';
      } else {
        lists.push({
          id: Date.now().toString(),
          name,
          words
        });
      }

      saveWordLists(lists);
      successEl.textContent = `Saved "${name}" with ${words.length} terms`;
      
      document.getElementById('list-name-input').value = '';
      document.getElementById('list-content-input').value = '';
      
      setTimeout(() => {
        switchTab('lists-tab');
        renderWordLists();
        updateHomeScreen();
        updateSetupScreen();
      }, 1000);
    }

    function editWordList(id) {
      const lists = getWordLists();
      const list = lists.find(l => l.id === id);
      if (!list) return;

      gameState.editingListId = id;
      document.getElementById('list-name-input').value = list.name;
      document.getElementById('list-content-input').value = list.words.map(w => `${w.term}, ${w.definition}`).join('\n');
      document.getElementById('cancel-edit-btn').style.display = 'block';
      document.getElementById('save-list-btn').textContent = 'Update List';
      
      switchTab('create-tab');
    }

    function cancelEdit() {
      gameState.editingListId = null;
      document.getElementById('list-name-input').value = '';
      document.getElementById('list-content-input').value = '';
      document.getElementById('cancel-edit-btn').style.display = 'none';
      document.getElementById('save-list-btn').textContent = 'Save List';
      document.getElementById('list-edit-error').textContent = '';
      document.getElementById('list-edit-success').textContent = '';
    }

    function deleteWordList(id) {
      if (!confirm('Delete this word list?')) return;
      
      let lists = getWordLists();
      lists = lists.filter(l => l.id !== id);
      saveWordLists(lists);
      
      if (localStorage.getItem(STORAGE_KEYS.SELECTED_LIST) === id) {
        localStorage.removeItem(STORAGE_KEYS.SELECTED_LIST);
      }
      
      renderWordLists();
      updateHomeScreen();
      updateSetupScreen();
    }

    function renderWordLists() {
      const container = document.getElementById('word-lists-container');
      const lists = getWordLists();
      const selectedId = localStorage.getItem(STORAGE_KEYS.SELECTED_LIST);

      if (lists.length === 0) {
        container.innerHTML = `
          <div class="no-lists">
            <p>No word lists yet.</p>
            <p style="margin-top: 10px;">Create your first list in the "Create New" tab.</p>
          </div>
        `;
        return;
      }

      container.innerHTML = lists.map(list => {
        const safeId = sanitizeId(list.id);
        return `
        <div class="word-list-item ${list.id === selectedId ? 'selected' : ''}" onclick="selectWordList('${safeId}')">
          <div class="list-info">
            <div class="list-name">${escapeHtml(list.name)}</div>
            <div class="list-count">${list.words.length} terms</div>
          </div>
          <div class="list-actions">
            <button class="edit-btn" onclick="event.stopPropagation(); editWordList('${safeId}')">Edit</button>
            <button class="delete-btn" onclick="event.stopPropagation(); deleteWordList('${safeId}')">Delete</button>
          </div>
        </div>
      `}).join('');
    }

    function switchTab(tabId) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      
      document.querySelector(`[onclick="switchTab('${tabId}')"]`).classList.add('active');
      document.getElementById(tabId).classList.add('active');
      
      if (tabId === 'lists-tab') {
        cancelEdit();
      }
    }

    function updateHomeScreen() {
      const selectedList = getSelectedList();
      const statusEl = document.getElementById('home-list-status');
      const newGameBtn = document.getElementById('new-game-btn');

      if (selectedList) {
        statusEl.innerHTML = `
          <div class="selected-list-display">
            <div class="label">Active Word List</div>
            <div class="name">${escapeHtml(selectedList.name)}</div>
            <div class="count">${selectedList.words.length} terms</div>
          </div>
        `;
        newGameBtn.disabled = false;
      } else {
        statusEl.innerHTML = `
          <div class="selected-list-display">
            <div class="label">No word list selected</div>
            <div class="name" style="color: var(--faker-glow);">Tap ‚öôÔ∏è to set up</div>
          </div>
        `;
        newGameBtn.disabled = true;
      }
    }

    function updateSetupScreen() {
      const selectedList = getSelectedList();
      const listNameEl = document.getElementById('setup-list-name');
      const listCountEl = document.getElementById('setup-list-count');
      const warningsEl = document.getElementById('mode-warnings');
      
      if (selectedList) {
        listNameEl.textContent = selectedList.name;
        listCountEl.textContent = `${selectedList.words.length} terms`;
        
        const wordCount = selectedList.words.length;
        const playerCount = getPlayerCount();
        let warnings = [];
        
        if (wordCount < playerCount && playerCount > 0) {
          warnings.push(`‚ö†Ô∏è "All Different" mode disabled (need ${playerCount}+ terms)`);
        }
        
        warningsEl.innerHTML = warnings.map(w => `<div class="mode-warning">${w}</div>`).join('');
      } else {
        listNameEl.textContent = 'None selected';
        listCountEl.textContent = '';
        warningsEl.innerHTML = '';
      }
    }

    function getPlayerCount() {
      const textarea = document.getElementById('players-textarea');
      const names = parsePlayerNames(textarea.value);
      return names.length;
    }

    function parsePlayerNames(text) {
      return text
        .split('\n')
        .map(name => {
          return name
            .trim()
            .replace(/,/g, '')           // Strip commas
            .replace(/\s+/g, ' ')         // Collapse whitespace
            .substring(0, 20);            // Truncate to 20 chars
        })
        .filter(name => name.length > 0)
        .slice(0, 24);
    }

    function getValidationStatus(names) {
      if (names.length === 0) {
        return { valid: false, message: 'Enter player names (one per line)', status: 'empty' };
      }
      if (names.length < 4) {
        return { valid: false, message: `Need ${4 - names.length} more player${4 - names.length !== 1 ? 's' : ''}`, status: 'error' };
      }
      if (names.length > 24) {
        return { valid: false, message: 'Maximum 24 players', status: 'error' };
      }
      
      // Check for duplicates (case-insensitive)
      const lowerNames = names.map(n => n.toLowerCase());
      const duplicates = lowerNames.filter((name, i) => lowerNames.indexOf(name) !== i);
      if (duplicates.length > 0) {
        return { valid: false, message: `Duplicate: "${duplicates[0]}"`, status: 'error' };
      }
      
      return { valid: true, message: `${names.length} players ‚Äî Ready!`, status: 'ready' };
    }

    function getMaxFakers(playerCount) {
      // Base limits by player count
      let max;
      if (playerCount >= 13) max = 3;
      else if (playerCount >= 9) max = 2;
      else max = 1;
      
      // Ensure at least 2 learners (cap fakers at playerCount - 2)
      return Math.min(max, Math.max(1, playerCount - 2));
    }

    function updateFakerOptions(playerCount) {
      const maxFakers = getMaxFakers(playerCount);
      const container = document.getElementById('faker-options');
      const hint = document.getElementById('faker-hint');
      
      let html = '';
      for (let i = 1; i <= 3; i++) {
        const disabled = i > maxFakers ? 'disabled' : '';
        const selected = i === gameState.settings.fakerCount && i <= maxFakers ? 'selected' : '';
        html += `<button class="option-btn ${selected}" data-fakers="${i}" onclick="selectFakers(${i})" ${disabled}>${i}</button>`;
      }
      container.innerHTML = html;
      
      if (gameState.settings.fakerCount > maxFakers) {
        gameState.settings.fakerCount = maxFakers;
        updateFakerOptions(playerCount);
      }
      
      if (maxFakers === 1) {
        hint.textContent = '9+ players unlocks 2 fakers, 13+ unlocks 3.';
      } else if (maxFakers === 2) {
        hint.textContent = '13+ players unlocks 3 fakers.';
      } else {
        hint.textContent = 'All faker options unlocked.';
      }
    }

    function updatePlayerCount() {
      const textarea = document.getElementById('players-textarea');
      const names = parsePlayerNames(textarea.value);
      const validation = getValidationStatus(names);
      const count = names.length;
      
      const badge = document.getElementById('player-count-badge');
      const hint = document.getElementById('player-hint');
      const startBtn = document.getElementById('btn-start');
      const selectedList = getSelectedList();
      
      // Update badge text and color based on validation status
      badge.textContent = validation.message;
      
      if (validation.status === 'ready') {
        badge.style.background = 'var(--learner-glow)';
      } else if (validation.status === 'error') {
        badge.style.background = 'var(--faker-glow)';
      } else {
        badge.style.background = 'var(--accent)';
      }
      
      // Update hint with helpful info
      if (validation.status === 'ready') {
        hint.textContent = 'Names are truncated to 20 characters. Ready to play!';
      } else if (validation.status === 'error' && validation.message.includes('Duplicate')) {
        hint.textContent = 'Each player needs a unique name.';
      } else {
        hint.textContent = 'Enter each player\'s name on a new line. Minimum 4, maximum 24 players.';
      }
      
      // Enable/disable start button
      startBtn.disabled = !validation.valid || !selectedList;
      
      updateFakerOptions(count);
      updateSetupScreen();
    }

    function selectFakers(count) {
      const playerCount = getPlayerCount();
      const maxFakers = getMaxFakers(playerCount);
      
      if (count > maxFakers) return;
      
      gameState.settings.fakerCount = count;
      document.querySelectorAll('[data-fakers]').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.fakers) === count);
      });
    }

    function selectGameMode(wordCount, playerCount) {
      const roll = Math.random();
      const canDoAllDifferent = wordCount >= playerCount;
      
      if (roll < 0.10) return "ALL_FAKERS";
      if (roll < 0.20 && canDoAllDifferent) return "ALL_DIFFERENT";
      if (roll < 0.20 && !canDoAllDifferent) return "NORMAL";
      if (roll < 0.30) return "NO_FAKER";
      return "NORMAL";
    }

    function startGame() {
      try {
        const selectedList = getSelectedList();
        if (!selectedList) {
          alert('Please select a word list first');
          return;
        }

        // Validate word list has at least one valid word
        if (!selectedList.words || selectedList.words.length === 0) {
          alert('Selected word list is empty. Please add terms to the list first.');
          return;
        }

        const textarea = document.getElementById('players-textarea');
        const names = parsePlayerNames(textarea.value);
        
        // Use centralized validation
        const validation = getValidationStatus(names);
        if (!validation.valid) {
          alert(validation.message);
          return;
        }

        // Save player names for next session
        savePlayerNames();

        gameState.players = names.map((name, i) => ({
          id: i,
          name: name,
          role: null,
          term: null,
          definition: null,
        hasViewed: false
      }));

      const wordCount = selectedList.words.length;
      const playerCount = gameState.players.length;

      gameState.gameMode = selectGameMode(wordCount, playerCount);
      
      const shuffledWords = shuffleArray([...selectedList.words]);
      
      gameState.players = shuffleArray(gameState.players);
      
      if (gameState.gameMode === "ALL_FAKERS") {
        const wordEntry = shuffledWords[0];
        gameState.secretWord = wordEntry.term;
        gameState.secretDefinition = wordEntry.definition;
        gameState.allTerms = [wordEntry];
        gameState.players.forEach(p => {
          p.role = 'faker';
          p.term = null;
          p.definition = null;
        });
      } else if (gameState.gameMode === "ALL_DIFFERENT") {
        // Defensive check: ensure we have enough words for all players
        if (shuffledWords.length < playerCount) {
          // Fall back to NORMAL mode if not enough words
          gameState.gameMode = "NORMAL";
          const wordEntry = shuffledWords[0];
          gameState.secretWord = wordEntry.term;
          gameState.secretDefinition = wordEntry.definition;
          gameState.allTerms = [wordEntry];
          const fakerCount = Math.min(gameState.settings.fakerCount, Math.max(1, gameState.players.length - 2));
          const fakerIndices = shuffleArray([...Array(gameState.players.length).keys()]).slice(0, fakerCount);
          gameState.players.forEach((p, i) => {
            if (fakerIndices.includes(i)) {
              p.role = 'faker';
              p.term = null;
              p.definition = null;
            } else {
              p.role = 'learner';
              p.term = wordEntry.term;
              p.definition = wordEntry.definition;
            }
          });
        } else {
          gameState.secretWord = "VARIOUS";
          gameState.secretDefinition = "Everyone had different terms!";
          gameState.allTerms = shuffledWords.slice(0, playerCount);
          gameState.players.forEach((p, i) => {
            p.role = 'learner';
            p.term = gameState.allTerms[i].term;
            p.definition = gameState.allTerms[i].definition;
          });
        }
      } else if (gameState.gameMode === "NO_FAKER") {
        const wordEntry = shuffledWords[0];
        gameState.secretWord = wordEntry.term;
        gameState.secretDefinition = wordEntry.definition;
        gameState.allTerms = [wordEntry];
        gameState.players.forEach(p => {
          p.role = 'learner';
          p.term = wordEntry.term;
          p.definition = wordEntry.definition;
        });
      } else {
        const wordEntry = shuffledWords[0];
        gameState.secretWord = wordEntry.term;
        gameState.secretDefinition = wordEntry.definition;
        gameState.allTerms = [wordEntry];
        
        // Ensure at least 2 learners by capping fakers at players - 2
        const fakerCount = Math.min(gameState.settings.fakerCount, Math.max(1, gameState.players.length - 2));
        const fakerIndices = shuffleArray([...Array(gameState.players.length).keys()]).slice(0, fakerCount);
        
        gameState.players.forEach((p, i) => {
          if (fakerIndices.includes(i)) {
            p.role = 'faker';
            p.term = null;
            p.definition = null;
          } else {
            p.role = 'learner';
            p.term = wordEntry.term;
            p.definition = wordEntry.definition;
          }
        });
      }

      gameState.currentPlayerIndex = 0;
      gameState.chosenFakers = [];
      
      showPassDevice();
      
      } catch (error) {
        console.error('Failed to start game:', error);
        showError('Something went wrong starting the game. Please try again.');
      }
    }

    function renderProgressDots(containerId) {
      const container = document.getElementById(containerId);
      
      // Add compact class for 12+ players to fit on small screens
      if (gameState.players.length >= 12) {
        container.classList.add('compact');
      } else {
        container.classList.remove('compact');
      }
      
      container.innerHTML = gameState.players.map((p, i) => {
        let cls = 'progress-dot';
        if (i < gameState.currentPlayerIndex) cls += ' done';
        else if (i === gameState.currentPlayerIndex) cls += ' active';
        return `<div class="${cls}"></div>`;
      }).join('');
    }

    function showPassDevice() {
      const player = gameState.players[gameState.currentPlayerIndex];
      document.getElementById('pass-player-name').textContent = player.name;
      renderProgressDots('progress-dots');
      hideCancelConfirm('pass');
      showScreen('pass');
    }

    function showRoleScreen() {
      // Prevent double-tap on Ready button
      if (isTransitioning) return;
      isTransitioning = true;
      
      const player = gameState.players[gameState.currentPlayerIndex];
      
      resetHoldToReveal();
      
      document.getElementById('role-player-label').textContent = player.name;
      
      const roleBadge = document.getElementById('role-badge');
      const roleWord = document.getElementById('role-word');
      const roleDefinition = document.getElementById('role-definition');
      const wordContainer = document.getElementById('role-word-container');
      const fakerContainer = document.getElementById('role-faker-container');
      
      if (player.role === "learner") {
        roleBadge.textContent = "LEARNER";
        roleBadge.className = "role-badge learner";
        wordContainer.style.display = "block";
        fakerContainer.style.display = "none";
        roleWord.textContent = player.term;
        roleDefinition.textContent = player.definition;
      } else {
        roleBadge.textContent = "FAKER";
        roleBadge.className = "role-badge faker";
        wordContainer.style.display = "none";
        fakerContainer.style.display = "block";
      }
      
      renderProgressDots('progress-dots-role');
      hideCancelConfirm('role');
      showScreen('role');
      
      // Release lock after screen transition animation (300ms)
      setTimeout(() => { isTransitioning = false; }, 350);
    }

    function nextPlayer() {
      // Prevent double-tap from advancing twice
      if (isTransitioning) return;
      isTransitioning = true;
      
      gameState.players[gameState.currentPlayerIndex].hasViewed = true;
      gameState.currentPlayerIndex++;
      
      if (gameState.currentPlayerIndex >= gameState.players.length) {
        document.getElementById('starting-player').textContent = gameState.players[0].name;
        showScreen('discussion');
      } else {
        showPassDevice();
      }
      
      // Release lock after screen transition animation (300ms)
      setTimeout(() => { isTransitioning = false; }, 350);
    }

    function showConfirmation() {
      const fakerCount = gameState.settings.fakerCount;
      gameState.chosenFakers = [];
      
      const instruction = document.getElementById('confirm-instruction');
      if (fakerCount === 1) {
        instruction.textContent = 'Select who the group decided is faking it:';
      } else {
        instruction.textContent = `Select the ${fakerCount} players the group decided are faking it:`;
      }
      
      const container = document.getElementById('confirm-options');
      container.innerHTML = gameState.players.map(p => `
        <div class="confirm-option" data-player-id="${p.id}" onclick="toggleConfirmation(${p.id})">
          <span class="player-name">${escapeHtml(p.name)}</span>
        </div>
      `).join('');
      
      updateSelectionCounter();
      showScreen('confirm');
    }

    function toggleConfirmation(playerId) {
      const fakerCount = gameState.settings.fakerCount;
      const index = gameState.chosenFakers.indexOf(playerId);
      
      if (index > -1) {
        gameState.chosenFakers.splice(index, 1);
      } else {
        if (gameState.chosenFakers.length < fakerCount) {
          gameState.chosenFakers.push(playerId);
        } else if (fakerCount === 1) {
          gameState.chosenFakers = [playerId];
        }
      }
      
      document.querySelectorAll('.confirm-option').forEach(opt => {
        const id = parseInt(opt.dataset.playerId);
        opt.classList.toggle('selected', gameState.chosenFakers.includes(id));
      });
      
      updateSelectionCounter();
    }

    function updateSelectionCounter() {
      const fakerCount = gameState.settings.fakerCount;
      const selected = gameState.chosenFakers.length;
      const counter = document.getElementById('selection-counter');
      const btn = document.getElementById('btn-reveal');
      
      if (selected === fakerCount) {
        counter.textContent = `${selected} of ${fakerCount} selected`;
        counter.classList.add('complete');
        btn.disabled = false;
      } else {
        counter.textContent = `Select ${fakerCount - selected} more player${fakerCount - selected !== 1 ? 's' : ''}`;
        counter.classList.remove('complete');
        btn.disabled = true;
      }
    }

    function revealResults() {
      const chosenPlayers = gameState.chosenFakers.map(id => 
        gameState.players.find(p => p.id === id)
      );
      const actualFakers = gameState.players.filter(p => p.role === "faker");
      
      const correctGuesses = chosenPlayers.filter(p => p.role === "faker").length;
      const totalFakers = actualFakers.length;
      
      document.getElementById('result-chosen-names').innerHTML = chosenPlayers.map(p => 
        `<div class="result-name">${escapeHtml(p.name)}</div>`
      ).join('');
      
      const resultReveal = document.getElementById('result-reveal');
      const resultRoles = document.getElementById('result-roles');
      
      resultRoles.innerHTML = chosenPlayers.map(p => {
        if (p.role === "faker") {
          return `<div class="role-badge faker">FAKER</div>`;
        } else {
          return `<div class="role-badge learner">LEARNER</div>`;
        }
      }).join('');
      
      if (correctGuesses === chosenPlayers.length && correctGuesses > 0) {
        resultReveal.className = "result-reveal correct";
      } else if (correctGuesses === 0) {
        resultReveal.className = "result-reveal wrong";
      } else {
        resultReveal.className = "result-reveal partial";
      }
      
      const winnerIcon = document.getElementById('winner-icon');
      const winnerText = document.getElementById('winner-text');
      const fakersSection = document.getElementById('actual-fakers-section');
      const fakersList = document.getElementById('actual-fakers-list');
      
      if (gameState.gameMode === "ALL_FAKERS") {
        winnerIcon.textContent = "üåÄ";
        winnerText.textContent = "Everyone was a Faker.";
        winnerText.className = "winner-text text-warning";
        fakersSection.style.display = "none";
      } else if (gameState.gameMode === "NO_FAKER") {
        winnerIcon.textContent = "üò±";
        winnerText.textContent = "There was no Faker.";
        winnerText.className = "winner-text text-warning";
        fakersSection.style.display = "none";
      } else if (gameState.gameMode === "ALL_DIFFERENT") {
        winnerIcon.textContent = "üé≠";
        winnerText.textContent = "Everyone had different terms!";
        winnerText.className = "winner-text text-warning";
        fakersSection.style.display = "none";
      } else if (correctGuesses > 0) {
        winnerIcon.textContent = "üéâ";
        if (correctGuesses === totalFakers) {
          winnerText.textContent = "Learners Win";
        } else {
          winnerText.textContent = `Found ${correctGuesses} of ${totalFakers}`;
        }
        winnerText.className = "winner-text text-success";
        
        if (correctGuesses < totalFakers) {
          const remainingFakers = actualFakers.filter(p => !gameState.chosenFakers.includes(p.id));
          fakersSection.style.display = "block";
          fakersList.innerHTML = remainingFakers.map(p => `
            <div class="faker-item">${escapeHtml(p.name)}</div>
          `).join('');
        } else {
          fakersSection.style.display = "none";
        }
      } else {
        winnerIcon.textContent = "üòà";
        winnerText.textContent = totalFakers > 1 ? "Fakers Win" : "Faker Wins";
        winnerText.className = "winner-text text-danger";
        
        fakersSection.style.display = "block";
        fakersList.innerHTML = actualFakers.map(p => `
          <div class="faker-item">${escapeHtml(p.name)}</div>
        `).join('');
      }
      
      showScreen('results');
    }

    function showSummary() {
      // Game completed - clear saved state
      clearGameState();
      
      document.getElementById('summary-word').textContent = gameState.secretWord;
      document.getElementById('summary-definition').textContent = gameState.secretDefinition;
      
      const allWordsContainer = document.getElementById('summary-all-words');
      const allWordsList = document.getElementById('all-words-list');
      
      if (gameState.gameMode === "ALL_DIFFERENT") {
        allWordsContainer.style.display = "block";
        allWordsList.innerHTML = gameState.players.map((p, i) => `
          <div class="all-words-item">
            <span class="player">${escapeHtml(p.name)}</span>
            <span class="term">${escapeHtml(p.term)}</span>
          </div>
        `).join('');
      } else {
        allWordsContainer.style.display = "none";
      }
      
      const twistReveal = document.getElementById('twist-reveal');
      const twistText = document.getElementById('twist-text');
      
      if (gameState.gameMode !== "NORMAL") {
        twistReveal.style.display = "block";
        switch (gameState.gameMode) {
          case "ALL_FAKERS":
            twistText.textContent = "Everyone was a faker. No one actually knew the term!";
            break;
          case "ALL_DIFFERENT":
            twistText.textContent = "Every player had a completely different term.";
            break;
          case "NO_FAKER":
            twistText.textContent = "There was no faker. Everyone had the same term but you accused an innocent learner!";
            break;
        }
      } else {
        twistReveal.style.display = "none";
      }
      
      showScreen('summary');
    }

    function playAgain() {
      gameState.players.forEach(p => {
        p.role = null;
        p.term = null;
        p.definition = null;
        p.hasViewed = false;
      });
      gameState.currentPlayerIndex = 0;
      gameState.chosenFakers = [];
      startGame();
    }

    function newPlayers() {
      gameState.players = [];
      document.getElementById('players-textarea').value = '';
      // Clear saved player names so fresh start
      try {
        localStorage.removeItem(STORAGE_KEYS.PLAYER_NAMES);
      } catch (e) {}
      updatePlayerCount();
      showScreen('setup');
    }

    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function sanitizeId(id) {
      // Ensure ID is a safe string (numeric only)
      return String(id).replace(/[^0-9]/g, '');
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
