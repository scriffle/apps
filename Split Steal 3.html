<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split/Steal Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a12;
            --bg-panel: #0d0d18;
            --bg-card: #12121f;
            --cyan: #00f0ff;
            --cyan-dim: #00a0aa;
            --cyan-glow: rgba(0, 240, 255, 0.4);
            --magenta: #ff00aa;
            --magenta-glow: rgba(255, 0, 170, 0.4);
            --green: #00ff88;
            --green-glow: rgba(0, 255, 136, 0.3);
            --red: #ff3366;
            --red-glow: rgba(255, 51, 102, 0.3);
            --orange: #ff9900;
            --orange-glow: rgba(255, 153, 0, 0.3);
            --text-primary: #e0f4ff;
            --text-dim: #6a8899;
            --grid-color: rgba(0, 240, 255, 0.06);
            --border-glow: 0 0 10px var(--cyan-glow), inset 0 0 10px rgba(0, 240, 255, 0.1);
            --transition-fast: 0.15s ease;
            --transition-med: 0.25s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(18px, 2.5vw, 24px);
            font-weight: 500;
            background: var(--bg-dark);
            color: var(--text-primary);
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 50px 50px;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: linear-gradient(180deg, rgba(0, 240, 255, 0.1) 0%, transparent 100%);
            border-bottom: 1px solid var(--cyan-dim);
            flex-shrink: 0;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--cyan);
            text-shadow: 0 0 20px var(--cyan-glow), 0 0 40px var(--cyan-glow);
        }

        .logo span {
            color: var(--magenta);
            text-shadow: 0 0 20px var(--magenta-glow), 0 0 40px var(--magenta-glow);
        }

        .stats-bar {
            display: flex;
            gap: 2rem;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 1.8vw, 1.2rem);
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.7em;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .stat-value {
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan-glow);
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 0;
            padding: 0 2rem;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--cyan-dim);
            flex-shrink: 0;
        }

        .tab-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 1.8vw, 1.1rem);
            font-weight: 700;
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            position: relative;
            transition: color var(--transition-fast);
        }

        .tab-btn:hover {
            color: var(--text-primary);
        }

        .tab-btn.active {
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan-glow);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--cyan);
            box-shadow: 0 0 10px var(--cyan), 0 0 20px var(--cyan-glow);
        }

        .tab-key {
            font-size: 0.7em;
            opacity: 0.5;
            margin-left: 0.5em;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .tab-panel {
            position: absolute;
            inset: 0;
            padding: 1.5rem 2rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-med), visibility var(--transition-med);
        }

        .tab-panel.active {
            opacity: 1;
            visibility: visible;
        }

        /* Scrollbar */
        .tab-panel::-webkit-scrollbar {
            width: 8px;
        }

        .tab-panel::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        .tab-panel::-webkit-scrollbar-thumb {
            background: var(--cyan-dim);
            border-radius: 4px;
        }

        /* Setup Tab */
        .setup-container {
            max-width: 900px;
            margin: 0 auto;
        }

        .setup-section {
            margin-bottom: 2rem;
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1rem, 2vw, 1.3rem);
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--cyan-glow);
        }

        .name-input-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .textarea-wrapper {
            position: relative;
        }

        .name-textarea {
            width: 100%;
            height: 300px;
            background: var(--bg-card);
            border: 1px solid var(--cyan-dim);
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(1rem, 2vw, 1.3rem);
            color: var(--text-primary);
            resize: none;
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        .name-textarea:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: var(--border-glow);
        }

        .name-textarea::placeholder {
            color: var(--text-dim);
        }

        .player-preview {
            background: var(--bg-card);
            border: 1px solid var(--cyan-dim);
            border-radius: 4px;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .preview-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .preview-count {
            color: var(--cyan);
        }

        .preview-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .preview-chip {
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid var(--cyan-dim);
            padding: 0.3rem 0.8rem;
            border-radius: 2px;
            font-size: 0.9em;
        }

        /* Buttons */
        .btn {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 1.8vw, 1.1rem);
            font-weight: 700;
            padding: 0.8rem 1.5rem;
            border: 1px solid var(--cyan);
            background: transparent;
            color: var(--cyan);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--cyan);
            opacity: 0;
            transition: opacity var(--transition-fast);
            z-index: -1;
        }

        .btn:hover {
            color: var(--bg-dark);
            text-shadow: none;
        }

        .btn:hover::before {
            opacity: 1;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: var(--cyan);
            color: var(--bg-dark);
            box-shadow: 0 0 20px var(--cyan-glow);
        }

        .btn-primary:hover {
            box-shadow: 0 0 30px var(--cyan-glow), 0 0 60px var(--cyan-glow);
        }

        .btn-danger {
            border-color: var(--red);
            color: var(--red);
        }

        .btn-danger::before {
            background: var(--red);
        }

        .btn-small {
            font-size: clamp(0.7rem, 1.4vw, 0.9rem);
            padding: 0.5rem 1rem;
        }

        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        /* Game Tab */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .round-display {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.5rem, 3vw, 2rem);
            color: var(--cyan);
            text-shadow: 0 0 20px var(--cyan-glow);
        }

        .game-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Game Result Banner */
        .game-result {
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.2rem, 2.5vw, 1.8rem);
            border-radius: 4px;
            display: none;
        }

        .game-result.win {
            display: block;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid var(--green);
            color: var(--green);
            box-shadow: 0 0 30px var(--green-glow);
            text-shadow: 0 0 20px var(--green-glow);
        }

        .game-result.loss {
            display: block;
            background: rgba(255, 51, 102, 0.1);
            border: 2px solid var(--red);
            color: var(--red);
            box-shadow: 0 0 30px var(--red-glow);
            text-shadow: 0 0 20px var(--red-glow);
        }

        /* Pair Grid */
        .pair-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .pair-box {
            background: var(--bg-card);
            border: 1px solid var(--cyan-dim);
            border-radius: 4px;
            padding: 1rem;
            transition: all var(--transition-fast);
        }

        .pair-box:hover {
            border-color: var(--cyan);
            box-shadow: var(--border-glow);
        }

        .pair-box.resolved {
            border-color: var(--text-dim);
            opacity: 0.7;
        }

        .pair-box.game-over {
            border-color: var(--green);
            box-shadow: 0 0 20px var(--green-glow);
            opacity: 1;
        }

        .pair-players {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
            font-size: clamp(1.1rem, 2.2vw, 1.4rem);
        }

        .pair-vs {
            color: var(--text-dim);
            font-size: 0.8em;
        }

        .player-name {
            padding: 0.2rem 0.6rem;
            border-radius: 2px;
        }

        .player-name.qualified {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid var(--green);
        }

        .player-name.unqualified {
            background: rgba(255, 153, 0, 0.2);
            border: 1px solid var(--orange);
        }

        .player-coins {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            color: var(--cyan);
        }

        .pair-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .outcome-btn {
            flex: 1;
            min-width: fit-content;
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(0.9rem, 1.6vw, 1.1rem);
            font-weight: 600;
            padding: 0.6rem 0.8rem;
            background: var(--bg-panel);
            border: 1px solid var(--cyan-dim);
            color: var(--text-primary);
            cursor: pointer;
            transition: all var(--transition-fast);
            border-radius: 2px;
        }

        .outcome-btn:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 10px var(--cyan-glow);
        }

        .outcome-btn.split {
            border-color: var(--green);
        }

        .outcome-btn.split:hover {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 10px var(--green-glow);
        }

        .outcome-btn.steal {
            border-color: var(--orange);
        }

        .outcome-btn.steal:hover {
            background: rgba(255, 153, 0, 0.2);
            box-shadow: 0 0 10px var(--orange-glow);
        }

        .outcome-btn.mutual-steal {
            border-color: var(--red);
        }

        .outcome-btn.mutual-steal:hover {
            background: rgba(255, 51, 102, 0.2);
            box-shadow: 0 0 10px var(--red-glow);
        }

        .pair-result {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 1.6vw, 1.1rem);
            padding: 0.5rem;
            text-align: center;
        }

        .undo-btn {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9em;
            padding: 0.4rem 0.8rem;
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid var(--red);
            color: var(--red);
            cursor: pointer;
            margin-top: 0.5rem;
            transition: all var(--transition-fast);
        }

        .undo-btn:hover {
            background: rgba(255, 51, 102, 0.3);
        }

        .undo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .auto-advance-box {
            border-style: dashed;
        }

        .auto-advance-label {
            color: var(--text-dim);
            font-style: italic;
        }

        /* Player Status Grid */
        .player-status-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--cyan-dim);
        }

        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 0.8rem;
        }

        .player-card {
            background: var(--bg-card);
            border: 1px solid var(--cyan-dim);
            padding: 0.8rem;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: clamp(1rem, 1.8vw, 1.2rem);
        }

        .player-card.eliminated {
            background: rgba(255, 51, 102, 0.1);
            border-color: var(--red);
            opacity: 0.5;
        }

        .player-card.charity-qualified {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--green);
        }

        .player-card.charity-unqualified {
            background: rgba(255, 153, 0, 0.1);
            border-color: var(--orange);
        }

        .player-card.winner {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid var(--green);
            box-shadow: 0 0 20px var(--green-glow);
        }

        .player-card-name {
            font-weight: 600;
        }

        .player-card-coins {
            font-family: 'Orbitron', sans-serif;
            color: var(--cyan);
        }

        .player-card-status {
            font-size: 0.8em;
            color: var(--text-dim);
        }

        /* History Tab */
        .history-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            max-width: 1400px;
        }

        @media (max-width: 900px) {
            .history-container {
                grid-template-columns: 1fr;
            }
        }

        .history-section {
            background: var(--bg-card);
            border: 1px solid var(--cyan-dim);
            border-radius: 4px;
            padding: 1.5rem;
        }

        .history-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1rem, 2vw, 1.3rem);
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--cyan-glow);
            border-bottom: 1px solid var(--cyan-dim);
            padding-bottom: 0.5rem;
        }

        .round-log {
            margin-bottom: 1.5rem;
        }

        .round-log-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            color: var(--magenta);
            margin-bottom: 0.5rem;
        }

        .round-log-entry {
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            background: var(--bg-panel);
            border-left: 3px solid var(--cyan-dim);
            font-size: 0.95em;
        }

        .round-log-entry.split {
            border-left-color: var(--green);
        }

        .round-log-entry.steal {
            border-left-color: var(--orange);
        }

        .round-log-entry.mutual-steal {
            border-left-color: var(--red);
        }

        .round-log-entry.auto-advance {
            border-left-color: var(--text-dim);
            font-style: italic;
        }

        .betrayal-entry {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            background: var(--bg-panel);
            border-left: 3px solid var(--orange);
        }

        .betrayal-count {
            font-family: 'Orbitron', sans-serif;
            color: var(--orange);
        }

        .eliminated-entry {
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            background: rgba(255, 51, 102, 0.1);
            border-left: 3px solid var(--red);
            display: flex;
            justify-content: space-between;
        }

        .eliminated-round {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            color: var(--text-dim);
        }

        .empty-state {
            color: var(--text-dim);
            font-style: italic;
            text-align: center;
            padding: 2rem;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            background: var(--bg-card);
            border: 1px solid var(--cyan);
            padding: 1rem 1.5rem;
            border-radius: 4px;
            box-shadow: 0 0 20px var(--cyan-glow);
            animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
            font-size: clamp(0.9rem, 1.6vw, 1.1rem);
        }

        .toast.error {
            border-color: var(--red);
            box-shadow: 0 0 20px var(--red-glow);
        }

        .toast.success {
            border-color: var(--green);
            box-shadow: 0 0 20px var(--green-glow);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(20px);
            }
        }

        /* Inline Confirm Panel */
        .confirm-panel {
            background: var(--bg-card);
            border: 2px solid var(--cyan);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 0 30px var(--cyan-glow);
            display: none;
        }

        .confirm-panel.active {
            display: block;
        }

        .confirm-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            color: var(--cyan);
            margin-bottom: 0.5rem;
        }

        .confirm-message {
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .redistribution-info {
            background: var(--bg-panel);
            padding: 1rem;
            margin-bottom: 1rem;
            border-left: 3px solid var(--green);
        }

        /* Rules Panel */
        .rules-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            max-width: 90vw;
            height: 100%;
            background: var(--bg-panel);
            border-left: 1px solid var(--cyan);
            box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            transition: right var(--transition-med);
            overflow-y: auto;
            padding: 2rem;
        }

        .rules-panel.active {
            right: 0;
        }

        .rules-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            color: var(--cyan);
            cursor: pointer;
            background: none;
            border: none;
        }

        .rules-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--cyan);
            margin-bottom: 1.5rem;
            text-shadow: 0 0 20px var(--cyan-glow);
        }

        .rules-list {
            list-style: none;
            counter-reset: rules;
        }

        .rules-list li {
            counter-increment: rules;
            margin-bottom: 1rem;
            padding-left: 2rem;
            position: relative;
        }

        .rules-list li::before {
            content: counter(rules);
            position: absolute;
            left: 0;
            font-family: 'Orbitron', sans-serif;
            color: var(--cyan);
        }

        .rules-list ul {
            margin-top: 0.5rem;
            margin-left: 1rem;
        }

        .rules-list ul li {
            counter-increment: none;
            padding-left: 1rem;
        }

        .rules-list ul li::before {
            content: 'â†’';
            color: var(--magenta);
        }

        .keyboard-hints {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--cyan-dim);
        }

        .keyboard-hint {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .key {
            font-family: 'Orbitron', sans-serif;
            background: var(--bg-card);
            padding: 0.2rem 0.5rem;
            border: 1px solid var(--cyan-dim);
            border-radius: 2px;
            font-size: 0.9em;
        }

        /* Overlay for rules panel */
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-med);
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">Split<span>/</span>Steal</div>
        <div class="stats-bar">
            <div class="stat">
                <span class="stat-label">Round</span>
                <span class="stat-value" id="statRound">â€”</span>
            </div>
            <div class="stat">
                <span class="stat-label">Active</span>
                <span class="stat-value" id="statActive">â€”</span>
            </div>
            <div class="stat">
                <span class="stat-label">Total $</span>
                <span class="stat-value" id="statCoins">â€”</span>
            </div>
        </div>
    </header>

    <!-- Tab Navigation -->
    <nav class="tab-nav">
        <button class="tab-btn active" data-tab="setup">Setup<span class="tab-key">[1]</span></button>
        <button class="tab-btn" data-tab="game">Game<span class="tab-key">[2]</span></button>
        <button class="tab-btn" data-tab="history">History<span class="tab-key">[3]</span></button>
        <button class="tab-btn" onclick="toggleRules()">Rules<span class="tab-key">[?]</span></button>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Setup Tab -->
        <div class="tab-panel active" id="tab-setup">
            <div class="setup-container">
                <div class="setup-section">
                    <h2 class="section-title">Add Players</h2>
                    <div class="name-input-area">
                        <div class="textarea-wrapper">
                            <textarea 
                                id="nameInput" 
                                class="name-textarea" 
                                placeholder="Enter player names, one per line...

Example:
Alice
Bob
Charlie
Diana"></textarea>
                        </div>
                        <div class="player-preview">
                            <div class="preview-title">Players: <span class="preview-count" id="playerCount">0</span></div>
                            <div class="preview-list" id="playerPreview"></div>
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="startGame()">Start Game</button>
                        <button class="btn" onclick="loadDefaultPlayers()">Load Demo Names</button>
                        <button class="btn btn-danger" onclick="clearNames()">Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Tab -->
        <div class="tab-panel" id="tab-game">
            <div class="game-header">
                <div class="round-display" id="roundDisplay">Round 1</div>
                <div class="game-controls">
                    <button class="btn btn-primary btn-small" onclick="showNextRoundConfirm()">Next Round</button>
                    <button class="btn btn-small" onclick="resetRound()">Reset Round</button>
                    <button class="btn btn-small" onclick="newGameSamePlayers()">New Game</button>
                    <button class="btn btn-danger btn-small" onclick="fullReset()">Full Reset</button>
                </div>
            </div>

            <!-- Next Round Confirmation Panel -->
            <div class="confirm-panel" id="nextRoundPanel">
                <div class="confirm-title">Proceed to Next Round?</div>
                <div class="redistribution-info" id="redistributionInfo"></div>
                <div class="btn-group">
                    <button class="btn btn-primary btn-small" onclick="confirmNextRound()">Proceed</button>
                    <button class="btn btn-small" onclick="hideNextRoundConfirm()">Cancel</button>
                </div>
            </div>

            <!-- Reset Confirmation Panels -->
            <div class="confirm-panel" id="resetRoundPanel">
                <div class="confirm-title">Reset Current Round?</div>
                <div class="confirm-message">This will clear all results for this round but keep players.</div>
                <div class="btn-group">
                    <button class="btn btn-danger btn-small" onclick="confirmResetRound()">Reset Round</button>
                    <button class="btn btn-small" onclick="hideResetRoundConfirm()">Cancel</button>
                </div>
            </div>

            <div class="confirm-panel" id="newGamePanel">
                <div class="confirm-title">Start New Game?</div>
                <div class="confirm-message">All coins will reset to $10. Same players.</div>
                <div class="btn-group">
                    <button class="btn btn-primary btn-small" onclick="confirmNewGame()">New Game</button>
                    <button class="btn btn-small" onclick="hideNewGameConfirm()">Cancel</button>
                </div>
            </div>

            <div class="confirm-panel" id="fullResetPanel">
                <div class="confirm-title">Full Reset?</div>
                <div class="confirm-message">This will clear all progress and return to setup.</div>
                <div class="btn-group">
                    <button class="btn btn-danger btn-small" onclick="confirmFullReset()">Full Reset</button>
                    <button class="btn btn-small" onclick="hideFullResetConfirm()">Cancel</button>
                </div>
            </div>

            <div class="game-result" id="gameResult"></div>

            <div class="pair-grid" id="pairGrid"></div>

            <div class="player-status-section">
                <h3 class="section-title">Player Status</h3>
                <div class="player-grid" id="playerGrid"></div>
            </div>
        </div>

        <!-- History Tab -->
        <div class="tab-panel" id="tab-history">
            <div class="history-container">
                <div class="history-section">
                    <h3 class="history-title">Round-by-Round Log</h3>
                    <div id="roundLog"><div class="empty-state">No rounds played yet</div></div>
                </div>
                <div>
                    <div class="history-section" style="margin-bottom: 1rem;">
                        <h3 class="history-title">Betrayal Ledger</h3>
                        <div id="betrayalLedger"><div class="empty-state">No betrayals yet</div></div>
                    </div>
                    <div class="history-section">
                        <h3 class="history-title">Eliminated Players</h3>
                        <div id="eliminatedList"><div class="empty-state">No eliminations yet</div></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Rules Panel (slide-out) -->
    <div class="overlay" id="overlay" onclick="toggleRules()"></div>
    <aside class="rules-panel" id="rulesPanel">
        <button class="rules-close" onclick="toggleRules()">âœ•</button>
        <h2 class="rules-title">Game Rules</h2>
        <ul class="rules-list">
            <li>Each player starts with <strong>$10</strong></li>
            <li>Players are randomly paired each round (never same pair twice in a row)</li>
            <li>Each pair chooses:
                <ul>
                    <li><strong>Both Split ðŸ’šðŸ’š</strong> â€” Each keeps their money</li>
                    <li><strong>One Steals ðŸ˜ˆðŸ˜¢</strong> â€” Stealer gets both amounts, other eliminated</li>
                    <li><strong>Both Steal ðŸ’€ðŸ’€</strong> â€” Both lose money and are eliminated</li>
                </ul>
            </li>
            <li>Lost funds (from steal/steal) are redistributed equally among remaining players</li>
            <li>Need <strong>$40+</strong> to qualify for charity donation</li>
            <li>Odd player out auto-advances (never same person twice)</li>
            <li>Game ends when too few players remain</li>
        </ul>
        <div class="keyboard-hints">
            <h3 style="color: var(--cyan); margin-bottom: 0.5rem;">Keyboard Shortcuts</h3>
            <div class="keyboard-hint">
                <span>Switch tabs</span>
                <span><span class="key">1</span> <span class="key">2</span> <span class="key">3</span></span>
            </div>
            <div class="keyboard-hint">
                <span>Open/close rules</span>
                <span><span class="key">?</span></span>
            </div>
            <div class="keyboard-hint">
                <span>Close panels</span>
                <span><span class="key">Esc</span></span>
            </div>
        </div>
    </aside>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const STARTING_COINS = 10;
        const CHARITY_THRESHOLD = 40;
        const STORAGE_KEY = 'splitStealGame';

        // ============================================
        // STATE
        // ============================================
        let state = {
            currentRound: 1,
            players: [],
            removedCoins: 0,
            resolvedPairs: new Set(),
            pairResults: new Map(),
            roundPairs: new Map(),
            previousPairs: new Set(),
            lastAutoAdvanced: null,
            gameEnded: false,
            gameStarted: false,
            history: {
                rounds: [],
                betrayals: {},
                eliminations: []
            }
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            loadFromStorage();
            setupEventListeners();
            updateAllDisplays();
        });

        function setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-btn[data-tab]').forEach(btn => {
                btn.addEventListener('click', () => switchTab(btn.dataset.tab));
            });

            // Name input live preview
            document.getElementById('nameInput').addEventListener('input', updatePlayerPreview);

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);

            // Auto-save
            window.addEventListener('beforeunload', saveToStorage);
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) saveToStorage();
            });
        }

        function handleKeyboard(e) {
            // Escape closes panels
            if (e.key === 'Escape') {
                closeAllPanels();
                return;
            }

            // Don't intercept if typing in textarea
            if (e.target.tagName === 'TEXTAREA') return;

            // Tab switching with number keys
            if (e.key === '1') switchTab('setup');
            if (e.key === '2') switchTab('game');
            if (e.key === '3') switchTab('history');
            if (e.key === '?') toggleRules();
        }

        // ============================================
        // TAB MANAGEMENT
        // ============================================
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn[data-tab]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabId);
            });
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `tab-${tabId}`);
            });
        }

        // ============================================
        // RULES PANEL
        // ============================================
        function toggleRules() {
            const panel = document.getElementById('rulesPanel');
            const overlay = document.getElementById('overlay');
            panel.classList.toggle('active');
            overlay.classList.toggle('active');
        }

        function closeAllPanels() {
            document.getElementById('rulesPanel').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('nextRoundPanel').classList.remove('active');
            document.getElementById('resetRoundPanel').classList.remove('active');
            document.getElementById('newGamePanel').classList.remove('active');
            document.getElementById('fullResetPanel').classList.remove('active');
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // ============================================
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============================================
        // SETUP TAB
        // ============================================
        function updatePlayerPreview() {
            const input = document.getElementById('nameInput').value;
            const names = parseNames(input);
            const preview = document.getElementById('playerPreview');
            const count = document.getElementById('playerCount');

            count.textContent = names.length;
            preview.innerHTML = names.length > 0
                ? names.map(n => `<span class="preview-chip">${escapeHtml(n)}</span>`).join('')
                : '<span class="empty-state">No names entered</span>';
        }

        function parseNames(input) {
            return input
                .split(/\n/)
                .map(name => name.trim())
                .filter(name => name.length > 0);
        }

        function loadDefaultPlayers() {
            const defaultNames = [
                "Emma", "Liam", "Olivia", "Noah", "Ava", "Ethan",
                "Sophia", "Mason", "Isabella", "William", "Mia", "James",
                "Charlotte", "Benjamin", "Amelia", "Lucas", "Harper", "Henry"
            ];
            document.getElementById('nameInput').value = defaultNames.join('\n');
            updatePlayerPreview();
            showToast('Demo names loaded', 'success');
        }

        function clearNames() {
            document.getElementById('nameInput').value = '';
            updatePlayerPreview();
        }

        function startGame() {
            const input = document.getElementById('nameInput').value;
            const names = parseNames(input);

            if (names.length < 2) {
                showToast('Need at least 2 players to start', 'error');
                return;
            }

            // Initialize players
            state.players = names.map((name, index) => ({
                id: index + 1,
                name: name,
                coins: STARTING_COINS,
                active: true,
                winner: false
            }));

            // Reset game state
            state.currentRound = 1;
            state.removedCoins = 0;
            state.resolvedPairs = new Set();
            state.pairResults = new Map();
            state.roundPairs = new Map();
            state.previousPairs = new Set();
            state.lastAutoAdvanced = null;
            state.gameEnded = false;
            state.gameStarted = true;
            state.history = { rounds: [], betrayals: {}, eliminations: [] };

            saveToStorage();
            updateAllDisplays();
            switchTab('game');
            showToast(`Game started with ${names.length} players!`, 'success');
        }

        // ============================================
        // GAME TAB - PAIRING LOGIC
        // ============================================
        function createPairsForRound() {
            const activePlayers = state.players.filter(p => p.active);
            const shuffled = [...activePlayers].sort(() => Math.random() - 0.5);
            const pairs = [];
            const paired = new Set();

            // Track previous round's pairs
            if (state.currentRound > 1) {
                state.previousPairs.clear();
                const prevPairs = state.roundPairs.get(state.currentRound - 1) || [];
                prevPairs.forEach(pair => {
                    if (pair.type === 'pair') {
                        state.previousPairs.add(`${pair.player1.id}-${pair.player2.id}`);
                    }
                });
            }

            // Create pairs avoiding previous matchups
            for (let i = 0; i < shuffled.length; i++) {
                if (paired.has(shuffled[i].id)) continue;

                for (let j = i + 1; j < shuffled.length; j++) {
                    if (paired.has(shuffled[j].id)) continue;

                    const pairKey1 = `${shuffled[i].id}-${shuffled[j].id}`;
                    const pairKey2 = `${shuffled[j].id}-${shuffled[i].id}`;
                    
                    if (!state.previousPairs.has(pairKey1) && !state.previousPairs.has(pairKey2)) {
                        pairs.push({
                            player1: { ...shuffled[i] },
                            player2: { ...shuffled[j] },
                            type: 'pair'
                        });
                        paired.add(shuffled[i].id);
                        paired.add(shuffled[j].id);
                        break;
                    }
                }
            }

            // Handle unpaired players (odd number)
            const unpaired = shuffled.filter(p => !paired.has(p.id));
            if (unpaired.length > 0) {
                const eligible = unpaired.filter(p => p.id !== state.lastAutoAdvanced);
                const autoPlayer = eligible.length > 0 
                    ? eligible[Math.floor(Math.random() * eligible.length)]
                    : unpaired[0];
                
                pairs.push({
                    player1: { ...autoPlayer },
                    type: 'single'
                });
                state.lastAutoAdvanced = autoPlayer.id;
            }

            state.roundPairs.set(state.currentRound, pairs);
            return pairs;
        }

        // ============================================
        // GAME TAB - PAIR RESOLUTION
        // ============================================
        function resolvePair(pairId, id1, id2, outcome) {
            if (state.gameEnded) return;

            const player1 = state.players.find(p => p.id === id1);
            const player2 = state.players.find(p => p.id === id2);

            // Store previous state for undo
            const prevState = {
                players: JSON.parse(JSON.stringify(state.players)),
                removedCoins: state.removedCoins
            };
            state.pairResults.set(pairId + '_prev', prevState);

            let resultText = '';
            let historyEntry = { type: outcome, p1: player1.name, p2: player2.name };

            switch (outcome) {
                case 'split':
                    resultText = 'Both Split ðŸ’šðŸ’š';
                    historyEntry.description = `${player1.name} & ${player2.name} both split`;
                    break;
                case 'steal1':
                    player1.coins += player2.coins;
                    player2.coins = 0;
                    player2.active = false;
                    resultText = `${player1.name} Stole ðŸ˜ˆ`;
                    historyEntry.description = `${player1.name} stole from ${player2.name}`;
                    recordBetrayal(player1.name, player2.name);
                    recordElimination(player2.name, state.currentRound);
                    break;
                case 'steal2':
                    player2.coins += player1.coins;
                    player1.coins = 0;
                    player1.active = false;
                    resultText = `${player2.name} Stole ðŸ˜ˆ`;
                    historyEntry.description = `${player2.name} stole from ${player1.name}`;
                    recordBetrayal(player2.name, player1.name);
                    recordElimination(player1.name, state.currentRound);
                    break;
                case 'stealsteal':
                    state.removedCoins += player1.coins + player2.coins;
                    player1.coins = 0;
                    player2.coins = 0;
                    player1.active = false;
                    player2.active = false;
                    resultText = 'Both Lost ðŸ’€ðŸ’€';
                    historyEntry.description = `${player1.name} & ${player2.name} both stole â€” eliminated`;
                    recordElimination(player1.name, state.currentRound);
                    recordElimination(player2.name, state.currentRound);
                    break;
            }

            state.resolvedPairs.add(pairId);
            state.pairResults.set(pairId, resultText);

            // Add to round history
            addToRoundHistory(historyEntry);

            saveToStorage();
            updateAllDisplays();

            if (areAllPairsResolved()) {
                checkRoundComplete();
            }
        }

        function autoAdvance(pairId, playerId) {
            if (state.gameEnded) return;

            const player = state.players.find(p => p.id === playerId);
            
            const prevState = {
                players: JSON.parse(JSON.stringify(state.players)),
                removedCoins: state.removedCoins
            };
            state.pairResults.set(pairId + '_prev', prevState);

            state.resolvedPairs.add(pairId);
            state.pairResults.set(pairId, 'Auto-Advanced');

            addToRoundHistory({
                type: 'auto-advance',
                p1: player.name,
                description: `${player.name} auto-advanced`
            });

            saveToStorage();
            updateAllDisplays();

            if (areAllPairsResolved()) {
                checkRoundComplete();
            }
        }

        function undoPair(pairId) {
            if (state.gameEnded) return;

            const prevState = state.pairResults.get(pairId + '_prev');
            if (prevState) {
                state.players = prevState.players;
                state.removedCoins = prevState.removedCoins;
                state.resolvedPairs.delete(pairId);
                state.pairResults.delete(pairId);
                state.pairResults.delete(pairId + '_prev');

                // Remove last history entry for this round
                const currentRoundHistory = state.history.rounds.find(r => r.round === state.currentRound);
                if (currentRoundHistory && currentRoundHistory.entries.length > 0) {
                    currentRoundHistory.entries.pop();
                }

                saveToStorage();
                updateAllDisplays();
                showToast('Action undone', 'info');
            }
        }

        function areAllPairsResolved() {
            const pairs = state.roundPairs.get(state.currentRound) || [];
            return pairs.every((_, index) => 
                state.resolvedPairs.has(`pair_${state.currentRound}_${index}`)
            );
        }

        // ============================================
        // GAME TAB - ROUND MANAGEMENT
        // ============================================
        function checkRoundComplete() {
            const activePlayers = state.players.filter(p => p.active);
            const pairs = state.roundPairs.get(state.currentRound) || [];
            const totalFunds = state.players.reduce((sum, p) => sum + p.coins, 0) + state.removedCoins;

            if (activePlayers.length <= 3) {
                let autoAdvancePlayer = null;
                let finalPair = null;

                pairs.forEach(pair => {
                    if (pair.type === 'single') {
                        autoAdvancePlayer = state.players.find(p => p.id === pair.player1.id);
                    } else {
                        finalPair = pair;
                    }
                });

                if (autoAdvancePlayer && finalPair) {
                    const p1 = state.players.find(p => p.id === finalPair.player1.id);
                    const p2 = state.players.find(p => p.id === finalPair.player2.id);

                    if (!p1.active && !p2.active) {
                        // Both stole - auto-advance player wins everything
                        autoAdvancePlayer.coins = totalFunds;
                        state.removedCoins = 0;
                        announceWinner([autoAdvancePlayer]);
                        return;
                    }
                } else if (activePlayers.length === 2) {
                    const pair = pairs.find(p => p.type === 'pair');
                    if (pair) {
                        const p1 = state.players.find(p => p.id === pair.player1.id);
                        const p2 = state.players.find(p => p.id === pair.player2.id);

                        if (!p1.active && !p2.active) {
                            announceGameOver();
                            return;
                        } else if (!p1.active || !p2.active) {
                            const winner = p1.active ? p1 : p2;
                            winner.coins += state.removedCoins;
                            state.removedCoins = 0;
                            announceWinner([winner]);
                            return;
                        } else {
                            // Both split - both win
                            if (state.removedCoins > 0) {
                                const split = Math.floor(state.removedCoins / 2);
                                const remainder = state.removedCoins % 2;
                                p1.coins += split;
                                p2.coins += split;
                                if (remainder > 0) {
                                    (Math.random() < 0.5 ? p1 : p2).coins += remainder;
                                }
                                state.removedCoins = 0;
                            }
                            announceWinner([p1, p2]);
                            return;
                        }
                    }
                }
            }

            // Check if game should end (less than 2 active players)
            if (activePlayers.length < 2) {
                if (activePlayers.length === 1) {
                    announceWinner(activePlayers);
                } else {
                    announceGameOver();
                }
            }
        }

        function announceWinner(winners) {
            state.gameEnded = true;
            winners.forEach(p => p.winner = true);

            const resultEl = document.getElementById('gameResult');
            if (winners.length === 1) {
                resultEl.innerHTML = `ðŸ† ${winners[0].name} wins with $${winners[0].coins}! ðŸ†`;
            } else {
                const text = winners.map(w => `${w.name}: $${w.coins}`).join(' & ');
                resultEl.innerHTML = `ðŸ† Winners split the pot! ${text} ðŸ†`;
            }
            resultEl.className = 'game-result win';

            saveToStorage();
            updateAllDisplays();
        }

        function announceGameOver() {
            state.gameEnded = true;
            const resultEl = document.getElementById('gameResult');
            resultEl.innerHTML = `ðŸ’€ Game Over â€” All funds lost ($${state.removedCoins}) ðŸ’€`;
            resultEl.className = 'game-result loss';

            saveToStorage();
            updateAllDisplays();
        }

        // Next round confirmation
        function showNextRoundConfirm() {
            if (!areAllPairsResolved()) {
                showToast('Resolve all pairs before proceeding', 'error');
                return;
            }

            const activePlayers = state.players.filter(p => p.active).length;
            if (activePlayers < 2) {
                showToast('Not enough players to continue', 'error');
                return;
            }

            const perPlayer = state.removedCoins > 0 
                ? (state.removedCoins / activePlayers).toFixed(2) 
                : 0;

            document.getElementById('redistributionInfo').innerHTML = state.removedCoins > 0
                ? `<strong>$${state.removedCoins}</strong> will be redistributed among <strong>${activePlayers}</strong> active players (~$${perPlayer} each)`
                : 'No funds to redistribute this round';

            document.getElementById('nextRoundPanel').classList.add('active');
        }

        function hideNextRoundConfirm() {
            document.getElementById('nextRoundPanel').classList.remove('active');
        }

        function confirmNextRound() {
            redistributeFunds();
            state.currentRound++;
            state.resolvedPairs = new Set();
            state.pairResults = new Map();

            hideNextRoundConfirm();
            saveToStorage();
            updateAllDisplays();
            showToast(`Round ${state.currentRound} started`, 'success');
        }

        function redistributeFunds() {
            if (state.removedCoins <= 0) return;

            const activePlayers = state.players.filter(p => p.active);
            if (activePlayers.length === 0) return;

            const baseAmount = Math.floor(state.removedCoins / activePlayers.length);
            const remainder = state.removedCoins % activePlayers.length;

            activePlayers.forEach(p => p.coins += baseAmount);

            if (remainder > 0) {
                const lucky = activePlayers[Math.floor(Math.random() * activePlayers.length)];
                lucky.coins += remainder;
            }

            state.removedCoins = 0;
        }

        // Reset confirmations
        function resetRound() {
            document.getElementById('resetRoundPanel').classList.add('active');
        }

        function hideResetRoundConfirm() {
            document.getElementById('resetRoundPanel').classList.remove('active');
        }

        function confirmResetRound() {
            state.resolvedPairs = new Set();
            state.pairResults = new Map();
            state.roundPairs.delete(state.currentRound);
            state.players.forEach(p => p.winner = false);
            state.gameEnded = false;

            // Remove current round from history
            state.history.rounds = state.history.rounds.filter(r => r.round !== state.currentRound);

            hideResetRoundConfirm();
            saveToStorage();
            updateAllDisplays();
            showToast('Round reset', 'info');
        }

        function newGameSamePlayers() {
            document.getElementById('newGamePanel').classList.add('active');
        }

        function hideNewGameConfirm() {
            document.getElementById('newGamePanel').classList.remove('active');
        }

        function confirmNewGame() {
            state.players.forEach(p => {
                p.coins = STARTING_COINS;
                p.active = true;
                p.winner = false;
            });

            state.currentRound = 1;
            state.removedCoins = 0;
            state.resolvedPairs = new Set();
            state.pairResults = new Map();
            state.roundPairs = new Map();
            state.previousPairs = new Set();
            state.lastAutoAdvanced = null;
            state.gameEnded = false;
            state.history = { rounds: [], betrayals: {}, eliminations: [] };

            hideNewGameConfirm();
            saveToStorage();
            updateAllDisplays();
            showToast('New game started!', 'success');
        }

        function fullReset() {
            document.getElementById('fullResetPanel').classList.add('active');
        }

        function hideFullResetConfirm() {
            document.getElementById('fullResetPanel').classList.remove('active');
        }

        function confirmFullReset() {
            state = {
                currentRound: 1,
                players: [],
                removedCoins: 0,
                resolvedPairs: new Set(),
                pairResults: new Map(),
                roundPairs: new Map(),
                previousPairs: new Set(),
                lastAutoAdvanced: null,
                gameEnded: false,
                gameStarted: false,
                history: { rounds: [], betrayals: {}, eliminations: [] }
            };

            document.getElementById('nameInput').value = '';
            updatePlayerPreview();

            hideFullResetConfirm();
            localStorage.removeItem(STORAGE_KEY);
            updateAllDisplays();
            switchTab('setup');
            showToast('Game reset', 'info');
        }

        // ============================================
        // HISTORY TRACKING
        // ============================================
        function addToRoundHistory(entry) {
            let roundHistory = state.history.rounds.find(r => r.round === state.currentRound);
            if (!roundHistory) {
                roundHistory = { round: state.currentRound, entries: [] };
                state.history.rounds.push(roundHistory);
            }
            roundHistory.entries.push(entry);
        }

        function recordBetrayal(stealer, victim) {
            const key = stealer;
            if (!state.history.betrayals[key]) {
                state.history.betrayals[key] = [];
            }
            state.history.betrayals[key].push(victim);
        }

        function recordElimination(name, round) {
            if (!state.history.eliminations.find(e => e.name === name)) {
                state.history.eliminations.push({ name, round });
            }
        }

        // ============================================
        // DISPLAY UPDATES
        // ============================================
        function updateAllDisplays() {
            updateStats();
            updateGameDisplay();
            updateHistoryDisplay();
        }

        function updateStats() {
            const active = state.players.filter(p => p.active).length;
            const total = state.players.reduce((sum, p) => sum + p.coins, 0) + state.removedCoins;

            document.getElementById('statRound').textContent = state.gameStarted ? state.currentRound : 'â€”';
            document.getElementById('statActive').textContent = state.gameStarted ? active : 'â€”';
            document.getElementById('statCoins').textContent = state.gameStarted ? `$${total}` : 'â€”';
        }

        function updateGameDisplay() {
            if (!state.gameStarted) return;

            document.getElementById('roundDisplay').textContent = `Round ${state.currentRound}`;

            // Get or create pairs
            let pairs = state.roundPairs.get(state.currentRound);
            if (!pairs) {
                pairs = createPairsForRound();
            }

            // Render pair grid
            const pairGrid = document.getElementById('pairGrid');
            pairGrid.innerHTML = pairs.map((pair, index) => {
                const pairId = `pair_${state.currentRound}_${index}`;
                const isResolved = state.resolvedPairs.has(pairId);

                if (pair.type === 'pair') {
                    const p1 = state.players.find(p => p.id === pair.player1.id);
                    const p2 = state.players.find(p => p.id === pair.player2.id);
                    const isGameOver = p1.winner || p2.winner;

                    return `
                        <div class="pair-box ${isResolved ? 'resolved' : ''} ${isGameOver ? 'game-over' : ''}">
                            <div class="pair-players">
                                <span class="player-name ${getQualifiedClass(p1.coins)}">
                                    ${escapeHtml(p1.name)} <span class="player-coins">$${p1.coins}</span>
                                </span>
                                <span class="pair-vs">vs</span>
                                <span class="player-name ${getQualifiedClass(p2.coins)}">
                                    ${escapeHtml(p2.name)} <span class="player-coins">$${p2.coins}</span>
                                </span>
                            </div>
                            <div class="pair-buttons">
                                ${isResolved ? `
                                    <div class="pair-result">${state.pairResults.get(pairId)}</div>
                                    ${!state.gameEnded ? `<button class="undo-btn" onclick="undoPair('${pairId}')">Undo</button>` : ''}
                                ` : `
                                    <button class="outcome-btn split" onclick="resolvePair('${pairId}', ${p1.id}, ${p2.id}, 'split')">ðŸ’šðŸ’š Split</button>
                                    <button class="outcome-btn steal" onclick="resolvePair('${pairId}', ${p1.id}, ${p2.id}, 'steal1')">${escapeHtml(p1.name)} ðŸ˜ˆ</button>
                                    <button class="outcome-btn steal" onclick="resolvePair('${pairId}', ${p1.id}, ${p2.id}, 'steal2')">${escapeHtml(p2.name)} ðŸ˜ˆ</button>
                                    <button class="outcome-btn mutual-steal" onclick="resolvePair('${pairId}', ${p1.id}, ${p2.id}, 'stealsteal')">ðŸ’€ðŸ’€ Both</button>
                                `}
                            </div>
                        </div>
                    `;
                } else {
                    const p1 = state.players.find(p => p.id === pair.player1.id);
                    return `
                        <div class="pair-box auto-advance-box ${isResolved ? 'resolved' : ''} ${p1.winner ? 'game-over' : ''}">
                            <div class="pair-players">
                                <span class="player-name ${getQualifiedClass(p1.coins)}">
                                    ${escapeHtml(p1.name)} <span class="player-coins">$${p1.coins}</span>
                                </span>
                                <span class="auto-advance-label">â€” Auto Advance</span>
                            </div>
                            <div class="pair-buttons">
                                ${isResolved ? `
                                    <div class="pair-result">Advanced</div>
                                    ${!state.gameEnded ? `<button class="undo-btn" onclick="undoPair('${pairId}')">Undo</button>` : ''}
                                ` : `
                                    <button class="outcome-btn" onclick="autoAdvance('${pairId}', ${p1.id})">Confirm Advance</button>
                                `}
                            </div>
                        </div>
                    `;
                }
            }).join('');

            // Render player status grid
            const playerGrid = document.getElementById('playerGrid');
            playerGrid.innerHTML = state.players.map(p => {
                let statusClass = '';
                let statusText = '';

                if (p.winner) {
                    statusClass = 'winner';
                    statusText = 'ðŸ† Winner';
                } else if (!p.active) {
                    statusClass = 'eliminated';
                    statusText = 'Out';
                } else if (p.coins >= CHARITY_THRESHOLD) {
                    statusClass = 'charity-qualified';
                    statusText = 'âœ“ Qualified';
                } else {
                    statusClass = 'charity-unqualified';
                    statusText = `$${CHARITY_THRESHOLD - p.coins} to qualify`;
                }

                return `
                    <div class="player-card ${statusClass}">
                        <span class="player-card-name">${escapeHtml(p.name)}</span>
                        <span>
                            <span class="player-card-coins">$${p.coins}</span>
                            <span class="player-card-status">${statusText}</span>
                        </span>
                    </div>
                `;
            }).join('');

            // Update game result display
            const resultEl = document.getElementById('gameResult');
            if (!state.gameEnded) {
                resultEl.className = 'game-result';
                resultEl.style.display = 'none';
            } else {
                resultEl.style.display = 'block';
            }
        }

        function updateHistoryDisplay() {
            // Round log
            const roundLogEl = document.getElementById('roundLog');
            if (state.history.rounds.length === 0) {
                roundLogEl.innerHTML = '<div class="empty-state">No rounds played yet</div>';
            } else {
                roundLogEl.innerHTML = state.history.rounds.map(r => `
                    <div class="round-log">
                        <div class="round-log-header">Round ${r.round}</div>
                        ${r.entries.map(e => `
                            <div class="round-log-entry ${e.type}">${escapeHtml(e.description)}</div>
                        `).join('')}
                    </div>
                `).join('');
            }

            // Betrayal ledger
            const betrayalEl = document.getElementById('betrayalLedger');
            const betrayals = Object.entries(state.history.betrayals);
            if (betrayals.length === 0) {
                betrayalEl.innerHTML = '<div class="empty-state">No betrayals yet</div>';
            } else {
                betrayalEl.innerHTML = betrayals.map(([stealer, victims]) => `
                    <div class="betrayal-entry">
                        <span>${escapeHtml(stealer)} stole from: ${victims.map(v => escapeHtml(v)).join(', ')}</span>
                        <span class="betrayal-count">Ã—${victims.length}</span>
                    </div>
                `).join('');
            }

            // Eliminated list
            const eliminatedEl = document.getElementById('eliminatedList');
            if (state.history.eliminations.length === 0) {
                eliminatedEl.innerHTML = '<div class="empty-state">No eliminations yet</div>';
            } else {
                eliminatedEl.innerHTML = state.history.eliminations.map(e => `
                    <div class="eliminated-entry">
                        <span>${escapeHtml(e.name)}</span>
                        <span class="eliminated-round">Round ${e.round}</span>
                    </div>
                `).join('');
            }
        }

        // ============================================
        // UTILITIES
        // ============================================
        function getQualifiedClass(coins) {
            return coins >= CHARITY_THRESHOLD ? 'qualified' : 'unqualified';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // PERSISTENCE
        // ============================================
        function saveToStorage() {
            const saveData = {
                currentRound: state.currentRound,
                players: state.players,
                removedCoins: state.removedCoins,
                resolvedPairs: Array.from(state.resolvedPairs),
                pairResults: Array.from(state.pairResults.entries()),
                roundPairs: Array.from(state.roundPairs.entries()),
                previousPairs: Array.from(state.previousPairs),
                lastAutoAdvanced: state.lastAutoAdvanced,
                gameEnded: state.gameEnded,
                gameStarted: state.gameStarted,
                history: state.history
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
        }

        function loadFromStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            try {
                const data = JSON.parse(saved);
                state.currentRound = data.currentRound || 1;
                state.players = data.players || [];
                state.removedCoins = data.removedCoins || 0;
                state.resolvedPairs = new Set(data.resolvedPairs || []);
                state.pairResults = new Map(data.pairResults || []);
                state.roundPairs = new Map(data.roundPairs || []);
                state.previousPairs = new Set(data.previousPairs || []);
                state.lastAutoAdvanced = data.lastAutoAdvanced;
                state.gameEnded = data.gameEnded || false;
                state.gameStarted = data.gameStarted || false;
                state.history = data.history || { rounds: [], betrayals: {}, eliminations: [] };

                if (state.gameStarted) {
                    switchTab('game');
                }

                showToast('Game restored', 'success');
            } catch (e) {
                console.error('Failed to load saved game:', e);
            }
        }

        // EASTER EGG: Konami code triggers confetti burst
        // â†‘ â†‘ â†“ â†“ â† â†’ â† â†’ B A
        let konamiProgress = 0;
        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        document.addEventListener('keydown', (e) => {
            if (e.code === konamiCode[konamiProgress]) {
                konamiProgress++;
                if (konamiProgress === konamiCode.length) {
                    konamiProgress = 0;
                    showToast('ðŸŽ® KONAMI CODE ACTIVATED! ðŸŽ®', 'success');
                    document.body.style.animation = 'pulse 0.5s ease 3';
                    setTimeout(() => document.body.style.animation = '', 1500);
                }
            } else {
                konamiProgress = 0;
            }
        });
    </script>
</body>
</html>