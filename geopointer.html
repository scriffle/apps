<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Point Through Earth</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 65vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
        }
        
        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            max-height: 35vh;
            overflow-y: auto;
        }
        
        .country-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
        }
        
        .country-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .country-btn.active {
            background: rgba(46, 204, 113, 0.4);
            border-color: #2ecc71;
        }
        
        #accuracy-display {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
        }
        
        #accuracy-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        #accuracy-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c 0%, #f39c12 50%, #2ecc71 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .warning {
            background: rgba(255, 152, 0, 0.95);
            padding: 20px;
            border-radius: 10px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 18px;
            display: none;
            z-index: 1000;
        }
        
        .debug-panel {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            margin-top: 10px;
            border-radius: 4px;
            line-height: 1.4;
        }
        
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-dot.active { background: #2ecc71; }
        .status-dot.inactive { background: #e74c3c; }
        
        #instructions {
            background: rgba(52, 152, 219, 0.2);
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="info">
        <div><span class="status-dot" id="location-status"></span><strong>Location:</strong> <span id="user-location">Initializing...</span></div>
        <div><span class="status-dot" id="orientation-status"></span><strong>Sensors:</strong> <span id="sensor-status">Waiting...</span></div>
        <div id="instructions">
            üì± Hold phone and tilt TOP away from you to point camera down through Earth<br>
            üß≠ 3D view is fixed: North is marked with red arrow
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="warning" id="sky-warning">
        ‚òÅÔ∏è Camera pointing at sky!<br>
        <small>Tilt phone more horizontal (top away from you)</small>
    </div>
    
    <div id="controls">
        <div style="font-weight: bold; margin-bottom: 10px;">Select Target Location:</div>
        <div>
            <button class="country-btn" onclick="setTarget('China', 35.8617, 104.1954)">üá®üá≥ China</button>
            <button class="country-btn" onclick="setTarget('USA', 37.0902, -95.7129)">üá∫üá∏ USA</button>
            <button class="country-btn" onclick="setTarget('UK', 55.3781, -3.4360)">üá¨üáß UK</button>
            <button class="country-btn" onclick="setTarget('Brazil', -14.2350, -51.9253)">üáßüá∑ Brazil</button>
            <button class="country-btn" onclick="setTarget('Japan', 36.2048, 138.2529)">üáØüáµ Japan</button>
            <button class="country-btn" onclick="setTarget('Egypt', 26.8206, 30.8025)">üá™üá¨ Egypt</button>
        </div>
        
        <div id="accuracy-display">
            <div style="font-size: 20px; font-weight: bold;">
                <span id="target-name">China</span>: <span id="distance">0</span> km
            </div>
            <div id="accuracy-bar"><div id="accuracy-fill"></div></div>
            <div>Accuracy: <span id="accuracy-percent" style="font-size: 24px; font-weight: bold;">0</span>%</div>
            <div id="direction-hint" style="margin-top: 10px; font-size: 14px;"></div>
        </div>
        
        <div class="debug-panel">
            <div><strong>Target:</strong> Az: <span id="target-az">0</span>¬∞, El: <span id="target-el">0</span>¬∞</div>
            <div><strong>Camera:</strong> Az: <span id="phone-az">0</span>¬∞, El: <span id="phone-el">0</span>¬∞</div>
            <div><strong>Phone Œ≤:</strong> <span id="phone-beta">0</span>¬∞ (0¬∞=flat, 90¬∞=vertical)</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let phoneArrow, targetArrow;
        let arrowGroup;
        
        // User location (default Melbourne)
        let userLat = -37.8136;
        let userLon = 144.9631;
        
        // Target location (default China)
        let targetLat = 35.8617;
        let targetLon = 104.1954;
        let targetName = "China";
        
        // Device orientation
        let deviceAlpha = 0;  // Compass heading (0=North)
        let deviceBeta = 90;  // Tilt (0=flat, 90=vertical)
        let deviceGamma = 0;  // Roll
        
        // Status flags
        let hasLocation = false;
        let hasOrientation = false;
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x203a43, 1, 50);
            
            // Camera setup - FIXED position, no rotation
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / (window.innerHeight * 0.65),
                0.1,
                100
            );
            // Fixed camera position - viewing from southeast, looking northwest
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight * 0.65);
            renderer.setClearColor(0x000000, 0.1);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            
            const directional1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directional1.position.set(10, 10, 5);
            scene.add(directional1);
            
            const directional2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directional2.position.set(-5, 5, -10);
            scene.add(directional2);
            
            // Create arrow group
            arrowGroup = new THREE.Group();
            scene.add(arrowGroup);
            
            // Phone arrow (green) - where camera points
            const phoneGeometry = new THREE.ConeGeometry(0.4, 2, 12);
            const phoneMaterial = new THREE.MeshPhongMaterial({
                color: 0x2ecc71,
                emissive: 0x27ae60,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            phoneArrow = new THREE.Mesh(phoneGeometry, phoneMaterial);
            arrowGroup.add(phoneArrow);
            
            // Target arrow (red) - correct direction
            const targetGeometry = new THREE.ConeGeometry(0.4, 2, 12);
            const targetMaterial = new THREE.MeshPhongMaterial({
                color: 0xe74c3c,
                emissive: 0xc0392b,
                emissiveIntensity: 0.3,
                opacity: 0.5,
                transparent: true
            });
            targetArrow = new THREE.Mesh(targetGeometry, targetMaterial);
            arrowGroup.add(targetArrow);
            
            // Reference grid
            const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            grid.position.y = -5;
            scene.add(grid);
            
            // Compass ring
            const ring = new THREE.RingGeometry(3, 3.2, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                opacity: 0.1,
                transparent: true
            });
            const ringMesh = new THREE.Mesh(ring, ringMaterial);
            ringMesh.rotation.x = -Math.PI / 2;
            scene.add(ringMesh);
            
            // Add North indicator
            const northGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
            const northMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const northMarker = new THREE.Mesh(northGeometry, northMaterial);
            northMarker.position.set(0, 0, -4); // North is negative Z
            northMarker.rotation.x = Math.PI / 2;
            scene.add(northMarker);
            
            // Add "N" text sprite (optional)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('N', 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, opacity: 0.8 });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(0, 1, -4);
            sprite.scale.set(1, 1, 1);
            scene.add(sprite);
            
            animate();
        }
        
        // Calculate direction through Earth (corrected algorithm)
        function calculateThroughEarth(lat1, lon1, lat2, lon2) {
            // Convert to radians
            const phi1 = lat1 * Math.PI / 180;
            const lambda1 = lon1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const lambda2 = lon2 * Math.PI / 180;
            
            // Convert to Cartesian coordinates
            const x1 = Math.cos(phi1) * Math.cos(lambda1);
            const y1 = Math.cos(phi1) * Math.sin(lambda1);
            const z1 = Math.sin(phi1);
            
            const x2 = Math.cos(phi2) * Math.cos(lambda2);
            const y2 = Math.cos(phi2) * Math.sin(lambda2);
            const z2 = Math.sin(phi2);
            
            // Vector through Earth
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dz = z2 - z1;
            
            // Local tangent plane (ENU) at user location
            const east = [-Math.sin(lambda1), Math.cos(lambda1), 0];
            const north = [
                -Math.sin(phi1) * Math.cos(lambda1),
                -Math.sin(phi1) * Math.sin(lambda1),
                Math.cos(phi1)
            ];
            const up = [
                Math.cos(phi1) * Math.cos(lambda1),
                Math.cos(phi1) * Math.sin(lambda1),
                Math.sin(phi1)
            ];
            
            // Project onto local axes
            const localEast = dx * east[0] + dy * east[1] + dz * east[2];
            const localNorth = dx * north[0] + dy * north[1] + dz * north[2];
            const localUp = dx * up[0] + dy * up[1] + dz * up[2];
            
            // Calculate azimuth (compass bearing)
            let azimuth = Math.atan2(localEast, localNorth) * 180 / Math.PI;
            if (azimuth < 0) azimuth += 360;
            
            // Calculate elevation
            const horizontalDist = Math.sqrt(localEast * localEast + localNorth * localNorth);
            const elevation = Math.atan2(localUp, horizontalDist) * 180 / Math.PI;
            
            // Distance through Earth
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) * 6371;
            
            return { azimuth, elevation, distance };
        }
        
        // Update visualization
        function updateVisualization() {
            if (!phoneArrow || !targetArrow) return;
            
            // Calculate target direction
            const target = calculateThroughEarth(userLat, userLon, targetLat, targetLon);
            
            // Camera elevation from phone orientation
            // Beta: 0=flat screen up, 90=vertical, 180=flat screen down
            // Camera points: 0¬∞‚Üí-90¬∞, 45¬∞‚Üí-45¬∞, 90¬∞‚Üí0¬∞, 135¬∞‚Üí+45¬∞
            const cameraElevation = deviceBeta - 90;
            
            // Check if pointing at sky
            if (cameraElevation > 0) {
                document.getElementById('sky-warning').style.display = 'block';
                phoneArrow.visible = false;
            } else {
                document.getElementById('sky-warning').style.display = 'none';
                phoneArrow.visible = true;
            }
            
            // Update arrow rotations using direction vectors
            // Target arrow - points in the calculated direction
            const targetDir = new THREE.Vector3();
            const targetAzRad = target.azimuth * Math.PI / 180;
            const targetElRad = target.elevation * Math.PI / 180;
            
            // Convert spherical to Cartesian (azimuth from North, elevation from horizontal)
            targetDir.x = Math.cos(targetElRad) * Math.sin(targetAzRad);  // East
            targetDir.y = Math.sin(targetElRad);  // Up
            targetDir.z = -Math.cos(targetElRad) * Math.cos(targetAzRad); // North (negative Z)
            
            targetArrow.lookAt(targetDir);
            targetArrow.rotateX(Math.PI / 2); // Cone default points up, rotate to point forward
            
            // Phone arrow - points where camera is aiming
            const phoneDir = new THREE.Vector3();
            const phoneAzRad = deviceAlpha * Math.PI / 180;
            const phoneElRad = cameraElevation * Math.PI / 180;
            
            phoneDir.x = Math.cos(phoneElRad) * Math.sin(phoneAzRad);  // East
            phoneDir.y = Math.sin(phoneElRad);  // Up
            phoneDir.z = -Math.cos(phoneElRad) * Math.cos(phoneAzRad); // North (negative Z)
            
            phoneArrow.lookAt(phoneDir);
            phoneArrow.rotateX(Math.PI / 2); // Cone default points up, rotate to point forward
            
            // Calculate accuracy
            let azimuthDiff = Math.abs(target.azimuth - deviceAlpha);
            if (azimuthDiff > 180) azimuthDiff = 360 - azimuthDiff;
            
            const elevationDiff = Math.abs(target.elevation - cameraElevation);
            const totalError = Math.sqrt(azimuthDiff * azimuthDiff + elevationDiff * elevationDiff);
            const accuracy = Math.max(0, Math.min(100, 100 - totalError * 1.5));
            
            // Update UI
            document.getElementById('target-name').textContent = targetName;
            document.getElementById('distance').textContent = Math.round(target.distance);
            document.getElementById('accuracy-percent').textContent = Math.round(accuracy);
            document.getElementById('accuracy-fill').style.width = accuracy + '%';
            
            // Color based on accuracy
            const hue = accuracy * 1.2; // 0=red, 120=green
            phoneArrow.material.color.setHSL(hue / 360, 1, 0.5);
            
            // Direction hints
            let hint = '';
            if (accuracy > 90) {
                hint = '‚úÖ Perfect! Camera pointing through Earth to ' + targetName;
            } else {
                if (azimuthDiff > 10) {
                    const angleDiff = ((target.azimuth - deviceAlpha + 540) % 360) - 180;
                    hint += angleDiff > 0 ? 'Turn RIGHT ‚û°Ô∏è ' : 'Turn LEFT ‚¨ÖÔ∏è ';
                }
                if (elevationDiff > 10) {
                    if (target.elevation < cameraElevation) {
                        hint += 'Tilt phone MORE HORIZONTAL (top away) ‚¨áÔ∏è';
                    } else {
                        hint += 'Tilt phone MORE VERTICAL (top toward you) ‚¨ÜÔ∏è';
                    }
                }
            }
            document.getElementById('direction-hint').innerHTML = hint;
            
            // Debug info
            document.getElementById('target-az').textContent = Math.round(target.azimuth);
            document.getElementById('target-el').textContent = Math.round(target.elevation);
            document.getElementById('phone-az').textContent = Math.round(deviceAlpha);
            document.getElementById('phone-el').textContent = Math.round(cameraElevation);
            document.getElementById('phone-beta').textContent = Math.round(deviceBeta);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Camera is FIXED - no rotation!
            // The 3D scene is aligned with the real world:
            // - North is toward negative Z
            // - East is toward positive X
            // - Up is toward positive Y
            
            updateVisualization();
            renderer.render(scene, camera);
        }
        
        // Get user location
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        userLat = position.coords.latitude;
                        userLon = position.coords.longitude;
                        hasLocation = true;
                        document.getElementById('user-location').innerHTML = 
                            `${userLat.toFixed(4)}¬∞, ${userLon.toFixed(4)}¬∞ ‚úì`;
                        document.getElementById('location-status').className = 'status-dot active';
                    },
                    error => {
                        // Use Melbourne as fallback
                        hasLocation = true;
                        document.getElementById('user-location').innerHTML = 
                            `Melbourne (default) ${userLat.toFixed(4)}¬∞, ${userLon.toFixed(4)}¬∞`;
                        document.getElementById('location-status').className = 'status-dot inactive';
                    },
                    { enableHighAccuracy: true, timeout: 10000 }
                );
            }
        }
        
        // Handle device orientation
        function handleOrientation(event) {
            if (event.alpha !== null) {
                deviceAlpha = event.alpha;
                deviceBeta = event.beta;
                deviceGamma = event.gamma;
                
                if (!hasOrientation) {
                    hasOrientation = true;
                    document.getElementById('sensor-status').textContent = 'Active ‚úì';
                    document.getElementById('orientation-status').className = 'status-dot active';
                }
            }
        }
        
        // Set target location
        function setTarget(name, lat, lon) {
            targetName = name;
            targetLat = lat;
            targetLon = lon;
            
            // Update buttons
            document.querySelectorAll('.country-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(name)) {
                    btn.classList.add('active');
                }
            });
        }
        
        // Request orientation permission (iOS)
        function requestOrientation() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                    });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }
        
        // Initialize everything
        window.addEventListener('load', () => {
            initScene();
            getUserLocation();
            requestOrientation();
            setTarget('China', 35.8617, 104.1954);
            
            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / (window.innerHeight * 0.65);
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight * 0.65);
            });
        });
        
        // iOS permission on tap
        document.addEventListener('click', () => {
            requestOrientation();
        }, { once: true });
    </script>
</body>
</html>