<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Point Through Earth</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f1419;
            color: white;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #info {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            max-width: 280px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px;
            border-radius: 8px;
            transition: transform 0.3s ease;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .country-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 10px;
            margin: 3px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
        }
        
        .country-btn:hover, .country-btn:active {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .country-btn.active {
            background: rgba(46, 204, 113, 0.4);
            border-color: #2ecc71;
        }
        
        #accuracy-display {
            position: absolute;
            bottom: 70px;
            left: 10px;
            pointer-events: none;
        }
        
        #accuracy-circle {
            width: 70px;
            height: 70px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }
        
        #accuracy-text {
            font-size: 20px;
            font-weight: bold;
        }
        
        #accuracy-label {
            font-size: 9px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #direction-hint {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            max-width: 200px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .warning {
            background: rgba(255, 152, 0, 0.95);
            padding: 15px 20px;
            border-radius: 10px;
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 16px;
            display: none;
            z-index: 1000;
            max-width: 250px;
        }
        
        .debug-panel {
            display: none;
        }
        
        .status-dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 4px;
        }
        
        .status-dot.active { background: #2ecc71; }
        .status-dot.inactive { background: #e74c3c; }
        
        #toggle-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        #toggle-controls:active {
            transform: scale(0.95);
        }
        
        #controls.collapsed {
            transform: translateY(calc(100% + 20px));
        }
        
        #target-display {
            position: absolute;
            top: 48px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        @media (min-width: 768px) {
            #info {
                max-width: 400px;
            }
            
            #controls {
                max-width: 600px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            #controls.collapsed {
                transform: translateX(-50%) translateY(calc(100% + 20px));
            }
            
            .country-btn {
                padding: 8px 15px;
                font-size: 14px;
            }
            
            #accuracy-circle {
                width: 90px;
                height: 90px;
            }
            
            #accuracy-text {
                font-size: 28px;
            }
            
            #direction-hint {
                bottom: 170px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <div style="display: flex; justify-content: space-between;">
            <span><span class="status-dot inactive" id="location-status"></span>GPS</span>
            <span><span class="status-dot inactive" id="orientation-status"></span>Sensors</span>
        </div>
        <div style="margin-top: 5px; font-size: 10px; opacity: 0.8;">Tilt phone forward to point down</div>
    </div>
    
    <div id="target-display">
        üìç <span id="target-name">China</span>: <span id="distance">0</span> km
    </div>
    
    <div id="accuracy-display">
        <div id="accuracy-circle">
            <div id="accuracy-text">0%</div>
            <div id="accuracy-label">accuracy</div>
        </div>
    </div>
    
    <div id="direction-hint"></div>
    
    <div class="warning" id="sky-warning">
        ‚òÅÔ∏è Pointing up!<br>
        <small>Tilt forward</small>
    </div>
    
    <button id="toggle-controls" onclick="toggleControls()">üåè</button>
    
    <div id="controls" class="collapsed">
        <div style="text-align: center; margin-bottom: 8px; font-size: 12px; opacity: 0.8;">Choose Target Location</div>
        <div style="display: flex; flex-wrap: wrap; justify-content: center;">
            <button class="country-btn" onclick="setTarget('China', 35.8617, 104.1954)">üá®üá≥ China</button>
            <button class="country-btn" onclick="setTarget('USA', 37.0902, -95.7129)">üá∫üá∏ USA</button>
            <button class="country-btn" onclick="setTarget('UK', 55.3781, -3.4360)">üá¨üáß UK</button>
            <button class="country-btn" onclick="setTarget('Brazil', -14.2350, -51.9253)">üáßüá∑ Brazil</button>
            <button class="country-btn" onclick="setTarget('Japan', 36.2048, 138.2529)">üáØüáµ Japan</button>
            <button class="country-btn" onclick="setTarget('Egypt', 26.8206, 30.8025)">üá™üá¨ Egypt</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let phoneArrow, targetArrow;
        let arrowGroup;
        
        // User location (default Melbourne)
        let userLat = -37.8136;
        let userLon = 144.9631;
        
        // Target location (default China)
        let targetLat = 35.8617;
        let targetLon = 104.1954;
        let targetName = "China";
        
        // Device orientation
        let deviceAlpha = 0;  // Compass heading (0=North)
        let deviceBeta = 90;  // Tilt (0=flat, 90=vertical)
        let deviceGamma = 0;  // Roll
        
        // Status flags
        let hasLocation = false;
        let hasOrientation = false;
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0f1419, 1, 50);
            
            // Camera setup - FIXED position, no rotation
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,  // Full screen now
                0.1,
                100
            );
            // Fixed camera position - closer for mobile viewing
            camera.position.set(6, 4, 6);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0f1419, 0.95);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            
            const directional1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directional1.position.set(10, 10, 5);
            scene.add(directional1);
            
            const directional2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directional2.position.set(-5, 5, -10);
            scene.add(directional2);
            
            // Create arrow group
            arrowGroup = new THREE.Group();
            scene.add(arrowGroup);
            
            // Phone arrow (green) - where camera points
            const phoneGeometry = new THREE.ConeGeometry(0.4, 2, 12);
            const phoneMaterial = new THREE.MeshPhongMaterial({
                color: 0x2ecc71,
                emissive: 0x27ae60,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            phoneArrow = new THREE.Mesh(phoneGeometry, phoneMaterial);
            arrowGroup.add(phoneArrow);
            
            // Target arrow (red) - correct direction
            const targetGeometry = new THREE.ConeGeometry(0.4, 2, 12);
            const targetMaterial = new THREE.MeshPhongMaterial({
                color: 0xe74c3c,
                emissive: 0xc0392b,
                emissiveIntensity: 0.3,
                opacity: 0.5,
                transparent: true
            });
            targetArrow = new THREE.Mesh(targetGeometry, targetMaterial);
            arrowGroup.add(targetArrow);
            
            // Reference grid (subtler for mobile)
            const grid = new THREE.GridHelper(16, 16, 0x333333, 0x222222);
            grid.position.y = -5;
            grid.material.opacity = 0.5;
            grid.material.transparent = true;
            scene.add(grid);
            
            // Compass ring (subtle)
            const ring = new THREE.RingGeometry(2.8, 3, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                opacity: 0.08,
                transparent: true
            });
            const ringMesh = new THREE.Mesh(ring, ringMaterial);
            ringMesh.rotation.x = -Math.PI / 2;
            scene.add(ringMesh);
            
            // Add North indicator (smaller for mobile)
            const northGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
            const northMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.7, transparent: true });
            const northMarker = new THREE.Mesh(northGeometry, northMaterial);
            northMarker.position.set(0, 0, -3.5); // North is negative Z
            northMarker.rotation.x = Math.PI / 2;
            scene.add(northMarker);
            
            // Add "N" text sprite
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('N', 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, opacity: 0.6, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(0, 0.8, -3.5);
            sprite.scale.set(0.8, 0.8, 0.8);
            scene.add(sprite);
            
            animate();
        }
        
        // Calculate direction through Earth (corrected algorithm)
        function calculateThroughEarth(lat1, lon1, lat2, lon2) {
            // Convert to radians
            const phi1 = lat1 * Math.PI / 180;
            const lambda1 = lon1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const lambda2 = lon2 * Math.PI / 180;
            
            // Convert to Cartesian coordinates
            const x1 = Math.cos(phi1) * Math.cos(lambda1);
            const y1 = Math.cos(phi1) * Math.sin(lambda1);
            const z1 = Math.sin(phi1);
            
            const x2 = Math.cos(phi2) * Math.cos(lambda2);
            const y2 = Math.cos(phi2) * Math.sin(lambda2);
            const z2 = Math.sin(phi2);
            
            // Vector through Earth
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dz = z2 - z1;
            
            // Local tangent plane (ENU) at user location
            const east = [-Math.sin(lambda1), Math.cos(lambda1), 0];
            const north = [
                -Math.sin(phi1) * Math.cos(lambda1),
                -Math.sin(phi1) * Math.sin(lambda1),
                Math.cos(phi1)
            ];
            const up = [
                Math.cos(phi1) * Math.cos(lambda1),
                Math.cos(phi1) * Math.sin(lambda1),
                Math.sin(phi1)
            ];
            
            // Project onto local axes
            const localEast = dx * east[0] + dy * east[1] + dz * east[2];
            const localNorth = dx * north[0] + dy * north[1] + dz * north[2];
            const localUp = dx * up[0] + dy * up[1] + dz * up[2];
            
            // Calculate azimuth (compass bearing)
            let azimuth = Math.atan2(localEast, localNorth) * 180 / Math.PI;
            if (azimuth < 0) azimuth += 360;
            
            // Calculate elevation
            const horizontalDist = Math.sqrt(localEast * localEast + localNorth * localNorth);
            const elevation = Math.atan2(localUp, horizontalDist) * 180 / Math.PI;
            
            // Distance through Earth
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) * 6371;
            
            return { azimuth, elevation, distance };
        }
        
        // Update visualization
        function updateVisualization() {
            if (!phoneArrow || !targetArrow) return;
            
            // Calculate target direction
            const target = calculateThroughEarth(userLat, userLon, targetLat, targetLon);
            
            // Camera elevation from phone orientation
            // Beta: 0=flat screen up, 90=vertical, 180=flat screen down
            // Camera points: 0¬∞‚Üí-90¬∞, 45¬∞‚Üí-45¬∞, 90¬∞‚Üí0¬∞, 135¬∞‚Üí+45¬∞
            const cameraElevation = deviceBeta - 90;
            
            // Check if pointing at sky
            if (cameraElevation > 0) {
                document.getElementById('sky-warning').style.display = 'block';
                phoneArrow.visible = false;
            } else {
                document.getElementById('sky-warning').style.display = 'none';
                phoneArrow.visible = true;
            }
            
            // Update arrow rotations using direction vectors
            // Target arrow - points in the calculated direction
            const targetDir = new THREE.Vector3();
            const targetAzRad = target.azimuth * Math.PI / 180;
            const targetElRad = target.elevation * Math.PI / 180;
            
            // Convert spherical to Cartesian (azimuth from North, elevation from horizontal)
            targetDir.x = Math.cos(targetElRad) * Math.sin(targetAzRad);  // East
            targetDir.y = Math.sin(targetElRad);  // Up
            targetDir.z = -Math.cos(targetElRad) * Math.cos(targetAzRad); // North (negative Z)
            
            targetArrow.lookAt(targetDir);
            targetArrow.rotateX(Math.PI / 2); // Cone default points up, rotate to point forward
            
            // Phone arrow - points where camera is aiming
            const phoneDir = new THREE.Vector3();
            const phoneAzRad = deviceAlpha * Math.PI / 180;
            const phoneElRad = cameraElevation * Math.PI / 180;
            
            phoneDir.x = Math.cos(phoneElRad) * Math.sin(phoneAzRad);  // East
            phoneDir.y = Math.sin(phoneElRad);  // Up
            phoneDir.z = -Math.cos(phoneElRad) * Math.cos(phoneAzRad); // North (negative Z)
            
            phoneArrow.lookAt(phoneDir);
            phoneArrow.rotateX(Math.PI / 2); // Cone default points up, rotate to point forward
            
            // Calculate accuracy
            let azimuthDiff = Math.abs(target.azimuth - deviceAlpha);
            if (azimuthDiff > 180) azimuthDiff = 360 - azimuthDiff;
            
            const elevationDiff = Math.abs(target.elevation - cameraElevation);
            const totalError = Math.sqrt(azimuthDiff * azimuthDiff + elevationDiff * elevationDiff);
            const accuracy = Math.max(0, Math.min(100, 100 - totalError * 1.5));
            
            // Update UI
            document.getElementById('target-name').textContent = targetName;
            document.getElementById('distance').textContent = Math.round(target.distance);
            
            const accuracyText = document.getElementById('accuracy-text');
            accuracyText.textContent = Math.round(accuracy) + '%';
            
            // Color the accuracy circle based on accuracy
            const accuracyCircle = document.getElementById('accuracy-circle');
            if (accuracy > 80) {
                accuracyCircle.style.borderColor = '#2ecc71';
                accuracyCircle.style.background = 'rgba(46, 204, 113, 0.1)';
                accuracyText.style.color = '#2ecc71';
            } else if (accuracy > 50) {
                accuracyCircle.style.borderColor = '#f39c12';
                accuracyCircle.style.background = 'rgba(243, 156, 18, 0.1)';
                accuracyText.style.color = '#f39c12';
            } else {
                accuracyCircle.style.borderColor = '#e74c3c';
                accuracyCircle.style.background = 'rgba(231, 76, 60, 0.1)';
                accuracyText.style.color = '#e74c3c';
            }
            
            // Color arrow based on accuracy
            const hue = accuracy * 1.2; // 0=red, 120=green
            phoneArrow.material.color.setHSL(hue / 360, 1, 0.5);
            
            // Direction hints
            let hint = '';
            if (accuracy > 90) {
                hint = '‚úÖ Perfect alignment!';
            } else {
                if (azimuthDiff > 10) {
                    const angleDiff = ((target.azimuth - deviceAlpha + 540) % 360) - 180;
                    hint += angleDiff > 0 ? '‚Üª Turn RIGHT ' : '‚Ü∫ Turn LEFT ';
                }
                if (elevationDiff > 10) {
                    if (target.elevation < cameraElevation) {
                        hint += 'üì± Tilt more flat';
                    } else {
                        hint += 'üì± Tilt more upright';
                    }
                }
            }
            document.getElementById('direction-hint').innerHTML = hint;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Camera is FIXED - no rotation!
            // The 3D scene is aligned with the real world:
            // - North is toward negative Z
            // - East is toward positive X
            // - Up is toward positive Y
            
            updateVisualization();
            renderer.render(scene, camera);
        }
        
        // Toggle controls panel
        function toggleControls() {
            const controls = document.getElementById('controls');
            const button = document.getElementById('toggle-controls');
            
            if (controls.classList.contains('collapsed')) {
                controls.classList.remove('collapsed');
                button.innerHTML = '‚úï';
            } else {
                controls.classList.add('collapsed');
                button.innerHTML = 'üåè';
            }
        }
        
        // Get user location
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        userLat = position.coords.latitude;
                        userLon = position.coords.longitude;
                        hasLocation = true;
                        document.getElementById('location-status').className = 'status-dot active';
                    },
                    error => {
                        // Use Melbourne as fallback
                        hasLocation = true;
                        document.getElementById('location-status').className = 'status-dot inactive';
                    },
                    { enableHighAccuracy: true, timeout: 10000 }
                );
            }
        }
        
        // Handle device orientation
        function handleOrientation(event) {
            if (event.alpha !== null) {
                deviceAlpha = event.alpha;
                deviceBeta = event.beta;
                deviceGamma = event.gamma;
                
                if (!hasOrientation) {
                    hasOrientation = true;
                    document.getElementById('orientation-status').className = 'status-dot active';
                }
            }
        }
        
        // Set target location
        function setTarget(name, lat, lon) {
            targetName = name;
            targetLat = lat;
            targetLon = lon;
            
            // Update buttons
            document.querySelectorAll('.country-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(name)) {
                    btn.classList.add('active');
                }
            });
            
            // Auto-close panel on mobile after selection
            if (window.innerWidth < 768) {
                setTimeout(() => {
                    document.getElementById('controls').classList.add('collapsed');
                    document.getElementById('toggle-controls').innerHTML = 'üåè';
                }, 300);
            }
        }
        
        // Request orientation permission (iOS)
        function requestOrientation() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                    });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }
        
        // Initialize everything
        window.addEventListener('load', () => {
            initScene();
            getUserLocation();
            requestOrientation();
            setTarget('China', 35.8617, 104.1954);
            
            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
        
        // iOS permission on tap
        document.addEventListener('click', () => {
            requestOrientation();
        }, { once: true });
    </script>
</body>
</html>