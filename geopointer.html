<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Point Through Earth</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 60vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            font-size: 12px;
        }
        
        #target-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .country-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 5px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .country-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        
        .country-btn.active {
            background: rgba(76, 175, 80, 0.7);
            border-color: #4CAF50;
        }
        
        #distance {
            font-size: 20px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        #accuracy {
            font-size: 24px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .warning {
            background: rgba(255, 152, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 18px;
            display: none;
        }
        
        #debug {
            font-family: monospace;
            font-size: 10px;
            opacity: 0.7;
            margin-top: 10px;
        }
        
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.active {
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        .status-dot.inactive {
            background: #f44336;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="info">
        <div><span class="status-dot" id="location-status"></span>Location: <span id="user-location">Getting location...</span></div>
        <div style="margin-top: 5px;"><span class="status-dot" id="orientation-status"></span>Orientation: Active</div>
        <div id="debug">
            Phone Tilt: <span id="phone-tilt">0</span>¬∞ | 
            Compass: <span id="compass-heading">0</span>¬∞ |
            Roll: <span id="phone-roll">0</span>¬∞
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="warning" id="pointing-up">
        ‚¨ÜÔ∏è You're pointing to the sky!<br>
        <small>Point down through the Earth to target countries</small>
    </div>
    
    <div id="target-info">
        <div style="font-size: 14px; margin-bottom: 10px;">Select target country:</div>
        <div>
            <button class="country-btn" onclick="setTarget('China', 35.8617, 104.1954)">üá®üá≥ China</button>
            <button class="country-btn" onclick="setTarget('USA', 37.0902, -95.7129)">üá∫üá∏ USA</button>
            <button class="country-btn" onclick="setTarget('UK', 55.3781, -3.4360)">üá¨üáß UK</button>
            <button class="country-btn" onclick="setTarget('Brazil', -14.2350, -51.9253)">üáßüá∑ Brazil</button>
            <button class="country-btn" onclick="setTarget('Japan', 36.2048, 138.2529)">üáØüáµ Japan</button>
            <button class="country-btn" onclick="setTarget('Egypt', 26.8206, 30.8025)">üá™üá¨ Egypt</button>
            <button class="country-btn" onclick="setTarget('India', 20.5937, 78.9629)">üáÆüá≥ India</button>
            <button class="country-btn" onclick="setTarget('Russia', 61.5240, 105.3188)">üá∑üá∫ Russia</button>
        </div>
        <div id="distance"></div>
        <div id="accuracy"></div>
        <div id="direction-hint" style="font-size: 14px; opacity: 0.8;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene variables
        let scene, camera, renderer, arrow, targetIndicator, earth;
        
        // Location variables - will be overwritten by actual GPS
        let userLat = null;
        let userLon = null;
        let hasLocation = false;
        
        // Target location
        let targetLat = 35.8617; // China default
        let targetLon = 104.1954;
        let targetName = "China";
        
        // Device orientation
        let deviceAlpha = 0, deviceBeta = 0, deviceGamma = 0;
        let hasOrientation = false;
        
        // Initialize Three.js scene
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1e3c72, 1, 30);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight * 0.6), 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
            renderer.setClearColor(0x000000, 0.1);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            // Create Earth sphere (for reference)
            const earthGeometry = new THREE.SphereGeometry(3, 32, 32);
            const earthMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2194ce,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);
            
            // Create pointing arrow
            const arrowGroup = new THREE.Group();
            
            // Arrow shaft
            const shaftGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const shaftMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3
            });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = -1.5;
            arrowGroup.add(shaft);
            
            // Arrow head
            const headGeometry = new THREE.ConeGeometry(0.3, 1, 8);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = -3.5;
            arrowGroup.add(head);
            
            arrow = arrowGroup;
            scene.add(arrow);
            
            // Create target indicator ring
            const ringGeometry = new THREE.TorusGeometry(3.5, 0.1, 8, 32);
            const ringMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.5
            });
            targetIndicator = new THREE.Mesh(ringGeometry, ringMaterial);
            scene.add(targetIndicator);
            
            animate();
        }
        
        // Calculate direction through Earth
        function calculateThroughEarthDirection(lat1, lon1, lat2, lon2) {
            // Convert to radians
            const phi1 = lat1 * Math.PI / 180;
            const lambda1 = lon1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const lambda2 = lon2 * Math.PI / 180;
            
            // Convert to 3D Cartesian coordinates on unit sphere
            const x1 = Math.cos(phi1) * Math.cos(lambda1);
            const y1 = Math.cos(phi1) * Math.sin(lambda1);
            const z1 = Math.sin(phi1);
            
            const x2 = Math.cos(phi2) * Math.cos(lambda2);
            const y2 = Math.cos(phi2) * Math.sin(lambda2);
            const z2 = Math.sin(phi2);
            
            // Vector from user to target through Earth
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dz = z2 - z1;
            
            // Normalize
            const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            // Convert to local tangent plane (East-North-Up)
            // East vector
            const east = [-Math.sin(lambda1), Math.cos(lambda1), 0];
            // North vector  
            const north = [-Math.sin(phi1) * Math.cos(lambda1), -Math.sin(phi1) * Math.sin(lambda1), Math.cos(phi1)];
            // Up vector (pointing away from Earth center)
            const up = [Math.cos(phi1) * Math.cos(lambda1), Math.cos(phi1) * Math.sin(lambda1), Math.sin(phi1)];
            
            // Project the through-Earth vector onto local coordinates
            const localEast = dx * east[0] + dy * east[1] + dz * east[2];
            const localNorth = dx * north[0] + dy * north[1] + dz * north[2];
            const localUp = dx * up[0] + dy * up[1] + dz * up[2];
            
            // Calculate azimuth (compass bearing) and elevation
            const azimuth = Math.atan2(localEast, localNorth) * 180 / Math.PI;
            const horizontalDist = Math.sqrt(localEast * localEast + localNorth * localNorth);
            const elevation = Math.atan2(-localUp, horizontalDist) * 180 / Math.PI; // Negative because down through Earth
            
            // Straight-line distance through Earth in km
            const distance = length * 6371;
            
            return { 
                azimuth: azimuth < 0 ? azimuth + 360 : azimuth, 
                elevation: elevation,
                distance: distance 
            };
        }
        
        // Update the 3D visualization
        function updateVisualization() {
            if (!arrow || !targetIndicator || !hasLocation) return;
            
            // Check if phone is pointing up (away from Earth)
            const phoneTilt = 90 - deviceBeta; // Convert to elevation angle
            
            if (phoneTilt > 0) {
                // Pointing upward - hide arrow and show warning
                arrow.visible = false;
                document.getElementById('pointing-up').style.display = 'block';
                document.getElementById('accuracy').innerHTML = 'üìç Point down through Earth';
                document.getElementById('accuracy').style.background = 'rgba(255, 152, 0, 0.5)';
                return;
            } else {
                arrow.visible = true;
                document.getElementById('pointing-up').style.display = 'none';
            }
            
            // Calculate target direction
            const target = calculateThroughEarthDirection(userLat, userLon, targetLat, targetLon);
            
            // Update target indicator orientation
            const targetRadX = (90 + target.elevation) * Math.PI / 180;
            const targetRadY = target.azimuth * Math.PI / 180;
            targetIndicator.rotation.x = targetRadX;
            targetIndicator.rotation.y = targetRadY;
            
            // Update phone arrow based on device orientation
            // Beta: front-back tilt (0=flat, 90=vertical, -90=upside down)
            // Alpha: compass heading (0-360)
            // Gamma: left-right tilt
            
            const phoneElevation = phoneTilt; // How much pointing down (negative) or up (positive)
            const phoneAzimuth = deviceAlpha;
            
            // Convert to radians for Three.js
            const phoneRadX = (90 + phoneElevation) * Math.PI / 180;
            const phoneRadY = phoneAzimuth * Math.PI / 180;
            
            arrow.rotation.x = phoneRadX;
            arrow.rotation.y = phoneRadY;
            
            // Calculate accuracy
            let azimuthDiff = Math.abs(target.azimuth - phoneAzimuth);
            if (azimuthDiff > 180) azimuthDiff = 360 - azimuthDiff;
            
            const elevationDiff = Math.abs(target.elevation - phoneElevation);
            const totalError = Math.sqrt(azimuthDiff * azimuthDiff + elevationDiff * elevationDiff);
            const accuracy = Math.max(0, 100 - totalError);
            
            // Update arrow color based on accuracy
            const hue = accuracy / 100 * 0.33; // Red to green
            arrow.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHSL(hue, 1, 0.5);
                    child.material.emissive.setHSL(hue, 1, 0.3);
                }
            });
            
            // Update UI
            document.getElementById('distance').innerHTML = 
                `üìç ${targetName}: ${target.distance.toFixed(0)} km through Earth`;
            
            document.getElementById('accuracy').innerHTML = `Accuracy: ${accuracy.toFixed(0)}%`;
            document.getElementById('accuracy').style.background = 
                accuracy > 80 ? 'rgba(76, 175, 80, 0.5)' : 
                accuracy > 50 ? 'rgba(255, 193, 7, 0.5)' : 
                'rgba(244, 67, 54, 0.5)';
            
            // Direction hints
            let hint = '';
            if (azimuthDiff > 10) {
                const turnDir = ((target.azimuth - phoneAzimuth + 540) % 360 - 180) > 0 ? 'right ‚û°Ô∏è' : 'left ‚¨ÖÔ∏è';
                hint += `Turn ${turnDir} `;
            }
            if (elevationDiff > 10) {
                const tiltDir = target.elevation < phoneElevation ? 'down ‚¨áÔ∏è' : 'up ‚¨ÜÔ∏è';
                hint += `Tilt ${tiltDir}`;
            }
            if (accuracy > 80) {
                hint = '‚úÖ Perfect! You\'re pointing through Earth to ' + targetName + '!';
            }
            document.getElementById('direction-hint').innerHTML = hint;
            
            // Update debug info
            document.getElementById('phone-tilt').textContent = phoneElevation.toFixed(1);
            document.getElementById('compass-heading').textContent = phoneAzimuth.toFixed(0);
            document.getElementById('phone-roll').textContent = deviceGamma.toFixed(1);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate Earth for visual effect
            if (earth) {
                earth.rotation.y += 0.002;
            }
            
            // Gentle camera orbit
            const time = Date.now() * 0.0005;
            camera.position.x = Math.sin(time) * 12;
            camera.position.z = Math.cos(time) * 12;
            camera.position.y = 6 + Math.sin(time * 2) * 2;
            camera.lookAt(0, 0, 0);
            
            updateVisualization();
            renderer.render(scene, camera);
        }
        
        // Get user's GPS location
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        userLat = position.coords.latitude;
                        userLon = position.coords.longitude;
                        hasLocation = true;
                        document.getElementById('user-location').textContent = 
                            `${userLat.toFixed(4)}¬∞, ${userLon.toFixed(4)}¬∞ (GPS active)`;
                        document.getElementById('location-status').className = 'status-dot active';
                        console.log("GPS Location acquired:", userLat, userLon);
                    },
                    error => {
                        // Handle different error types
                        let errorMsg = '';
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = "Location permission denied";
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = "Location unavailable";
                                break;
                            case error.TIMEOUT:
                                errorMsg = "Location timeout";
                                break;
                            default:
                                errorMsg = "Location error";
                        }
                        
                        console.log(`${errorMsg}: ${error.message}`);
                        
                        // Fallback to Melbourne
                        userLat = -37.8136;
                        userLon = 144.9631;
                        hasLocation = true;
                        document.getElementById('user-location').innerHTML = 
                            `Melbourne (${errorMsg}) <button onclick="getUserLocation()" style="margin-left: 10px; padding: 2px 8px; background: rgba(255,255,255,0.2); border: 1px solid white; border-radius: 3px; color: white; cursor: pointer;">Retry</button>`;
                        document.getElementById('location-status').className = 'status-dot inactive';
                    },
                    { 
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            } else {
                // No geolocation available
                userLat = -37.8136;
                userLon = 144.9631;
                hasLocation = true;
                document.getElementById('user-location').textContent = 'Melbourne (GPS not supported)';
                document.getElementById('location-status').className = 'status-dot inactive';
            }
        }
        
        // Handle device orientation changes
        function handleOrientation(event) {
            if (event.alpha !== null && event.beta !== null && event.gamma !== null) {
                deviceAlpha = event.alpha; // Compass direction (0-360)
                deviceBeta = event.beta;   // Front-back tilt (-180 to 180)
                deviceGamma = event.gamma; // Left-right tilt (-90 to 90)
                hasOrientation = true;
                document.getElementById('orientation-status').className = 'status-dot active';
            }
        }
        
        // Set target country
        function setTarget(name, lat, lon) {
            targetName = name;
            targetLat = lat;
            targetLon = lon;
            
            // Update button states
            document.querySelectorAll('.country-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(name)) {
                    btn.classList.add('active');
                }
            });
        }
        
        // Request permission for iOS devices
        function requestOrientationPermission() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response == 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                    })
                    .catch(console.error);
            } else {
                // Non-iOS devices
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }
        
        // Initialize everything
        window.addEventListener('load', () => {
            initThree();
            getUserLocation();
            requestOrientationPermission();
            
            // Set default target
            setTarget('China', 35.8617, 104.1954);
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / (window.innerHeight * 0.6);
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
            });
        });
        
        // iOS permission on first tap
        document.addEventListener('click', function() {
            requestOrientationPermission();
        }, { once: true });
    </script>
</body>
</html>