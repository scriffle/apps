<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Electron Simulation with Multiple Cylinders</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #controls { margin-top: 20px; }
        #electronSlider { width: 500px; }
    </style>
</head>
<body>
    <div id="simulation"></div>
    <div id="controls">
        <label for="electronSlider">Number of Electrons: </label>
        <input type="range" id="electronSlider" min="0" max="500" value="100" step="1" style="width: 500px;">
        <span id="electronCount">100</span>
        <button id="addCylinder">Add Cylinder</button>
        <button id="deleteCylinder">Delete Selected Cylinder</button>
    </div>
    <div id="instructions">
        <p>Left-click to select a cylinder</p>
        <p>Right-click and drag to rotate the view</p>
        <p>Scroll to zoom in/out</p>
        <p>WASD keys to move selected cylinder in XY plane</p>
        <p>QE keys to rotate selected cylinder around Z-axis (blue)</p>
        <p>Shift + movement keys to move faster</p>
    </div>

    <script>
        const ELECTRON_RADIUS = 5;
        const CYLINDER_RADIUS = 50;
        const CYLINDER_HEIGHT = 400;
        const BROWNIAN_FORCE = 0.1;
        const REPULSION_FORCE = 100;
        const GRID_SIZE = 200;

        let cylinders = [];
        let electrons = [];
        let electronSlider;
        let selectedCylinder = null;
        let cameraRotX = -Math.PI/6;
        let cameraRotY = -Math.PI/4;
        let cameraZoom = -0.3;
        let nextCylinderPosition = 0;

        function setup() {
            const canvas = createCanvas(800, 600, WEBGL);
            canvas.parent('simulation');
            
            electronSlider = select('#electronSlider');
            electronSlider.input(updateElectronCount);

            select('#addCylinder').mousePressed(addCylinder);
            select('#deleteCylinder').mousePressed(deleteSelectedCylinder);

            // Create two initial cylinders
            addCylinder();
            addCylinder();

            updateElectronCount();
        }

        function draw() {
            background(220);
            
            // Set up camera
            camera(0, -200, (height/2) / tan(PI/6), 0, 0, 0, 0, 1, 0);
            
            // Apply user rotation and zoom
            rotateX(cameraRotX);
            rotateY(cameraRotY);
            scale(1 + cameraZoom);

            // Lighting
            ambientLight(100);
            pointLight(255, 255, 255, 200, -200, 200);

            // Draw world axes
            drawAxes();

            // Draw cylinders
            for (let cylinder of cylinders) {
                cylinder.draw();
            }

            // Update and draw electrons
            for (let electron of electrons) {
                electron.update();
                electron.draw();
            }

            // Display electron count
            select('#electronCount').html(electrons.length);

            // Handle cylinder movement
            if (selectedCylinder) {
                let speed = keyIsDown(SHIFT) ? 5 : 1;
                if (keyIsDown(87)) selectedCylinder.position.y += speed; // W
                if (keyIsDown(83)) selectedCylinder.position.y -= speed; // S
                if (keyIsDown(65)) selectedCylinder.position.x -= speed; // A
                if (keyIsDown(68)) selectedCylinder.position.x += speed; // D
                if (keyIsDown(81)) selectedCylinder.rotation.z -= 0.05; // Q
                if (keyIsDown(69)) selectedCylinder.rotation.z += 0.05; // E
            }
        }

        function drawAxes() {
            stroke(255, 0, 0); // X axis - Red
            line(-300, 0, 0, 300, 0, 0);
            stroke(0, 255, 0); // Y axis - Green
            line(0, -300, 0, 0, 300, 0);
            stroke(0, 0, 255); // Z axis - Blue
            line(0, 0, -300, 0, 0, 300);
            noStroke();
        }

        function mousePressed() {
            if (mouseButton === LEFT) {
                let closestCylinder = null;
                let closestDist = Infinity;
                for (let cylinder of cylinders) {
                    let d = dist(mouseX - width/2, mouseY - height/2, cylinder.position.x, -cylinder.position.y);
                    if (d < closestDist) {
                        closestDist = d;
                        closestCylinder = cylinder;
                    }
                }
                selectedCylinder = closestCylinder;
                for (let cylinder of cylinders) {
                    cylinder.selected = (cylinder === selectedCylinder);
                }
            }
        }

        function mouseDragged() {
            if (mouseButton === RIGHT) {
                cameraRotY += (mouseX - pmouseX) * 0.01;
                cameraRotX += (mouseY - pmouseY) * 0.01;
                cameraRotX = constrain(cameraRotX, -PI/2, PI/2);
            }
        }

        function mouseWheel(event) {
            cameraZoom -= event.delta * 0.001;
            cameraZoom = constrain(cameraZoom, -0.5, 1.5);
            return false;
        }

        function addCylinder() {
            const positions = [
                [-GRID_SIZE, -GRID_SIZE], [0, -GRID_SIZE], [GRID_SIZE, -GRID_SIZE],
                [-GRID_SIZE, 0], [0, 0], [GRID_SIZE, 0],
                [-GRID_SIZE, GRID_SIZE], [0, GRID_SIZE], [GRID_SIZE, GRID_SIZE]
            ];
            if (nextCylinderPosition < positions.length) {
                const [x, y] = positions[nextCylinderPosition];
                cylinders.push(new Cylinder(x, y, 0));
                nextCylinderPosition++;
            }
        }

        function deleteSelectedCylinder() {
            if (selectedCylinder && cylinders.length > 1) {
                cylinders = cylinders.filter(c => c !== selectedCylinder);
                selectedCylinder = null;
                // Redistribute electrons
                for (let electron of electrons) {
                    if (electron.cylinder === selectedCylinder) {
                        electron.cylinder = random(cylinders);
                        electron.resetPosition();
                    }
                }
            }
        }

        function updateElectronCount() {
            const targetCount = int(electronSlider.value());
            while (electrons.length < targetCount) {
                electrons.push(new Electron(random(cylinders)));
            }
            while (electrons.length > targetCount) {
                electrons.pop();
            }
        }

        class Cylinder {
            constructor(x, y, z) {
                this.position = createVector(x, y, z);
                this.rotation = createVector(0, 0, 0);
                this.selected = false;
            }

            draw() {
                push();
                translate(this.position.x, this.position.y, this.position.z);
                rotateZ(this.rotation.z);
                noStroke();
                fill(this.selected ? color(200, 255, 200) : 200);
                cylinder(CYLINDER_RADIUS, CYLINDER_HEIGHT);
                pop();
            }
        }

        class Electron {
            constructor(cylinder) {
                this.resetPosition(cylinder);
                this.velocity = createVector(0, 0, 0);
            }

            resetPosition(cylinder) {
                this.cylinder = cylinder;
                const angle = random(TWO_PI);
                const height = random(-CYLINDER_HEIGHT/2, CYLINDER_HEIGHT/2);
                this.localPosition = createVector(
                    CYLINDER_RADIUS * cos(angle),
                    height,
                    CYLINDER_RADIUS * sin(angle)
                );
            }

            update() {
                // Apply Brownian motion
                this.velocity.add(p5.Vector.random3D().mult(BROWNIAN_FORCE));

                // Apply repulsion from other electrons
                for (let other of electrons) {
                    if (other !== this) {
                        const force = p5.Vector.sub(this.getWorldPosition(), other.getWorldPosition());
                        const distSq = force.magSq();
                        if (distSq > 0 && distSq < 10000) {
                            force.setMag(REPULSION_FORCE / distSq);
                            this.velocity.add(force);
                        }
                    }
                }

                // Update position
                this.localPosition.add(this.velocity);

                // Find the outermost surface
                let outermostCylinder = this.cylinder;
                let outermostDistance = CYLINDER_RADIUS;
                const worldPos = this.getWorldPosition();

                for (let cylinder of cylinders) {
                    const cylinderLocalPos = this.getLocalPosition(cylinder, worldPos);
                    const distToCylinder = sqrt(cylinderLocalPos.x * cylinderLocalPos.x + cylinderLocalPos.z * cylinderLocalPos.z);
                    
                    if (distToCylinder < CYLINDER_RADIUS && 
                        abs(cylinderLocalPos.y) <= CYLINDER_HEIGHT / 2 &&
                        distToCylinder > outermostDistance) {
                        outermostCylinder = cylinder;
                        outermostDistance = distToCylinder;
                    }
                }

                // Move to the outermost cylinder if necessary
                if (outermostCylinder !== this.cylinder) {
                    this.cylinder = outermostCylinder;
                    this.localPosition = this.getLocalPosition(this.cylinder, worldPos);
                }

                // Constrain to cylinder surface
                const xzMag = sqrt(this.localPosition.x * this.localPosition.x + this.localPosition.z * this.localPosition.z);
                const scale = CYLINDER_RADIUS / xzMag;
                this.localPosition.x *= scale;
                this.localPosition.z *= scale;
                this.localPosition.y = constrain(this.localPosition.y, -CYLINDER_HEIGHT/2, CYLINDER_HEIGHT/2);

                // Dampen velocity
                this.velocity.mult(0.95);
            }

            getWorldPosition() {
                let worldPos = this.localPosition.copy();
                worldPos.rotate(this.cylinder.rotation.z, createVector(0, 0, 1));
                worldPos.add(this.cylinder.position);
                return worldPos;
            }

            getLocalPosition(cylinder, worldPos) {
                let localPos = p5.Vector.sub(worldPos, cylinder.position);
                localPos.rotate(-cylinder.rotation.z, createVector(0, 0, 1));
                return localPos;
            }

            draw() {
                push();
                translate(this.cylinder.position.x, this.cylinder.position.y, this.cylinder.position.z);
                rotateZ(this.cylinder.rotation.z);
                translate(this.localPosition.x, this.localPosition.y, this.localPosition.z);
                fill(0, 0, 255);
                noStroke();
                sphere(ELECTRON_RADIUS);
                pop();
            }
        }
    </script>
</body>
</html>
