<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Electron Simulation with Multiple Draggable and Resizable Bars</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 1px solid black;
    }
    #controls {
      margin-top: 20px;
      width: 500px;
    }
    label {
      font-size: 16px;
      margin-right: 10px;
    }
    input[type="number"] {
      width: 80px;
    }
    #voltageSlider {
      width: 500px;
    }
    #resetButton {
      margin-top: 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="barCanvas"></canvas>

  <div id="controls">
    <label for="voltageSlider">Voltage: </label>
    <input type="range" id="voltageSlider" min="0" max="500" value="10">
    <input type="number" id="voltageNumber" min="0" max="500" value="10">
    <span id="voltageValue"></span>
    <br><br>
    <label for="temperatureSlider">Temperature: </label>
    <input type="range" id="temperatureSlider" min="0" max="2" step="0.1" value="0.5">
    <span id="temperatureValue">0.5</span>
  </div>

  <button id="resetButton">Reset Simulation</button>

  <script>
    // Get canvas and set its size dynamically
    const canvas = document.getElementById('barCanvas');
    const ctx = canvas.getContext('2d');
    let canvasWidth = window.innerWidth * 0.8;
    let canvasHeight = 600;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Electron and bar settings
    const electronRadius = 5;
    const gradientRadius = electronRadius * 5; // Radius for gradient effect around electrons
    const minBarWidth = 50;
    const minBarHeight = 50;
    let brownianMotionIntensity = 0.5; // Initial temperature setting
    let numElectrons = 10;

    // Each bar has its own properties
    let bars = [];

    // Helper function to generate random blue shades
    function randomBlueShade() {
      const blueValue = Math.floor(150 + Math.random() * 100);
      return `rgb(0, 0, ${blueValue})`;
    }

    // Helper function to check if two bars overlap
    function doBarsOverlap(bar1, bar2) {
      return (
        bar1.startX < bar2.startX + bar2.width &&
        bar1.startX + bar1.width > bar2.startX &&
        bar1.startY < bar2.startY + bar2.height &&
        bar1.startY + bar1.height > bar2.startY
      );
    }

    // Helper function to compute the overlapping region of two bars
    function getOverlapRegion(bar1, bar2) {
      const xOverlapStart = Math.max(bar1.startX, bar2.startX);
      const xOverlapEnd = Math.min(bar1.startX + bar1.width, bar2.startX + bar2.width);
      const yOverlapStart = Math.max(bar1.startY, bar2.startY);
      const yOverlapEnd = Math.min(bar1.startY + bar1.height, bar2.startY + bar2.height);
      return {
        xStart: xOverlapStart,
        xEnd: xOverlapEnd,
        yStart: yOverlapStart,
        yEnd: yOverlapEnd,
      };
    }

    // Electron object
    class Electron {
      constructor(x, y, bar) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.color = randomBlueShade();
        this.bar = bar; // Track which bar the electron belongs to
        this.dragging = false;
      }

      draw() {
        // Draw the green gradient around the electron
        const gradient = ctx.createRadialGradient(this.x, this.y, electronRadius, this.x, this.y, gradientRadius);
        gradient.addColorStop(0, 'rgba(0, 255, 0, 0.2)');
        gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.beginPath();
        ctx.arc(this.x, this.y, gradientRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.closePath();

        // Draw the electron itself
        ctx.beginPath();
        ctx.arc(this.x, this.y, electronRadius, 0, Math.PI * 2);
        ctx.fillStyle = this.dragging ? 'red' : this.color;
        ctx.fill();
        ctx.closePath();
      }

      update(electrons) {
        if (!this.dragging) {
          // Brownian motion (random movements depending on temperature)
          this.vx += (Math.random() - 0.5) * brownianMotionIntensity;
          this.vy += (Math.random() - 0.5) * brownianMotionIntensity;

          // Repulsive forces due to other electrons (inverse square law)
          electrons.forEach(otherElectron => {
            if (otherElectron !== this) {
              const dx = this.x - otherElectron.x;
              const dy = this.y - otherElectron.y;
              let distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < electronRadius * 2) distance = electronRadius * 2; // Preventing too close contact

              const force = 100 / (distance * distance); // Repulsion intensity is constant
              this.vx += (dx / distance) * force;
              this.vy += (dy / distance) * force;
            }
          });

          // Update position and contain within overlapping bars
          this.x += this.vx;
          this.y += this.vy;
          this.containWithinBars(electrons);
        }
      }

      containWithinBars(electrons) {
        let isStuck = true; // Assume the electron is stuck until proven otherwise

        // Ensure the electron can move freely between overlapping bars
        bars.forEach(bar => {
          if (this.x > bar.startX && this.x < bar.startX + bar.width &&
              this.y > bar.startY && this.y < bar.startY + bar.height) {
            isStuck = false; // Electron is inside a bar and not stuck
          }
        });

        // Nudge electron if it's stuck in a corner
        if (isStuck) {
          this.vx += (Math.random() - 0.5) * 2;
          this.vy += (Math.random() - 0.5) * 2;
        }
      }
    }

    // Bar object to handle bar properties and electron containment
    class Bar {
      constructor(startX, startY, width, height) {
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.electrons = []; // List of electrons within the bar
        this.isDraggingBar = false;
        this.isResizing = { left: false, right: false, top: false, bottom: false };
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
      }

      // Add electrons in the Last In, First Out (LIFO) manner
      addElectrons(count) {
        for (let i = 0; i < count; i++) {
          const x = Math.random() * (this.width - 2 * electronRadius) + this.startX + electronRadius;
          const y = Math.random() * (this.height - 2 * electronRadius) + this.startY + electronRadius;
          this.electrons.push(new Electron(x, y, this));
        }
      }

      // Remove electrons in Last In, First Out (LIFO) order
      removeElectrons(count) {
        for (let i = 0; i < count; i++) {
          this.electrons.pop();
        }
      }

      draw() {
        // Find bars that overlap with this one
        let overlappingBars = bars.filter(bar => bar !== this && doBarsOverlap(this, bar));

        // Draw the metal bar with a lighter gray color
        ctx.fillStyle = '#d3d3d3';
        ctx.fillRect(this.startX, this.startY, this.width, this.height);

        // Draw borders, but remove overlapping edges
        overlappingBars.forEach(overlapBar => {
          const overlap = getOverlapRegion(this, overlapBar);

          // Right edge
          if (this.startX + this.width > overlap.xStart && this.startX + this.width < overlap.xEnd) {
            ctx.clearRect(this.startX + this.width - 10, overlap.yStart, 10, overlap.yEnd - overlap.yStart);
          } else {
            ctx.fillStyle = '#a9a9a9'; // Right border
            ctx.fillRect(this.startX + this.width - 10, this.startY, 10, this.height);
          }

          // Left edge
          if (this.startX > overlap.xStart && this.startX < overlap.xEnd) {
            ctx.clearRect(this.startX, overlap.yStart, 10, overlap.yEnd - overlap.yStart);
          } else {
            ctx.fillStyle = '#a9a9a9'; // Left border
            ctx.fillRect(this.startX, this.startY, 10, this.height);
          }

          // Top edge
          if (this.startY > overlap.yStart && this.startY < overlap.yEnd) {
            ctx.clearRect(overlap.xStart, this.startY, overlap.xEnd - overlap.xStart, 10);
          } else {
            ctx.fillStyle = '#a9a9a9'; // Top border
            ctx.fillRect(this.startX, this.startY, this.width, 10);
          }

          // Bottom edge
          if (this.startY + this.height > overlap.yStart && this.startY + this.height < overlap.yEnd) {
            ctx.clearRect(overlap.xStart, this.startY + this.height - 10, overlap.xEnd - overlap.xStart, 10);
          } else {
            ctx.fillStyle = '#a9a9a9'; // Bottom border
            ctx.fillRect(this.startX, this.startY + this.height - 10, this.width, 10);
          }
        });

        // Draw electrons inside the bar
        this.electrons.forEach(electron => electron.draw());
      }

      updateElectrons(electrons) {
        this.electrons.forEach(electron => electron.update(electrons));
      }
    }

    // Initialize six bars with random starting positions and sizes
    function initializeBars() {
      bars = [
        new Bar(50, 50, 300, 150),
        new Bar(400, 50, 300, 150),
        new Bar(200, 200, 300, 150),
        new Bar(500, 200, 300, 150),
        new Bar(100, 350, 300, 150),
        new Bar(400, 350, 300, 150)
      ];

      // Initialize electrons for each bar
      bars.forEach(bar => bar.addElectrons(numElectrons));
    }

    // Main animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw all bars and update their electrons
      let allElectrons = [];
      bars.forEach(bar => {
        bar.draw();
        allElectrons = allElectrons.concat(bar.electrons); // Collect electrons from all bars
      });

      // Update electron positions and interactions across all bars
      bars.forEach(bar => {
        bar.updateElectrons(allElectrons);
      });

      requestAnimationFrame(animate);
    }

    // Initialize and start the simulation
    initializeBars();
    animate();

    // Handle voltage slider and number input (for controlling number of electrons)
    const voltageSlider = document.getElementById('voltageSlider');
    const voltageNumber = document.getElementById('voltageNumber');
    const voltageValueDisplay = document.getElementById('voltageValue');

    function updateVoltage(newNumElectrons) {
      voltageSlider.value = newNumElectrons;
      voltageNumber.value = newNumElectrons;
      voltageValueDisplay.textContent = newNumElectrons;

      let electronDiff = newNumElectrons - numElectrons;
      if (electronDiff > 0) {
        bars.forEach(bar => {
          bar.addElectrons(electronDiff); // Add new electrons
        });
      } else if (electronDiff < 0) {
        bars.forEach(bar => {
          bar.removeElectrons(-electronDiff); // Remove electrons (LIFO)
        });
      }
      numElectrons = newNumElectrons;
    }

    voltageSlider.addEventListener('input', (e) => {
      updateVoltage(parseInt(e.target.value, 10));
    });

    voltageNumber.addEventListener('input', (e) => {
      updateVoltage(parseInt(e.target.value, 10));
    });

    // Handle temperature slider (for controlling brownian motion)
    const temperatureSlider = document.getElementById('temperatureSlider');
    const temperatureValueDisplay = document.getElementById('temperatureValue');
    temperatureSlider.addEventListener('input', (e) => {
      brownianMotionIntensity = parseFloat(e.target.value);
      temperatureValueDisplay.textContent = brownianMotionIntensity.toFixed(1);
    });

    // Reset the simulation
    const resetButton = document.getElementById('resetButton');
    resetButton.addEventListener('click', () => {
      numElectrons = 10;
      brownianMotionIntensity = 0.5;
      voltageSlider.value = 10;
      voltageNumber.value = 10;
      temperatureSlider.value = 0.5;
      voltageValueDisplay.textContent = '10';
      temperatureValueDisplay.textContent = '0.5';

      initializeBars(); // Reset bars and electrons
    });

    // Handle mouse events for dragging bars, resizing bars, and dragging electrons
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      bars.forEach(bar => {
        // Detect if resizing the bar
        if (Math.abs(mouseX - (bar.startX + bar.width)) < 10 && mouseY > bar.startY && mouseY < bar.startY + bar.height) {
          bar.isResizing.right = true;
        } else if (Math.abs(mouseX - bar.startX) < 10 && mouseY > bar.startY && mouseY < bar.startY + bar.height) {
          bar.isResizing.left = true;
        } else if (Math.abs(mouseY - bar.startY) < 10 && mouseX > bar.startX && mouseX < bar.startX + bar.width) {
          bar.isResizing.top = true;
        } else if (Math.abs(mouseY - (bar.startY + bar.height)) < 10 && mouseX > bar.startX && mouseX < bar.startX + bar.width) {
          bar.isResizing.bottom = true;
        } else if (mouseX >= bar.startX && mouseX <= bar.startX + bar.width && mouseY >= bar.startY && mouseY <= bar.startY + bar.height) {
          // Click inside the bar to drag it
          bar.isDraggingBar = true;
          bar.dragOffsetX = mouseX - bar.startX;
          bar.dragOffsetY = mouseY - bar.startY;
        }

        // Find the electron that was clicked
        bar.electrons.forEach(electron => {
          const dx = mouseX - electron.x;
          const dy = mouseY - electron.y;
          if (Math.sqrt(dx * dx + dy * dy) < electronRadius) {
            draggedElectron = electron;
            electron.dragging = true;
          }
        });
      });
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      bars.forEach(bar => {
        // Handle resizing the bar
        if (bar.isResizing.right) {
          bar.width = mouseX - bar.startX;
          if (bar.width < minBarWidth) bar.width = minBarWidth;
        } else if (bar.isResizing.left) {
          const newBarStartX = mouseX;
          const newBarWidth = bar.width + (bar.startX - newBarStartX);
          if (newBarWidth >= minBarWidth) {
            bar.startX = newBarStartX;
            bar.width = newBarWidth;
          }
        } else if (bar.isResizing.top) {
          const newBarStartY = mouseY;
          const newBarHeight = bar.height + (bar.startY - newBarStartY);
          if (newBarHeight >= minBarHeight) {
            bar.startY = newBarStartY;
            bar.height = newBarHeight;
          }
        } else if (bar.isResizing.bottom) {
          bar.height = mouseY - bar.startY;
          if (bar.height < minBarHeight) bar.height = minBarHeight;
        }

        // Handle dragging the bar
        if (bar.isDraggingBar) {
          bar.startX = mouseX - bar.dragOffsetX;
          bar.startY = mouseY - bar.dragOffsetY;
        }
      });

      // Handle dragging electrons
      if (draggedElectron) {
        draggedElectron.x = mouseX;
        draggedElectron.y = mouseY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      bars.forEach(bar => {
        bar.isResizing = { left: false, right: false, top: false, bottom: false };
        bar.isDraggingBar = false;
      });

      if (draggedElectron) {
        draggedElectron.dragging = false;
        draggedElectron = null;
      }
    });

    canvas.addEventListener('mouseleave', () => {
      bars.forEach(bar => {
        bar.isResizing = { left: false, right: false, top: false, bottom: false };
        bar.isDraggingBar = false;
      });

      if (draggedElectron) {
        draggedElectron.dragging = false;
        draggedElectron = null;
      }
    });

  </script>
</body>
</html>
