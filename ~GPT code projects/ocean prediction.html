<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OISST v2.1 — Robust fetch with mirror fallback + ocean snapping</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root{--bg:#0b1020;--ink:#e9eef9;--muted:#9fb0d0;--card:#151b31}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:16px 20px;border-bottom:1px solid #2a3354}
  h1{margin:0;font-size:18px}
  .wrap{max-width:1100px;margin:0 auto;padding:20px}
  .panel{background:var(--card);border:1px solid #2a3354;border-radius:14px;padding:16px;margin-bottom:16px}
  label{display:block;margin:6px 0 2px;color:var(--muted)}
  input,button{background:#0f1530;color:var(--ink);border:1px solid #2a3354;border-radius:10px;padding:8px 10px}
  input[type="number"]{width:120px}
  .row{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end}
  button.primary{background:linear-gradient(180deg,#3a7bfd,#2b63d1);border:0}
  canvas{background:#0b1020;border:1px solid #2a3354;border-radius:14px}
  .stats{display:grid;grid-template-columns:repeat(4,minmax(160px,1fr));gap:10px;margin-top:10px}
  .stat{background:#0f1530;border:1px solid #2a3354;border-radius:12px;padding:10px}
  .stat b{display:block;font-size:13px;color:var(--muted);margin-bottom:4px}
  .table{max-height:220px;overflow:auto;border:1px solid #2a3354;border-radius:10px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:6px 8px;border-bottom:1px solid #2a3354}
  th{position:sticky;top:0;background:#101737}
  .chip{display:inline-block;padding:4px 8px;border:1px solid #2a3354;border-radius:999px;margin-right:6px}
  a{color:#a7cbff}
  .status{padding:10px 12px;border-radius:10px;border:1px solid #2a3354;background:#0f1530;font-size:13px}
  .ok{color:#9af5b4}.warn{color:#ffd37a}.err{color:#ff9a9a}
</style>
</head>
<body>
<header>
  <h1>NOAA OISST v2.1 — Daily SST (2025+) with mirror fallback</h1>
  <div style="color:#9fb0d0;font-size:13px">If you’re opening this file directly (file://), consider running a tiny local server for fewer CORS hiccups (e.g., <code>python -m http.server</code>).</div>
</header>

<div class="wrap">
  <div class="panel">
    <div class="row">
      <div>
        <label>Latitude (°)</label>
        <input id="lat" type="number" step="0.01" value="-37.81">
      </div>
      <div>
        <label>Longitude (°)</label>
        <input id="lon" type="number" step="0.01" value="144.96">
      </div>
      <div>
        <label>Start date</label>
        <input id="start" type="date">
      </div>
      <div>
        <label>End date</label>
        <input id="end" type="date">
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="go" class="primary">Fetch OISST</button>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="download">Download CSV</button>
      </div>
    </div>
    <div id="status" class="status" style="margin-top:10px"></div>
  </div>

  <div class="panel">
    <div class="chip">Raw SST (daily)</div>
    <div class="chip">Deseasonalised (NOAA anomaly)</div>
    <label style="margin-left:8px"><input type="checkbox" id="smooth"> 30-day rolling mean</label>
    <canvas id="chart" height="120" style="margin-top:10px"></canvas>
    <div class="stats" id="stats" hidden>
      <div class="stat"><b>Grid cell</b><span id="cell"></span></div>
      <div class="stat"><b>Points</b><span id="npts"></span></div>
      <div class="stat"><b>Mean SST (°C)</b><span id="mean"></span></div>
      <div class="stat"><b>Min / Max (°C)</b><span id="minmax"></span></div>
    </div>
  </div>

  <div class="panel">
    <div class="table">
      <table id="tbl">
        <thead><tr><th>Date</th><th>SST (°C)</th><th>Anomaly (°C)</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script>
/* -------- Config: two servers + dataset IDs -------- */
const MIRRORS = [
  { // NOAA CoastWatch ERDDAP (OISST v2.1, 1981→present)
    name: "CoastWatch",
    base: "https://coastwatch.pfeg.noaa.gov/erddap/griddap",
    id:   "ncdcOisst21Agg_LonPM180",
    fill: -9.99, // missing
    lonScheme: "pm180" // but will try both pm180 & 0..360 when needed
  },
  { // NOAA NCEI ERDDAP (feature collection; 2020→present, includes anom)
    name: "NCEI",
    base: "https://www.ncei.noaa.gov/erddap/griddap",
    id:   "ncdc_oisst_v2_avhrr_by_time_zlev_lat_lon",
    fill: -999.0,
    lonScheme: "0360" // documented actual_range 0.125..359.875
  }
];

const FILL_FALLBACK = -9.99; // default if we can't detect

/* -------- helpers -------- */
function iso(d){ return d.toISOString().slice(0,10); }
function fromEpochSec(s){ return new Date(s*1000); }
function snapQuarter(x){ return Math.round(x/0.25)*0.25; }
function wrap180(lon){ let x=lon; while(x<=-180)x+=360; while(x>180)x-=360; return x; }
function to0360(lon){ lon = wrap180(lon); return lon<0 ? lon+360 : lon; }
function kmGreatCircle(lat1,lon1,lat2,lon2){
  const R=6371, toR=Math.PI/180, φ1=lat1*toR, φ2=lat2*toR, dφ=(lat2-lat1)*toR, dλ=(lon2-lon1)*toR;
  const a=Math.sin(dφ/2)**2+Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2; return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}
function withTimeout(ms, fetchPromise){
  const t = new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), ms));
  return Promise.race([fetchPromise, t]);
}

/* -------- UI -------- */
const ui = {
  lat: document.getElementById('lat'),
  lon: document.getElementById('lon'),
  start: document.getElementById('start'),
  end: document.getElementById('end'),
  go: document.getElementById('go'),
  dl: document.getElementById('download'),
  status: document.getElementById('status'),
  smooth: document.getElementById('smooth'),
  chart: document.getElementById('chart').getContext('2d'),
  stats: document.getElementById('stats'),
  cell: document.getElementById('cell'),
  npts: document.getElementById('npts'),
  mean: document.getElementById('mean'),
  minmax: document.getElementById('minmax'),
  tbody: document.querySelector('#tbl tbody')
};
let chart, SERIES=[], ACTIVE=null;

function setStatus(msg, tone="ok"){ ui.status.className="status "+(tone||""); ui.status.textContent=msg; }

/* -------- ERDDAP helpers -------- */
function lastUrl(m){ return `${m.base}/${m.id}.json?time[(last)]`; }
function seriesUrl(m, start,end, lat,lon){
  // try both lon representations per mirror
  const lonA = (m.lonScheme==="0360") ? to0360(lon) : wrap180(lon);
  const lonB = (m.lonScheme==="0360") ? wrap180(lon) : to0360(lon);
  const q = (L)=>`sst[(${start}T00:00:00Z):1:(${end}T00:00:00Z)][(0.0)][(${lat})][(${L})],`+
                 `anom[(${start}T00:00:00Z):1:(${end}T00:00:00Z)][(0.0)][(${lat})][(${L})]`;
  return [`${m.base}/${m.id}.json?${q(lonA)}`, `${m.base}/${m.id}.json?${q(lonB)}`];
}
function tileUrl(m, date, latMin,latMax, lonMin,lonMax){
  const LM = (x)=> (m.lonScheme==="0360") ? to0360(x) : wrap180(x);
  const lmin=LM(lonMin), lmax=LM(lonMax);
  return `${m.base}/${m.id}.json?sst[(${date}T00:00:00Z):1:(${date}T00:00:00Z)][(0.0)][(${latMin}):0.25:(${latMax})][(${lmin}):0.25:(${lmax})]`;
}

/* -------- parsing & transforms -------- */
function toSeries(rows, cols, fill){
  const tI=cols.indexOf("time"), sI=cols.indexOf("sst"), aI=cols.indexOf("anom");
  const out=[];
  for(const r of rows){
    const d=fromEpochSec(r[tI]); if(d.getUTCFullYear()<2025) continue;
    const s=r[sI], a=r[aI];
    out.push({ date: iso(d),
               sst: (s==null || s===fill || s===FILL_FALLBACK) ? null : +s.toFixed(3),
               anom:(a==null || a===fill || a===FILL_FALLBACK) ? null : +a.toFixed(3) });
  }
  return out;
}
function calcStats(vals){
  const v=vals.filter(x=>x!=null); if(!v.length) return {mean:null,min:null,max:null};
  const sum=v.reduce((a,b)=>a+b,0); return {mean:sum/v.length, min:Math.min(...v), max:Math.max(...v)};
}
function rollingMean(arr, win=30){
  if(!arr?.length) return [];
  const out=new Array(arr.length).fill(null); let sum=0, q=[];
  for(let i=0;i<arr.length;i++){
    const v=arr[i]; q.push(v); sum+=(v??0);
    if(q.length>win){ sum-=(q.shift()??0); }
    if(q.length===win && !q.some(x=>x==null)) out[i]=+(sum/win).toFixed(3);
  }
  return out;
}

/* -------- rendering -------- */
function render(series){
  const labels=series.map(d=>d.date);
  const sst=series.map(d=>d.sst);
  const anm=series.map(d=>d.anom);
  const sstSm=ui.smooth.checked ? rollingMean(sst,30) : null;

  const datasets=[
    {label:"SST (°C)", data: sst, borderWidth:1.8, pointRadius:0, tension:.2},
    {label:"Deseasonalised anomaly (°C)", data: anm, borderWidth:1.8, pointRadius:0, tension:.2}
  ];
  if(sstSm){ datasets.push({label:"SST 30-day mean (°C)", data: sstSm, borderWidth:2.2, borderDash:[4,3], pointRadius:0, tension:.1}); }

  if(chart) chart.destroy();
  chart=new Chart(ui.chart,{ type:'line', data:{labels,datasets},
    options:{ interaction:{mode:'nearest',intersect:false},
      scales:{x:{ticks:{maxTicksLimit:14}}, y:{title:{display:true,text:"°C"}}},
      plugins:{legend:{display:true}} } });

  const {mean,min,max}=calcStats(sst);
  ui.mean.textContent = mean==null ? "—" : mean.toFixed(3);
  ui.minmax.textContent = (min==null||max==null) ? "—" : `${min.toFixed(2)} / ${max.toFixed(2)}`;
  ui.npts.textContent = series.length.toString();

  ui.tbody.innerHTML="";
  for(const r of series.slice(0,300)){
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${r.date}</td><td>${r.sst??""}</td><td>${r.anom??""}</td>`;
    ui.tbody.appendChild(tr);
  }
  ui.stats.hidden=false;
}

/* -------- data access with mirror + lon fallback -------- */
async function probeLatest(m){
  const r = await withTimeout(12000, fetch(lastUrl(m), {cache:"no-store"}));
  if(!r.ok) throw new Error(`HTTP ${r.status} probing latest on ${m.name}`);
  const j = await r.json();
  const tI=j.table.columnNames.indexOf("time");
  const epoch=j.table.rows?.[0]?.[tI];
  if(typeof epoch!=="number") throw new Error("bad time");
  return iso(fromEpochSec(epoch));
}
async function trySeries(m, start,end, lat,lon){
  const [u1,u2]=seriesUrl(m,start,end,lat,lon);
  for(const u of [u1,u2]){
    try{
      const r=await withTimeout(20000, fetch(u, {cache:"no-store"}));
      if(!r.ok) continue;
      const j=await r.json();
      return toSeries(j.table.rows, j.table.columnNames, m.fill);
    }catch(_){ /* try the alternate */ }
  }
  throw new Error("both lon formats failed");
}
async function tryTile(m, date, latMin,latMax, lonMin,lonMax){
  const u=tileUrl(m,date,latMin,latMax,lonMin,lonMax);
  const r=await withTimeout(12000, fetch(u, {cache:"no-store"}));
  if(!r.ok) throw new Error(`tile ${r.status}`);
  return r.json();
}

/* Find nearest valid ocean cell (by fill value) at the latest date */
async function findOceanCell(m, latest, lat,lon){
  const [u1,u2]=seriesUrl(m, latest,latest, lat,lon);
  for(const u of [u1,u2]){
    try{
      const r=await withTimeout(8000, fetch(u, {cache:"no-store"})); if(!r.ok) continue;
      const j=await r.json();
      const cols=j.table.columnNames, sI=cols.indexOf("sst");
      const v=j.table.rows?.[0]?.[sI];
      if(v!=null && v!==m.fill && v!==FILL_FALLBACK) return {lat,lon,snapped:false};
    }catch(_){}
  }
  // expand search tiles
  const radii=[0.5,1,2,3];
  let best=null, bestKm=1e12;
  for(const rdeg of radii){
    const latMin=Math.max(-89.875, snapQuarter(lat - rdeg));
    const latMax=Math.min( 89.875, snapQuarter(lat + rdeg));
    const lonMin=lon - rdeg, lonMax=lon + rdeg;
    try{
      const j=await tryTile(m, latest, latMin,latMax, lonMin,lonMax);
      const c=j.table.columnNames, sI=c.indexOf("sst"), laI=c.indexOf("latitude"), loI=c.indexOf("longitude");
      for(const row of j.table.rows){
        const s=row[sI], la=row[laI], lo=row[loI];
        if(s==null || s===m.fill || s===FILL_FALLBACK) continue;
        const d=kmGreatCircle(lat,lon, la,lo);
        if(d<bestKm){ bestKm=d; best={lat:la,lon:lo}; }
      }
      if(best) break;
    }catch(_){ /* next ring */ }
  }
  return best ? {...best, snapped:true} : {lat,lon,snapped:false};
}

/* -------- main run (with mirror fallback and chunking) -------- */
async function run(){
  ui.go.disabled=true;
  const origLat=snapQuarter(parseFloat(ui.lat.value));
  const origLon=wrap180(snapQuarter(parseFloat(ui.lon.value)));
  let userStart=ui.start.value || "2025-01-01";
  let userEnd  =ui.end.value   || iso(new Date());
  setStatus("Probing mirrors for latest available day…","warn");

  let latest=null, mirror=null, errmsg=[];
  for(const m of MIRRORS){
    try{ latest=await probeLatest(m); mirror=m; break; }
    catch(e){ errmsg.push(`${m.name}: ${e.message}`); }
  }
  if(!mirror){ setStatus(`All mirrors down or blocked. ${errmsg.join(" | ")}`,"err"); ui.go.disabled=false; return; }
  ACTIVE=mirror;

  // clamp dates
  let start = userStart < "2025-01-01" ? "2025-01-01" : userStart;
  let end   = userEnd > latest ? latest : userEnd;
  if(userEnd>latest){ ui.end.value=latest; setStatus(`Using ${mirror.name}. End date clamped: ${userEnd} → ${latest}.`,"warn"); }
  else setStatus(`Using ${mirror.name}. Latest day: ${latest}. Checking ocean cell…`,"ok");
  if(start>end){
    const eD=new Date(end+"T00:00:00Z"); const back=new Date(eD.getTime()-90*864e5);
    start=iso(back); ui.start.value=start; setStatus(`Start date moved to ${start} to ensure a valid range.`,"warn");
  }

  // ocean snap
  const ocean=await findOceanCell(mirror, latest, origLat, origLon);
  const lat=ocean.lat, lon=ocean.lon;
  if(ocean.snapped) setStatus(`Snapped to ocean cell ${lat.toFixed(3)}°, ${lon.toFixed(3)}° (was ${origLat.toFixed(3)}°, ${origLon.toFixed(3)}°). Fetching…`,"ok");
  else setStatus(`Selected cell seems valid. Fetching…`,"ok");

  // full range → monthly chunks fallback
  try{
    SERIES = await trySeries(mirror, start,end, lat,lon);
  }catch(e){
    setStatus(`Full-range fetch failed (${e.message}). Retrying monthly chunks…`,"warn");
    SERIES=[];
    const sD=new Date(start+"T00:00:00Z"), eD=new Date(end+"T00:00:00Z");
    const cursor=new Date(Date.UTC(sD.getUTCFullYear(), sD.getUTCMonth(), 1));
    while(cursor<=eD){
      const chunkStart=iso(cursor);
      const next=new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth()+1, 1));
      const chunkEnd=iso(new Date(Math.min(next.getTime()-864e5, eD.getTime())));
      try{
        const part=await trySeries(mirror, chunkStart,chunkEnd, lat,lon);
        SERIES.push(...part); setStatus(`Fetched ${chunkStart} → ${chunkEnd}…`,"ok");
      }catch(e2){
        setStatus(`Skipped ${chunkStart} → ${chunkEnd} (${e2.message}).`,"warn");
      }
      cursor.setUTCMonth(cursor.getUTCMonth()+1);
    }
  }

  if(!SERIES.length){ setStatus("No data returned. Move further offshore or change dates.","err"); ui.go.disabled=false; return; }

  // render + labels
  const moved = (lat!==origLat || lon!==origLon);
  ui.cell.textContent = moved
    ? `${lat.toFixed(3)}°, ${lon.toFixed(3)}° (snapped from ${origLat.toFixed(3)}°, ${origLon.toFixed(3)}°)`
    : `${lat.toFixed(3)}°, ${lon.toFixed(3)}° (nearest 0.25°)`;

  render(SERIES);
  setStatus(`OK — ${SERIES.length} daily points from ${SERIES[0].date} → ${SERIES[SERIES.length-1].date}.`,"ok");
  ui.go.disabled=false;
}

/* ---- init & UI hooks ---- */
(function init(){
  ui.start.value="2025-01-01";
  ui.end.value=iso(new Date());
  const isFile = location.protocol==="file:";
  if(isFile) setStatus("Tip: running via a local server (http://localhost) avoids some CORS edge cases.","warn");
  else setStatus("Ready. Click “Fetch OISST”.","ok");
})();
ui.go.addEventListener('click', run);
ui.smooth.addEventListener('change', ()=>{ if(SERIES.length) render(SERIES); });
ui.dl.addEventListener('click', ()=>{
  if(!SERIES.length){ setStatus("No data to download yet.","warn"); return; }
  const header="date,sst_C,anom_C\n";
  const body=SERIES.map(r=>`${r.date},${r.sst??""},${r.anom??""}`).join("\n");
  const blob=new Blob([header+body], {type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=Object.assign(document.createElement('a'), {href:url, download:"oisst_2025_plus.csv"});
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});
</script>
</body>
</html>
