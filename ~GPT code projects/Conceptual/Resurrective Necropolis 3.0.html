<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Global Names Memorial - Speaking Every Name</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
    :root {
        --primary-bg: #1a1a1a;
        --secondary-bg: #363636;
        --glass-bg: rgba(255, 255, 255, 0.1);
        --text-primary: #ffffff;
        --text-secondary: #cccccc;
        --accent: #4a90e2;
        --sacred: #ffd700;
        --taboo: #ff6b6b;
        --transition: #9b59b6;
        --cultural: #2ecc71;
    }

    * {
        box-sizing: border-box;
    }

    html {
        background: var(--primary-bg);
        min-height: 100%;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "Noto Sans Arabic", "Noto Sans Hebrew", "Noto Sans Ethiopic", "Noto Sans Tifinagh", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
        background-attachment: fixed;
        color: var(--text-primary);
        padding: 1rem;
        position: relative;
        overflow-x: hidden;
    }

    .container {
        background: var(--glass-bg);
        padding: 2rem;
        border-radius: 1.5rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        text-align: center;
        width: min(95vw, 800px);
        max-width: 800px;
        margin: auto;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
        margin: 0 0 0.5rem 0;
        font-size: clamp(1.8rem, 6vw, 2.5rem);
        text-transform: uppercase;
        letter-spacing: 3px;
        color: var(--text-primary);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .subtitle {
        font-size: clamp(0.9rem, 3vw, 1.1rem);
        color: var(--text-secondary);
        margin-bottom: 2rem;
        font-style: italic;
    }

    /* Name Display Section */
    .name-display-section {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 1rem;
        padding: 2rem;
        margin-bottom: 1.5rem;
        min-height: 200px;
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .name-main {
        font-size: clamp(1.8rem, 7vw, 2.5rem);
        margin: 0.5rem 0;
        line-height: 1.4;
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.3s ease;
        word-wrap: break-word;
        padding: 0.5rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "Noto Sans Arabic", "Noto Sans Hebrew", "Noto Sans Ethiopic", "Noto Sans Tifinagh", "Arial Unicode MS", sans-serif;
    }

    .name-main:hover {
        transform: scale(1.02);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .name-components {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        justify-content: center;
        margin: 1rem 0;
    }

    .component {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.3rem 0.8rem;
        border-radius: 0.5rem;
        font-size: 0.9rem;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .component-label {
        color: var(--text-secondary);
        font-size: 0.8rem;
        margin-right: 0.3rem;
    }

    /* Meanings Section */
    .meanings-section {
        background: rgba(74, 144, 226, 0.15);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(74, 144, 226, 0.3);
        text-align: left;
    }

    .meanings-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 0.5rem;
        font-size: 1rem;
    }

    .meaning-item {
        font-size: 0.85rem;
        margin: 0.3rem 0;
        padding-left: 1rem;
    }

    .meaning-label {
        color: var(--text-secondary);
        font-style: italic;
    }

    /* Old Names Section */
    .old-names-section {
        background: rgba(255, 215, 0, 0.1);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(255, 215, 0, 0.3);
        text-align: left;
    }

    .old-names-title {
        font-weight: bold;
        color: var(--sacred);
        margin-bottom: 0.5rem;
        font-size: 1rem;
    }

    /* Cultural Context */
    .cultural-context {
        background: rgba(74, 144, 226, 0.1);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(74, 144, 226, 0.3);
    }

    .culture-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 0.8rem;
        text-align: left;
    }

    .info-item {
        font-size: 0.9rem;
    }

    .info-label {
        color: var(--accent);
        font-weight: bold;
    }

    /* Special Indicators */
    .special-indicators {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        margin: 1rem 0;
        flex-wrap: wrap;
    }

    .indicator {
        padding: 0.3rem 0.8rem;
        border-radius: 2rem;
        font-size: 0.85rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 0.3rem;
    }

    .indicator-sacred {
        background: var(--sacred);
        color: var(--primary-bg);
    }

    .indicator-taboo {
        background: var(--taboo);
        color: white;
    }

    .indicator-transition {
        background: var(--transition);
        color: white;
    }

    .indicator-cultural {
        background: var(--cultural);
        color: white;
    }

    .indicator-mononym {
        background: #3498db;
        color: white;
    }

    .indicator-old-name {
        background: #8b4513;
        color: white;
    }

    /* Voice Status */
    .voice-status {
        color: var(--text-secondary);
        margin: 1rem 0;
        font-size: 0.9rem;
        font-style: italic;
        min-height: 1.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .sign-language-note {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }

    /* Controls */
    .controls {
        display: grid;
        gap: 1rem;
        margin-top: 2rem;
    }

    .control-row {
        display: flex;
        gap: 0.8rem;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        padding: 0.6rem 1rem;
        border-radius: 1rem;
        min-width: 160px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    button {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 0.5rem;
        cursor: pointer;
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
        transition: all 0.3s ease;
        min-width: 100px;
    }

    button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:active:not(:disabled) {
        transform: translateY(0);
    }

    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    button.primary {
        background: var(--accent);
        border-color: var(--accent);
    }

    button.primary:hover:not(:disabled) {
        background: #5ba0f2;
    }

    /* Toggle Switches */
    .switch {
        position: relative;
        display: inline-block;
        width: 52px;
        height: 26px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.2);
        transition: .4s;
        border-radius: 26px;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .slider {
        background-color: var(--accent);
    }

    input:checked + .slider:before {
        transform: translateX(26px);
    }

    /* Stats Display */
    .stats {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-top: 1.5rem;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 0.5rem;
    }

    /* Loading Status */
    .loading-status {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 0.8rem;
        padding: 1rem;
        margin: 1rem 0;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-secondary);
        font-size: 0.9rem;
    }

    .error-message {
        background: rgba(255, 107, 107, 0.2);
        border: 1px solid rgba(255, 107, 107, 0.5);
        color: #ff6b6b;
    }

    /* Modal for Information */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
    }

    .modal-content {
        background: var(--secondary-bg);
        margin: 5% auto;
        padding: 2rem;
        border-radius: 1rem;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: var(--text-primary);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .close {
        color: var(--text-secondary);
        float: right;
        font-size: 2rem;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
    }

    .close:hover {
        color: var(--text-primary);
    }

    /* Info Button */
    #infoButton {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        width: 40px;
        height: 40px;
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: rgba(255, 255, 255, 0.7);
        z-index: 100;
        padding: 0;
    }

    #infoButton:hover {
        color: var(--text-primary);
        transform: scale(1.1);
    }

    /* Acknowledgment Style */
    .acknowledgment {
        font-size: 1.1rem;
        line-height: 1.8;
        color: var(--text-primary);
        padding: 2rem;
        text-align: center;
        font-style: italic;
        background: rgba(255, 215, 0, 0.1);
        border-radius: 1rem;
        border: 1px solid rgba(255, 215, 0, 0.3);
    }

    /* Responsive Design */
    @media (max-width: 600px) {
        .container {
            padding: 1.5rem;
        }
        
        .name-display-section {
            padding: 1.5rem;
        }
        
        .control-group {
            min-width: 140px;
        }
        
        .culture-info {
            grid-template-columns: 1fr;
        }
    }

    /* Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .fade-in {
        animation: fadeIn 0.5s ease-out;
    }

    /* Special script displays */
    .script-display {
        font-size: 1.2rem;
        margin: 0.5rem 0;
        opacity: 0.8;
    }

    .rtl {
        direction: rtl;
    }

    .click-notation {
        font-family: "Noto Sans", "DejaVu Sans", sans-serif;
        font-size: 1.3rem;
    }

    /* Loading indicator */
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--accent);
        animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>

</head>
<body>
    <button id="infoButton" title="About this work">?</button>
    
    <div class="container">
        <h1>Resurrective Necropolis</h1>
        
        <div id="loadingStatus" class="loading-status">
            <span class="loading"></span> Loading language data...
        </div>
        
        <div class="name-display-section">
            <div id="nameDisplay" class="name-main fade-in"></div>
            <div id="scriptDisplay" class="script-display"></div>
            <div id="nameComponents" class="name-components"></div>
            <div id="specialIndicators" class="special-indicators"></div>
            <div id="culturalContext" class="cultural-context"></div>
            <div id="meaningsSection" class="meanings-section" style="display: none;"></div>
            <div id="oldNamesSection" class="old-names-section" style="display: none;"></div>
            <div id="voiceStatus" class="voice-status"></div>
            <div id="signLanguageNote" class="sign-language-note" style="display: none;"></div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <button id="initVoiceButton" class="primary">Initialize Voice System</button>
                <button id="toggleButton">Pause</button>
                <button id="speakButton">Speak Name</button>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <span>Slow</span>
                    <label class="switch">
                        <input type="checkbox" id="speedToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Fast</span>
                </div>
                
                <div class="control-group">
                    <span>Random</span>
                    <label class="switch">
                        <input type="checkbox" id="weightedToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Weighted</span>
                </div>
                
                <div class="control-group">
                    <span>Basic</span>
                    <label class="switch">
                        <input type="checkbox" id="detailToggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span>Detailed</span>
                </div>
                
                <div class="control-group">
                    <span>Current</span>
                    <label class="switch">
                        <input type="checkbox" id="oldNamesToggle">
                        <span class="slider"></span>
                    </label>
                    <span>Historical</span>
                </div>
            </div>
        </div>
        
        <div id="statsDisplay" class="stats"></div>
    </div>
    
    <!-- Information Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>About This Memorial</h2>
            <div class="acknowledgment">
                This work recognizes the profound diversity of human naming across all cultures. 
                It acknowledges that names carry deep meaning‚Äîthey can be sacred, earned through 
                life experiences, changed to reflect identity, or held in silence to honor the dead. 
                Some names are visual, some are whistled, some contain sounds unique to specific 
                languages. Every name represents a life, a story, a connection to family and culture.
                <br><br>
                By speaking these names‚Äîor respectfully acknowledging when they cannot be spoken‚Äîwe 
                honor the universal human practice of remembering through naming.
            </div>
        </div>
    </div>

    <script>
// Language Data Loader
class LanguageDataLoader {
    constructor() {
        this.cache = new Map();
        this.loadingPromises = new Map();
        this.metadata = null;
        this.config = null;
    }

    async loadMetadata() {
        try {
            console.log('Loading metadata from:', './languages/metadata.json');
            const response = await fetch('./languages/metadata.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log('Metadata loaded successfully:', data);
            this.metadata = data;
            this.config = data.config;
            return data;
        } catch (error) {
            console.error('Failed to load metadata:', error);
            throw error;
        }
    }

    async loadLanguageFamily(familyId) {
        // Check cache first
        if (this.cache.has(familyId)) {
            return this.cache.get(familyId);
        }

        // Check if already loading
        if (this.loadingPromises.has(familyId)) {
            return this.loadingPromises.get(familyId);
        }

        // Find family info
        const familyInfo = this.metadata.languageFamilies.find(f => f.id === familyId);
        if (!familyInfo) {
            throw new Error(`Unknown language family: ${familyId}`);
        }

        // Create loading promise
        const loadPromise = this._loadFamilyData(familyInfo);
        this.loadingPromises.set(familyId, loadPromise);

        try {
            const data = await loadPromise;
            this.cache.set(familyId, data);
            this.loadingPromises.delete(familyId);
            
            // Mark as loaded in metadata
            familyInfo.loaded = true;
            
            return data;
        } catch (error) {
            this.loadingPromises.delete(familyId);
            throw error;
        }
    }

    async _loadFamilyData(familyInfo) {
        const url = `${this.config.dataPath}${familyInfo.fileName}`;
        let lastError;
        
        for (let attempt = 0; attempt < this.config.maxRetries; attempt++) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                lastError = error;
                if (attempt < this.config.maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, this.config.retryDelay));
                }
            }
        }
        
        throw lastError;
    }

    async preloadCommon() {
        if (!this.config.preloadCommon) return;
        
        const promises = this.config.preloadCommon.map(familyId => 
            this.loadLanguageFamily(familyId).catch(err => 
                console.warn(`Failed to preload ${familyId}:`, err)
            )
        );
        
        await Promise.allSettled(promises);
    }

    getLoadedFamilies() {
        return Array.from(this.cache.keys());
    }

    getAllFamilyIds() {
        return this.metadata.languageFamilies.map(f => f.id);
    }

    getFamilyInfo(familyId) {
        return this.metadata.languageFamilies.find(f => f.id === familyId);
    }
}

// Global data loader instance
const dataLoader = new LanguageDataLoader();

// Application state
let appState = {
    isRunning: true,
    isFast: false,
    isWeighted: false,
    showDetails: true,
    showOldNames: false,
    isVoiceInitialized: false,
    currentName: null,
    synth: window.speechSynthesis,
    voices: [],
    intervalId: null,
    SLOW_SPEED: 10000,
    FAST_SPEED: 5000,
    metadata: null,
    isInitialized: false
};

// Initialize the application
async function initializeApp() {
    const loadingStatus = document.getElementById('loadingStatus');
    
    try {
        // Load metadata
        loadingStatus.innerHTML = '<span class="loading"></span> Loading system metadata...';
        appState.metadata = await dataLoader.loadMetadata();
        
        // Preload common languages
        loadingStatus.innerHTML = '<span class="loading"></span> Loading common language families...';
        await dataLoader.preloadCommon();
        
        // Mark as initialized
        appState.isInitialized = true;
        
        // Hide loading status
        loadingStatus.style.display = 'none';
        
        // Update stats
        updateStats();
        
        // Update voice status
        updateVoiceStatus('Click "Initialize Voice System" to enable speech');
        
        // Start the app
        startApp();
        
    } catch (error) {
        console.error('Failed to initialize app:', error);
        loadingStatus.className = 'loading-status error-message';
        loadingStatus.innerHTML = `
            ‚ö†Ô∏è Failed to load language data. 
            Please ensure the JSON files are in the ./languages/ directory.
            <br>Error: ${error.message}
        `;
    }
}

// Start the interval once app is initialized
async function startApp() {
    if (appState.isInitialized) {
        startInterval();
    }
}

// Voice system initialization
async function initializeVoiceSystem() {
    const status = document.getElementById('voiceStatus');
    status.innerHTML = '<span class="loading"></span> Initializing voice system...';
    
    try {
        // Check browser support
        if (!('speechSynthesis' in window)) {
            throw new Error('Speech synthesis not supported in this browser');
        }
        
        // Load voices
        appState.voices = await loadVoices();
        
        if (appState.voices.length === 0) {
            throw new Error('No voices available');
        }
        
        // Test voice
        await testVoice();
        
        appState.isVoiceInitialized = true;
        status.innerHTML = '‚úì Voice system ready';
        document.getElementById('initVoiceButton').style.display = 'none';
        
        // Start the memorial if not already running
        if (!appState.intervalId) {
            startInterval();
        }
        
    } catch (error) {
        console.error('Voice initialization failed:', error);
        status.innerHTML = `‚ö†Ô∏è ${error.message}. Names will display without audio.`;
        document.getElementById('initVoiceButton').textContent = 'Retry Voice';
        
        // Start without voice if not already running
        if (!appState.intervalId) {
            startInterval();
        }
    }
}

function loadVoices() {
    return new Promise((resolve) => {
        const loadVoiceList = () => {
            const voices = appState.synth.getVoices();
            if (voices.length > 0) {
                // List of novelty voices to exclude
                const EXCLUDED_VOICES = [
                    'trinoids', 'zarvox', 'albert', 'whisper', 'bahh', 'boing', 
                    'bubbles', 'deranged', 'hysterical', 'cellos', 'pipe organ', 
                    'organ', 'good news', 'bad news', 'bells', 'jester', 'princess', 
                    'superstar', 'junior', 'wobble'
                ];
                
                // Log excluded voices for debugging
                const excludedVoicesList = voices.filter(voice => {
                    const voiceNameLower = voice.name.toLowerCase();
                    return EXCLUDED_VOICES.some(excluded => voiceNameLower.includes(excluded));
                });
                
                if (excludedVoicesList.length > 0) {
                    console.log('Excluding novelty voices:', excludedVoicesList.map(v => v.name));
                }
                
                resolve(voices);
            }
        };
        
        loadVoiceList();
        if (appState.synth.onvoiceschanged !== undefined) {
            appState.synth.onvoiceschanged = loadVoiceList;
        }
        
        // Timeout fallback
        setTimeout(() => resolve(appState.synth.getVoices()), 1000);
    });
}

function testVoice() {
    return new Promise((resolve) => {
        const utterance = new SpeechSynthesisUtterance('Voice initialized');
        utterance.volume = 0.1;
        utterance.onend = () => resolve();
        utterance.onerror = () => resolve();
        appState.synth.speak(utterance);
        
        // Timeout fallback
        setTimeout(resolve, 2000);
    });
}

// Name generation
async function generateName() {
    if (!appState.isInitialized) {
        return null;
    }
    
    try {
        const familyId = await selectFamily();
        const familyData = await dataLoader.loadLanguageFamily(familyId);
        const gender = selectGender(familyData, familyId);
        const components = buildNameComponents(familyData, gender, familyId);
        
        return {
            familyId: familyId,
            familyData: familyData,
            gender: gender,
            components: components,
            display: formatNameForDisplay(components, familyData, familyId),
            spoken: formatNameForSpeech(components, familyData, familyId),
            metadata: gatherMetadata(components, familyData, gender, familyId)
        };
    } catch (error) {
        console.error('Error generating name:', error);
        return null;
    }
}

async function selectFamily() {
    const families = dataLoader.getAllFamilyIds();
    console.log('Available families:', families);
    
    if (!families || families.length === 0) {
        throw new Error('No language families available');
    }
    
    if (!appState.isWeighted) {
        const selected = families[Math.floor(Math.random() * families.length)];
        console.log('Selected family:', selected);
        return selected;
    }
    
    // Weighted selection
    const weights = families.map(id => {
        const info = dataLoader.getFamilyInfo(id);
        return info.populationPercentage || 1;
    });
    const total = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * total;
    
    for (let i = 0; i < families.length; i++) {
        random -= weights[i];
        if (random <= 0) {
            console.log('Selected family (weighted):', families[i]);
            return families[i];
        }
    }
    
    return families[0];
}

function selectGender(familyData, familyId) {
    const genderSystem = appState.metadata.genderSystem;
    
    // Check for cultural specific genders
    const culturalGenders = Object.entries(genderSystem.culturalSpecific)
        .filter(([_, info]) => info.cultures.some(c => 
            familyData.metadata.family.includes(c) ||
            familyId.toLowerCase().includes(c.toLowerCase())
        ))
        .map(([gender, _]) => gender);
    
    const allGenders = [
        ...genderSystem.binary,
        ...genderSystem.nonBinary,
        ...culturalGenders
    ];
    
    return allGenders[Math.floor(Math.random() * allGenders.length)];
}

function buildNameComponents(familyData, gender, familyId) {
    const components = {};
    
    // Handle old names if enabled
    if (appState.showOldNames && familyData.nameComponents.oldNames) {
        return buildOldNameComponents(familyData, gender);
    }
    
    // Handle special cases (same as before)
    if (familyData.specialFeatures?.deathTaboo?.active && Math.random() < 0.1) {
        return {
            isTaboo: true,
            substitute: familyData.specialFeatures.deathTaboo.substitute,
            originalType: 'ancestral'
        };
    }
    
    if (familyData.specialFeatures?.sacredNames && Math.random() < 0.05) {
        return {
            isSacred: true,
            display: familyData.nameComponents.traditional?.display || '[ceremonial name]'
        };
    }
    
    // Continue with regular name building...
    // (This is the same logic as in the original, but using familyData instead of looking it up)
    
    // Standard structure handling
    let givenNames = [];
    
    if (familyData.nameComponents.given) {
        const genderMap = {
            'male': 'male',
            'female': 'female',
            'neutral': 'neutral',
            'fluid': 'neutral',
            'agender': 'neutral',
            'hijra': 'neutral',
            'twoSpirit': 'neutral',
            'faAfafine': 'female',
            'mahu': 'neutral',
            'sistergirl': 'female',
            'xGender': 'neutral'
        };
        
        const genderKey = genderMap[gender] || 'neutral';
        givenNames = familyData.nameComponents.given[genderKey] || 
                    familyData.nameComponents.given.neutral ||
                    [...(familyData.nameComponents.given.male || []), 
                     ...(familyData.nameComponents.given.female || [])];
    }
    
    // Handle mononyms
    if (familyData.nameComponents.mononyms && Math.random() < 0.3) {
        components.mononym = randomChoice(familyData.nameComponents.mononyms);
        components.isMononym = true;
        return components;
    }
    
    // Regular names
    if (givenNames && givenNames.length > 0) {
        components.given = randomChoice(givenNames);
    }
    
    // Family names
    if (familyData.nameComponents.family) {
        if (typeof familyData.nameComponents.family === 'object' && !Array.isArray(familyData.nameComponents.family)) {
            // Handle structured family names
            const allFamilyNames = [
                ...(familyData.nameComponents.family.common || []),
                ...(familyData.nameComponents.family.compound || []),
                ...(familyData.nameComponents.family.noble || []),
                ...(familyData.nameComponents.family.single || []),
                ...(familyData.nameComponents.family.romanized || [])
            ];
            if (allFamilyNames.length > 0) {
                components.family = randomChoice(allFamilyNames);
            }
        } else if (Array.isArray(familyData.nameComponents.family)) {
            components.family = randomChoice(familyData.nameComponents.family);
        }
    }
    
    // Add patronymics for Indo-European if applicable
    if (familyId === 'indoEuropean' && familyData.metadata.hasPatronymics && Math.random() < 0.5) {
        const patronymics = familyData.nameComponents.patronymic;
        if (patronymics?.russian) {
            components.patronymic = randomChoice(
                gender === 'female' ? patronymics.russian.female : patronymics.russian.male
            );
        }
    }
    
    return components;
}

function buildOldNameComponents(familyData, gender) {
    const oldNames = familyData.nameComponents.oldNames;
    if (!oldNames) return { noOldNames: true };
    
    const genderKey = gender === 'female' ? 'female' : 'male';
    const genderOldNames = oldNames[genderKey];
    if (!genderOldNames) return { noOldNames: true };
    
    // Get all categories of old names
    const categories = Object.keys(genderOldNames);
    if (categories.length === 0) return { noOldNames: true };
    
    // Select a category
    const category = randomChoice(categories);
    const categoryNames = genderOldNames[category];
    
    // Get name and meaning
    const nameEntries = Object.entries(categoryNames);
    if (nameEntries.length === 0) return { noOldNames: true };
    
    const [name, meaning] = randomChoice(nameEntries);
    
    return {
        given: name,
        meaning: meaning,
        isOldName: true,
        category: category,
        gender: gender
    };
}

function formatNameForDisplay(components, familyData, familyId) {
    // Handle special display cases
    if (components.noOldNames) {
        return '[No historical names available]';
    }
    
    if (components.isTaboo) {
        return components.substitute || 'Kuminjay';
    }
    
    if (components.isSacred) {
        return components.display;
    }
    
    if (components.isMononym) {
        return components.mononym;
    }
    
    if (components.isOldName) {
        return components.given;
    }
    
    // Standard format based on name order
    const parts = [];
    const order = familyData.metadata.nameOrder;
    
    if (order === 'family_first') {
        if (components.family) parts.push(components.family);
        if (components.given) parts.push(components.given);
    } else {
        if (components.given) parts.push(components.given);
        if (components.patronymic) parts.push(components.patronymic);
        if (components.family) parts.push(components.family);
    }
    
    return parts.join(' ') || '[Name cannot be displayed]';
}

function formatNameForSpeech(components, familyData, familyId) {
    if (components.isTaboo) {
        return "Name cannot be spoken due to cultural taboo";
    }
    
    if (components.isSacred) {
        return "Sacred name - spoken only in ceremony";
    }
    
    // Default to display format
    return formatNameForDisplay(components, familyData, familyId);
}

function gatherMetadata(components, familyData, gender, familyId) {
    const metadata = {
        languageFamily: familyData.metadata.family,
        writingSystems: familyData.metadata.writingSystems,
        gender: gender,
        culturalNotes: []
    };
    
    // Add relevant cultural notes
    if (components.isMononym) {
        metadata.culturalNotes.push("Mononym (single name)");
    }
    
    if (components.patronymic) {
        metadata.culturalNotes.push("Includes patronymic");
    }
    
    if (components.isOldName) {
        metadata.culturalNotes.push(`Historical name (${components.category})`);
    }
    
    if (familyData.metadata.hasClickConsonants) {
        metadata.culturalNotes.push("Contains click consonants");
    }
    
    if (familyData.metadata.tonal) {
        metadata.culturalNotes.push("Tonal language");
    }
    
    if (familyData.metadata.rtl?.length > 0) {
        metadata.culturalNotes.push("Written right-to-left");
    }
    
    // Gender-specific notes
    const genderInfo = appState.metadata.genderSystem.culturalSpecific[gender];
    if (genderInfo) {
        metadata.culturalNotes.push(`${gender}: ${genderInfo.cultures.join(', ')} cultural identity`);
    }
    
    return metadata;
}

// Display functions
function displayName(nameData) {
    if (!nameData) return;
    
    const nameDisplay = document.getElementById('nameDisplay');
    const scriptDisplay = document.getElementById('scriptDisplay');
    const componentsDisplay = document.getElementById('nameComponents');
    const indicatorsDisplay = document.getElementById('specialIndicators');
    const contextDisplay = document.getElementById('culturalContext');
    const meaningsSection = document.getElementById('meaningsSection');
    const oldNamesSection = document.getElementById('oldNamesSection');
    const voiceStatus = document.getElementById('voiceStatus');
    const signNote = document.getElementById('signLanguageNote');
    
    // Reset displays
    nameDisplay.className = 'name-main fade-in';
    scriptDisplay.textContent = '';
    componentsDisplay.innerHTML = '';
    indicatorsDisplay.innerHTML = '';
    contextDisplay.innerHTML = '';
    meaningsSection.style.display = 'none';
    oldNamesSection.style.display = 'none';
    signNote.style.display = 'none';
    
    // Main name display
    nameDisplay.textContent = nameData.display;
    
    // Handle special scripts
    if (nameData.metadata.writingSystems.includes('Arabic') || 
        nameData.metadata.writingSystems.includes('Hebrew')) {
        nameDisplay.classList.add('rtl');
    }
    
    // Show components if detailed view
    if (appState.showDetails && !nameData.components.isTaboo && !nameData.components.isSacred) {
        displayComponents(nameData.components, componentsDisplay);
        
        // Show meanings if available
        if (nameData.familyData.nameComponents.meanings && !nameData.components.isOldName) {
            displayMeanings(nameData, meaningsSection);
        }
        
        // Show old name details if it's an old name
        if (nameData.components.isOldName) {
            displayOldNameDetails(nameData, oldNamesSection);
        }
    }
    
    // Special indicators
    displayIndicators(nameData, indicatorsDisplay);
    
    // Cultural context
    if (appState.showDetails) {
        displayCulturalContext(nameData, contextDisplay);
    }
    
    // Store current name
    appState.currentName = nameData;
}

function displayComponents(components, container) {
    Object.entries(components).forEach(([key, value]) => {
        if (key === 'isMononym' || key === 'isTaboo' || key === 'isSacred' || 
            key === 'isOldName' || key === 'category' || key === 'meaning' ||
            key === 'noOldNames') {
            return;
        }
        
        const div = document.createElement('div');
        div.className = 'component';
        
        const label = document.createElement('span');
        label.className = 'component-label';
        label.textContent = formatComponentLabel(key) + ':';
        
        const text = document.createElement('span');
        text.textContent = value;
        
        div.appendChild(label);
        div.appendChild(text);
        container.appendChild(div);
    });
}

function displayMeanings(nameData, container) {
    const meanings = nameData.familyData.nameComponents.meanings;
    if (!meanings) return;
    
    const relevantMeanings = [];
    
    // Check given name meaning
    if (nameData.components.given && meanings.given && meanings.given[nameData.components.given]) {
        relevantMeanings.push({
            name: nameData.components.given,
            meaning: meanings.given[nameData.components.given],
            type: 'Given name'
        });
    }
    
    // Check family name meaning
    if (nameData.components.family && meanings.family && meanings.family[nameData.components.family]) {
        relevantMeanings.push({
            name: nameData.components.family,
            meaning: meanings.family[nameData.components.family],
            type: 'Family name'
        });
    }
    
    // Check patronymic meaning
    if (nameData.components.patronymic && meanings.patronymic) {
        const suffix = nameData.components.patronymic.match(/(ovich|ovna|evich|evna)$/);
        if (suffix) {
            relevantMeanings.push({
                name: suffix[0],
                meaning: nameData.gender === 'female' ? 'daughter of' : 'son of',
                type: 'Patronymic'
            });
        }
    }
    
    if (relevantMeanings.length > 0) {
        container.style.display = 'block';
        container.innerHTML = '<div class="meanings-title">Name Meanings:</div>';
        
        relevantMeanings.forEach(item => {
            const div = document.createElement('div');
            div.className = 'meaning-item';
            div.innerHTML = `<span class="meaning-label">${item.type}:</span> ${item.name} = "${item.meaning}"`;
            container.appendChild(div);
        });
    }
}

function displayOldNameDetails(nameData, container) {
    if (!nameData.components.isOldName) return;
    
    container.style.display = 'block';
    container.innerHTML = `
        <div class="old-names-title">Historical Name:</div>
        <div class="meaning-item">
            <span class="meaning-label">Period:</span> ${formatCategory(nameData.components.category)}
        </div>
        <div class="meaning-item">
            <span class="meaning-label">Name:</span> ${nameData.components.given}
        </div>
        <div class="meaning-item">
            <span class="meaning-label">Meaning:</span> "${nameData.components.meaning}"
        </div>
    `;
}

function displayIndicators(nameData, container) {
    const indicators = [];
    
    if (nameData.components.isTaboo) {
        indicators.push({ class: 'indicator-taboo', text: '‚ö†Ô∏è Death Taboo Active' });
    }
    
    if (nameData.components.isSacred) {
        indicators.push({ class: 'indicator-sacred', text: 'üôè Sacred Name' });
    }
    
    if (nameData.components.isMononym) {
        indicators.push({ class: 'indicator-mononym', text: '‚óâ Mononym' });
    }
    
    if (nameData.components.isOldName) {
        indicators.push({ class: 'indicator-old-name', text: 'üìú Historical Name' });
    }
    
    if (nameData.gender !== 'male' && nameData.gender !== 'female') {
        const genderInfo = appState.metadata.genderSystem.culturalSpecific[nameData.gender];
        const symbol = genderInfo?.symbol || '‚öß';
        indicators.push({ 
            class: 'indicator-cultural', 
            text: `${symbol} ${formatGender(nameData.gender)}` 
        });
    }
    
    indicators.forEach(indicator => {
        const span = document.createElement('span');
        span.className = `indicator ${indicator.class}`;
        span.textContent = indicator.text;
        container.appendChild(span);
    });
}

function displayCulturalContext(nameData, container) {
    const info = document.createElement('div');
    info.className = 'culture-info';
    
    // Language family
    addInfoItem(info, 'Language Family', nameData.metadata.languageFamily);
    
    // Writing systems
    addInfoItem(info, 'Writing System', nameData.metadata.writingSystems.join(', '));
    
    // Gender
    addInfoItem(info, 'Gender', formatGender(nameData.gender));
    
    // Cultural notes
    if (nameData.metadata.culturalNotes.length > 0) {
        addInfoItem(info, 'Cultural Notes', nameData.metadata.culturalNotes.join('; '));
    }
    
    container.appendChild(info);
}

function addInfoItem(container, label, value) {
    const div = document.createElement('div');
    div.className = 'info-item';
    div.innerHTML = `<span class="info-label">${label}:</span> ${value}`;
    container.appendChild(div);
}

// Speech functions
function speakName(nameData) {
    if (!appState.isVoiceInitialized || !nameData) {
        return;
    }
    
    if (nameData.components.isTaboo) {
        updateVoiceStatus('Observing speech taboo');
        return;
    }
    
    if (nameData.components.isSacred) {
        updateVoiceStatus('Sacred name - spoken privately only');
        return;
    }
    
    try {
        appState.synth.cancel();
        
        const utterance = new SpeechSynthesisUtterance(nameData.spoken);
        const voice = selectVoice(nameData);
        
        if (voice) {
            utterance.voice = voice;
            updateVoiceStatus(`Speaking with ${voice.name}`);
        }
        
        // Adjust speech parameters based on gender
        utterance.rate = 0.9;
        utterance.pitch = getPitchForGender(nameData.gender);
        utterance.volume = 1.0;
        
        appState.synth.speak(utterance);
        
    } catch (error) {
        console.error('Speech error:', error);
        updateVoiceStatus('Speech error occurred');
    }
}

function selectVoice(nameData) {
    const preferredVoices = nameData.familyData.metadata.voicePreferences || [];
    
    if (!appState.voices || appState.voices.length === 0) {
        return null;
    }
    
    // List of novelty voices to exclude
    const EXCLUDED_VOICES = [
        'trinoids', 'zarvox', 'albert', 'whisper', 'bahh', 'boing', 
        'bubbles', 'deranged', 'hysterical', 'cellos', 'pipe organ', 
        'organ', 'good news', 'bad news', 'bells', 'jester', 'princess', 
        'superstar', 'junior', 'wobble'
    ];
    
    // Filter out excluded voices
    const availableVoices = appState.voices.filter(voice => {
        const voiceNameLower = voice.name.toLowerCase();
        return !EXCLUDED_VOICES.some(excluded => voiceNameLower.includes(excluded));
    });
    
    if (availableVoices.length === 0) {
        return null;
    }
    
    // Try to match preferred language/locale
    for (const pref of preferredVoices) {
        const voice = availableVoices.find(v => v.lang === pref || v.lang.startsWith(pref));
        if (voice) return voice;
    }
    
    // Fallback to any non-excluded voice
    return availableVoices.find(v => v.default) || availableVoices[0];
}

function getPitchForGender(gender) {
    const pitchMap = {
        'female': 1.2,
        'male': 0.9,
        'neutral': 1.0,
        'fluid': 1.0,
        'agender': 1.0,
        'hijra': 1.1,
        'twoSpirit': 1.0,
        'faAfafine': 1.15,
        'mahu': 1.1,
        'sistergirl': 1.2,
        'xGender': 1.0
    };
    
    return pitchMap[gender] || 1.0;
}

function updateVoiceStatus(message) {
    const status = document.getElementById('voiceStatus');
    status.textContent = message;
}

// Utility functions
function randomChoice(array) {
    if (!array || array.length === 0) return '';
    return array[Math.floor(Math.random() * array.length)];
}

function formatComponentLabel(key) {
    const labelMap = {
        'given': 'Given name',
        'family': 'Family name',
        'patronymic': 'Patronymic',
        'particle': 'Particle',
        'mononym': 'Single name',
        'native': 'Native form',
        'english': 'English form'
    };
    
    return labelMap[key] || key.charAt(0).toUpperCase() + key.slice(1);
}

function formatGender(gender) {
    const genderMap = {
        'male': 'Male',
        'female': 'Female',
        'neutral': 'Gender neutral',
        'fluid': 'Gender fluid',
        'agender': 'Agender',
        'hijra': 'Hijra (South Asian third gender)',
        'twoSpirit': 'Two-Spirit (Native American)',
        'faAfafine': 'Fa\'afafine (Samoan third gender)',
        'mahu': 'MƒÅh≈´ (Hawaiian/Tahitian)',
        'sistergirl': 'Sistergirl (Aboriginal Australian)',
        'xGender': 'X-gender (Japanese non-binary)'
    };
    
    return genderMap[gender] || gender;
}

function formatCategory(category) {
    const categoryMap = {
        'ancient': 'Ancient period',
        'medieval': 'Medieval period',
        'slavic': 'Slavic tradition',
        'indic': 'Indian subcontinent',
        'historical': 'Historical figure',
        'legendary': 'Legendary/Mythological',
        'epic': 'Epic tradition',
        'royal': 'Royal/Noble',
        'traditional': 'Traditional'
    };
    
    return categoryMap[category] || category.charAt(0).toUpperCase() + category.slice(1);
}

// Interval management
function startInterval() {
    if (!appState.isInitialized) {
        console.log('Cannot start interval - app not initialized');
        return;
    }
    
    // Generate first name immediately
    generateAndDisplay();
    
    if (appState.intervalId) {
        clearInterval(appState.intervalId);
    }
    
    const speed = appState.isFast ? appState.FAST_SPEED : appState.SLOW_SPEED;
    appState.intervalId = setInterval(() => {
        if (appState.isRunning) {
            generateAndDisplay();
        }
    }, speed);
}

async function generateAndDisplay() {
    if (!appState.isInitialized) {
        console.log('App not initialized yet');
        return;
    }
    
    try {
        const nameData = await generateName();
        if (nameData) {
            displayName(nameData);
            
            if (appState.isRunning && appState.isVoiceInitialized) {
                speakName(nameData);
            }
            
            updateStats(nameData);
        } else {
            console.error('No name data generated');
        }
    } catch (error) {
        console.error('Error in generateAndDisplay:', error);
    }
}

function updateStats(nameData) {
    const stats = document.getElementById('statsDisplay');
    
    if (!appState.metadata) {
        stats.innerHTML = 'Loading...';
        return;
    }
    
    const parts = [];
    
    if (appState.isWeighted) {
        if (nameData && nameData.familyData) {
            parts.push(`Population weighting active (${nameData.familyData.metadata.family}: ${nameData.familyData.metadata.populationPercentage}%)`);
        } else {
            parts.push('Population weighting active');
        }
    } else {
        parts.push('Random selection (equal probability)');
    }
    
    const loadedCount = dataLoader.getLoadedFamilies().length;
    const totalCount = appState.metadata.languageFamilies.length;
    
    parts.push(`${loadedCount} of ${totalCount} language families loaded`);
    
    if (appState.showOldNames) {
        parts.push('Showing historical names');
    }
    
    stats.innerHTML = parts.join(' ‚Ä¢ ');
}

// Event handlers
document.getElementById('initVoiceButton').addEventListener('click', initializeVoiceSystem);

document.getElementById('toggleButton').addEventListener('click', () => {
    appState.isRunning = !appState.isRunning;
    document.getElementById('toggleButton').textContent = appState.isRunning ? 'Pause' : 'Resume';
    
    if (appState.isRunning) {
        generateAndDisplay();
    } else {
        appState.synth.cancel();
    }
});

document.getElementById('speedToggle').addEventListener('change', (e) => {
    appState.isFast = e.target.checked;
    startInterval();
});

document.getElementById('weightedToggle').addEventListener('change', (e) => {
    appState.isWeighted = e.target.checked;
    updateStats(appState.currentName);
});

document.getElementById('detailToggle').addEventListener('change', (e) => {
    appState.showDetails = e.target.checked;
    if (appState.currentName) {
        displayName(appState.currentName);
    }
});

document.getElementById('oldNamesToggle').addEventListener('change', (e) => {
    appState.showOldNames = e.target.checked;
    generateAndDisplay();
});

document.getElementById('speakButton').addEventListener('click', () => {
    if (appState.currentName) {
        speakName(appState.currentName);
    }
});

// Name click handler for image search
document.getElementById('nameDisplay').addEventListener('click', (e) => {
    const name = e.target.textContent;
    if (name && !name.includes('[') && !name.includes('Name withheld')) {
        window.focus();
        setTimeout(() => {
            const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(name)}&tbm=isch`;
            window.open(searchUrl, '_blank', 'noopener,noreferrer');
            window.focus();
        }, 0);
    }
});

// Info modal handlers
document.getElementById('infoButton').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'block';
});

document.querySelector('.close').addEventListener('click', () => {
    document.getElementById('infoModal').style.display = 'none';
});

window.addEventListener('click', (e) => {
    const modal = document.getElementById('infoModal');
    if (e.target === modal) {
        modal.style.display = 'none';
    }
});

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
    initializeApp();
});

// Start the interval once app is initialized
async function startApp() {
    if (appState.isInitialized) {
        startInterval();
    }
}

// Handle visibility change to pause/resume
document.addEventListener('visibilitychange', () => {
    if (document.hidden && appState.isRunning) {
        appState.synth.cancel();
    }
});

// Error handling
window.addEventListener('error', (e) => {
    console.error('Application error:', e.error);
});

// Prevent speech on page unload
window.addEventListener('beforeunload', () => {
    if (appState.synth) {
        appState.synth.cancel();
    }
});
    </script>
</body>
</html>