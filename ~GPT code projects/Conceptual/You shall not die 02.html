<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>You Shall Not Die</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #363636 100%);
            color: #fff;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 400px;
            backdrop-filter: blur(10px);
        }
        h2 {
            margin: 0 0 1.5rem 0;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        .names {
            font-size: 2rem;
            margin: 1.5rem 0;
            min-height: 4rem;
            line-height: 1.5;
            color: #ffffff;
        }
        .culture {
            color: #cccccc;
            font-style: italic;
            margin-bottom: 1.5rem;
        }
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #4CAF50;
        }
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        .switch-label {
            font-size: 0.9rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            cursor: pointer;
            padding: 0.7rem 1.2rem;
            font-size: 1rem;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        button.active {
            background: rgba(255, 255, 255, 0.3);
        }
        .stats {
            font-size: 0.8rem;
            color: #999;
            margin-top: 1rem;
        }
        .voice-status {
            color: #999;
            margin: 1rem 0;
            font-size: 0.9rem;
            font-style: italic;
        }
        #initVoiceButton {
            background: #4CAF50;
            margin-bottom: 1rem;
        }
        #initVoiceButton:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>You Shall Not Die</h2>
        <div class="names" id="nameDisplay"></div>
        <div class="culture" id="cultureDisplay"></div>
        <div class="voice-status" id="voiceStatus">Click Initialize Voice to begin speaking</div>
        <div class="stats" id="statsDisplay"></div>
        <div class="controls">
            <button id="initVoiceButton">Initialize Voice</button>
            <button id="toggleButton">Pause</button>
            <div class="control-group">
                <span class="switch-label">Slow</span>
                <label class="switch">
                    <input type="checkbox" id="speedToggle">
                    <span class="slider"></span>
                </label>
                <span class="switch-label">Fast</span>
            </div>
            <div class="control-group">
                <span class="switch-label">Random</span>
                <label class="switch">
                    <input type="checkbox" id="weightedToggle">
                    <span class="slider"></span>
                </label>
                <span class="switch-label">Weighted</span>
            </div>
            <button id="speakButton">Speak</button>
        </div>
    </div>

    <script>
        const namesDatabase = {
            indo_european: {
                metadata: {
                    family: "Indo-European",
                    population_percentage: 46,
                    writing_systems: ["Latin", "Cyrillic", "Devanagari", "Bengali", "Greek"],
                    major_languages: ["English", "Hindi", "Spanish", "Portuguese", "Russian", "Bengali", "Persian"],
                    name_order: "given_name_first",
                    preferred_voices: ["en-US", "hi-IN", "es-ES", "pt-PT", "ru-RU"]
                },
                male_names: [
                    "Alexander", "Mohammed", "James", "John", "William", "Raj", "Michael",
                    "David", "Robert", "Joseph", "Daniel", "Ivan", "Dmitri", "Vladimir",
                    "Mohammad", "Ali", "Reza", "Amit", "Rahul", "Rajesh", "Carlos",
                    "Juan", "Antonio", "José", "Miguel", "Pedro", "Francisco", "Manuel",
                    "Sergei", "Andrei", "Pavel", "Viktor", "Nikolai", "Boris", "Arjun",
                    "Arun", "Vijay", "Rajiv", "Suresh", "Alessandro", "Marco", "Giuseppe",
                    "Giovanni", "Pierre", "Jean", "Louis", "François", "Hans", "Heinrich",
                    "Wilhelm", "Thomas"
                ],
                female_names: [
                    "Maria", "Anna", "Sofia", "Emma", "Elena", "Olga", "Tatiana",
                    "Irina", "Svetlana", "Ekaterina", "Ana", "Isabella", "Victoria",
                    "Priya", "Anjali", "Deepa", "Sunita", "Anita", "Laura", "Carmen",
                    "Isabel", "Patricia", "Marie", "Catherine", "Elizabeth", "Sarah",
                    "Emily", "Olivia", "Ava", "Charlotte", "Sophia", "Amelia", "Pooja",
                    "Neha", "Divya", "Ritu", "Aisha", "Fatima", "Maryam", "Zahra",
                    "Chiara", "Francesca", "Giulia", "Martina", "Alice", "Julie",
                    "Louise", "Sophie", "Anna-Maria", "Helga"
                ],
                family_names: [
                    "Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller",
                    "Davis", "Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez",
                    "Wilson", "Anderson", "Thomas", "Taylor", "Moore", "Jackson", "Martin",
                    "Lee", "Perez", "Thompson", "White", "Harris", "Sanchez", "Clark",
                    "Ramirez", "Lewis", "Robinson", "Walker", "Young", "Allen", "King",
                    "Wright", "Scott", "Torres", "Nguyen", "Hill", "Flores", "Green",
                    "Adams", "Nelson", "Baker", "Hall", "Rivera", "Campbell", "Mitchell",
                    "Carter", "Roberts", "Ivanov", "Petrov", "Smirnov", "Kuznetsov", 
                    "Popov", "Sokolov", "Lebedev", "Kozlov", "Novikov", "Morozov",
                    "Volkov", "Kowalski", "Wiśniewski", "Dąbrowski", "Lewandowski",
                    "Wójcik", "Kamiński", "Kowalczyk", "Zieliński", "Szymański",
                    "Kumar", "Singh", "Patel", "Shah", "Sharma", "Verma", "Gupta",
                    "Rossi", "Russo", "Ferrari", "Esposito", "Bianchi", "Romano",
                    "Colombo", "Bernard", "Robert", "Richard", "Dubois", "Thomas",
                    "Petit", "Müller", "Schmidt", "Schneider", "Fischer", "Weber",
                    "Meyer", "Wagner", "Becker", "Schulz", "Hoffmann", "Schäfer",
                    "Koch", "Bauer", "Richter", "Klein", "Wolf", "Schröder"
                ]
            },
            sino_tibetan: {
                metadata: {
                    family: "Sino-Tibetan",
                    population_percentage: 20,
                    writing_systems: ["Chinese Characters", "Latin", "Tibetan"],
                    major_languages: ["Mandarin", "Wu", "Cantonese", "Min", "Tibetan"],
                    name_order: "family_name_first",
                    preferred_voices: ["zh-CN", "zh-TW", "zh-HK", "zh"]
                },
                male_names: [
                    "Wei", "Ming", "Jun", "Hao", "Yi", "Jian", "Lei", "Gang", "Xiong", "Tao",
                    "Cheng", "Feng", "Hong", "Long", "Ping", "Ting", "Wen", "Xiang", "Yang", "Zhi",
                    "Bin", "De", "Fu", "Guo", "Hui", "Jing", "Kai", "Li", "Nan", "Peng",
                    "Qiang", "Rui", "Sheng", "Tian", "Wei", "Xin", "Yong", "Zheng", "Bo", "Chang",
                    "Dong", "En", "Fei", "Guang", "Han", "Jin", "Kang", "Liang", "Min", "Ning"
                ],
                female_names: [
                    "Xia", "Ying", "Mei", "Lan", "Hui", "Xue", "Juan", "Yan", "Qing", "Na",
                    "Hong", "Lin", "Zhen", "Yue", "Jing", "Hua", "Xin", "Yu", "Feng", "Li",
                    "Ming", "Ping", "Qi", "Rong", "Shan", "Ting", "Wei", "Xiang", "Yi", "Zhi",
                    "Ai", "Bao", "Chen", "Dan", "E", "Fang", "Guo", "Han", "Juan", "Kun",
                    "Lei", "Min", "Ning", "Ou", "Pei", "Qian", "Ru", "Shu", "Tao", "Wen"
                ],
                family_names: [
                    "Wang", "Li", "Zhang", "Liu", "Chen", "Yang", "Huang", "Zhao", "Wu", "Zhou",
                    "Xu", "Sun", "Ma", "Zhu", "Hu", "Guo", "He", "Gao", "Lin", "Luo",
                    "Zheng", "Liang", "Xie", "Song", "Tang", "Xu", "Han", "Feng", "Deng", "Cao",
                    "Peng", "Zeng", "Xiao", "Tian", "Dong", "Pan", "Yuan", "Cai", "Jiang", "Yu",
                    "Du", "Ye", "Cheng", "Su", "Wei", "Lv", "Ding", "Ren", "Yao", "Shen",
                    "Zhong", "Jiang", "Cui", "Zheng", "He", "Xu", "Fan", "Shi", "Jin", "Wei",
                    "Feng", "Deng", "Cao", "Peng", "Zeng", "Xiao", "Tian", "Dong", "Pan", "Yuan",
                    "Lu", "Mao", "Qian", "Dai", "Fu", "Kong", "Bai", "Hao", "Yan", "Shi",
                    "Qin", "Zou", "Xiong", "Cui", "Tao", "Lu", "Mao", "Qian", "Dai", "Fu",
                    "Jia", "Xue", "Lei", "Fang", "Chang", "Hou", "Gu", "Yan", "Han", "Qiu"
                ]
            }
        };

        let isRunning = true;
        let isFast = false;
        let isWeighted = false;
        let intervalId = null;
        let synth = window.speechSynthesis;
        let voices = [];
        let currentCulture = null;
        let currentGender = null;
        let isVoiceInitialized = false;
        const SLOW_SPEED = 10000;
        const FAST_SPEED = 5000;

        async function initializeVoice() {
            try {
                updateVoiceStatus("Initializing voice system...");
                
                synth.cancel();
                voices = await loadVoices();
                
                if (!voices || voices.length === 0) {
                    throw new Error("No voices available");
                }

                voices.forEach(voice => {
                    voice.gender = (voice.name.toLowerCase().includes('female') ||
                                  voice.name.toLowerCase().includes('woman')) ? 'female' : 'male';
                });

                const testUtterance = new SpeechSynthesisUtterance("Voice initialized");
                testUtterance.volume = 0.1;
                
                return new Promise((resolve, reject) => {
                    testUtterance.onend = () => {
                        isVoiceInitialized = true;
                        updateVoiceStatus("Voice system ready");
                        document.getElementById('initVoiceButton').style.display = 'none';
                        resolve();
                    };
                    
                    testUtterance.onerror = (e) => {
                        reject(new Error(`Speech test failed: ${e.error}`));
                    };

                    synth.speak(testUtterance);
                });

            } catch (error) {
                console.error("Voice initialization error:", error);
                updateVoiceStatus(`Voice initialization failed: ${error.message}. Please try again.`);
                throw error;
            }
        }

        function loadVoices() {
            return new Promise((resolve, reject) => {
                const maxAttempts = 10;
                let attempts = 0;

                function tryGetVoices() {
                    attempts++;
                    let voiceList = synth.getVoices();
                    
                    if (voiceList.length > 0) {
                        resolve(voiceList);
                    } else if (attempts < maxAttempts) {
                        setTimeout(tryGetVoices, 500);
                    } else {
                        reject(new Error("Could not load voices after multiple attempts"));
                    }
                }

                if (synth.onvoiceschanged !== undefined) {
                    synth.onvoiceschanged = () => {
                        let voiceList = synth.getVoices();
                        if (voiceList.length > 0) {
                            resolve(voiceList);
                        }
                    };
                    tryGetVoices();
                } else {
                    tryGetVoices();
                }
            });
        }

        function updateVoiceStatus(message) {
            const status = document.getElementById('voiceStatus');
            status.textContent = message;
        }

        document.getElementById('initVoiceButton').addEventListener('click', async () => {
            try {
                await initializeVoice();
                generateAndSpeak();
            } catch (error) {
                console.error("Failed to initialize voice:", error);
            }
        });

        const toggleButton = document.getElementById('toggleButton');
        const speedToggle = document.getElementById('speedToggle');
        const weightedToggle = document.getElementById('weightedToggle');
        const speakButton = document.getElementById('speakButton');

        toggleButton.addEventListener('click', () => {
            isRunning = !isRunning;
            toggleButton.textContent = isRunning ? 'Pause' : 'Resume';
            if (isRunning) {
                generateAndSpeak();
                startInterval();
            } else {
                clearInterval(intervalId);
                synth.cancel();
            }
        });

        speedToggle.addEventListener('change', () => {
            isFast = speedToggle.checked;
            if (isRunning) {
                startInterval();
            }
        });

        weightedToggle.addEventListener('change', () => {
            isWeighted = weightedToggle.checked;
            updateStats();
        });

        speakButton.addEventListener('click', () => {
            if (!isVoiceInitialized) {
                updateVoiceStatus("Please initialize voice system first");
                return;
            }
            
            if (currentCulture) {
                const nameDisplay = document.getElementById('nameDisplay');
                speakNames(nameDisplay.textContent, currentCulture, currentGender);
            }
        });

        function getRandomName(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function weightedRandomCulture() {
            if (!isWeighted) {
                return Object.keys(namesDatabase)[Math.floor(Math.random() * Object.keys(namesDatabase).length)];
            }

            const totalPercentage = Object.values(namesDatabase).reduce((sum, family) => 
                sum + family.metadata.population_percentage, 0);
            
            let random = Math.random() * totalPercentage;
            let currentSum = 0;

            for (const [culture, data] of Object.entries(namesDatabase)) {
                currentSum += data.metadata.population_percentage;
                if (random <= currentSum) {
                    return culture;
                }
            }

            return Object.keys(namesDatabase)[0];
        }

        function findBestVoice(preferredVoices, gender) {
            if (!voices || voices.length === 0) {
                return null;
            }

            for (const lang of preferredVoices) {
                const exactMatch = voices.find(v => 
                    v.lang === lang && 
                    v.gender === gender
                );
                if (exactMatch) return exactMatch;
            }

            for (const lang of preferredVoices) {
                const langPrefix = lang.split('-')[0];
                const familyMatch = voices.find(v => 
                    v.lang.startsWith(langPrefix) && 
                    v.gender === gender
                );
                if (familyMatch) return familyMatch;
            }

            const genderMatch = voices.find(v => v.gender === gender);
            if (genderMatch) return genderMatch;

            return voices[0];
        }

        function speakNames(text, culture, gender) {
            if (!isVoiceInitialized) {
                updateVoiceStatus("Please initialize voice system first");
                return;
            }

            try {
                synth.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                const familyData = namesDatabase[culture];
                const voice = findBestVoice(familyData.metadata.preferred_voices, gender);

                if (voice) {
                    utterance.voice = voice;
                }

                utterance.rate = 0.9;
                utterance.pitch = gender === 'female' ? 1.2 : 0.9;
                
                utterance.onerror = (e) => {
                    updateVoiceStatus(`Speech error: ${e.error}`);
                };

                synth.speak(utterance);
            } catch (error) {
                updateVoiceStatus(`Speech error: ${error.message}`);
            }
        }

        function updateStats() {
            const statsDisplay = document.getElementById('statsDisplay');
            if (isWeighted) {
                const currentFamily = namesDatabase[currentCulture];
                if (currentFamily) {
                    statsDisplay.textContent = 
                        `Using population weighting (${currentFamily.metadata.family}: ${currentFamily.metadata.population_percentage}%)`;
                }
            } else {
                statsDisplay.textContent = 'Random selection (equal probability)';
            }
        }

        function startInterval() {
            clearInterval(intervalId);
            intervalId = setInterval(generateAndSpeak, isFast ? FAST_SPEED : SLOW_SPEED);
        }

        function generateAndSpeak() {
            if (!isVoiceInitialized) {
                updateVoiceStatus("Please initialize voice system first");
                return;
            }

            const culture = weightedRandomCulture();
            currentCulture = culture;
            const familyData = namesDatabase[culture];
            
            currentGender = Math.random() < 0.5 ? 'male' : 'female';
            const givenName = getRandomName(familyData[`${currentGender}_names`]);
            const familyName = getRandomName(familyData.family_names);

            const nameDisplay = document.getElementById('nameDisplay');
            const cultureDisplay = document.getElementById('cultureDisplay');
            
            nameDisplay.classList.remove('fade-in');
            cultureDisplay.classList.remove('fade-in');
            void nameDisplay.offsetWidth;
            nameDisplay.classList.add('fade-in');
            cultureDisplay.classList.add('fade-in');

            const fullName = familyData.metadata.name_order === "given_name_first" ? 
                `${givenName} ${familyName}` : 
                `${familyName} ${givenName}`;

            nameDisplay.textContent = fullName;
            cultureDisplay.textContent = `(${familyData.metadata.family})`;
            
            if (isRunning) {
                speakNames(fullName, culture, currentGender);
            }
            
            updateStats();
        }

        window.onerror = function(msg, url, lineNo, columnNo, error) {
            updateVoiceStatus(`An error occurred: ${msg}`);
            return false;
        };

        async function init() {
            try {
                updateVoiceStatus("Click 'Initialize Voice' to begin");
                updateStats();
                const nameDisplay = document.getElementById('nameDisplay');
                if (!nameDisplay.textContent) {
                    generateAndSpeak();
                }
                startInterval();
            } catch (error) {
                updateVoiceStatus(`Initialization error: ${error.message}`);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>