<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Capsule Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
        }
        #ui label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="ui">
        <label>
            Length: <input type="range" id="length" min="5" max="50" value="20">
        </label>
        <label>
            Central Radius: <input type="range" id="centralRadius" min="2" max="10" value="5">
        </label>
        <label>
            End Radius: <input type="range" id="endRadius" min="2" max="10" value="5">
        </label>
        <label>
            Emission Rate: <input type="range" id="emissionRate" min="1" max="200" value="10"> <span id="rateDisplay">10</span> Hz
        </label>
        <button id="toggleEmission">Start Emission</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r138/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three-orbitcontrols/2.110.3/OrbitControls.min.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(50, 50, 50);
        scene.add(ambientLight, pointLight);

        // Add controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Capsule parameters
        let capsule = null;
        let length = 20; // Default length
        let centralRadius = 5; // Default central radius
        let endRadius = 5; // Default end radius

        // Electrons
        const electrons = [];
        const electronGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const electronMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff });

        // Cathode and Anode
        const cathodeGeometry = new THREE.SphereGeometry(1, 16, 16);
        const cathodeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const anodeMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
        let cathode, anode;

        // Create capsule geometry
        function createCapsule(length, centralRadius, endRadius) {
            if (capsule) scene.remove(capsule);

            const cylinderHeight = length;
            const capsuleGeometry = new THREE.CapsuleGeometry(endRadius, cylinderHeight - 2 * endRadius, 32, 32);

            const capsuleMaterial = new THREE.MeshPhongMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.9,
            });

            capsule = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
            scene.add(capsule);

            // Update cathode and anode positions
            if (!cathode) {
                cathode = new THREE.Mesh(cathodeGeometry, cathodeMaterial);
                scene.add(cathode);
            }
            cathode.position.set(0, -length / 2 - endRadius, 0);

            if (!anode) {
                anode = new THREE.Mesh(cathodeGeometry, anodeMaterial);
                scene.add(anode);
            }
            anode.position.set(0, length / 2 + endRadius, 0);
        }

        // Initial creation
        createCapsule(length, centralRadius, endRadius);

        // UI Updates
        document.getElementById("length").addEventListener("input", (event) => {
            length = parseFloat(event.target.value);
            createCapsule(length, centralRadius, endRadius);
        });

        document.getElementById("centralRadius").addEventListener("input", (event) => {
            centralRadius = parseFloat(event.target.value);
            createCapsule(length, centralRadius, endRadius);
        });

        document.getElementById("endRadius").addEventListener("input", (event) => {
            endRadius = parseFloat(event.target.value);
            createCapsule(length, centralRadius, endRadius);
        });

        // Emission rate control
        let emissionRate = 10;
        document.getElementById("emissionRate").addEventListener("input", (event) => {
            emissionRate = parseInt(event.target.value);
            document.getElementById("rateDisplay").innerText = emissionRate;
        });

        let emitting = false;
        document.getElementById("toggleEmission").addEventListener("click", () => {
            emitting = !emitting;
            document.getElementById("toggleEmission").innerText = emitting ? "Stop Emission" : "Start Emission";
        });

        // Emit electrons
        function emitElectrons() {
            if (!emitting) return;

            const electron = new THREE.Mesh(electronGeometry, electronMaterial);
            electron.position.copy(cathode.position);
            const angle = Math.random() * Math.PI * 2;
            electron.velocity = new THREE.Vector3(Math.cos(angle), Math.random() * 0.5, Math.sin(angle));
            electrons.push(electron);
            scene.add(electron);
        }

        setInterval(emitElectrons, 1000 / emissionRate);

        // Update electrons
        function updateElectrons() {
            const removalIndexes = [];
            electrons.forEach((electron, index) => {
                electron.position.add(electron.velocity);

                // Attract to anode
                const toAnode = new THREE.Vector3().subVectors(anode.position, electron.position);
                const distance = toAnode.length();
                if (distance < 2) {
                    removalIndexes.push(index);
                    scene.remove(electron);
                } else {
                    toAnode.normalize();
                    electron.velocity.add(toAnode.multiplyScalar(0.01 / distance));
                }
            });

            // Remove touched electrons
            removalIndexes.reverse().forEach((index) => {
                electrons.splice(index, 1);
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updateElectrons();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
