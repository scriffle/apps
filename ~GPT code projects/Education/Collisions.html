<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Two-Body Physics Simulator</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            background-color: #f0f0f0;
            display: block;
        }
    </style>
</head>
<body>
<canvas id="simCanvas"></canvas>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    let objects = [];
    let draggingObject = null;
    let dragOffset = {x: 0, y: 0};

    // Initialize the simulation
    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Create two draggable objects
        objects.push(new PhysicsObject(200, 200, 30, 1, {x: 2, y: 0}, {x: 0, y: 0}));
        objects.push(new PhysicsObject(400, 200, 30, 1, {x: -2, y: 0}, {x: 0, y: 0}));

        // Event listeners for dragging
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);

        // Start simulation loop
        requestAnimationFrame(update);
    }

    // Physics Object class
    class PhysicsObject {
        constructor(x, y, radius, mass, velocity, acceleration) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.mass = mass;
            this.velocity = velocity;
            this.acceleration = acceleration;
        }

        // Draw the object and vectors
        draw() {
            // Draw the object
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'black';
            ctx.fill();
            ctx.closePath();

            // Draw velocity vector (blue arrow)
            drawArrow(this.x, this.y, this.x + this.velocity.x * 20, this.y + this.velocity.y * 20, 'blue');

            // Draw acceleration vector (red arrow)
            drawArrow(this.x, this.y, this.x + this.acceleration.x * 100, this.y + this.acceleration.y * 100, 'red');
        }

        // Update position and velocity based on acceleration
        update(dt) {
            // Apply acceleration to velocity
            this.velocity.x += this.acceleration.x * dt;
            this.velocity.y += this.acceleration.y * dt;

            // Apply velocity to position
            this.x += this.velocity.x * dt;
            this.y += this.velocity.y * dt;

            // Wrap around screen (x-axis and y-axis)
            if (this.x > canvas.width) this.x = 0;
            if (this.x < 0) this.x = canvas.width;
            if (this.y > canvas.height) this.y = 0;
            if (this.y < 0) this.y = canvas.height;
        }
    }

    // Utility function to draw arrows
    function drawArrow(fromX, fromY, toX, toY, color) {
        const headLength = 10; // Length of the arrowhead
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);

        // Draw the line part of the arrow
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw the arrowhead
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(toX, toY);
        ctx.fillStyle = color;
        ctx.fill();
    }

    // Collision detection and response
    function checkCollision() {
        for (let i = 0; i < objects.length; i++) {
            for (let j = i + 1; j < objects.length; j++) {
                let objA = objects[i];
                let objB = objects[j];

                // Check if the objects are overlapping (simple circular collision)
                let dx = objB.x - objA.x;
                let dy = objB.y - objA.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < objA.radius + objB.radius) {
                    // Resolve collision with ft = mv
                    let normal = {x: dx / distance, y: dy / distance};

                    // Calculate relative velocity
                    let relVel = {
                        x: objB.velocity.x - objA.velocity.x,
                        y: objB.velocity.y - objA.velocity.y
                    };

                    // Calculate velocity along the normal direction
                    let velAlongNormal = relVel.x * normal.x + relVel.y * normal.y;

                    if (velAlongNormal > 0) continue; // They are moving apart

                    // Rebound using simple collision response
                    let e = 1; // Coefficient of restitution (elastic collision)
                    let j = -(1 + e) * velAlongNormal / (1 / objA.mass + 1 / objB.mass);

                    // Apply impulse to both objects
                    let impulse = {x: j * normal.x, y: j * normal.y};
                    objA.velocity.x -= impulse.x / objA.mass;
                    objA.velocity.y -= impulse.y / objA.mass;
                    objB.velocity.x += impulse.x / objB.mass;
                    objB.velocity.y += impulse.y / objB.mass;
                }
            }
        }
    }

    // Update the simulation
    function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const dt = 0.01; // Small time step for updates

        // Update and draw each object
        for (let obj of objects) {
            obj.update(dt);
            obj.draw();
        }

        // Check for collisions and handle them
        checkCollision();

        // Request the next frame
        requestAnimationFrame(update);
    }

    // Drag-and-drop interaction
    function onMouseDown(e) {
        let mousePos = getMousePos(e);
        for (let obj of objects) {
            let dx = mousePos.x - obj.x;
            let dy = mousePos.y - obj.y;
            if (Math.sqrt(dx * dx + dy * dy) < obj.radius) {
                draggingObject = obj;
                dragOffset.x = dx;
                dragOffset.y = dy;
                return;
            }
        }
    }

    function onMouseMove(e) {
        if (draggingObject) {
            let mousePos = getMousePos(e);
            draggingObject.x = mousePos.x - dragOffset.x;
            draggingObject.y = mousePos.y - dragOffset.y;
        }
    }

    function onMouseUp(e) {
        draggingObject = null;
    }

    function getMousePos(e) {
        let rect = canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    // Resize canvas when window is resized
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // Initialize the simulation
    init();
</script>
</body>
</html>
