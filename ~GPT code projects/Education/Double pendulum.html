<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Multiple Double Pendulum Simulations with Trails</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
        #simulations { display: flex; flex-wrap: wrap; }
        .simulation { border: 1px solid #ccc; padding: 10px; box-sizing: border-box; }
        canvas { border: 1px solid #ddd; }
        .controls { display: grid; grid-template-columns: auto auto; gap: 5px; margin-top: 10px; }
        label { text-align: right; }
        input[type="range"] { width: 150px; }
        #globalControls { margin: 10px; }
        .buttonGroup { display: flex; gap: 5px; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="globalControls">
        <button id="startAllBtn">Start All</button>
        <button id="resetAllBtn">Reset All</button>
        <button id="randomizeAllBtn">Randomize All</button>
        <label for="numPendulums">Number of Pendulums:</label>
        <input type="number" id="numPendulums" min="1" max="10" value="2">
        <button id="updateNumBtn">Update</button>
    </div>
    <div id="simulations"></div>

    <script>
    class DoublePendulum {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.isRunning = false;
            this.trail = [];
            this.reset();
        }

        reset() {
            this.theta1 = Math.PI / 2;
            this.theta2 = Math.PI / 2;
            this.omega1 = 0;
            this.omega2 = 0;
            this.length1 = 1;
            this.length2 = 1;
            this.mass1 = 1;
            this.mass2 = 1;
            this.g = 9.81;
            this.damping = 1e-10;  // Set to minimum above 0
            this.trail = [];
        }

        randomize() {
            this.theta1 = Math.random() * Math.PI * 2 - Math.PI;
            this.theta2 = Math.random() * Math.PI * 2 - Math.PI;
            this.omega1 = (Math.random() * 2 - 1) * 5;
            this.omega2 = (Math.random() * 2 - 1) * 5;
            this.length1 = Math.random() * 0.5 + 0.5;
            this.length2 = Math.random() * 0.5 + 0.5;
            this.mass1 = Math.random() * 1.5 + 0.5;
            this.mass2 = Math.random() * 1.5 + 0.5;
            this.damping = Math.random() * 0.01;
            this.trail = [];
        }

        derivatives(state) {
            const [theta1, omega1, theta2, omega2] = state;
            const { length1, length2, mass1, mass2, g } = this;

            const cos12 = Math.cos(theta1 - theta2);
            const sin12 = Math.sin(theta1 - theta2);

            const domega1 = (-g * (2 * mass1 + mass2) * Math.sin(theta1) - mass2 * g * Math.sin(theta1 - 2 * theta2)
                             - 2 * sin12 * mass2 * (omega2 * omega2 * length2 + omega1 * omega1 * length1 * cos12))
                            / (length1 * (2 * mass1 + mass2 - mass2 * Math.cos(2 * theta1 - 2 * theta2)));

            const domega2 = (2 * sin12 * (omega1 * omega1 * length1 * (mass1 + mass2) + g * (mass1 + mass2) * Math.cos(theta1)
                             + omega2 * omega2 * length2 * mass2 * cos12))
                            / (length2 * (2 * mass1 + mass2 - mass2 * Math.cos(2 * theta1 - 2 * theta2)));

            return [omega1, domega1, omega2, domega2];
        }

        rk4Step(state, dt) {
            const k1 = this.derivatives(state);
            const k2 = this.derivatives(state.map((x, i) => x + k1[i] * dt / 2));
            const k3 = this.derivatives(state.map((x, i) => x + k2[i] * dt / 2));
            const k4 = this.derivatives(state.map((x, i) => x + k3[i] * dt));

            return state.map((x, i) => x + (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i]) * dt / 6);
        }

        update(dt) {
            let state = [this.theta1, this.omega1, this.theta2, this.omega2];
            state = this.rk4Step(state, dt);

            [this.theta1, this.omega1, this.theta2, this.omega2] = state;

            // Apply damping
            this.omega1 *= (1 - this.damping);
            this.omega2 *= (1 - this.damping);

            // Update trail
            const scale = Math.min(this.canvas.width, this.canvas.height) / 4;
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 4;
            const x1 = centerX + this.length1 * scale * Math.sin(this.theta1);
            const y1 = centerY + this.length1 * scale * Math.cos(this.theta1);
            const x2 = x1 + this.length2 * scale * Math.sin(this.theta2);
            const y2 = y1 + this.length2 * scale * Math.cos(this.theta2);

            this.trail.push({x: x2, y: y2, time: Date.now()});
            // Remove trail points older than 5 seconds
            this.trail = this.trail.filter(point => Date.now() - point.time < 5000);
        }

        draw() {
            const scale = Math.min(this.canvas.width, this.canvas.height) / 4;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 4;

            // Draw trail
            this.ctx.beginPath();
            this.trail.forEach((point, index) => {
                const alpha = 1 - (Date.now() - point.time) / 5000;
                this.ctx.strokeStyle = `rgba(255, 165, 0, ${alpha})`;
                if (index === 0) {
                    this.ctx.moveTo(point.x, point.y);
                } else {
                    this.ctx.lineTo(point.x, point.y);
                }
            });
            this.ctx.stroke();

            const x1 = centerX + this.length1 * scale * Math.sin(this.theta1);
            const y1 = centerY + this.length1 * scale * Math.cos(this.theta1);
            const x2 = x1 + this.length2 * scale * Math.sin(this.theta2);
            const y2 = y1 + this.length2 * scale * Math.cos(this.theta2);

            this.ctx.beginPath();
            this.ctx.moveTo(centerX, centerY);
            this.ctx.lineTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();

            this.ctx.beginPath();
            this.ctx.arc(x1, y1, Math.sqrt(this.mass1) * 5, 0, 2 * Math.PI);
            this.ctx.arc(x2, y2, Math.sqrt(this.mass2) * 5, 0, 2 * Math.PI);
            this.ctx.fillStyle = '#000';
            this.ctx.fill();
        }
    }

    class Simulation {
        constructor(containerId, index, totalSimulations) {
            this.container = document.getElementById(containerId);
            this.index = index;
            this.createElements(totalSimulations);
            this.pendulum = new DoublePendulum(`canvas${this.index}`);
            this.setupEventListeners();
        }

        createElements(totalSimulations) {
            const simulationDiv = document.createElement('div');
            simulationDiv.className = 'simulation';
            simulationDiv.style.width = `${100 / totalSimulations}%`;
            simulationDiv.innerHTML = `
                <h3>Pendulum ${this.index + 1}</h3>
                <canvas id="canvas${this.index}"></canvas>
                <div class="controls">
                    <label for="length1_${this.index}">Length 1:</label>
                    <input type="range" id="length1_${this.index}" min="0.5" max="1.5" step="0.1" value="1">
                    <label for="length2_${this.index}">Length 2:</label>
                    <input type="range" id="length2_${this.index}" min="0.5" max="1.5" step="0.1" value="1">
                    <label for="angle1_${this.index}">Angle 1:</label>
                    <input type="range" id="angle1_${this.index}" min="-180" max="180" value="90">
                    <label for="angle2_${this.index}">Angle 2:</label>
                    <input type="range" id="angle2_${this.index}" min="-180" max="180" value="90">
                    <label for="mass1_${this.index}">Mass 1:</label>
                    <input type="range" id="mass1_${this.index}" min="0.5" max="2" step="0.1" value="1">
                    <label for="mass2_${this.index}">Mass 2:</label>
                    <input type="range" id="mass2_${this.index}" min="0.5" max="2" step="0.1" value="1">
                    <label for="damping_${this.index}">Damping:</label>
                    <input type="range" id="damping_${this.index}" min="0" max="0.01" step="0.0001" value="0.0000000001">
                </div>
                <div class="buttonGroup">
                    <button class="startBtn">Start</button>
                    <button class="resetBtn">Reset</button>
                    <button class="randomizeBtn">Randomize</button>
                </div>
            `;
            this.container.appendChild(simulationDiv);
            this.simDiv = simulationDiv;

            // Set canvas size
            const canvas = this.simDiv.querySelector(`#canvas${this.index}`);
            canvas.width = this.simDiv.clientWidth - 22; // Subtract padding and border
            canvas.height = window.innerHeight * 0.6; // 60% of window height
        }

        setupEventListeners() {
            const startBtn = this.simDiv.querySelector('.startBtn');
            const resetBtn = this.simDiv.querySelector('.resetBtn');
            const randomizeBtn = this.simDiv.querySelector('.randomizeBtn');
            const controls = this.simDiv.querySelectorAll('input');

            startBtn.addEventListener('click', () => this.toggleSimulation());
            resetBtn.addEventListener('click', () => this.resetSimulation());
            randomizeBtn.addEventListener('click', () => this.randomizeSimulation());
            controls.forEach(control => {
                control.addEventListener('input', () => this.updatePendulum());
            });
        }

        toggleSimulation() {
            this.pendulum.isRunning = !this.pendulum.isRunning;
            const startBtn = this.simDiv.querySelector('.startBtn');
            startBtn.textContent = this.pendulum.isRunning ? 'Stop' : 'Start';
            if (this.pendulum.isRunning) {
                this.animate();
            }
        }

        resetSimulation() {
            this.pendulum.reset();
            this.pendulum.isRunning = false;
            const startBtn = this.simDiv.querySelector('.startBtn');
            startBtn.textContent = 'Start';
            this.updateControlsFromPendulum();
            this.pendulum.draw();
        }

        randomizeSimulation() {
            this.pendulum.randomize();
            this.updateControlsFromPendulum();
            this.pendulum.draw();
        }

        updatePendulum() {
            const length1 = this.simDiv.querySelector(`#length1_${this.index}`).value;
            const length2 = this.simDiv.querySelector(`#length2_${this.index}`).value;
            const angle1 = this.simDiv.querySelector(`#angle1_${this.index}`).value;
            const angle2 = this.simDiv.querySelector(`#angle2_${this.index}`).value;
            const mass1 = this.simDiv.querySelector(`#mass1_${this.index}`).value;
            const mass2 = this.simDiv.querySelector(`#mass2_${this.index}`).value;
            const damping = this.simDiv.querySelector(`#damping_${this.index}`).value;

            this.pendulum.length1 = parseFloat(length1);
            this.pendulum.length2 = parseFloat(length2);
            this.pendulum.theta1 = parseFloat(angle1) * Math.PI / 180;
            this.pendulum.theta2 = parseFloat(angle2) * Math.PI / 180;
            this.pendulum.mass1 = parseFloat(mass1);
            this.pendulum.mass2 = parseFloat(mass2);
            this.pendulum.damping = parseFloat(damping);
            this.pendulum.omega1 = 0;
            this.pendulum.omega2 = 0;
            this.pendulum.draw();
        }

        updateControlsFromPendulum() {
            this.simDiv.querySelector(`#length1_${this.index}`).value = this.pendulum.length1;
            this.simDiv.querySelector(`#length2_${this.index}`).value = this.pendulum.length2;
            this.simDiv.querySelector(`#angle1_${this.index}`).value = this.pendulum.theta1 * 180 / Math.PI;
            this.simDiv.querySelector(`#angle2_${this.index}`).value = this.pendulum.theta2 * 180 / Math.PI;
            this.simDiv.querySelector(`#mass1_${this.index}`).value = this.pendulum.mass1;
            this.simDiv.querySelector(`#mass2_${this.index}`).value = this.pendulum.mass2;
            this.simDiv.querySelector(`#damping_${this.index}`).value = this.pendulum.damping;
        }

        animate() {
            if (!this.pendulum.isRunning) return;
            this.pendulum.update(1/60);  // Assume 60 FPS
            this.pendulum.draw();
            requestAnimationFrame(() => this.animate());
        }
    }

    class SimulationManager {
        constructor() {
            this.simulations = [];
            this.setupGlobalControls();
        }

        setupGlobalControls() {
            document.getElementById('startAllBtn').addEventListener('click', () => this.startAll());
            document.getElementById('resetAllBtn').addEventListener('click', () => this.resetAll());
            document.getElementById('randomizeAllBtn').addEventListener('click', () => this.randomizeAll());
            document.getElementById('updateNumBtn').addEventListener('click', () => this.updateNumPendulums());
        }

        createSimulations(num) {
            const container = document.getElementById('simulations');
            container.innerHTML = '';
            this.simulations = [];
            for (let i = 0; i < num; i++) {
                this.simulations.push(new Simulation('simulations', i, num));
            }
        }

        startAll() {
            this.simulations.forEach(sim => {
                if (!sim.pendulum.isRunning) {
                    sim.toggleSimulation();
                }
            });
        }

        resetAll() {
            this.simulations.forEach(sim => sim.resetSimulation());
        }

        randomizeAll() {
            this.simulations.forEach(sim => sim.randomizeSimulation());
        }

        updateNumPendulums() {
            const num = parseInt(document.getElementById('numPendulums').value);
            if (num >= 1 && num <= 10) {
                this.createSimulations(num);
            } else {
                alert('Please enter a number between 1 and 10');
            }
        }
    }

    // Initialize the simulation
    const manager = new SimulationManager();
    manager.createSimulations(2);
    </script>
</body>
</html>