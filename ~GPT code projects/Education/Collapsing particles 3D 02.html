<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Barnes-Hut N-Body Simulation with Collisions</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      color: white;
      font-family: Arial, sans-serif;
    }
    button {
      margin: 5px;
    }
    #progress-bar-container {
      position: absolute;
      top: 90px;
      left: 10px;
      width: 300px;
      height: 20px;
      border: 1px solid #ccc;
      background: #222;
      display: none; /* Hide initially */
    }
    #progress-bar {
      width: 0%;
      height: 100%;
      background: #4caf50;
    }
    #particle-count {
      position: absolute;
      top: 120px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>Particles: <input type="number" id="numParticles" value="1000" min="1"></label>
    <label>Steps: <input type="number" id="numSteps" value="500" min="1"></label>
    <label>Spread: <input type="number" id="spread" value="500" min="1"></label>
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="replayBtn" disabled>Replay</button>
  </div>

  <div id="progress-bar-container">
    <div id="progress-bar"></div>
  </div>
  <div id="particle-count">Particles: 0</div>

  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.141.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.141.0/examples/jsm/controls/OrbitControls.js';

    // Initialize Scene, Camera, and Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 100;
    controls.maxDistance = 3000;

    let particles = [];
    let steps = [];
    let running = false;
    let currentStep = 0;
    let progressBar = document.getElementById('progress-bar');
    let progressBarContainer = document.getElementById('progress-bar-container');
    let particleCountDisplay = document.getElementById('particle-count');
    let animationFrameId = null;

    const dt = 0.1;
    const G = 1.0;
    const softening = 0.01;

    class Particle {
      constructor(x, y, z, vx, vy, vz, mass) {
        this.position = new THREE.Vector3(x, y, z);
        this.velocity = new THREE.Vector3(vx, vy, vz);
        this.mass = mass;
        this.radius = Math.cbrt(mass);

        const geometry = new THREE.SphereGeometry(this.radius);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.mesh = new THREE.Mesh(geometry, material);
        scene.add(this.mesh);
      }

      updatePosition() {
        this.position.add(this.velocity.clone().multiplyScalar(dt));
        this.mesh.position.copy(this.position);
      }
    }

    // Basic render loop to keep scene visible during calculations
    function render() {
      controls.update();
      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(render);
    }

    function updateParticleCount() {
      particleCountDisplay.textContent = `Particles: ${particles.length}`;
    }

    function clearScene() {
      while (scene.children.length > 0) {
        scene.remove(scene.children[0]);
      }
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    }

    function initParticles(numParticles, spread) {
      particles = [];
      for (let i = 0; i < numParticles; i++) {
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI;
        const radius = spread * Math.sqrt(Math.random());

        const x = radius * Math.sin(angle2) * Math.cos(angle1);
        const y = radius * Math.sin(angle2) * Math.sin(angle1);
        const z = radius * Math.cos(angle2);

        const vx = Math.random() * 0.2 - 0.1;
        const vy = Math.random() * 0.2 - 0.1;
        const vz = Math.random() * 0.2 - 0.1;

        const mass = Math.random() * 10 + 1;
        particles.push(new Particle(x, y, z, vx, vy, vz, mass));
      }
      updateParticleCount();
    }

    function handleCollisions() {
      let newParticles = [];
      let merged = new Set();

      for (let i = 0; i < particles.length; i++) {
        if (merged.has(i)) continue;
        for (let j = i + 1; j < particles.length; j++) {
          if (merged.has(j)) continue;

          const p1 = particles[i];
          const p2 = particles[j];
          const dist = p1.position.distanceTo(p2.position);

          if (dist < (p1.radius + p2.radius)) {
            const newMass = p1.mass + p2.mass;
            const newPosition = p1.position.clone().multiplyScalar(p1.mass)
              .add(p2.position.clone().multiplyScalar(p2.mass)).divideScalar(newMass);
            const newVelocity = p1.velocity.clone().multiplyScalar(p1.mass)
              .add(p2.velocity.clone().multiplyScalar(p2.mass)).divideScalar(newMass);
            const newParticle = new Particle(
              newPosition.x, newPosition.y, newPosition.z,
              newVelocity.x, newVelocity.y, newVelocity.z, newMass
            );
            newParticles.push(newParticle);
            merged.add(i);
            merged.add(j);
          }
        }
        if (!merged.has(i)) newParticles.push(particles[i]);
      }
      particles = newParticles;
      updateParticleCount();
    }

    async function prerenderSimulation(numSteps) {
      progressBarContainer.style.display = 'block';
      steps = [];
      
      // Start basic render loop
      render();

      for (let i = 0; i < numSteps; i++) {
        handleCollisions();
        particles.forEach(p => p.updatePosition());
        steps.push(particles.map(p => ({ pos: p.position.clone(), vel: p.velocity.clone() })));
        progressBar.style.width = `${(i / numSteps) * 100}%`;
        if (i % 10 === 0) await new Promise(r => setTimeout(r, 1));
      }
      progressBarContainer.style.display = 'none';
    }

    function animateReplay() {
      let stepIndex = 0;
      
      function animate() {
        if (stepIndex >= steps.length) {
          cancelAnimationFrame(animationFrameId);
          return;
        }
        
        particles.forEach((p, i) => {
          if (steps[stepIndex][i]) {  // Check if the step data exists
            p.position.copy(steps[stepIndex][i].pos);
            p.mesh.position.copy(p.position);
          }
        });
        
        controls.update();
        renderer.render(scene, camera);
        stepIndex++;
        animationFrameId = requestAnimationFrame(animate);
      }
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      animate();
    }

    document.getElementById('startBtn').addEventListener('click', async () => {
      clearScene();
      const numParticles = parseInt(document.getElementById('numParticles').value);
      const numSteps = parseInt(document.getElementById('numSteps').value);
      const spread = parseInt(document.getElementById('spread').value);
      initParticles(numParticles, spread);
      await prerenderSimulation(numSteps);
      document.getElementById('replayBtn').disabled = false;
      animateReplay();
    });

    document.getElementById('replayBtn').addEventListener('click', animateReplay);

    document.getElementById('stopBtn').addEventListener('click', () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    });

    // Handle window resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    camera.position.z = 1500;
    
    // Start initial render loop
    render();
  </script>
</body>
</html>