<!DOCTYPE html>
<html>
<head>
    <title>Large-Scale Gravitational Accretion Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: inline-block;
            width: 150px;
        }
        .checkbox-container {
            margin: 10px 0;
        }
        #distance-indicator {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="togglePause()">Play/Pause</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="centerView()">Return to Center</button>
        <div>Particles: <span id="particleCount">0</span></div>
        <div>Largest Mass: <span id="largestMass">1.0</span></div>
        <div class="checkbox-container">
            <label>
                <input type="checkbox" checked onchange="toggleCenterTracking()">
                Track Largest Mass
            </label>
        </div>
        <div class="slider-container">
            <label>Population: </label>
            <input type="range" min="500" max="5000" step="100" value="2000" oninput="updatePopulation(this.value)">
            <span id="populationValue">2000</span>
        </div>
        <div class="slider-container">
            <label>Base Zoom: </label>
            <input type="range" min="0.01" max="0.2" step="0.01" value="0.05" oninput="updateZoom(this.value)">
            <span id="zoomValue">0.05x</span>
        </div>
        <div class="slider-container">
            <label>View Scale (Linearâ†’Log): </label>
            <input type="range" min="1" max="10" step="0.1" value="1" oninput="updateViewScale(this.value)">
            <span id="viewScaleValue">1.0</span>
        </div>
        <div class="slider-container">
            <label>Time Speed: </label>
            <input type="range" min="0.1" max="5" step="0.1" value="1" oninput="updateTimeStep(this.value)">
            <span id="timeValue">1.0x</span>
        </div>
        <div class="slider-container">
            <label>Gravity Strength: </label>
            <input type="range" min="0.1" max="100" step="0.1" value="1" oninput="updateGravity(this.value)">
            <span id="gravityValue">1.0x</span>
        </div>
    </div>
    <div id="distance-indicator"></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const distanceIndicator = document.getElementById('distance-indicator');
        
        let isPaused = true;
        let zoom = 0.05;
        let viewScale = 1;
        let timeMultiplier = 1;
        let gravityMultiplier = 1;
        let largestMass = 1;
        let largestParticle = null;
        let particleCount = 2000;
        let trackCenter = true;
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        const WORLD_SIZE = 50000000; // 1000x larger world
        const INITIAL_RADIUS = 50000; // Initial particle distribution radius
        const BASE_G = 6.67430e-11 * 1e13;
        let G = BASE_G;
        const SOFTENING = 100;
        const BASE_TIME_STEP = 0.2;
        let TIME_STEP = BASE_TIME_STEP;
        const BASE_RADIUS = 8;
        const MAX_VELOCITY = 1000;
        const FLASH_DURATION = 20;
        const MIN_PARTICLE_SIZE = 2;
        const CENTER_LINEAR_RADIUS = 10000; // Region that stays linear
        
        const CLOCKWISE_COLOR = '#ffff00';
        const ANTICLOCKWISE_COLOR = '#00ff00';
        const LARGEST_COLOR = '#ffffff';

        function scaleDistance(distance) {
            if (viewScale === 1 || distance <= CENTER_LINEAR_RADIUS) {
                return distance;
            }
            
            const logBase = Math.pow(10, viewScale - 1);
            if (distance <= CENTER_LINEAR_RADIUS) {
                return distance;
            }
            
            const scaledDistance = CENTER_LINEAR_RADIUS + 
                (Math.log(distance / CENTER_LINEAR_RADIUS) / Math.log(logBase)) * 
                (distance - CENTER_LINEAR_RADIUS) / 
                (Math.log(WORLD_SIZE / CENTER_LINEAR_RADIUS) / Math.log(logBase));
            
            return scaledDistance;
        }

        function unscaleDistance(scaledDistance) {
            if (viewScale === 1 || scaledDistance <= CENTER_LINEAR_RADIUS) {
                return scaledDistance;
            }
            
            const logBase = Math.pow(10, viewScale - 1);
            return CENTER_LINEAR_RADIUS * Math.pow(logBase, 
                (scaledDistance - CENTER_LINEAR_RADIUS) * 
                (Math.log(WORLD_SIZE / CENTER_LINEAR_RADIUS) / Math.log(logBase)) / 
                (WORLD_SIZE - CENTER_LINEAR_RADIUS));
        }

        class Flash {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.life = FLASH_DURATION;
            }

            draw() {
                if (this.life <= 0) return false;
                
                const scaledX = scaleDistance(this.x - WORLD_SIZE/2) + WORLD_SIZE/2;
                const scaledY = scaleDistance(this.y - WORLD_SIZE/2) + WORLD_SIZE/2;
                
                const screenX = (scaledX - cameraX) * zoom + canvas.width / 2;
                const screenY = (scaledY - cameraY) * zoom + canvas.height / 2;
                
                const alpha = this.life / FLASH_DURATION;
                const size = this.size * (2 - alpha) * zoom;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
                
                this.life--;
                return true;
            }
        }

        let flashes = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let cameraX = WORLD_SIZE / 2;
        let cameraY = WORLD_SIZE / 2;

        function centerView() {
            cameraX = WORLD_SIZE / 2;
            cameraY = WORLD_SIZE / 2;
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                // Adjust drag sensitivity based on view scale
                const dragFactor = Math.pow(viewScale, 0.5);
                cameraX -= (dx / zoom) * dragFactor;
                cameraY -= (dy / zoom) * dragFactor;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
            
            // Update distance indicator
            const worldX = unscaleDistance((e.clientX - canvas.width/2)/zoom + cameraX - WORLD_SIZE/2) + WORLD_SIZE/2;
            const worldY = unscaleDistance((e.clientY - canvas.height/2)/zoom + cameraY - WORLD_SIZE/2) + WORLD_SIZE/2;
            const distanceFromCenter = Math.sqrt(
                Math.pow(worldX - WORLD_SIZE/2, 2) + 
                Math.pow(worldY - WORLD_SIZE/2, 2)
            );
            distanceIndicator.textContent = `Distance from center: ${Math.round(distanceFromCenter).toLocaleString()} units`;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.mass = 1;
                this.radius = Math.sqrt(this.mass) * BASE_RADIUS;
                this.merged = false;
                this.orbitDirection = 0;
            }

            getOrbitDirection() {
                if (!largestParticle || this === largestParticle) return 0;

                const dx = this.x - largestParticle.x;
                const dy = this.y - largestParticle.y;
                const dvx = this.vx - largestParticle.vx;
                const dvy = this.vy - largestParticle.vy;

                const crossProduct = dx * dvy - dy * dvx;

                return Math.sign(crossProduct);
            }

            update(particles) {
                if (this.merged) return;

                let fx = 0;
                let fy = 0;

                for (let other of particles) {
                    if (other === this || other.merged) continue;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);

                    if (dist < (this.radius + other.radius)) {
                        if (this.mass >= other.mass) {
                            const oldMass = this.mass;
                            this.mass += other.mass;
                            this.radius = Math.sqrt(this.mass) * BASE_RADIUS;
                            
                            const totalMass = this.mass;
                            const massRatio = other.mass / totalMass;
                            this.vx = this.vx * (1 - massRatio) + other.vx * massRatio;
                            this.vy = this.vy * (1 - massRatio) + other.vy * massRatio;
                            
                            other.merged = true;
                            
                            flashes.push(new Flash(this.x, this.y, this.radius * 2));
                            
                            if (this.mass > largestMass) {
                                largestMass = this.mass;
                                largestParticle = this;
                                document.getElementById('largestMass').textContent = largestMass.toFixed(1);
                            }
                        }
                        continue;
                    }

                    const softenedDistSq = distSq + SOFTENING * (1 + Math.log10(this.mass + other.mass));
                    const force = G * this.mass * other.mass / softenedDistSq;
                    const dampening = 1 / (1 + dist * 0.0001);
                    fx += force * dx / dist * dampening;
                    fy += force * dy / dist * dampening;
                }

                const massDamping = 1 / (1 + Math.log10(this.mass) * 0.5);
                const ax = (fx / this.mass) * massDamping;
                const ay = (fy / this.mass) * massDamping;
                
                this.vx += ax * TIME_STEP;
                this.vy += ay * TIME_STEP;
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > MAX_VELOCITY) {
                    const scale = MAX_VELOCITY / speed;
                    this.vx *= scale;
                    this.vy *= scale;
                }
                
                const posDamping = 1 / (1 + Math.log10(this.mass) * 0.2);
                this.x += this.vx * TIME_STEP * posDamping;
                this.y += this.vy * TIME_STEP * posDamping;

                // Toroidal wrapping with the larger world size
                if (this.x < 0) this.x = WORLD_SIZE;
                if (this.x > WORLD_SIZE) this.x = 0;
                if (this.y < 0) this.y = WORLD_SIZE;
                if (this.y > WORLD_SIZE) this.y = 0;

                this.orbitDirection = this.getOrbitDirection();
            }

            draw() {
                if (this.merged) return;

                // Scale position based on view scale
                const scaledX = scaleDistance(this.x - WORLD_SIZE/2) + WORLD_SIZE/2;
                const scaledY = scaleDistance(this.y - WORLD_SIZE/2) + WORLD_SIZE/2;
                
                const screenX = (scaledX - cameraX) * zoom + canvas.width / 2;
                const screenY = (scaledY - cameraY) * zoom + canvas.height / 2;

                if (screenX < -100 || screenX > canvas.width + 100 ||
                    screenY < -100 || screenY > canvas.height + 100) return;

                const distanceFromCenter = Math.sqrt(
                    Math.pow(this.x - WORLD_SIZE/2, 2) + 
                    Math.pow(this.y - WORLD_SIZE/2, 2)
                );

                // Adjust particle size based on distance from center and view scale
                let sizeAdjustment = 1;
                if (distanceFromCenter > CENTER_LINEAR_RADIUS) {
                    sizeAdjustment = Math.pow(viewScale, 0.5);
                }
                const renderedSize = Math.max(MIN_PARTICLE_SIZE, 
                    this.radius * zoom * sizeAdjustment);

                ctx.beginPath();
                ctx.arc(screenX, screenY, renderedSize, 0, Math.PI * 2);
                
                if (this === largestParticle) {
                    ctx.fillStyle = LARGEST_COLOR;
                } else {
                    // Color gradient based on distance from center
                    const normalizedDistance = Math.min(1, distanceFromCenter / WORLD_SIZE);
                    switch (this.orbitDirection) {
                        case 1:  
                            ctx.fillStyle = CLOCKWISE_COLOR;
                            break;
                        case -1: 
                            ctx.fillStyle = ANTICLOCKWISE_COLOR;
                            break;
                        default: 
                            ctx.fillStyle = `hsl(200, 80%, ${70 - normalizedDistance * 40}%)`;
                    }
                }
                ctx.fill();
            }
        }

        let particles = [];
        function initParticles() {
            particles = [];
            flashes = [];
            largestMass = 1;
            largestParticle = null;
            document.getElementById('largestMass').textContent = largestMass.toFixed(1);

            // Create particles in a circular distribution
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(Math.random()) * INITIAL_RADIUS; // Square root for uniform distribution
                const x = WORLD_SIZE/2 + radius * Math.cos(angle);
                const y = WORLD_SIZE/2 + radius * Math.sin(angle);
                
                const particle = new Particle(x, y);
                
                // Add initial orbital velocity
                const orbitSpeed = Math.sqrt(G * radius) * 0.5;
                particle.vx = -orbitSpeed * Math.sin(angle);
                particle.vy = orbitSpeed * Math.cos(angle);
                
                particles.push(particle);
            }
        }

        function drawGrid() {
            const gridStep = CENTER_LINEAR_RADIUS;
            const maxGrids = 5;
            
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
            ctx.lineWidth = 1;

            // Draw circular distance markers
            for (let i = 1; i <= maxGrids; i++) {
                const radius = i * gridStep;
                const scaledRadius = scaleDistance(radius);
                
                ctx.beginPath();
                ctx.arc(
                    (WORLD_SIZE/2 - cameraX) * zoom + canvas.width/2,
                    (WORLD_SIZE/2 - cameraY) * zoom + canvas.height/2,
                    scaledRadius * zoom,
                    0, Math.PI * 2
                );
                ctx.stroke();

                // Add distance labels
                const labelX = (WORLD_SIZE/2 - cameraX + scaledRadius) * zoom + canvas.width/2;
                const labelY = (WORLD_SIZE/2 - cameraY) * zoom + canvas.height/2;
                ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.fillText(`${radius.toLocaleString()} units`, labelX + 5, labelY);
            }
        }

        function toggleCenterTracking() {
            trackCenter = !trackCenter;
        }

        function updateParticles() {
            if (isPaused) return;
            
            for (let particle of particles) {
                particle.update(particles);
            }
            
            particles = particles.filter(p => !p.merged);
            document.getElementById('particleCount').textContent = particles.length;

            if (!isDragging && trackCenter && largestParticle) {
                cameraX = largestParticle.x;
                cameraY = largestParticle.y;
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();
            
            for (let particle of particles) {
                particle.draw();
            }

            flashes = flashes.filter(flash => flash.draw());

            requestAnimationFrame(draw);
        }

        function togglePause() {
            isPaused = !isPaused;
        }

        function updatePopulation(value) {
            particleCount = parseInt(value);
            document.getElementById('populationValue').textContent = particleCount;
            resetSimulation();
        }

        function resetSimulation() {
            initParticles();
        }

        function updateZoom(value) {
            zoom = parseFloat(value);
            document.getElementById('zoomValue').textContent = zoom.toFixed(2) + 'x';
        }

        function updateViewScale(value) {
            viewScale = parseFloat(value);
            document.getElementById('viewScaleValue').textContent = viewScale.toFixed(1);
        }

        function updateTimeStep(value) {
            timeMultiplier = parseFloat(value);
            TIME_STEP = BASE_TIME_STEP * timeMultiplier;
            document.getElementById('timeValue').textContent = timeMultiplier.toFixed(1) + 'x';
        }

        function updateGravity(value) {
            gravityMultiplier = parseFloat(value);
            G = BASE_G * gravityMultiplier;
            document.getElementById('gravityValue').textContent = gravityMultiplier.toFixed(1) + 'x';
        }

        initParticles();
        setInterval(updateParticles, 1000 / 60);
        draw();
    </script>
</body>
</html>