<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flocking - Advanced Behaviors</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            font-size: 12px;
            border: 1px solid #333;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            font-size: 11px;
            border: 1px solid #333;
            max-width: 200px;
        }
        #controls label {
            display: block;
            margin: 4px 0;
        }
        #controls input[type="range"] {
            width: 100%;
            margin: 2px 0;
        }
        #controls button {
            width: 100%;
            margin: 2px 0;
            padding: 4px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            cursor: pointer;
        }
        #controls button:hover {
            background: #333;
        }
        .behavior-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>Arrows: <span id="count">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div>Avg Energy: <span id="energy">100</span>%</div>
        <div style="margin-top: 8px;">
            <div><span class="behavior-indicator" style="background: #0ff;"></span>Normal</div>
            <div><span class="behavior-indicator" style="background: #f0f;"></span>Mating</div>
            <div><span class="behavior-indicator" style="background: #ff0;"></span>Hungry</div>
            <div><span class="behavior-indicator" style="background: #f00;"></span>Fleeing</div>
            <div><span class="behavior-indicator" style="background: #0f0;"></span>Perched</div>
        </div>
        <div style="margin-top: 8px;">Click: predator | Shift+Click: food</div>
    </div>
    <div id="controls">
        <h4 style="margin: 0 0 8px 0;">Core Behaviors</h4>
        <label>Separation: <input type="range" id="separation" min="0" max="5" step="0.5" value="1.5"></label>
        <label>Alignment: <input type="range" id="alignment" min="0" max="5" step="0.5" value="1"></label>
        <label>Cohesion: <input type="range" id="cohesion" min="0" max="5" step="0.5" value="1"></label>
        <label>Wander: <input type="range" id="wander" min="0" max="2" step="0.1" value="0.3"></label>
        
        <h4 style="margin: 8px 0;">Advanced Behaviors</h4>
        <label>Fear Level: <input type="range" id="fear" min="0" max="5" step="0.5" value="2"></label>
        <label>Hunger Rate: <input type="range" id="hunger" min="0" max="0.01" step="0.001" value="0.002"></label>
        <label>Mating Drive: <input type="range" id="mating" min="0" max="1" step="0.1" value="0.3"></label>
        <label>Rest Need: <input type="range" id="fatigue" min="0" max="0.01" step="0.001" value="0.003"></label>
        
        <h4 style="margin: 8px 0;">Environment</h4>
        <button id="addPerch">Add Perch Zone</button>
        <button id="clearPerches">Clear Perches</button>
        <button id="addFood">Spawn Food</button>
        
        <h4 style="margin: 8px 0;">Simulation</h4>
        <label>Count: <input type="range" id="arrowCount" min="500" max="5000" step="500" value="2000"></label>
        <label>Speed: <input type="range" id="maxSpeed" min="1" max="8" step="0.5" value="4"></label>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Performance settings
        ctx.imageSmoothingEnabled = false;
        
        // Constants
        const PI2 = Math.PI * 2;
        const HALF_WIDTH = canvas.width * 0.5;
        const HALF_HEIGHT = canvas.height * 0.5;
        
        // Behavior states
        const STATE_NORMAL = 0;
        const STATE_MATING = 1;
        const STATE_HUNGRY = 2;
        const STATE_FLEEING = 3;
        const STATE_PERCHED = 4;
        
        // Flocking parameters
        let sepWeight = 1.5;
        let aliWeight = 1;
        let cohWeight = 1;
        let wanderWeight = 0.3;
        let fearLevel = 2;
        let hungerRate = 0.002;
        let matingDrive = 0.3;
        let fatigueRate = 0.003;
        let maxSpeed = 4;
        let maxForce = 0.2;
        const perceptionRadius = 50;
        const perceptionRadiusSq = perceptionRadius * perceptionRadius;
        const avoidRadius = 25;
        const avoidRadiusSq = avoidRadius * avoidRadius;
        
        // Environment
        const predators = [];
        const food = [];
        const perches = [];
        let mouseX = -1000;
        let mouseY = -1000;
        
        // Performance
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        
        // Spatial grid
        const gridSize = 100;
        const gridCols = Math.ceil(canvas.width / gridSize) + 1;
        const gridRows = Math.ceil(canvas.height / gridSize) + 1;
        const grid = new Array(gridCols * gridRows);
        
        // Arrow data - expanded for behaviors
        let arrowCount = 2000;
        const maxArrows = 5000;
        const posX = new Float32Array(maxArrows);
        const posY = new Float32Array(maxArrows);
        const velX = new Float32Array(maxArrows);
        const velY = new Float32Array(maxArrows);
        const accX = new Float32Array(maxArrows);
        const accY = new Float32Array(maxArrows);
        const energy = new Float32Array(maxArrows);
        const hunger = new Float32Array(maxArrows);
        const matingUrge = new Float32Array(maxArrows);
        const state = new Uint8Array(maxArrows);
        const stateTimer = new Float32Array(maxArrows);
        const targetX = new Float32Array(maxArrows);
        const targetY = new Float32Array(maxArrows);
        const wanderAngle = new Float32Array(maxArrows);
        
        // Initialize arrows
        function initArrows(count) {
            arrowCount = count;
            for (let i = 0; i < count; i++) {
                posX[i] = Math.random() * canvas.width;
                posY[i] = Math.random() * canvas.height;
                velX[i] = (Math.random() - 0.5) * maxSpeed;
                velY[i] = (Math.random() - 0.5) * maxSpeed;
                accX[i] = 0;
                accY[i] = 0;
                energy[i] = 0.5 + Math.random() * 0.5;
                hunger[i] = Math.random() * 0.5;
                matingUrge[i] = Math.random() * 0.3;
                state[i] = STATE_NORMAL;
                stateTimer[i] = 0;
                targetX[i] = posX[i];
                targetY[i] = posY[i];
                wanderAngle[i] = Math.random() * PI2;
            }
            document.getElementById('count').textContent = count;
        }
        
        initArrows(arrowCount);
        
        // Helper functions
        function distSq(x1, y1, x2, y2) {
            let dx = x1 - x2;
            let dy = y1 - y2;
            
            if (dx > HALF_WIDTH) dx -= canvas.width;
            else if (dx < -HALF_WIDTH) dx += canvas.width;
            if (dy > HALF_HEIGHT) dy -= canvas.height;
            else if (dy < -HALF_HEIGHT) dy += canvas.height;
            
            return dx * dx + dy * dy;
        }
        
        function wrapDiff(x1, y1, x2, y2, out) {
            out.x = x2 - x1;
            out.y = y2 - y1;
            
            if (out.x > HALF_WIDTH) out.x -= canvas.width;
            else if (out.x < -HALF_WIDTH) out.x += canvas.width;
            if (out.y > HALF_HEIGHT) out.y -= canvas.height;
            else if (out.y < -HALF_HEIGHT) out.y += canvas.height;
        }
        
        function setMag(vec, mag) {
            const lenSq = vec.x * vec.x + vec.y * vec.y;
            if (lenSq > 0) {
                const scale = mag / Math.sqrt(lenSq);
                vec.x *= scale;
                vec.y *= scale;
            }
        }
        
        function limit(vec, max) {
            const lenSq = vec.x * vec.x + vec.y * vec.y;
            if (lenSq > max * max) {
                const scale = max / Math.sqrt(lenSq);
                vec.x *= scale;
                vec.y *= scale;
            }
        }
        
        // Build spatial grid
        function buildGrid() {
            for (let i = 0; i < grid.length; i++) {
                grid[i] = null;
            }
            
            for (let i = 0; i < arrowCount; i++) {
                const gx = Math.floor(posX[i] / gridSize);
                const gy = Math.floor(posY[i] / gridSize);
                const idx = gy * gridCols + gx;
                
                const old = grid[idx];
                grid[idx] = { i: i, next: old };
            }
        }
        
        // Get neighbors
        const neighbors = new Uint16Array(50);
        function getNeighbors(i, neighbors) {
            let count = 0;
            const x = posX[i];
            const y = posY[i];
            const gx = Math.floor(x / gridSize);
            const gy = Math.floor(y / gridSize);
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ngx = gx + dx;
                    const ngy = gy + dy;
                    
                    if (ngx >= 0 && ngx < gridCols && ngy >= 0 && ngy < gridRows) {
                        let node = grid[ngy * gridCols + ngx];
                        while (node) {
                            if (node.i !== i) {
                                const dSq = distSq(x, y, posX[node.i], posY[node.i]);
                                if (dSq < perceptionRadiusSq) {
                                    neighbors[count++] = node.i;
                                    if (count >= 50) return count;
                                }
                            }
                            node = node.next;
                        }
                    }
                }
            }
            
            return count;
        }
        
        // Behavior functions
        const sep = { x: 0, y: 0 };
        const ali = { x: 0, y: 0 };
        const coh = { x: 0, y: 0 };
        const diff = { x: 0, y: 0 };
        const wander = { x: 0, y: 0 };
        
        function updateBehaviorState(i) {
            // Update timers
            stateTimer[i] -= 0.016;
            
            // Energy and hunger
            energy[i] -= fatigueRate;
            hunger[i] += hungerRate;
            
            if (energy[i] < 0) energy[i] = 0;
            if (energy[i] > 1) energy[i] = 1;
            if (hunger[i] > 1) hunger[i] = 1;
            
            // State transitions
            switch(state[i]) {
                case STATE_NORMAL:
                    // Check for state changes
                    if (energy[i] < 0.2) {
                        // Find nearest perch
                        let nearestPerch = -1;
                        let nearestDist = Infinity;
                        for (let p = 0; p < perches.length; p++) {
                            const d = distSq(posX[i], posY[i], perches[p].x, perches[p].y);
                            if (d < nearestDist) {
                                nearestDist = d;
                                nearestPerch = p;
                            }
                        }
                        if (nearestPerch >= 0) {
                            state[i] = STATE_PERCHED;
                            targetX[i] = perches[nearestPerch].x;
                            targetY[i] = perches[nearestPerch].y;
                            stateTimer[i] = 3 + Math.random() * 2;
                        }
                    } else if (hunger[i] > 0.7) {
                        state[i] = STATE_HUNGRY;
                    } else if (Math.random() < matingDrive * 0.01 && energy[i] > 0.5) {
                        state[i] = STATE_MATING;
                        stateTimer[i] = 5;
                    }
                    break;
                    
                case STATE_MATING:
                    matingUrge[i] += 0.01;
                    if (stateTimer[i] <= 0 || energy[i] < 0.3) {
                        state[i] = STATE_NORMAL;
                        matingUrge[i] = 0;
                    }
                    break;
                    
                case STATE_HUNGRY:
                    if (hunger[i] < 0.3 || food.length === 0) {
                        state[i] = STATE_NORMAL;
                    }
                    break;
                    
                case STATE_FLEEING:
                    if (stateTimer[i] <= 0) {
                        state[i] = STATE_NORMAL;
                    }
                    break;
                    
                case STATE_PERCHED:
                    energy[i] += 0.02;
                    if (stateTimer[i] <= 0 || energy[i] > 0.9) {
                        state[i] = STATE_NORMAL;
                        // Launch from perch
                        velX[i] = (Math.random() - 0.5) * maxSpeed;
                        velY[i] = (Math.random() - 0.5) * maxSpeed;
                    }
                    break;
            }
            
            // Check for predators
            for (let p = 0; p < predators.length; p++) {
                const d = distSq(posX[i], posY[i], predators[p].x, predators[p].y);
                if (d < 10000 && state[i] !== STATE_PERCHED) {
                    state[i] = STATE_FLEEING;
                    stateTimer[i] = 2;
                    targetX[i] = predators[p].x;
                    targetY[i] = predators[p].y;
                }
            }
        }
        
        function applyBehaviors(i) {
            const x = posX[i];
            const y = posY[i];
            let behaviorForce = { x: 0, y: 0 };
            
            switch(state[i]) {
                case STATE_HUNGRY:
                    // Seek nearest food
                    let nearestFood = -1;
                    let nearestDist = Infinity;
                    for (let f = 0; f < food.length; f++) {
                        const d = distSq(x, y, food[f].x, food[f].y);
                        if (d < nearestDist) {
                            nearestDist = d;
                            nearestFood = f;
                        }
                    }
                    if (nearestFood >= 0) {
                        wrapDiff(x, y, food[nearestFood].x, food[nearestFood].y, behaviorForce);
                        setMag(behaviorForce, maxSpeed * 1.5);
                        behaviorForce.x -= velX[i];
                        behaviorForce.y -= velY[i];
                        limit(behaviorForce, maxForce * 2);
                        
                        // Eat food if close
                        if (nearestDist < 400) {
                            hunger[i] -= 0.1;
                            food[nearestFood].energy -= 0.02;
                            if (food[nearestFood].energy <= 0) {
                                food.splice(nearestFood, 1);
                            }
                        }
                    }
                    break;
                    
                case STATE_MATING:
                    // Spiral dance behavior
                    const angle = Math.atan2(velY[i], velX[i]) + 0.3;
                    behaviorForce.x = Math.cos(angle) * maxSpeed;
                    behaviorForce.y = Math.sin(angle) * maxSpeed;
                    behaviorForce.x -= velX[i];
                    behaviorForce.y -= velY[i];
                    limit(behaviorForce, maxForce);
                    break;
                    
                case STATE_FLEEING:
                    // Flee from target
                    wrapDiff(x, y, targetX[i], targetY[i], behaviorForce);
                    setMag(behaviorForce, -maxSpeed * 2 * fearLevel);
                    behaviorForce.x -= velX[i];
                    behaviorForce.y -= velY[i];
                    limit(behaviorForce, maxForce * 3);
                    break;
                    
                case STATE_PERCHED:
                    // Move to perch
                    wrapDiff(x, y, targetX[i], targetY[i], behaviorForce);
                    const distToPerch = Math.sqrt(behaviorForce.x * behaviorForce.x + behaviorForce.y * behaviorForce.y);
                    if (distToPerch > 20) {
                        setMag(behaviorForce, maxSpeed);
                        behaviorForce.x -= velX[i];
                        behaviorForce.y -= velY[i];
                        limit(behaviorForce, maxForce * 2);
                    } else {
                        // Slow down near perch
                        velX[i] *= 0.9;
                        velY[i] *= 0.9;
                    }
                    break;
            }
            
            accX[i] += behaviorForce.x;
            accY[i] += behaviorForce.y;
        }
        
        function updateArrow(i) {
            // Update behavior state
            updateBehaviorState(i);
            
            // Skip flocking for perched birds
            if (state[i] === STATE_PERCHED) {
                applyBehaviors(i);
                return;
            }
            
            // Reset forces
            sep.x = 0; sep.y = 0;
            ali.x = 0; ali.y = 0;
            coh.x = 0; coh.y = 0;
            let sepCount = 0;
            let total = 0;
            
            const x = posX[i];
            const y = posY[i];
            
            // Get neighbors
            const neighborCount = getNeighbors(i, neighbors);
            
            // Process neighbors
            for (let n = 0; n < neighborCount; n++) {
                const j = neighbors[n];
                const dSq = distSq(x, y, posX[j], posY[j]);
                
                if (dSq < avoidRadiusSq && dSq > 0) {
                    wrapDiff(x, y, posX[j], posY[j], diff);
                    const factor = 1 / Math.sqrt(dSq);
                    sep.x -= diff.x * factor;
                    sep.y -= diff.y * factor;
                    sepCount++;
                }
                
                // Only align/cohere with same state
                if (Math.abs(state[i] - state[j]) <= 1) {
                    ali.x += velX[j];
                    ali.y += velY[j];
                    coh.x += posX[j];
                    coh.y += posY[j];
                    total++;
                }
            }
            
            // Apply separation
            if (sepCount > 0) {
                sep.x /= sepCount;
                sep.y /= sepCount;
                setMag(sep, maxSpeed);
                sep.x -= velX[i];
                sep.y -= velY[i];
                limit(sep, maxForce);
                accX[i] += sep.x * sepWeight;
                accY[i] += sep.y * sepWeight;
            }
            
            // Apply alignment and cohesion
            if (total > 0) {
                // Alignment
                ali.x /= total;
                ali.y /= total;
                setMag(ali, maxSpeed);
                ali.x -= velX[i];
                ali.y -= velY[i];
                limit(ali, maxForce);
                accX[i] += ali.x * aliWeight;
                accY[i] += ali.y * aliWeight;
                
                // Cohesion
                coh.x /= total;
                coh.y /= total;
                wrapDiff(x, y, coh.x, coh.y, diff);
                setMag(diff, maxSpeed);
                diff.x -= velX[i];
                diff.y -= velY[i];
                limit(diff, maxForce);
                accX[i] += diff.x * cohWeight;
                accY[i] += diff.y * cohWeight;
            }
            
            // Wandering
            wanderAngle[i] += (Math.random() - 0.5) * 0.3;
            wander.x = Math.cos(wanderAngle[i]) * wanderWeight;
            wander.y = Math.sin(wanderAngle[i]) * wanderWeight;
            accX[i] += wander.x;
            accY[i] += wander.y;
            
            // Apply behavior-specific forces
            applyBehaviors(i);
        }
        
        // Main update
        function update() {
            buildGrid();
            
            // Update predators
            for (let i = predators.length - 1; i >= 0; i--) {
                predators[i].life -= 0.016;
                if (predators[i].life <= 0) {
                    predators.splice(i, 1);
                }
            }
            
            // Update all arrows
            let totalEnergy = 0;
            for (let i = 0; i < arrowCount; i++) {
                accX[i] = 0;
                accY[i] = 0;
                updateArrow(i);
                
                // Update velocity with energy modifier
                const energyMod = 0.5 + energy[i] * 0.5;
                velX[i] += accX[i];
                velY[i] += accY[i];
                
                // Limit speed based on energy
                const currentMaxSpeed = maxSpeed * energyMod;
                const vSq = velX[i] * velX[i] + velY[i] * velY[i];
                if (vSq > currentMaxSpeed * currentMaxSpeed) {
                    const scale = currentMaxSpeed / Math.sqrt(vSq);
                    velX[i] *= scale;
                    velY[i] *= scale;
                }
                
                // Update position
                posX[i] += velX[i];
                posY[i] += velY[i];
                
                // Wrap edges
                if (posX[i] < 0) posX[i] += canvas.width;
                else if (posX[i] > canvas.width) posX[i] -= canvas.width;
                if (posY[i] < 0) posY[i] += canvas.height;
                else if (posY[i] > canvas.height) posY[i] -= canvas.height;
                
                totalEnergy += energy[i];
            }
            
            // Update UI
            document.getElementById('energy').textContent = Math.round(totalEnergy / arrowCount * 100);
        }
        
        // Render
        function render() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw perches
            ctx.fillStyle = 'rgba(0,100,0,0.3)';
            for (let p of perches) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 50, 0, PI2);
                ctx.fill();
            }
            
            // Draw food
            ctx.fillStyle = '#ff0';
            for (let f of food) {
                ctx.beginPath();
                ctx.arc(f.x, f.y, 5 * f.energy, 0, PI2);
                ctx.fill();
            }
            
            // Draw predators
            ctx.fillStyle = 'rgba(255,0,0,0.8)';
            for (let p of predators) {
                const alpha = p.life / 3;
                ctx.fillStyle = `rgba(255,0,0,${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 10, 0, PI2);
                ctx.fill();
            }
            
            // Draw arrows by state
            const colors = ['#0ff', '#f0f', '#ff0', '#f00', '#0f0'];
            
            for (let s = 0; s < 5; s++) {
                ctx.fillStyle = colors[s];
                ctx.beginPath();
                
                for (let i = 0; i < arrowCount; i++) {
                    if (state[i] !== s) continue;
                    
                    const x = posX[i];
                    const y = posY[i];
                    const angle = Math.atan2(velY[i], velX[i]);
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const size = state[i] === STATE_PERCHED ? 4 : 8;
                    
                    const x1 = x + cos * size;
                    const y1 = y + sin * size;
                    const x2 = x - cos * size/2 - sin * size/2.5;
                    const y2 = y - sin * size/2 + cos * size/2.5;
                    const x3 = x - cos * size/2 + sin * size/2.5;
                    const y3 = y - sin * size/2 - cos * size/2.5;
                    
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                }
                
                ctx.fill();
            }
        }
        
        // Animation loop
        function animate() {
            update();
            render();
            
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps').textContent = fps;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Event handlers
        canvas.addEventListener('click', (e) => {
            if (e.shiftKey) {
                // Add food
                food.push({ x: e.clientX, y: e.clientY, energy: 1 });
            } else {
                // Add predator
                predators.push({ x: e.clientX, y: e.clientY, life: 3 });
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Control handlers
        document.getElementById('separation').addEventListener('input', (e) => {
            sepWeight = parseFloat(e.target.value);
        });
        document.getElementById('alignment').addEventListener('input', (e) => {
            aliWeight = parseFloat(e.target.value);
        });
        document.getElementById('cohesion').addEventListener('input', (e) => {
            cohWeight = parseFloat(e.target.value);
        });
        document.getElementById('wander').addEventListener('input', (e) => {
            wanderWeight = parseFloat(e.target.value);
        });
        document.getElementById('fear').addEventListener('input', (e) => {
            fearLevel = parseFloat(e.target.value);
        });
        document.getElementById('hunger').addEventListener('input', (e) => {
            hungerRate = parseFloat(e.target.value);
        });
        document.getElementById('mating').addEventListener('input', (e) => {
            matingDrive = parseFloat(e.target.value);
        });
        document.getElementById('fatigue').addEventListener('input', (e) => {
            fatigueRate = parseFloat(e.target.value);
        });
        document.getElementById('maxSpeed').addEventListener('input', (e) => {
            maxSpeed = parseFloat(e.target.value);
        });
        document.getElementById('arrowCount').addEventListener('input', (e) => {
            initArrows(parseInt(e.target.value));
        });
        
        // Button handlers
        document.getElementById('addPerch').addEventListener('click', () => {
            perches.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            });
        });
        
        document.getElementById('clearPerches').addEventListener('click', () => {
            perches.length = 0;
        });
        
        document.getElementById('addFood').addEventListener('click', () => {
            for (let i = 0; i < 5; i++) {
                food.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    energy: 1
                });
            }
        });
        
        // Start with some perches and food
        for (let i = 0; i < 3; i++) {
            perches.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height
            });
        }
        
        for (let i = 0; i < 10; i++) {
            food.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                energy: 1
            });
        }
        
        // Start animation
        animate();
    </script>
</body>
</html>