<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disc Accretion Simulation (Barnes–Hut) with Zoom & Pan - Full Code</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      max-width: 800px;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 1em;
    }
    #controls label {
      display: inline-flex;
      align-items: center;
    }

    #computeControls, #replayControls {
      margin: 10px 0;
    }

    #progressBarContainer {
      width: 300px;
      background-color: #e0e0e0;
      border: 1px solid #ccc;
      height: 20px;
      position: relative;
      margin-bottom: 10px;
    }
    #progressBar {
      background-color: #76c7c0;
      height: 100%;
      width: 0%;
      transition: width 0.2s;
    }

    .hidden {
      display: none;
    }

    /* Canvas for 2D rendering (600×600) */
    #replayCanvas {
      border: 1px solid #aaa;
      background: #000;
      display: block;
      width: 600px;
      height: 600px;
      cursor: crosshair; /* We'll change to 'grab' or 'grabbing' in code if desired */
    }

    #sliderContainer {
      width: 600px;
    }
    #scrubSlider {
      width: 100%;
      box-sizing: border-box;
    }

    #memoryInfo {
      font-size: 0.9em;
      color: #444;
      margin-left: 10px;
    }
    #particleCountLive {
      margin-left: 10px;
      font-size: 0.9em;
      color: #444;
    }
  </style>
</head>
<body>
<h1>Disc Accretion Simulation (Barnes–Hut) with Zoom & Pan</h1>

<!-- Parameter Controls -->
<div id="controls">
  <label>Particles:
    <input type="number" id="particleCount" value="1000" style="width:80px;" />
  </label>
  <label>Steps:
    <input type="number" id="numSteps" value="50000" style="width:80px;" />
  </label>
  <label>Δt:
    <input type="number" id="timeStep" value="0.05" step="0.01" style="width:60px;" />
  </label>
  <label>ε:
    <input type="number" id="softening" value="0.01" step="0.001" style="width:60px;" />
  </label>
  <label>θ:
    <input type="number" id="theta" value="0.5" step="0.1" style="width:50px;" />
  </label>
  <label>G:
    <input type="number" id="gravConst" value="1.0" step="0.1" style="width:50px;" />
  </label>
  <label>Spread:
    <input type="number" id="initialSpread" value="700" style="width:70px;" />
  </label>
  <label>
    <input type="checkbox" id="immediatelyCalculate" checked />
    Immediately Calculate
  </label>
</div>

<!-- Computation Controls -->
<div id="computeControls">
  <button id="startBtn">Start Calculation</button>
  <button id="stopBtn">Stop Calculation</button>
  <span id="memoryInfo">Memory Used: 0 MB / 200 MB</span>
  <span id="particleCountLive">Particles: 0</span>
</div>

<!-- Progress Bar Container -->
<div id="progressBarContainer">
  <div id="progressBar"></div>
</div>

<hr/>

<!-- Replay UI -->
<div id="replayControls" class="hidden">
  <div style="margin-bottom:10px;">
    <button id="replayStartBtn">Start Replay</button>
    <button id="replayStopBtn">Stop Replay</button>
    <label style="margin-left:10px;">Speed:
      <input type="range" id="speedSlider" min="0" max="500" step="0.1" value="1" />
      <span id="speedValue">1.0x</span>
    </label>
    <span id="particleCountLiveReplay" style="margin-left:10px; font-size:0.9em; color:#444;">
      Particles: 0
    </span>
  </div>
  <div id="sliderContainer">
    <label>Frame:
      <input type="range" id="scrubSlider" min="0" max="0" step="1" value="0" />
    </label>
  </div>
</div>

<!-- The Canvas for Rendering -->
<canvas id="replayCanvas" width="600" height="600"></canvas>

<script>
/* =============================================================================
 * Global Variables & UI References
 * ============================================================================= */
const DB_NAME       = 'GravityDiscDB';
const STORE_NAME    = 'particleSnapshots';
let db              = null;

let particleCount   = 1000;
let totalSteps      = 50000;
let dt              = 0.05;
let softening       = 0.01;
let barnesHutTheta  = 0.5;
let G               = 1.0;
let initialSpread   = 700;

let isComputing     = false;
let currentStep     = 0;
let maxStep         = 0;
const batchSize     = 50;

let simulationParticles = [];

const approximateMaxBytes = 200 * 1024 * 1024; // 200 MB limit
let currentStoredBytes    = 0;
const alertThresholdRatio = 0.95; // 95% => auto-stop

let memoryInfoEl          = null;
let particleCountLiveEl   = null;
let particleCountLiveReplayEl = null;

let isReplaying   = false;
let replayFrame   = 0;
let replayInterval= null;
const replayBatchSize=500;
let replayCache   = {};
let replayCacheStart=0;
let replayCacheEnd  =-1;
let replayCanvas, ctx2D;
let speedMultiplier=1.0;

// Quadtree constants
const MIN_HALF_SIZE=1e-10, MAX_DEPTH=50;

// Zoom & Pan
let zoomLevel   = 1.0;
let offsetX     = 0;
let offsetY     = 0;
let isPanning   = false;
let lastMouseX  = 0;
let lastMouseY  = 0;
let mouseX      = 0;
let mouseY      = 0;
let panLimit    = 1.25; // limit for panning relative to initialSpread

/* =============================================================================
 * Utility & Initialization
 * ============================================================================= */
function $(id){ return document.getElementById(id); }
function showElement(elem){ elem.classList.remove("hidden"); }
function hideElement(elem){ elem.classList.add("hidden"); }

function formatMB(bytes){
  return (bytes / (1024*1024)).toFixed(1);
}
function updateMemoryUsage(){
  const usedMB = formatMB(currentStoredBytes);
  const maxMB  = formatMB(approximateMaxBytes);
  memoryInfoEl.textContent = `Memory Used: ${usedMB} MB / ${maxMB} MB`;
}
function updateProgressBar(){
  const pct = (currentStep / totalSteps)*100;
  $("progressBar").style.width = pct.toFixed(2) + "%";
}

/* =============================================================================
 * IndexedDB Setup
 * ============================================================================= */
function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = (e) => {
      db = e.target.result;
      if(!db.objectStoreNames.contains(STORE_NAME)){
        db.createObjectStore(STORE_NAME, { keyPath:"timestep" });
      }
    };
    request.onsuccess = (e) => {
      db = e.target.result;
      resolve(db);
    };
    request.onerror = (err) => reject(err);
  });
}

async function clearParticleData(){
  if(!db) return;
  return new Promise((resolve,reject)=>{
    const tx = db.transaction([STORE_NAME], 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const req = store.clear();
    req.onsuccess=()=> resolve(true);
    req.onerror  =(err)=> reject(err);
  });
}

async function storeTimestep(step, floatArray){
  return new Promise((resolve,reject)=>{
    if(!db){ reject("DB not initialized"); return; }
    const tx = db.transaction([STORE_NAME], 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const data= {
      timestep: step,
      particles: floatArray
    };
    const req= store.put(data);
    req.onsuccess=()=>resolve(true);
    req.onerror  =(err)=>reject(err);
  });
}

async function getTimestepsRange(startStep, endStep){
  if(!db) throw "DB not initialized";
  if(startStep> endStep) return [];
  return new Promise((resolve,reject)=>{
    const tx= db.transaction([STORE_NAME],"readonly");
    const store= tx.objectStore(STORE_NAME);

    const range= IDBKeyRange.bound(startStep, endStep);
    const req= store.openCursor(range);
    const results=[];
    req.onsuccess=(e)=>{
      const cursor= e.target.result;
      if(cursor){
        results.push(cursor.value);
        cursor.continue();
      } else {
        resolve(results);
      }
    };
    req.onerror=(err)=>reject(err);
  });
}

/* =============================================================================
 * Barnes–Hut Quadtree Implementation
 * ============================================================================= */
class QuadNode {
  constructor(xMid,yMid,halfSize){
    this.xMid     = xMid;
    this.yMid     = yMid;
    this.halfSize = halfSize;
    this.mass = 0;
    this.cmx  = 0;
    this.cmy  = 0;
    this.isLeaf = true;
    this.particleIndex = -1;
    this.children= [null,null,null,null];
  }
}

function buildQuadTree(particles){
  if(particles.length===0) return null;
  let minX= Infinity, maxX=-Infinity;
  let minY= Infinity, maxY=-Infinity;
  for(const p of particles){
    if(p.x< minX) minX=p.x;
    if(p.x> maxX) maxX=p.x;
    if(p.y< minY) minY=p.y;
    if(p.y> maxY) maxY=p.y;
  }
  const centerX= 0.5*(minX+maxX);
  const centerY= 0.5*(minY+maxY);
  let halfSize= 0.5*Math.max(maxX-minX, maxY-minY);
  if(halfSize<1e-6) halfSize=1e-6;
  const root= new QuadNode(centerX,centerY,halfSize);

  for(let i=0; i<particles.length; i++){
    insertParticle(root, particles, i,0);
  }
  return root;
}

function insertParticle(node, particles, i, depth){
  const p= particles[i];
  if(node.isLeaf && node.particleIndex<0){
    node.particleIndex= i;
    node.mass= p.mass;
    node.cmx= p.x*p.mass;
    node.cmy= p.y*p.mass;
    return;
  }
  if(node.isLeaf && node.particleIndex>=0){
    const oldIndex= node.particleIndex;
    node.particleIndex= -1;
    node.isLeaf= false;
    insertIntoChild(node, particles, oldIndex, depth+1);
    insertIntoChild(node, particles, i, depth+1);
    updateNodeMassCOM(node);
    return;
  }
  insertIntoChild(node, particles, i, depth+1);
  updateNodeMassCOM(node);
}

function insertIntoChild(node, particles, i, depth){
  if(node.halfSize<MIN_HALF_SIZE || depth>MAX_DEPTH){
    if(node.isLeaf && node.particleIndex<0){
      node.particleIndex= i;
      node.mass= particles[i].mass;
      node.cmx= particles[i].x* node.mass;
      node.cmy= particles[i].y* node.mass;
    } else if(node.isLeaf && node.particleIndex>=0){
      const oldP= particles[node.particleIndex];
      const newP= particles[i];
      const newMass= oldP.mass + newP.mass;

      const px_i= oldP.mass* oldP.vx;
      const py_i= oldP.mass* oldP.vy;
      const px_j= newP.mass* newP.vx;
      const py_j= newP.mass* newP.vy;
      oldP.mass= newMass;
      oldP.vx  = (px_i+ px_j)/ newMass;
      oldP.vy  = (py_i+ py_j)/ newMass;
      oldP.radius= Math.cbrt(newMass);

      node.mass= oldP.mass;
      node.cmx = oldP.x* oldP.mass;
      node.cmy = oldP.y* oldP.mass;
    }
    return;
  }
  const p= particles[i];
  const midX= node.xMid, midY= node.yMid;
  const half= node.halfSize/2;
  const isNorth= (p.y>= midY);
  const isWest = (p.x< midX);

  let childIndex= 0; // NW=0, NE=1, SW=2, SE=3
  if(isNorth && !isWest) childIndex=1;
  else if(!isNorth && isWest) childIndex=2;
  else if(!isNorth && !isWest) childIndex=3;

  if(!node.children[childIndex]){
    let cx= midX, cy= midY;
    if(childIndex===0){ cx= midX-half; cy= midY+half; }
    if(childIndex===1){ cx= midX+half; cy= midY+half; }
    if(childIndex===2){ cx= midX-half; cy= midY-half; }
    if(childIndex===3){ cx= midX+half; cy= midY-half; }
    node.children[childIndex]= new QuadNode(cx, cy, half);
    node.isLeaf= false;
  }
  insertParticle(node.children[childIndex], particles, i, depth+1);
}

function updateNodeMassCOM(node){
  node.mass=0; node.cmx=0; node.cmy=0;
  if(node.isLeaf && node.particleIndex>=0){
    const p= simulationParticles[node.particleIndex];
    node.mass= p.mass;
    node.cmx = p.x*p.mass;
    node.cmy = p.y*p.mass;
    return;
  }
  for(let c=0; c<4; c++){
    const child= node.children[c];
    if(child && child.mass>0){
      node.mass+= child.mass;
      node.cmx += child.cmx;
      node.cmy += child.cmy;
    }
  }
}

function computeForcesBarnesHut(particles, root, theta){
  for(let i=0; i<particles.length; i++){
    const p= particles[i];
    p.fx=0; p.fy=0;
    const [fx, fy]= computeForceOnParticle(p, root, theta);
    p.fx= fx; p.fy= fy;
  }
}

function computeForceOnParticle(p, node, theta){
  if(!node|| node.mass<=0) return [0,0];
  if(node.isLeaf && node.particleIndex>=0){
    if(node.particleIndex===p.index) return [0,0];
    return directForce(p, simulationParticles[node.particleIndex]);
  }
  const dx= (node.cmx/node.mass)- p.x;
  const dy= (node.cmy/node.mass)- p.y;
  const dist= Math.sqrt(dx*dx+ dy*dy)+ 1e-12;
  if((node.halfSize*2)/dist< theta){
    const fMag= (G*p.mass*node.mass)/(dist*dist + softening*softening);
    const fx= fMag*(dx/dist);
    const fy= fMag*(dy/dist);
    return [fx, fy];
  } else {
    let fxSum=0, fySum=0;
    for(let c=0; c<4; c++){
      const child= node.children[c];
      if(child && child.mass>0){
        const [cx,cy]= computeForceOnParticle(p, child, theta);
        fxSum+= cx; fySum+= cy;
      }
    }
    return [fxSum, fySum];
  }
}

function directForce(p1, p2){
  const dx= p2.x- p1.x;
  const dy= p2.y- p1.y;
  const r2= dx*dx+ dy*dy+ softening*softening;
  const r= Math.sqrt(r2);
  if(r<1e-12) return [0,0];
  const f= (G*p1.mass*p2.mass)/ r2;
  const fx= f*(dx/r);
  const fy= f*(dy/r);
  return [fx, fy];
}

function integrate(particles){
  for(const p of particles){
    p.vx += (p.fx/p.mass)*dt;
    p.vy += (p.fy/p.mass)*dt;
    p.x  += p.vx*dt;
    p.y  += p.vy*dt;
  }
}

function handleCollisions(particles){
  const n= particles.length;
  const toRemove= new Set();
  for(let i=0; i<n; i++){
    if(toRemove.has(i)) continue;
    for(let j=i+1; j<n; j++){
      if(toRemove.has(j)) continue;
      const pi=particles[i], pj=particles[j];
      const rSum= pi.radius+ pj.radius;
      const dx  = pj.x- pi.x;
      const dy  = pj.y- pi.y;
      if(dx*dx+ dy*dy< (rSum*rSum)){
        // merge
        const totalMass= pi.mass+ pj.mass;
        const px_i= pi.mass*pi.vx; const py_i= pi.mass*pi.vy;
        const px_j= pj.mass*pj.vx; const py_j= pj.mass*pj.vy;
        pi.mass= totalMass;
        pi.vx= (px_i+ px_j)/ totalMass;
        pi.vy= (py_i+ py_j)/ totalMass;
        pi.radius= Math.cbrt(totalMass);
        toRemove.add(j);
      }
    }
  }
  if(toRemove.size>0){
    return particles.filter((_, idx)=> !toRemove.has(idx));
  }
  return particles;
}

function packParticles(particles){
  const n= particles.length;
  const floatArray= new Float32Array(n*6);
  for(let i=0; i<n; i++){
    const off= i*6;
    const p= particles[i];
    floatArray[off+0]= p.x;
    floatArray[off+1]= p.y;
    floatArray[off+2]= p.vx;
    floatArray[off+3]= p.vy;
    floatArray[off+4]= p.radius;
    floatArray[off+5]= p.mass;
  }
  return floatArray;
}

/* =============================================================================
 * Main Simulation Loop (Calculation Phase)
 * ============================================================================= */
async function runSimulation(){
  if(isComputing) return;
  isComputing= true;

  $("progressBarContainer").style.display= "";
  hideElement($("replayControls"));
  stopReplay();
  ctx2D.clearRect(0,0,replayCanvas.width, replayCanvas.height);
  $("scrubSlider").min=0;
  $("scrubSlider").max=0;
  $("scrubSlider").value=0;

  $("speedSlider").value= "1";
  $("speedValue").textContent= "1.0x";
  speedMultiplier= 1.0;

  // Reset zoom & pan
  zoomLevel= 1.0;
  offsetX= 0;
  offsetY= 0;

  // Read parameters
  particleCount  = parseInt($("particleCount").value,10);
  totalSteps     = parseInt($("numSteps").value,10);
  dt             = parseFloat($("timeStep").value);
  softening      = parseFloat($("softening").value);
  barnesHutTheta = parseFloat($("theta").value);
  G              = parseFloat($("gravConst").value);
  initialSpread  = parseFloat($("initialSpread").value);

  await clearParticleData();
  replayCache     = {};
  replayCacheStart=0;
  replayCacheEnd  =-1;
  currentStep     =0;
  maxStep         =0;
  currentStoredBytes=0;
  updateMemoryUsage();

  // Generate initial particles
  simulationParticles= [];
  for(let i=0; i< particleCount; i++){
    const rr= Math.sqrt(Math.random())* initialSpread;
    const ang= Math.random()* 2*Math.PI;
    const x= rr* Math.cos(ang);
    const y= rr* Math.sin(ang);
    const vx=0, vy=0;
    const mass=1.0;
    const radius= Math.cbrt(mass);
    simulationParticles.push({ index:i, x,y, vx,vy, mass, radius, fx:0, fy:0 });
  }

  updateProgressBar();

  (async function loopStep(){
    if(!isComputing){
      maxStep= (currentStep>0)? (currentStep-1) : 0;
      $("progressBarContainer").style.display= "none";
      showReplayUI();
      startReplay();
      return;
    }

    particleCountLiveEl.textContent= "Particles: " + simulationParticles.length;
    const limit= Math.min(currentStep+ batchSize, totalSteps);
    for(; currentStep< limit; currentStep++){
      const root= buildQuadTree(simulationParticles);
      computeForcesBarnesHut(simulationParticles, root, barnesHutTheta);
      integrate(simulationParticles);
      simulationParticles= handleCollisions(simulationParticles);

      const floatArray= packParticles(simulationParticles);
      try{
        await storeTimestep(currentStep, floatArray);
      }catch(err){
        console.error("IndexedDB store error:", err);
        isComputing= false;
        break;
      }

      currentStoredBytes += floatArray.length*4;
      updateMemoryUsage();
      if(currentStoredBytes >= approximateMaxBytes*alertThresholdRatio){
        isComputing= false;
        break;
      }
      updateProgressBar();
    }

    if(currentStep< totalSteps && isComputing){
      setTimeout(loopStep, 0);
    }else{
      isComputing= false;
      maxStep= currentStep>0? (currentStep-1) : 0;
      $("progressBarContainer").style.display= "none";
      showReplayUI();
      startReplay();
    }
  })();
}

/* =============================================================================
 * Replay Phase
 * ============================================================================= */
function showReplayUI(){
  showElement($("replayControls"));
  $("scrubSlider").min= 0;
  $("scrubSlider").max= maxStep;
  $("scrubSlider").value= 0;
}

async function loadReplayBatch(startFrame, endFrame){
  const data= await getTimestepsRange(startFrame, endFrame);
  data.sort((a,b)=> a.timestep - b.timestep);
  return data;
}

async function ensureReplayCache(frame){
  if(frame< replayCacheStart || frame> replayCacheEnd){
    const newStart= frame;
    const newEnd  = Math.min(frame+ replayBatchSize-1, maxStep);
    const batchData= await loadReplayBatch(newStart,newEnd);

    replayCache= {};
    for(const record of batchData){
      replayCache[record.timestep]= record;
    }
    replayCacheStart= newStart;
    replayCacheEnd  = newEnd;
  }
}

function unpackParticles(floatArray){
  const n= floatArray.length/6;
  const arr= [];
  for(let i=0; i<n; i++){
    const off= i*6;
    arr.push({
      x: floatArray[off+0],
      y: floatArray[off+1],
      vx: floatArray[off+2],
      vy: floatArray[off+3],
      radius: floatArray[off+4],
      mass: floatArray[off+5]
    });
  }
  return arr;
}

function drawFrame2D(particles){
  if(!ctx2D) return;
  ctx2D.clearRect(0,0,replayCanvas.width,replayCanvas.height);

  $("particleCountLiveReplay").textContent = "Particles: " + particles.length;

  // highlight top5 if >=100
  let top5= new Set();
  if(particles.length>=100){
    const biggest= [...particles].sort((a,b)=> b.mass - a.mass).slice(0,5);
    for(const p of biggest) top5.add(p);
  }

  const baseScale= 600 / (2* initialSpread);
  const scale= baseScale * zoomLevel;
  const cx= replayCanvas.width/2;
  const cy= replayCanvas.height/2;

  for(const p of particles){
    const sx= cx + p.x* scale + offsetX;
    const sy= cy - p.y* scale + offsetY;
    const r = Math.max(1, p.radius* scale);

    ctx2D.fillStyle= "white";
    ctx2D.beginPath();
    ctx2D.arc(sx, sy, r, 0, 2*Math.PI);
    ctx2D.fill();

    if(top5.has(p)){
      ctx2D.strokeStyle= "limegreen";
      ctx2D.lineWidth= 2;
      ctx2D.beginPath();
      ctx2D.arc(sx, sy, r+2, 0, 2*Math.PI);
      ctx2D.stroke();
    }
  }
}

/* Start & Stop Replay */
async function startReplay(){
  if(isReplaying) return;
  isReplaying= true;

  replayFrame= parseInt($("scrubSlider").value,10)||0;
  await ensureReplayCache(replayFrame);

  if(replayInterval) {
    clearInterval(replayInterval);
  }
  replayInterval= setInterval(async ()=>{
    if(!isReplaying) return;
    await ensureReplayCache(replayFrame);

    const record= replayCache[replayFrame];
    if(record && record.particles){
      const arr= unpackParticles(record.particles);
      drawFrame2D(arr);
    }

    replayFrame++;
    $("scrubSlider").value= replayFrame;
    if(replayFrame> maxStep){
      stopReplay();
    }
  }, 100/speedMultiplier);
}

function stopReplay(){
  if(replayInterval){
    clearInterval(replayInterval);
    replayInterval= null;
  }
  isReplaying= false;
}

/* =============================================================================
 * Zoom & Pan (Wheel + Mouse Drag)
 * ============================================================================= */
function handleWheel(e) {
  e.preventDefault();
  const delta= -e.deltaY;
  const zoomFactor= 1.1;
  if(delta>0) zoomLevel*= zoomFactor;
  else        zoomLevel/= zoomFactor;

  zoomLevel= Math.min(Math.max(0.05, zoomLevel), 20.0);

  // re-draw if paused
  if(!isReplaying){
    const record= replayCache[replayFrame];
    if(record && record.particles){
      const arr= unpackParticles(record.particles);
      drawFrame2D(arr);
    }
  }
}

function onCanvasMouseDown(e){
  if(e.button!== 0) return;
  isPanning= true;
  lastMouseX= e.clientX;
  lastMouseY= e.clientY;
  replayCanvas.style.cursor= "grabbing";
}

function onCanvasMouseMove(e){
  const rect= replayCanvas.getBoundingClientRect();
  mouseX= e.clientX- rect.left;
  mouseY= e.clientY- rect.top;

  if(isPanning){
    const dx= e.clientX- lastMouseX;
    const dy= e.clientY- lastMouseY;
    lastMouseX= e.clientX;
    lastMouseY= e.clientY;

    offsetX+= dx;
    offsetY+= dy;

    // clamp offset
    const maxOffset= initialSpread* panLimit;
    offsetX= Math.max(-maxOffset, Math.min(offsetX, maxOffset));
    offsetY= Math.max(-maxOffset, Math.min(offsetY, maxOffset));

    if(!isReplaying){
      const record= replayCache[replayFrame];
      if(record && record.particles){
        const arr= unpackParticles(record.particles);
        drawFrame2D(arr);
      }
    }
  }
}

function onCanvasMouseUp(e){
  if(e.button!== 0) return;
  isPanning= false;
  replayCanvas.style.cursor= "crosshair";
}

/* =============================================================================
 * initUI & onLoad
 * ============================================================================= */
function initUI(){
  $("startBtn").addEventListener("click", ()=>{
    if(!isComputing) runSimulation();
  });
  $("stopBtn").addEventListener("click", ()=>{
    isComputing= false;
  });

  $("replayStartBtn").addEventListener("click", ()=>{
    stopReplay();
    speedMultiplier= parseFloat($("speedSlider").value);
    startReplay();
  });
  $("replayStopBtn").addEventListener("click", ()=>{
    stopReplay();
  });

  $("speedSlider").addEventListener("input", (e)=>{
    speedMultiplier= parseFloat(e.target.value);
    $("speedValue").textContent= speedMultiplier.toFixed(1)+ "x";
    if(isReplaying){
      stopReplay();
      startReplay();
    }
  });

  $("scrubSlider").addEventListener("input", async(e)=>{
    replayFrame= parseInt(e.target.value,10);
    if(!isReplaying){
      await ensureReplayCache(replayFrame);
      const record= replayCache[replayFrame];
      if(record && record.particles){
        const arr= unpackParticles(record.particles);
        drawFrame2D(arr);
      }
    }
  });

  memoryInfoEl            = $("memoryInfo");
  particleCountLiveEl     = $("particleCountLive");
  particleCountLiveReplayEl = $("particleCountLiveReplay");
}

window.addEventListener("load", async ()=>{
  await openDatabase();
  initUI();

  replayCanvas= $("replayCanvas");
  ctx2D       = replayCanvas.getContext("2d");

  // Setup zoom & pan event listeners
  replayCanvas.addEventListener("wheel", handleWheel, { passive:false });
  replayCanvas.addEventListener("mousedown", onCanvasMouseDown);
  replayCanvas.addEventListener("mousemove", onCanvasMouseMove);
  replayCanvas.addEventListener("mouseup",   onCanvasMouseUp);
  // If needed: handle "mouseleave" => stop panning

  // Possibly hide progress bar if not immediate
  if($("immediatelyCalculate").checked){
    runSimulation();
  } else {
    $("progressBarContainer").style.display= "none";
  }
});
</script>
</body>
</html>