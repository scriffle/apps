<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; background: #1a1a1a; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
        }
        .dg.main {
            position: absolute !important;
            top: 10px !important;
            right: 10px !important;
        }
        .dg.main.taller-than-window {
            overflow-y: auto;
        }
        .dg.main .close-button.close-bottom {
            position: relative;
        }
        #gui-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            padding: 10px;
            cursor: move;
        }
        #collapse-btn {
            position: absolute;
            top: 0;
            right: 0;
            padding: 5px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            z-index: 1000;
        }
        #title {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="title">Electrons on Metal Capsule</div>
    <div id="info">Drag to rotate (X/Y/Z). Scroll to zoom.</div>
    <div id="gui-container">
        <button id="collapse-btn">â‰¡</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x1a1a1a);
        document.body.appendChild(renderer.domElement);

        // Performance monitoring
        let lastTime = performance.now();
        let frameCount = 0;
        let currentFPS = 0;

        // Physics constants
        const COULOMB_CONSTANT = 0.1;
        const DAMPING = 0.95;
        const MIN_DISTANCE = 0.2;
        const TIMESTEP = 0.016;
        
        // Metrics object
        const metrics = {
            fps: 0,
            voltage: 0,
            electronCount: 0,
            updateInterval: 500 // ms
        };
        
        // Default settings
        const DEFAULT_SETTINGS = {
            cylinderLength: 2,
            radius: 0.5,
            segments: 32,
            particles: 10,
            showParticles: true,
            rotationX: 0,
            rotationY: 0,
            rotationZ: 0,
            simulating: false,
            chargeStrength: 1.0,
            brownianMotion: 0.05,
            emissionRate: 1,
            cathodeEnabled: false
        };

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Default camera position
        const defaultCameraPosition = { x: 0, y: 0, z: 5 };
        camera.position.copy(defaultCameraPosition);

        // Parameters
        const params = {
            ...DEFAULT_SETTINGS,
            resetView: function() {
                camera.position.copy(defaultCameraPosition);
                params.rotationX = 0;
                params.rotationY = 0;
                params.rotationZ = 0;
                updateGUIControllers();
            },
            resetSettings: function() {
                Object.keys(DEFAULT_SETTINGS).forEach(key => {
                    params[key] = DEFAULT_SETTINGS[key];
                });
                updateGeometry();
                updateGUIControllers();
            }
        };

        // Update all GUI controllers
        function updateGUIControllers() {
            for (let i in gui.__controllers) {
                gui.__controllers[i].updateDisplay();
            }
        }

        // Fixed Cathode class
        class Cathode {
            constructor(parentMesh, length, radius) {
                // Create cathode mesh
                const sphereGeom = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                });

                this.mesh = new THREE.Mesh(sphereGeom, material);
                
                // Position cathode at top of cylinder
                this.mesh.position.set(radius, length/2, 0);
                
                // Add glow effect
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3
                });
                const glowSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    glowMaterial
                );
                this.mesh.add(glowSphere);

                // Add to parent (capsule)
                parentMesh.add(this.mesh);
                this.lastEmissionTime = 0;
            }

            updatePosition(length, radius) {
                this.mesh.position.set(radius, length/2, 0);
            }

            emitElectron(parentRotation) {
                if (!params.cathodeEnabled) return null;
                
                const now = performance.now() / 1000;
                if (now - this.lastEmissionTime < 1 / params.emissionRate) return null;
                
                this.lastEmissionTime = now;
                
                const particleGeometry = new THREE.SphereGeometry(0.05, 12, 12);
                const particleMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4444ff,
                    emissive: 0x2222ff,
                    emissiveIntensity: 0.3
                });

                const mesh = new THREE.Mesh(particleGeometry, particleMaterial);
                mesh.position.copy(this.mesh.getWorldPosition(new THREE.Vector3()));
                
                return new Particle(mesh);
            }
        }

        // Particle class
        class Particle {
            constructor(mesh) {
                this.mesh = mesh;
                this.velocity = new THREE.Vector3();
                this.charge = -1;
                this.mass = 1;
            }

            updatePosition(particles, capsuleLength, radius) {
                const force = new THREE.Vector3();
                
                particles.forEach(other => {
                    if (other === this) return;
                    
                    const diff = new THREE.Vector3().subVectors(this.mesh.position, other.mesh.position);
                    const distance = diff.length();
                    
                    if (distance < MIN_DISTANCE) {
                        const repulsionForce = 5 * COULOMB_CONSTANT / (MIN_DISTANCE * MIN_DISTANCE);
                        force.add(diff.normalize().multiplyScalar(repulsionForce));
                        return;
                    }
                    
                    const forceMagnitude = (COULOMB_CONSTANT * Math.abs(this.charge * other.charge) * params.chargeStrength) / (distance * distance);
                    force.add(diff.normalize().multiplyScalar(forceMagnitude));
                });

                if (params.brownianMotion > 0) {
                    force.add(new THREE.Vector3(
                        (Math.random() - 0.5) * params.brownianMotion * 4,
                        (Math.random() - 0.5) * params.brownianMotion * 4,
                        (Math.random() - 0.5) * params.brownianMotion * 4
                    ));
                }

                this.velocity.add(force.multiplyScalar(TIMESTEP / this.mass));
                this.velocity.multiplyScalar(DAMPING);
                this.mesh.position.add(this.velocity.clone().multiplyScalar(TIMESTEP));
                this.constrainToSurface(capsuleLength, radius);
            }

            constrainToSurface(capsuleLength, radius) {
                const pos = this.mesh.position;
                
                if (Math.abs(pos.y) <= capsuleLength / 2) {
                    const xz = new THREE.Vector2(pos.x, pos.z);
                    xz.setLength(radius);
                    pos.x = xz.x;
                    pos.z = xz.y;
                } else {
                    const cap = pos.y > 0 ? capsuleLength/2 : -capsuleLength/2;
                    const sphere = new THREE.Vector3(pos.x, pos.y - cap, pos.z);
                    sphere.setLength(radius);
                    pos.copy(sphere).add(new THREE.Vector3(0, cap, 0));
                }
            }
        }

        // Create capsule geometry
        function createCapsule(length, radius, segments) {
            const geometry = new THREE.Group();

            const material = new THREE.MeshPhongMaterial({ 
                color: 0x808080,
                wireframe: false,
                transparent: true,
                opacity: 0.9
            });

            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, length, segments);
            const cylinder = new THREE.Mesh(cylinderGeometry, material);
            geometry.add(cylinder);

            const sphereGeometry = new THREE.SphereGeometry(radius, segments, segments / 2);
            
            const topSphere = new THREE.Mesh(sphereGeometry, material);
            topSphere.position.y = length / 2;
            geometry.add(topSphere);

            const bottomSphere = new THREE.Mesh(sphereGeometry, material);
            bottomSphere.position.y = -length / 2;
            geometry.add(bottomSphere);

            return geometry;
        }

        let particleObjects = [];
        let cathode = null;

        function createParticles(count, capsuleLength, radius) {
            const particles = new THREE.Group();
            const particleGeometry = new THREE.SphereGeometry(0.05, 12, 12);
            
            particleObjects = [];

            for (let i = 0; i < count; i++) {
                const particleMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4444ff,
                    emissive: 0x2222ff,
                    emissiveIntensity: 0.3
                });

                const mesh = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                
                mesh.position.x = Math.cos(theta) * Math.sin(phi) * radius;
                mesh.position.y = (Math.random() - 0.5) * capsuleLength;
                mesh.position.z = Math.sin(theta) * Math.sin(phi) * radius;
                
                particles.add(mesh);
                particleObjects.push(new Particle(mesh));
            }

            metrics.electronCount = particleObjects.length;
            return particles;
        }

        // Calculate voltage based on electron distribution
        function calculateVoltage() {
            if (particleObjects.length === 0) return 0;
            
            let totalPotential = 0;
            const center = new THREE.Vector3(0, 0, 0);
            
            particleObjects.forEach(particle => {
                const distance = particle.mesh.position.distanceTo(center);
                totalPotential += COULOMB_CONSTANT * Math.abs(particle.charge) / distance;
            });
            
            return totalPotential / particleObjects.length;
        }

        // Update metrics
        function updateMetrics() {
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastTime >= metrics.updateInterval) {
                metrics.fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                metrics.voltage = calculateVoltage().toFixed(2);
                metrics.electronCount = particleObjects.length;
                
                frameCount = 0;
                lastTime = currentTime;
                
                updateGUIControllers();
            }
        }

        let capsule = createCapsule(params.cylinderLength, params.radius, params.segments);
        let particles = createParticles(params.particles, params.cylinderLength, params.radius);
        scene.add(capsule);
        scene.add(particles);
        cathode = new Cathode(capsule, params.cylinderLength, params.radius);

        // GUI setup
        const guiContainer = document.getElementById('gui-container');
        const gui = new dat.GUI({ autoPlace: false });
        guiContainer.appendChild(gui.domElement);

        // Make GUI draggable
        let isDraggingGui = false;
        let guiOffset = { x: 0, y: 0 };

        guiContainer.addEventListener('mousedown', (e) => {
            if (e.target === guiContainer || e.target === document.getElementById('collapse-btn')) {
                isDraggingGui = true;
                guiOffset.x = e.clientX - guiContainer.offsetLeft;
                guiOffset.y = e.clientY - guiContainer.offsetTop;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingGui) {
                guiContainer.style.left = (e.clientX - guiOffset.x) + 'px';
                guiContainer.style.top = (e.clientY - guiOffset.y) + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingGui = false;
        });

        // GUI controls
        const metricsFolder = gui.addFolder('Metrics');
        metricsFolder.add(metrics, 'fps').name('FPS').listen();
        metricsFolder.add(metrics, 'voltage').name('Voltage').listen();
        metricsFolder.add(metrics, 'electronCount').name('Electron Count').listen();
        metricsFolder.add(metrics, 'updateInterval', 100, 1000).name('Update Interval (ms)');

        const geometryFolder = gui.addFolder('Geometry');
        geometryFolder.add(params, 'cylinderLength', 0.5, 50).onChange(updateGeometry);
        geometryFolder.add(params, 'radius', 0.1, 2).onChange(updateGeometry);
        geometryFolder.add(params, 'particles', 1, 50).step(1).onChange(updateGeometry);
        geometryFolder.add(params, 'showParticles').onChange(value => particles.visible = value);

        const rotationFolder = gui.addFolder('Rotation');
        rotationFolder.add(params, 'rotationX', 0, Math.PI * 2);
        rotationFolder.add(params, 'rotationY', 0, Math.PI * 2);
        rotationFolder.add(params, 'rotationZ', 0, Math.PI * 2);

        const simulationFolder = gui.addFolder('Simulation');
        simulationFolder.add(params, 'simulating').name('Run Simulation');
        simulationFolder.add(params, 'chargeStrength', 0.1, 5).name('Charge Strength');
        simulationFolder.add(params, 'brownianMotion', 0, 5.0).name('Thermal Motion');

        const cathodeFolder = gui.addFolder('Cathode');
        cathodeFolder.add(params, 'cathodeEnabled').name('Enable Emission');
        cathodeFolder.add(params, 'emissionRate', 0.1, 200).name('Emission Rate (Hz)');

        gui.add(params, 'resetView').name('Reset View');
        gui.add(params, 'resetSettings').name('Reset All Settings');

        metricsFolder.open();
        geometryFolder.open();
        rotationFolder.open();
        simulationFolder.open();
        cathodeFolder.open();

        function updateGeometry() {
            scene.remove(capsule);
            scene.remove(particles);
            capsule = createCapsule(params.cylinderLength, params.radius, params.segments);
            particles = createParticles(params.particles, params.cylinderLength, params.radius);
            scene.add(capsule);
            scene.add(particles);
            
            // Create new cathode attached to new capsule
            cathode = new Cathode(capsule, params.cylinderLength, params.radius);
        }

        // Zoom control
        document.addEventListener('wheel', (e) => {
            if (e.target === renderer.domElement) {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(2, Math.min(100, camera.position.z));
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update metrics
            updateMetrics();

            // Update rotations
            capsule.rotation.x = params.rotationX;
            capsule.rotation.y = params.rotationY;
            capsule.rotation.z = params.rotationZ;
            particles.rotation.x = params.rotationX;
            particles.rotation.y = params.rotationY;
            particles.rotation.z = params.rotationZ;

            // Update particle physics
            if (params.simulating) {
                particleObjects.forEach(particle => {
                    particle.updatePosition(particleObjects, params.cylinderLength, params.radius);
                });

                // Emit new electrons from cathode
                if (cathode && params.cathodeEnabled) {
                    const newElectron = cathode.emitElectron(capsule.rotation);
                    if (newElectron) {
                        particles.add(newElectron.mesh);
                        particleObjects.push(newElectron);
                        metrics.electronCount = particleObjects.length;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
