<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron Simulation with Wall Option</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: black;
            color: white;
        }
        canvas {
            display: block;
            border: 2px solid white;
        }
        #controlPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid white;
            border-radius: 5px;
            color: white;
        }
        label, input {
            margin: 5px 0;
            display: block;
        }
        button, input[type="checkbox"] {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="simulation"></canvas>
    <div id="controlPanel">
        <label for="rateSlider">Emission Rate: <span id="rateDisplay">1</span> Hz</label>
        <input type="range" id="rateSlider" min="1" max="200" value="1">
        <button id="toggleEmission">Start Emission</button>
        <label><input type="checkbox" id="toggleCathode" checked> Cathode Active</label>
        <label><input type="checkbox" id="toggleAnode" checked> Anode Active</label>
        <label><input type="checkbox" id="toggleWall" checked> Wall Active</label>
    </div>

    <script>
        const canvas = document.getElementById('simulation');
        const ctx = canvas.getContext('2d');

        canvas.width = 600;
        canvas.height = 600;

        const ELECTRON_RADIUS = 5; // Size of each electron
        const ANODE_RADIUS = 10; // Radius of the anode
        const COULOMB_CONSTANT = 1000; // Scaled constant for visualization
        const ANODE_CHARGE = 5000; // Positive charge of the anode
        const TIME_STEP = 0.1; // Time step for simulation
        const DAMPING = 0.95; // Friction to stabilize movement

        const controlPanel = document.getElementById('controlPanel');
        const rateSlider = document.getElementById('rateSlider');
        const rateDisplay = document.getElementById('rateDisplay');
        const toggleEmission = document.getElementById('toggleEmission');
        const toggleCathode = document.getElementById('toggleCathode');
        const toggleAnode = document.getElementById('toggleAnode');
        const toggleWall = document.getElementById('toggleWall');

        let electrons = [];
        let emissionRate = 1; // Hz
        let emitting = false;
        let cathodeActive = true;
        let anodeActive = true;
        let wallActive = true;

        const cathode = { x: canvas.width / 2 - 100, y: canvas.height / 2, dragging: false };
        const anode = { x: canvas.width / 2 + 100, y: canvas.height / 2, dragging: false };

        // Update rate display
        rateSlider.addEventListener('input', () => {
            emissionRate = parseInt(rateSlider.value);
            rateDisplay.textContent = emissionRate;
        });

        // Toggle emission
        toggleEmission.addEventListener('click', () => {
            emitting = !emitting;
            toggleEmission.textContent = emitting ? 'Stop Emission' : 'Start Emission';
        });

        // Toggle cathode
        toggleCathode.addEventListener('change', () => {
            cathodeActive = toggleCathode.checked;
        });

        // Toggle anode
        toggleAnode.addEventListener('change', () => {
            anodeActive = toggleAnode.checked;
        });

        // Toggle wall
        toggleWall.addEventListener('change', () => {
            wallActive = toggleWall.checked;
        });

        function drawElectron(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, ELECTRON_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "cyan";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.stroke();
        }

        function drawCathode() {
            ctx.beginPath();
            ctx.arc(cathode.x, cathode.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = "red";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.stroke();
        }

        function drawAnode() {
            ctx.beginPath();
            ctx.arc(anode.x, anode.y, ANODE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "black";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.stroke();
        }

        function updatePositions() {
            for (let i = electrons.length - 1; i >= 0; i--) {
                let fx = 0;
                let fy = 0;

                // Calculate forces due to other electrons
                for (let j = 0; j < electrons.length; j++) {
                    if (i === j) continue;

                    const dx = electrons[i].x - electrons[j].x;
                    const dy = electrons[i].y - electrons[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Apply Coulomb's law if distance > 2*ELECTRON_RADIUS
                    if (distance > 2 * ELECTRON_RADIUS) {
                        const force = COULOMB_CONSTANT / (distance * distance);
                        fx += (force * dx) / distance;
                        fy += (force * dy) / distance;
                    } else if (distance > 0) {
                        // Prevent overlap by applying a repelling force
                        const overlapForce = (2 * ELECTRON_RADIUS - distance) * 10;
                        fx += (overlapForce * dx) / distance;
                        fy += (overlapForce * dy) / distance;
                    }
                }

                // Apply attraction to the anode
                if (anodeActive) {
                    const dx = anode.x - electrons[i].x;
                    const dy = anode.y - electrons[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Coulomb's law attraction
                    if (distance > ELECTRON_RADIUS) {
                        const force = (ANODE_CHARGE / (distance * distance));
                        fx += (force * dx) / distance;
                        fy += (force * dy) / distance;
                    }

                    // Remove electrons if they touch the anode
                    if (distance <= ANODE_RADIUS + ELECTRON_RADIUS) {
                        electrons.splice(i, 1);
                        continue;
                    }
                }

                // Update velocity with damping
                electrons[i].vx += fx * TIME_STEP;
                electrons[i].vy += fy * TIME_STEP;
                electrons[i].vx *= DAMPING;
                electrons[i].vy *= DAMPING;

                // Update position
                electrons[i].x += electrons[i].vx * TIME_STEP;
                electrons[i].y += electrons[i].vy * TIME_STEP;

                // Reflect off walls if wall is active
                if (wallActive) {
                    if (electrons[i].x - ELECTRON_RADIUS < 0) {
                        electrons[i].x = ELECTRON_RADIUS;
                        electrons[i].vx = -electrons[i].vx;
                    }
                    if (electrons[i].x + ELECTRON_RADIUS > canvas.width) {
                        electrons[i].x = canvas.width - ELECTRON_RADIUS;
                        electrons[i].vx = -electrons[i].vx;
                    }
                    if (electrons[i].y - ELECTRON_RADIUS < 0) {
                        electrons[i].y = ELECTRON_RADIUS;
                        electrons[i].vy = -electrons[i].vy;
                    }
                    if (electrons[i].y + ELECTRON_RADIUS > canvas.height) {
                        electrons[i].y = canvas.height - ELECTRON_RADIUS;
                        electrons[i].vy = -electrons[i].vy;
                    }
                }
            }
        }

        function emitElectrons() {
            if (emitting && cathodeActive) {
                const now = performance.now();
                const interval = 1000 / emissionRate;
                if (!this.lastEmission || now - this.lastEmission >= interval) {
                    electrons.push({
                        x: cathode.x,
                        y: cathode.y,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 1,
                    });
                    this.lastEmission = now;
                }
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw cathode
            if (cathodeActive) drawCathode();

            // Draw anode
            if (anodeActive) drawAnode();

            // Draw electrons
            for (const electron of electrons) {
                drawElectron(electron.x, electron.y);
            }
        }

        function animate() {
            emitElectrons();
            updatePositions();
            render();
            requestAnimationFrame(animate);
        }

        // Handle cathode and anode dragging
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (Math.sqrt((cathode.x - x) ** 2 + (cathode.y - y) ** 2) <= 10) {
                cathode.dragging = true;
            }

            if (Math.sqrt((anode.x - x) ** 2 + (anode.y - y) ** 2) <= ANODE_RADIUS) {
                anode.dragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (cathode.dragging) {
                cathode.x = x;
                cathode.y = y;
            }

            if (anode.dragging) {
                anode.x = x;
                anode.y = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            cathode.dragging = false;
            anode.dragging = false;
        });

        // Start simulation
        animate();
    </script>
</body>
</html>

