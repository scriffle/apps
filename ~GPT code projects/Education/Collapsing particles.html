<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>2D Barnesâ€“Hut N-Body Gravity Simulation</title>
<style>
  body {
    font-family: sans-serif;
    margin: 20px;
  }
  canvas {
    border: 1px solid #444;
    background: #111;
    display: block;
    margin-top: 10px;
  }
  #controls {
    margin-bottom: 10px;
  }
  #progress-bar-container, 
  #progress-bar-container-replay {
    width: 300px;
    height: 20px;
    border: 1px solid #ccc;
    margin-top: 10px;
    position: relative;
    display: none; 
  }
  #progress-bar, 
  #progress-bar-replay {
    width: 0%;
    height: 100%;
    background-color: #4caf50;
  }
  #log {
    white-space: pre;
    border: 1px solid #ccc;
    background-color: #f7f7f7;
    padding: 5px;
    max-height: 100px;
    overflow-y: auto;
    margin-top: 10px;
    font-size: 12px;
  }
</style>
</head>
<body>

<div id="controls">
  <label>Number of Particles: 
    <input type="number" id="numParticles" value="50" min="1" max="100000">
  </label>
  <label>Number of Time Steps: 
    <input type="number" id="numTimeSteps" value="2000" min="1">
  </label>
  <label>Time Step dt: 
    <input type="number" step="0.001" id="timeStep" value="0.1">
  </label>
  <label>Softening: 
    <input type="number" step="0.0001" id="softening" value="0.01">
  </label>
  <br><br>
  <label>Barnes-Hut Theta: 
    <input type="number" step="0.1" id="theta" value="0.5">
  </label>
  <label>Gravity Constant G: 
    <input type="number" step="0.1" id="gravConstant" value="1.0">
  </label>
  <label>Initial Spread: 
    <input type="number" step="1" id="spread" value="300">
  </label>
  <br><br>
  <label>Angular Bias (swirl factor): 
    <input type="number" step="0.1" id="angularBias" value="1">
  </label>
  <br><br>
  <!-- Track largest mass checkbox -->
  <input type="checkbox" id="trackLargestMass"> Track Largest Mass
  <br><br>
  <input type="checkbox" id="simNoVisual"> Simulate without visualization (faster)
  <br><br>
  <button id="startSimBtn">Start Simulation</button>
  <button id="stopSimBtn" disabled>Stop Simulation</button>
  <button id="replaySimBtn" disabled>Replay Animation</button>
  <button id="exportDataBtn" disabled>Export Data</button>
  <label>Playback Speed:
    <select id="playbackSpeed">
      <option value="1">1x</option>
      <option value="2">2x</option>
      <option value="4">4x</option>
      <option value="10">10x</option>
      <option value="50">50x</option>
    </select>
  </label>
</div>

<!-- Shows the current particle count -->
<div>
  <strong>Particle Count:</strong> <span id="particleCountSpan">0</span>
</div>

<!-- Main Simulation Progress Bar -->
<div id="progress-bar-container">
  <div id="progress-bar"></div>
</div>

<!-- Replay Progress Bar -->
<div id="progress-bar-container-replay">
  <div id="progress-bar-replay"></div>
</div>

<canvas id="simulationCanvas" width="800" height="800"></canvas>

<div id="log"></div>

<script>
/*****************************************************************************
 * Simulation Parameters
 ****************************************************************************/
let particles = [];
let numParticles = 50;
let numTimeSteps = 2000;
let dt = 0.1;
let softening = 0.01;
let G = 1.0;
let theta = 0.5;
let spread = 300;
let angularBias = 1;
let running = false;
let currentTimeStep = 0;

// Data for replay
let timeStepsData = [];  
// We'll store "keyframes" to limit memory usage
const KEYFRAME_INTERVAL = 10; // only store every 10th frame in timeStepsData

// Canvas
let simulationCanvas = null;
let simCtx = null;
let simulationRequestId = null;

// Collision radius scaling
const radiusScaleFactor = 1.0; 
const MIN_SCREEN_RADIUS = 1;  

// For 3D mass-volume => r ~ cbrt(m)
let trackLargestMass = false;

/*****************************************************************************
 * Particle Class
 * - We add a ring buffer to store up to 1 second of positions 
 *   if the total number of particles < 100.
 ****************************************************************************/
class Particle {
  constructor(x, y, vx, vy, mass, radius) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.mass = mass;
    this.radius = radius;

    this.trail = []; // store recent positions for the last 1 second
  }
}

/*****************************************************************************
 * Utility & Logging
 ****************************************************************************/
function logMessage(msg) {
  const logDiv = document.getElementById("log");
  logDiv.textContent += msg + "\n";
  logDiv.scrollTop = logDiv.scrollHeight;
}

function updateParticleCount() {
  document.getElementById("particleCountSpan").textContent = particles.length;
}

/*****************************************************************************
 * Quadtree Node (Barnes-Hut)
 ****************************************************************************/
class QuadTreeNode {
  constructor(x, y, size) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.children = [null, null, null, null];
    this.mass = 0;
    this.cx = 0;
    this.cy = 0;
    this.particle = null;
  }

  insert(p) {
    // If this node has no particle and no children, store p here
    if (
      this.mass === 0 &&
      this.children[0] === null && this.children[1] === null &&
      this.children[2] === null && this.children[3] === null &&
      this.particle === null
    ) {
      this.particle = p;
      this.mass = p.mass;
      this.cx = p.x;
      this.cy = p.y;
      return;
    }

    // Otherwise, update center of mass
    let totalMass = this.mass + p.mass;
    this.cx = (this.cx * this.mass + p.x * p.mass) / totalMass;
    this.cy = (this.cy * this.mass + p.y * p.mass) / totalMass;
    this.mass = totalMass;

    // If this node was a leaf with a single particle, subdivide
    if (this.particle !== null) {
      let oldP = this.particle;
      this.particle = null;
      this._subdivideAndInsert(oldP);
    }
    this._subdivideAndInsert(p);
  }

  _subdivideAndInsert(p) {
    let mid = this.size / 2;
    let index = 0;
    // quadrant indices:
    // 0: top-left, 1: top-right, 2: bottom-left, 3: bottom-right
    let left = (p.x < this.x);
    let top  = (p.y < this.y);

    if (!left &&  top) index = 1;
    if ( left && !top) index = 2;
    if (!left && !top) index = 3;

    if (this.children[index] === null) {
      let childX = this.x + (left ? -mid/2 : mid/2);
      let childY = this.y + (top  ? -mid/2 : mid/2);
      this.children[index] = new QuadTreeNode(childX, childY, mid);
    }
    this.children[index].insert(p);
  }

  accumulateForce(px, py, pmass, axay) {
    if (this.mass === 0) return;

    let dx = this.cx - px;
    let dy = this.cy - py;
    let distSq = dx*dx + dy*dy + softening*softening;
    let dist = Math.sqrt(distSq);

    let ratio = this.size / dist;

    // If far enough or leaf node, treat as single mass
    if (
      (this.children[0] === null && this.children[1] === null &&
       this.children[2] === null && this.children[3] === null) ||
      (ratio < theta)
    ) {
      let invDist3 = 1.0 / (distSq * dist);
      let f = G * this.mass * pmass * invDist3;
      axay[0] += f * dx;
      axay[1] += f * dy;
    } else {
      for (let i = 0; i < 4; i++) {
        if (this.children[i] !== null) {
          this.children[i].accumulateForce(px, py, pmass, axay);
        }
      }
    }
  }
}

/*****************************************************************************
 * Initialization
 ****************************************************************************/
function initParticles() {
  particles = [];
  for (let i = 0; i < numParticles; i++) {
    // random position in a circle
    let angle = 2 * Math.PI * Math.random();
    let r = spread * Math.sqrt(Math.random());
    let x = r * Math.cos(angle);
    let y = r * Math.sin(angle);

    // swirl velocity
    let vMag = angularBias * (r / spread);
    let vx = -Math.sin(angle) * vMag;
    let vy =  Math.cos(angle) * vMag;

    let p = new Particle(x, y, vx, vy, 1, 1);
    particles.push(p);
  }
  updateParticleCount();
}

function buildQuadTree() {
  // Just assume a bounding region from -spread*2..spread*2 to ensure coverage
  let size = spread * 4;
  let root = new QuadTreeNode(0, 0, size); // center at (0,0)

  for (let p of particles) {
    root.insert(p);
  }
  return root;
}

/*****************************************************************************
 * Collisions
 ****************************************************************************/
function handleCollisions() {
  let merged = new Set();

  for (let i = 0; i < particles.length; i++) {
    if (merged.has(i)) continue;

    for (let j = i + 1; j < particles.length; j++) {
      if (merged.has(j)) continue;

      let pi = particles[i];
      let pj = particles[j];
      let dx = pi.x - pj.x;
      let dy = pi.y - pj.y;
      let dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < (pi.radius + pj.radius)) {
        // merge
        let m1 = pi.mass;
        let m2 = pj.mass;
        let newMass = m1 + m2;

        let newX = (pi.x*m1 + pj.x*m2) / newMass;
        let newY = (pi.y*m1 + pj.y*m2) / newMass;
        let newVx = (pi.vx*m1 + pj.vx*m2) / newMass;
        let newVy = (pi.vy*m1 + pj.vy*m2) / newMass;

        pi.mass = newMass;
        pi.x = newX;
        pi.y = newY;
        pi.vx = newVx;
        pi.vy = newVy;
        pi.radius = Math.cbrt(newMass) * radiusScaleFactor;

        merged.add(j);
      }
    }
  }

  if (merged.size > 0) {
    particles = particles.filter((_, idx) => !merged.has(idx));
    updateParticleCount();
  }
}

/*****************************************************************************
 * Step
 ****************************************************************************/
function stepSimulation() {
  let root = buildQuadTree();

  for (let p of particles) {
    let axay = [0, 0];
    root.accumulateForce(p.x, p.y, p.mass, axay);
    // a = F/m
    p.vx += (axay[0] / p.mass) * dt;
    p.vy += (axay[1] / p.mass) * dt;
  }

  // Integrate + store trail
  // If fewer than 100 particles, we store a trail of up to 1 second = (1/dt) steps
  let trailMaxLen = (particles.length < 100) ? Math.round(1 / dt) : 0;

  for (let p of particles) {
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    if (trailMaxLen > 0) {
      p.trail.push({x: p.x, y: p.y});
      if (p.trail.length > trailMaxLen) {
        p.trail.shift(); 
      }
    }
  }

  handleCollisions();
}

/*****************************************************************************
 * Drawing
 ****************************************************************************/
function drawParticles() {
  simCtx.clearRect(0, 0, simulationCanvas.width, simulationCanvas.height);

  // If not tracking largest mass => camera center at 0,0
  // If tracking => camera center at largest mass
  trackLargestMass = document.getElementById("trackLargestMass").checked;

  let largest = null;
  if (trackLargestMass && particles.length > 0) {
    largest = particles.reduce((acc, p) => (p.mass > acc.mass ? p : acc), particles[0]);
  }

  // scale
  // We choose a fixed scale factor to show ~ +/- spread region 
  // (You can tweak the +100 if you want more margin)
  let scaleVal = simulationCanvas.width / (2 * spread + 100);

  simCtx.save();
  // center canvas
  simCtx.translate(simulationCanvas.width/2, simulationCanvas.height/2);

  if (largest) {
    simCtx.translate(-largest.x*scaleVal, -largest.y*scaleVal);
  }
  else {
    // fixed camera at origin
    // no extra translation needed
  }
  
  // draw trails if <100
  if (particles.length < 100) {
    simCtx.strokeStyle = "rgba(255,255,255,0.3)";
    simCtx.lineWidth = 1;
    for (let p of particles) {
      if (p.trail.length < 2) continue;
      simCtx.beginPath();
      let firstPt = p.trail[0];
      simCtx.moveTo(firstPt.x * scaleVal, firstPt.y * scaleVal);
      for (let i = 1; i < p.trail.length; i++) {
        let tpt = p.trail[i];
        simCtx.lineTo(tpt.x * scaleVal, tpt.y * scaleVal);
      }
      simCtx.stroke();
    }
  }

  // find top 5 largest
  let top5 = [...particles].sort((a,b) => b.mass - a.mass).slice(0, 5);

  // draw all
  simCtx.fillStyle = "white";
  for (let p of particles) {
    let sx = p.x * scaleVal;
    let sy = p.y * scaleVal;
    let sr = p.radius * scaleVal;
    if (sr < MIN_SCREEN_RADIUS) sr = MIN_SCREEN_RADIUS;

    simCtx.beginPath();
    simCtx.arc(sx, sy, sr, 0, 2*Math.PI);
    simCtx.fill();
  }

  // highlight top 5 with a soft color
  simCtx.strokeStyle = "rgba(0,255,255,0.5)";
  simCtx.lineWidth = 2;
  for (let i = 0; i < top5.length; i++) {
    let p = top5[i];
    let sx = p.x * scaleVal;
    let sy = p.y * scaleVal;
    let sr = p.radius * scaleVal + 2; // +2 px for extra ring
    if (sr < MIN_SCREEN_RADIUS) sr = MIN_SCREEN_RADIUS;
    simCtx.beginPath();
    simCtx.arc(sx, sy, sr, 0, 2*Math.PI);
    simCtx.stroke();
  }

  simCtx.restore();
}

/*****************************************************************************
 * Rendering Loop
 ****************************************************************************/
function renderLoop() {
  if (!running) return;
  drawParticles();
  simulationRequestId = requestAnimationFrame(renderLoop);
}

/*****************************************************************************
 * Running the Simulation
 ****************************************************************************/
function runSimulationNoVisual() {
  const stepsPerBatch = 10; 
  function runBatch() {
    let stepsToDo = Math.min(stepsPerBatch, numTimeSteps - currentTimeStep);
    for (let i = 0; i < stepsToDo; i++) {
      stepSimulation();
      // store only every KEYFRAME_INTERVAL
      if (currentTimeStep % KEYFRAME_INTERVAL === 0) {
        storeCurrentState();
      }
      currentTimeStep++;
      updateProgressBar(currentTimeStep / numTimeSteps);
    }

    if (currentTimeStep < numTimeSteps && running) {
      setTimeout(runBatch, 0);
    } else {
      finishSimulation();
    }
  }
  runBatch();
}

function runSimulationVisual() {
  const singleStep = () => {
    if (!running) return;
    stepSimulation();

    // store only every KEYFRAME_INTERVAL
    if (currentTimeStep % KEYFRAME_INTERVAL === 0) {
      storeCurrentState();
    }
    currentTimeStep++;
    updateProgressBar(currentTimeStep / numTimeSteps);

    drawParticles();

    if (currentTimeStep < numTimeSteps && running) {
      setTimeout(singleStep, 0);
    } else {
      finishSimulation();
    }
  };
  singleStep();

  // (Alternatively: run step in a loop + call renderLoop())
  // renderLoop();
}

/*****************************************************************************
 * Data Storage & Replay
 ****************************************************************************/
function storeCurrentState() {
  // We'll store positions + radii for replay
  let frameData = particles.map(p => [p.x, p.y, p.radius]);
  timeStepsData.push(frameData);
}

function replayAnimation() {
  showReplayProgressBar(true);

  let speed = parseFloat(document.getElementById("playbackSpeed").value);
  let stepIndex = 0;
  let totalFrames = timeStepsData.length;

  cancelAnimationFrame(simulationRequestId);

  function replayStep() {
    if (stepIndex >= totalFrames) {
      showReplayProgressBar(false);
      return;
    }

    simCtx.clearRect(0, 0, simulationCanvas.width, simulationCanvas.height);

    let frameData = timeStepsData[stepIndex];
    // find top 5 by approximate mass => r^3
    let sorted = frameData.map(d => {
      let [x, y, r] = d;
      return {x, y, r, vol: r*r*r};
    }).sort((a,b) => b.vol - a.vol);
    let top5 = sorted.slice(0,5);

    // If tracking largest mass => center on biggest
    trackLargestMass = document.getElementById("trackLargestMass").checked;
    let largest = (trackLargestMass && sorted.length>0) ? sorted[0] : null;

    let scaleVal = simulationCanvas.width / (2*spread + 100);

    simCtx.save();
    simCtx.translate(simulationCanvas.width/2, simulationCanvas.height/2);
    if (largest) {
      simCtx.translate(-largest.x*scaleVal, -largest.y*scaleVal);
    }

    // draw all
    simCtx.fillStyle = "white";
    for (let d of frameData) {
      let [x, y, r] = d;
      let sx = x * scaleVal;
      let sy = y * scaleVal;
      let sr = r * scaleVal;
      if (sr < MIN_SCREEN_RADIUS) sr = MIN_SCREEN_RADIUS;
      simCtx.beginPath();
      simCtx.arc(sx, sy, sr, 0, 2*Math.PI);
      simCtx.fill();
    }

    // highlight top 5
    simCtx.strokeStyle = "rgba(0,255,255,0.5)";
    simCtx.lineWidth = 2;
    for (let p of top5) {
      let sx = p.x * scaleVal;
      let sy = p.y * scaleVal;
      let sr = p.r * scaleVal + 2;
      if (sr < MIN_SCREEN_RADIUS) sr = MIN_SCREEN_RADIUS;
      simCtx.beginPath();
      simCtx.arc(sx, sy, sr, 0, 2*Math.PI);
      simCtx.stroke();
    }

    simCtx.restore();

    updateReplayProgressBar(stepIndex / totalFrames);
    stepIndex++;
    setTimeout(replayStep, 16 / speed); // ~60 fps => 16ms
  }
  replayStep();
}

/*****************************************************************************
 * Progress Bars
 ****************************************************************************/
function updateProgressBar(ratio) {
  document.getElementById("progress-bar").style.width = (ratio * 100) + "%";
}
function showProgressBar(show) {
  const barContainer = document.getElementById("progress-bar-container");
  if (show) {
    barContainer.style.display = "block";
    updateProgressBar(0);
  } else {
    barContainer.style.display = "none";
  }
}
function updateReplayProgressBar(ratio) {
  document.getElementById("progress-bar-replay").style.width = (ratio * 100) + "%";
}
function showReplayProgressBar(show) {
  const barContainer = document.getElementById("progress-bar-container-replay");
  if (show) {
    barContainer.style.display = "block";
    updateReplayProgressBar(0);
  } else {
    barContainer.style.display = "none";
  }
}

/*****************************************************************************
 * Simulation Lifecycle
 ****************************************************************************/
function startSimulation() {
  numParticles = parseInt(document.getElementById("numParticles").value);
  numTimeSteps = parseInt(document.getElementById("numTimeSteps").value);
  dt = parseFloat(document.getElementById("timeStep").value);
  softening = parseFloat(document.getElementById("softening").value);
  theta = parseFloat(document.getElementById("theta").value);
  G = parseFloat(document.getElementById("gravConstant").value);
  spread = parseFloat(document.getElementById("spread").value);
  angularBias = parseFloat(document.getElementById("angularBias").value);

  running = true;
  currentTimeStep = 0;
  timeStepsData = []; // clear old data

  initParticles();
  // store initial keyframe
  storeCurrentState(); 

  showProgressBar(true);
  document.getElementById("startSimBtn").disabled = true;
  document.getElementById("stopSimBtn").disabled = false;
  document.getElementById("replaySimBtn").disabled = true;
  document.getElementById("exportDataBtn").disabled = true;

  logMessage("Simulation started with " + numParticles + " particles.");

  if (document.getElementById("simNoVisual").checked) {
    runSimulationNoVisual();
  } else {
    runSimulationVisual();
  }
}

function stopSimulation() {
  running = false;
  if (simulationRequestId) {
    cancelAnimationFrame(simulationRequestId);
    simulationRequestId = null;
  }
  logMessage("Simulation stopped.");
}

function finishSimulation() {
  running = false;
  if (simulationRequestId) {
    cancelAnimationFrame(simulationRequestId);
    simulationRequestId = null;
  }

  document.getElementById("startSimBtn").disabled = false;
  document.getElementById("stopSimBtn").disabled = true;
  document.getElementById("replaySimBtn").disabled = false;
  document.getElementById("exportDataBtn").disabled = false;
  showProgressBar(false);

  logMessage("Simulation finished. Total keyframes stored: " + timeStepsData.length);
}

function exportData() {
  // Export the stored frames
  let dataStr = JSON.stringify({
    numParticles: numParticles,
    numTimeSteps: timeStepsData.length,
    dt: dt,
    data: timeStepsData
  });
  let blob = new Blob([dataStr], { type: "application/json" });
  let url = URL.createObjectURL(blob);

  let a = document.createElement("a");
  a.href = url;
  a.download = "simulation_data.json";
  a.click();
  URL.revokeObjectURL(url);

  logMessage("Exported data (keyframes only).");
}

/*****************************************************************************
 * Main
 ****************************************************************************/
window.onload = function() {
  simulationCanvas = document.getElementById("simulationCanvas");
  simCtx = simulationCanvas.getContext("2d");

  document.getElementById("startSimBtn").addEventListener("click", startSimulation);
  document.getElementById("stopSimBtn").addEventListener("click", stopSimulation);
  document.getElementById("replaySimBtn").addEventListener("click", replayAnimation);
  document.getElementById("exportDataBtn").addEventListener("click", exportData);
};
</script>

</body>
</html>