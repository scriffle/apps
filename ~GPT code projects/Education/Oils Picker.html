<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compact RGB Color Space with Image Upload</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #topPanel {
            display: flex;
            height: 30%; /* Reduced height */
            background-color: #fff;
        }
        #rgbCanvas {
            flex: 1;
            background-color: #fff;
            position: relative;
        }
        #photoCanvasContainer {
            flex: 1;
            background-color: #fff;
            position: relative;
            border-left: 1px solid #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #photoCanvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            object-fit: contain; /* Ensures correct aspect ratio */
        }
        #photoUpload {
            position: absolute;
            top: 5px; /* Reduced margin */
            right: 5px; /* Reduced margin */
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 3px; /* Reduced padding */
            border-radius: 3px;
            font-size: 12px; /* Smaller font size */
        }
        #oilColorsPanel {
            width: 100%;
            height: 20%; /* Reduced height */
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: #333;
            padding: 5px; /* Reduced padding */
        }
        #selectedColorBox {
            width: 60px; /* Reduced size */
            height: 60px; /* Reduced size */
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            border: 1px solid #fff;
            font-size: 12px; /* Smaller font size */
            font-weight: bold;
            border-radius: 5px; /* Reduced border-radius */
        }
        .color-box {
            width: 60px; /* Reduced size */
            height: 60px; /* Reduced size */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 12px; /* Smaller font size */
            font-weight: bold;
            border: 1px solid #000;
            text-align: center;
            border-radius: 5px; /* Reduced border-radius */
        }
        #matchingPanels {
            width: 100%;
            height: 40%; /* Reduced height */
            display: flex;
            justify-content: space-around;
            background-color: #000;
            padding-top: 5px; /* Reduced padding */
        }
        .matching-panel {
            width: 21%; /* Slightly reduced width */
            height: 100%;
            background-color: #000;
            color: #fff;
            font-size: 12px; /* Smaller font size */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px; /* Reduced padding */
            border: 1px solid #fff;
            border-radius: 5px; /* Reduced border-radius */
        }
        .result-color {
            width: 100%;
            height: 30px; /* Reduced height */
            margin-bottom: 5px; /* Reduced margin */
            border: 1px solid #fff;
            border-radius: 3px;
        }
        .swatch-container {
            display: flex;
            width: 100%;
            margin-top: 5px; /* Reduced margin */
            border-radius: 3px;
            overflow: hidden;
        }
        .swatch {
            height: 15px; /* Reduced height */
            text-align: center;
            font-size: 10px; /* Smaller font size */
            color: #fff;
            position: relative;
        }
        .swatch.black {
            position: relative;
            color: #fff;
            z-index: 1;
        }
        .swatch.black::before {
            content: '';
            position: absolute;
            top: -2px;
            bottom: -2px;
            left: -2px;
            right: -2px;
            border-radius: 10px;
            border: 2px solid #ccc; /* Light grey border */
            z-index: -1; /* Ensure it's behind the swatch */
        }
        #loadingIndicator {
            position: absolute;
            top: 30px; /* Adjusted position */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 3px 5px; /* Reduced padding */
            border-radius: 3px;
            font-size: 12px; /* Smaller font size */
            display: none;
        }
        #cursorCircle {
            position: absolute;
            width: 8px; /* Reduced size */
            height: 8px; /* Reduced size */
            border-radius: 50%;
            background-color: #000;
            pointer-events: none;
            display: none; /* Hidden until the mouse moves over the canvas */
        }

        /* Modal Dialog Styles */
        #onboardingModal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent background */
            z-index: 20;
            justify-content: center;
            align-items: center;
            font-size: 16px;
        }
        #onboardingContent {
            background-color: #fff;
            color: #000;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            width: 80%;
        }
        #closeModalButton {
            background-color: #007bff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
        #closeModalButton:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <div id="topPanel">
        <canvas id="rgbCanvas"></canvas>
        <div id="photoCanvasContainer">
            <input type="file" id="photoUpload" accept="image/*">
            <canvas id="photoCanvas"></canvas>
        </div>
        <div id="cursorCircle"></div>
    </div>
    <div id="loadingIndicator">Matching Colors, please wait...</div>

    <div id="oilColorsPanel">
        <div id="selectedColorBox">Selected Color</div>
        <div class="color-box" style="background-color: #ffffff; color: #000;">White</div>
        <div class="color-box" style="background-color: #000000; color: #fff;">Black</div>
        <div class="color-box" style="background-color: #e34234; color: #fff;">Cadmium Red</div>
        <div class="color-box" style="background-color: #00a86b; color: #fff;">Viridian Green</div>
        <div class="color-box" style="background-color: #4169e1; color: #fff;">Ultramarine Blue</div>
        <div class="color-box" style="background-color: #ffd700; color: #000;">Cadmium Yellow</div>
        <div class="color-box" style="background-color: #007ba7; color: #fff;">Cerulean Blue</div>
        <div class="color-box" style="background-color: #b03060; color: #fff;">Alizarin Crimson</div>
        <div class="color-box" style="background-color: #d2b48c; color: #000;">Yellow Ochre</div>
        <div class="color-box" style="background-color: #e97451; color: #fff;">Burnt Sienna</div>
        <div class="color-box" style="background-color: #755a57; color: #fff;">Raw Umber</div>
        <div class="color-box" style="background-color: #123524; color: #fff;">Phthalo Green</div>
    </div>

    <div id="matchingPanels">
        <div class="matching-panel" id="panelTwo">Two</div>
        <div class="matching-panel" id="panelThree">Three</div>
        <div class="matching-panel" id="panelFour">Four</div>
        <div class="matching-panel" id="panelFive">Five</div>
    </div>

    <!-- Onboarding Modal -->
    <div id="onboardingModal">
        <div id="onboardingContent">
            <h2>Welcome to the Color Mixing App!</h2>
            <p>This tool allows you to explore color mixing using a simulated oil paint palette.</p>
            <ul style="text-align: left;">
                <li>Use the RGB color panel on the left to pick a color, or upload a photo to select a color from it.</li>
                <li>The selected color will appear in the "Selected Color" box.</li>
                <li>Below, you will see the closest possible color matches using different combinations of oil paints.</li>
                <li>The percentages represent the proportion of each paint color in the mix.</li>
            </ul>
            <button id="closeModalButton">Got it!</button>
        </div>
    </div>

    <script>
        const rgbCanvas = document.getElementById('rgbCanvas');
        const photoCanvas = document.getElementById('photoCanvas');
        const contextRGB = rgbCanvas.getContext('2d');
        const contextPhoto = photoCanvas.getContext('2d');
        const selectedColorBox = document.getElementById('selectedColorBox');
        const matchingPanels = document.getElementById('matchingPanels');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const cursorCircle = document.getElementById('cursorCircle');
        let searchTimeout;
        let searchInProgress = false;
        let lastMouseEvent = null;
        let uploadedImage = null; // Variable to store the uploaded image

        const oilColors = [
            { name: 'White', rgb: [255, 255, 255], cmy: [0, 0, 0] },
            { name: 'Black', rgb: [0, 0, 0], cmy: [100, 100, 100] },
            { name: 'Cadmium Red', rgb: [227, 66, 52], cmy: [0, 71, 80] },
            { name: 'Viridian Green', rgb: [0, 168, 107], cmy: [100, 0, 36] },
            { name: 'Ultramarine Blue', rgb: [65, 105, 225], cmy: [71, 53, 0] },
            { name: 'Cadmium Yellow', rgb: [255, 215, 0], cmy: [0, 16, 100] },
            { name: 'Cerulean Blue', rgb: [0, 123, 167], cmy: [100, 26, 34] },
            { name: 'Alizarin Crimson', rgb: [176, 48, 96], cmy: [0, 73, 45] },
            { name: 'Yellow Ochre', rgb: [210, 180, 140], cmy: [0, 14, 33] },
            { name: 'Burnt Sienna', rgb: [233, 116, 81], cmy: [0, 50, 65] },
            { name: 'Raw Umber', rgb: [117, 90, 87], cmy: [0, 23, 26] },
            { name: 'Phthalo Green', rgb: [18, 53, 36], cmy: [87, 52, 77] }
        ];

        function resizeCanvas() {
            const halfWidth = window.innerWidth / 2;
            const height = window.innerHeight * 0.3; /* Adjusted for smaller screen */
            rgbCanvas.width = halfWidth;
            rgbCanvas.height = height;
            photoCanvas.width = halfWidth;
            photoCanvas.height = height;
            drawRGBColorSpace();

            if (uploadedImage) {
                drawImageOnCanvas(uploadedImage);
            }

            // Restart color matching after resizing
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            if (searchInProgress) {
                searchInProgress = false;
            }
            startColorMatching(lastMouseEvent);
        }

        function drawRGBColorSpace() {
            const width = rgbCanvas.width;
            const height = rgbCanvas.height;

            // Create the image data
            const imageData = contextRGB.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;

                    // Calculate color based on the vertical position (y)
                    const midHeight = height / 2;

                    let r, g, b;

                    if (y < midHeight) {
                        // Transition from white at the top to full tint at the middle
                        const tint = 1 - (y / midHeight); // 1 at top (white), 0 at middle (full tint)

                        const segmentWidth = width / 3;

                        if (x < segmentWidth) {  // Red to Green
                            r = 255;
                            g = Math.round((x / segmentWidth) * 255);
                            b = 0;
                        } else if (x < 2 * segmentWidth) {  // Green to Blue
                            r = Math.round(((2 * segmentWidth - x) / segmentWidth) * 255);
                            g = 255;
                            b = Math.round(((x - segmentWidth) / segmentWidth) * 255);
                        } else {  // Blue back to Red
                            r = Math.round(((x - 2 * segmentWidth) / segmentWidth) * 255);
                            g = Math.round(((3 * segmentWidth - x) / segmentWidth) * 255);
                            b = 255;
                        }

                        // Apply tint
                        r = Math.round(255 - (255 - r) * (1 - tint));
                        g = Math.round(255 - (255 - g) * (1 - tint));
                        b = Math.round(255 - (255 - b) * (1 - tint));

                    } else {
                        // Transition from full tint at the middle to black at the bottom
                        const tint = (y - midHeight) / midHeight; // 0 at middle (full tint), 1 at bottom (black)

                        const segmentWidth = width / 3;

                        if (x < segmentWidth) {  // Red to Green
                            r = 255;
                            g = Math.round((x / segmentWidth) * 255);
                            b = 0;
                        } else if (x < 2 * segmentWidth) {  // Green to Blue
                            r = Math.round(((2 * segmentWidth - x) / segmentWidth) * 255);
                            g = 255;
                            b = Math.round(((x - segmentWidth) / segmentWidth) * 255);
                        } else {  // Blue back to Red
                            r = Math.round(((x - 2 * segmentWidth) / segmentWidth) * 255);
                            g = Math.round(((3 * segmentWidth - x) / segmentWidth) * 255);
                            b = 255;
                        }

                        // Apply tint towards black
                        r = Math.round(r * (1 - tint));
                        g = Math.round(g * (1 - tint));
                        b = Math.round(b * (1 - tint));
                    }

                    // Set pixel data
                    data[index] = r;        // Red
                    data[index + 1] = g;    // Green
                    data[index + 2] = b;    // Blue
                    data[index + 3] = 255;  // Alpha (fully opaque)
                }
            }

            // Draw the image data on the canvas
            contextRGB.putImageData(imageData, 0, 0);
        }

        function rgbToCmy(r, g, b) {
            // Convert RGB to CMY
            const c = 100 - (r / 255) * 100;
            const m = 100 - (g / 255) * 100;
            const y = 100 - (b / 255) * 100;
            return { C: Math.round(c), M: Math.round(m), Y: Math.round(y) };
        }

        function calculateColorMatch(cmyTarget, numColors) {
            let bestMatch = null;
            let bestMatchPercentage = [];
            let minDistance = Infinity;

            // Generate combinations of the oil colors
            const combinations = generateCombinations(oilColors, numColors);

            combinations.forEach(combination => {
                const result = findClosestMix(cmyTarget, combination);

                if (result.distance < minDistance) {
                    minDistance = result.distance;
                    bestMatch = result.color;
                    bestMatchPercentage = result.percentages;
                }

                // Check if the search should be interrupted
                if (!searchInProgress) {
                    return;
                }
            });

            return { bestMatch, bestMatchPercentage };
        }

        function generateCombinations(arr, size) {
            function* doCombination(offset, combo) {
                if (combo.length === size) {
                    yield combo;
                    return;
                }
                for (let i = offset; i < arr.length; i++) {
                    yield* doCombination(i + 1, combo.concat(arr[i]));
                }
            }
            return Array.from(doCombination(0, []));
        }

        function findClosestMix(target, colors) {
            const weights = new Array(colors.length).fill(0);
            let minDistance = Infinity;
            let bestWeights = [];

            function evaluate(weights) {
                let mixedC = 0, mixedM = 0, mixedY = 0;
                weights.forEach((w, i) => {
                    mixedC += colors[i].cmy[0] * w;
                    mixedM += colors[i].cmy[1] * w;
                    mixedY += colors[i].cmy[2] * w;
                });

                const dist = Math.sqrt(
                    Math.pow(mixedC - target.C, 2) +
                    Math.pow(mixedM - target.M, 2) +
                    Math.pow(mixedY - target.Y, 2)
                );

                if (dist < minDistance) {
                    minDistance = dist;
                    bestWeights = weights.slice();
                }
            }

            // Basic brute-force search with a step of 10% increments
            for (let w1 = 0; w1 <= 1; w1 += 0.1) {
                for (let w2 = 0; w1 + w2 <= 1; w2 += 0.1) {
                    if (colors.length > 2) {
                        for (let w3 = 0; w1 + w2 + w3 <= 1; w3 += 0.1) {
                            if (colors.length > 3) {
                                for (let w4 = 0; w1 + w2 + w3 + w4 <= 1; w4 += 0.1) {
                                    if (colors.length > 4) {
                                        for (let w5 = 0; w1 + w2 + w3 + w4 + w5 <= 1; w5 += 0.1) {
                                            if (Math.abs(w1 + w2 + w3 + w4 + w5 - 1) < 0.1) {
                                                evaluate([w1, w2, w3, w4, w5]);
                                            }
                                        }
                                    } else if (Math.abs(w1 + w2 + w3 + w4 - 1) < 0.1) {
                                        evaluate([w1, w2, w3, w4]);
                                    }
                                }
                            } else if (Math.abs(w1 + w2 + w3 - 1) < 0.1) {
                                evaluate([w1, w2, w3]);
                            }
                        }
                    } else if (Math.abs(w1 + w2 - 1) < 0.1) {
                        evaluate([w1, w2]);
                    }
                }
            }

            return { color: colors, percentages: bestWeights, distance: minDistance };
        }

        function findClosestRGBPosition(r, g, b) {
            const width = rgbCanvas.width;
            const height = rgbCanvas.height;

            let closestX = 0;
            let closestY = 0;
            let minDistance = Infinity;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const currentR = contextRGB.getImageData(x, y, 1, 1).data[0];
                    const currentG = contextRGB.getImageData(x, y, 1, 1).data[1];
                    const currentB = contextRGB.getImageData(x, y, 1, 1).data[2];

                    const distance = Math.sqrt(
                        Math.pow(currentR - r, 2) +
                        Math.pow(currentG - g, 2) +
                        Math.pow(currentB - b, 2)
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestX = x;
                        closestY = y;
                    }
                }
            }

            return { x: closestX, y: closestY };
        }

        function renderMatchingPanels(cmy) {
            const panels = [
                { element: document.getElementById('panelTwo'), colors: 2 },
                { element: document.getElementById('panelThree'), colors: 3 },
                { element: document.getElementById('panelFour'), colors: 4 },
                { element: document.getElementById('panelFive'), colors: 5 },
            ];

            panels.forEach(panel => {
                const match = calculateColorMatch(cmy, panel.colors);
                renderPanel(panel.element, match.bestMatch, match.bestMatchPercentage);
            });
        }

        function renderPanel(panel, colors, percentages) {
            panel.innerHTML = ''; // Clear existing content
            
            // Calculate and display the resulting mixed color
            const resultColor = calculateMixedColor(colors, percentages);
            const resultColorDiv = document.createElement('div');
            resultColorDiv.classList.add('result-color');
            resultColorDiv.style.backgroundColor = `rgb(${resultColor.r}, ${resultColor.g}, ${resultColor.b})`;
            panel.appendChild(resultColorDiv);

            colors.forEach((color, index) => {
                const swatchContainer = document.createElement('div');
                swatchContainer.classList.add('swatch-container');

                const swatch = document.createElement('div');
                swatch.classList.add('swatch');
                if (color.name === 'Black') {
                    swatch.classList.add('black'); // Add the 'black' class for special styling
                }
                swatch.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                swatch.style.width = `${percentages[index] * 100}%`;

                const label = document.createElement('div');
                label.innerText = `${color.name}: ${Math.round(percentages[index] * 100)}%`;

                swatchContainer.appendChild(swatch);
                panel.appendChild(swatchContainer);
                panel.appendChild(label);
            });
        }

        function calculateMixedColor(colors, percentages) {
            let r = 0, g = 0, b = 0;
            colors.forEach((color, index) => {
                r += color.rgb[0] * percentages[index];
                g += color.rgb[1] * percentages[index];
                b += color.rgb[2] * percentages[index];
            });
            return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
        }

        function startColorMatching(event) {
            if (!event) return;

            const canvas = event.target;
            const context = canvas === rgbCanvas ? contextRGB : contextPhoto;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const pixelData = context.getImageData(mouseX, mouseY, 1, 1).data;
            const r = pixelData[0];
            const g = pixelData[1];
            const b = pixelData[2];

            const cmy = rgbToCmy(r, g, b);

            // Adjust the font color for contrast
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            selectedColorBox.style.color = brightness > 125 ? '#000' : '#fff';

            // Display the selected color in the left panel
            selectedColorBox.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            selectedColorBox.textContent = `Selected Color`;

            // If hovering over the photo panel, find the closest matching position in the RGB panel
            if (canvas === photoCanvas) {
                const { x, y } = findClosestRGBPosition(r, g, b);
                cursorCircle.style.left = `${x + rgbCanvas.getBoundingClientRect().left - 4}px`; // Center circle
                cursorCircle.style.top = `${y + rgbCanvas.getBoundingClientRect().top - 4}px`;
                cursorCircle.style.display = 'block';
            } else {
                cursorCircle.style.left = `${event.clientX - 4}px`; // Center circle
                cursorCircle.style.top = `${event.clientY - 4}px`;
                cursorCircle.style.display = 'block';
            }

            // Cancel any ongoing search
            if (searchInProgress) {
                searchInProgress = false;
            }

            // Start a new search
            loadingIndicator.style.display = 'block';
            searchInProgress = true;

            searchTimeout = setTimeout(() => {
                renderMatchingPanels(cmy);
                loadingIndicator.style.display = 'none'; // Hide loading indicator after rendering
                searchInProgress = false;
            }, 0); // Delay to allow the loading indicator to display
        }

        function drawImageOnCanvas(img) {
            contextPhoto.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
            const scale = Math.min(photoCanvas.width / img.width, photoCanvas.height / img.height);
            const x = (photoCanvas.width / 2) - (img.width / 2) * scale;
            const y = (photoCanvas.height / 2) - (img.height / 2) * scale;
            contextPhoto.drawImage(img, x, y, img.width * scale, img.height * scale);
        }

        rgbCanvas.addEventListener('mousemove', (event) => {
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            startColorMatching(event);
        });

        photoCanvas.addEventListener('mousemove', (event) => {
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            startColorMatching(event);
        });

        document.getElementById('photoUpload').addEventListener('change', (event) => {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedImage = new Image(); // Store the uploaded image
                uploadedImage.onload = () => {
                    drawImageOnCanvas(uploadedImage);
                };
                uploadedImage.src = e.target.result;
            };
            if (file) {
                reader.readAsDataURL(file);
            }
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();  // Initial draw

        // Onboarding Modal
        function showOnboardingModal() {
            if (!localStorage.getItem('hasVisited')) {
                document.getElementById('onboardingModal').style.display = 'flex';
                localStorage.setItem('hasVisited', 'true');
            }
        }

        document.getElementById('closeModalButton').addEventListener('click', () => {
            document.getElementById('onboardingModal').style.display = 'none';
        });

        window.addEventListener('load', showOnboardingModal);
    </script>

</body>
</html>
