<!DOCTYPE html>
<html>
<head>
    <title>Gravitational Accretion Simulation - Advanced Orbital Motion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        canvas {
            border: 1px solid #333;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: inline-block;
            width: 150px;
        }
        .checkbox-container {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="togglePause()">Play/Pause</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="recenterView()">Recenter</button>
        <div>Particles: <span id="particleCount">0</span></div>
        <div>Largest Mass: <span id="largestMass">1.0</span></div>
        <div class="checkbox-container">
            <label>
                <input type="checkbox" checked onchange="toggleCenterTracking()">
                Track Largest Mass
            </label>
        </div>
        <div class="slider-container">
            <label>Population: </label>
            <input type="range" min="500" max="5000" step="100" value="2000" oninput="updatePopulation(this.value)">
            <span id="populationValue">2000</span>
        </div>
        <div class="slider-container">
            <label>Zoom: </label>
            <input type="range" min="0.001" max="0.2" step="0.001" value="0.05" oninput="updateZoom(this.value)">
            <span id="zoomValue">0.05x</span>
        </div>
        <div class="slider-container">
            <label>View Scale: </label>
            <input type="range" min="1" max="10" step="0.1" value="0.004" oninput="updateViewScale(this.value)">
            <span id="viewScaleValue">Linear</span>
        </div>
        <div class="slider-container">
            <label>Time Speed: </label>
            <input type="range" min="0.1" max="5" step="0.1" value="1" oninput="updateTimeStep(this.value)">
            <span id="timeValue">1.0x</span>
        </div>
        <div class="slider-container">
            <label>Gravity Strength: </label>
            <input type="range" min="0.1" max="100" step="0.1" value="1" oninput="updateGravity(this.value)">
            <span id="gravityValue">1.0x</span>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isPaused = true;
        let zoom = 0.05;
        let timeMultiplier = 1;
        let gravityMultiplier = 1;
        let largestMass = 1;
        let largestParticle = null;
        let particleCount = 2000;
        let trackCenter = true;
        let viewScale = 0.004; // Starting at 0.004
        let pulsePhase = 0;
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        const WORLD_SIZE = 50000000;
        const INITIAL_RADIUS = 50000;
        const BASE_G = 6.67430e-11 * 1e13;
        let G = BASE_G;
        const SOFTENING = 100;
        const BASE_TIME_STEP = 0.2;
        let TIME_STEP = BASE_TIME_STEP;
        const BASE_RADIUS = 8;
        const MAX_VELOCITY = 1000;
        const FLASH_DURATION = 20;
        const MIN_PARTICLE_SIZE = 2;
        const CLOCKWISE_COLOR = '#ffff00';
        const ANTICLOCKWISE_COLOR = '#00ff00';
        const LARGEST_COLOR = '#ffffff';
        const CENTER_INDICATOR_COLOR = '#00ffff';
        const PULSE_SPEED = 0.05;

        function transformCoordinate(value, center) {
            const distFromCenter = value - center;
            if (viewScale === 1) return value;
            
            const sign = Math.sign(distFromCenter);
            const absDistance = Math.abs(distFromCenter);
            
            if (absDistance <= INITIAL_RADIUS) {
                return value;
            }
            
            const logScale = (viewScale - 1) / 9;
            const linearPart = INITIAL_RADIUS;
            const logBase = 1 + (9 * logScale);
            const logPart = Math.log(absDistance / INITIAL_RADIUS + 1) / Math.log(logBase) * INITIAL_RADIUS * viewScale;
            const transformedDist = (linearPart + logPart) * sign;
            
            return center + transformedDist;
        }

        function drawCenterIndicator() {
            if (!largestParticle) return;
            
            const screenX = (transformCoordinate(largestParticle.x, cameraX) - cameraX) * zoom + canvas.width / 2;
            const screenY = (transformCoordinate(largestParticle.y, cameraY) - cameraY) * zoom + canvas.height / 2;
            
            pulsePhase = (pulsePhase + PULSE_SPEED) % (Math.PI * 2);
            const pulseOpacity = 0.3 + 0.7 * Math.abs(Math.sin(pulsePhase));
            
            ctx.beginPath();
            ctx.arc(screenX, screenY, 50, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(0, 255, 255, ${pulseOpacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        class Flash {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.life = FLASH_DURATION;
            }

            draw() {
                if (this.life <= 0) return false;
                
                const screenX = (transformCoordinate(this.x, cameraX) - cameraX) * zoom + canvas.width / 2;
                const screenY = (transformCoordinate(this.y, cameraY) - cameraY) * zoom + canvas.height / 2;
                
                const alpha = this.life / FLASH_DURATION;
                const size = this.size * (2 - alpha) * zoom;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
                
                this.life--;
                return true;
            }
        }

        let flashes = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let cameraX = WORLD_SIZE / 2;
        let cameraY = WORLD_SIZE / 2;
        let targetCameraX = WORLD_SIZE / 2;
        let targetCameraY = WORLD_SIZE / 2;

        function recenterView() {
            if (largestParticle) {
                targetCameraX = largestParticle.x;
                targetCameraY = largestParticle.y;
            } else {
                targetCameraX = WORLD_SIZE / 2;
                targetCameraY = WORLD_SIZE / 2;
            }
            trackCenter = true;
            document.querySelector('.checkbox-container input').checked = true;
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
            trackCenter = false;
            document.querySelector('.checkbox-container input').checked = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                targetCameraX -= dx / zoom;
                targetCameraY -= dy / zoom;
                cameraX = targetCameraX;
                cameraY = targetCameraY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.mass = 1;
                this.radius = Math.sqrt(this.mass) * BASE_RADIUS;
                this.merged = false;
                this.orbitDirection = 0;
                
                this.lastRadialDistance = null;
                this.radialDistanceHistory = [];
                this.lastExtremalPoint = 0;
            }

            getOrbitDirection() {
                if (!largestParticle || this === largestParticle) return 0;

                const dx = this.x - largestParticle.x;
                const dy = this.y - largestParticle.y;
                const dvx = this.vx - largestParticle.vx;
                const dvy = this.vy - largestParticle.vy;

                const crossProduct = dx * dvy - dy * dvx;
                return Math.sign(crossProduct);
            }

            circularizeOrbit() {
                if (!largestParticle || this === largestParticle) return;

                const dx = this.x - largestParticle.x;
                const dy = this.y - largestParticle.y;
                const dvx = this.vx - largestParticle.vx;
                const dvy = this.vy - largestParticle.vy;
                
                const r = Math.sqrt(dx * dx + dy * dy);
                
                this.radialDistanceHistory.push(r);
                if (this.radialDistanceHistory.length > 3) {
                    this.radialDistanceHistory.shift();
                }

                if (this.radialDistanceHistory.length === 3) {
                    const [r1, r2, r3] = this.radialDistanceHistory;
                    
                    if ((r2 >= r1 && r2 >= r3) || (r2 <= r1 && r2 <= r3)) {
                        if (this.lastExtremalPoint > 10) {
                            const speed = Math.sqrt(dvx * dvx + dvy * dvy);
                            const centralMass = largestParticle.mass;
                            const idealCircularSpeed = Math.sqrt((G * centralMass) / r);
                            const crossProduct = dx * dvy - dy * dvx;
                            const direction = Math.sign(crossProduct);
                            
                            const norm = Math.sqrt(dx * dx + dy * dy);
                            const tangentialX = -dy / norm * direction;
                            const tangentialY = dx / norm * direction;
                            
                            const blendFactor = 0.1;
                            const newSpeed = speed * (1 - blendFactor) + idealCircularSpeed * blendFactor;
                            
                            this.vx = largestParticle.vx + tangentialX * newSpeed;
                            this.vy = largestParticle.vy + tangentialY * newSpeed;
                            
                            this.lastExtremalPoint = 0;
                        }
                    }
                }
                
                this.lastExtremalPoint++;
            }

            update(particles) {
                if (this.merged) return;

                let fx = 0;
                let fy = 0;

                for (let other of particles) {
                    if (other === this || other.merged) continue;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);

                    if (dist < (this.radius + other.radius)) {
                        if (this.mass >= other.mass) {
                            this.mass += other.mass;
                            this.radius = Math.sqrt(this.mass) * BASE_RADIUS;
                            
                            const massRatio = other.mass / this.mass;
                            this.vx = this.vx * (1 - massRatio) + other.vx * massRatio;
                            this.vy = this.vy * (1 - massRatio) + other.vy * massRatio;
                            
                            other.merged = true;
                            flashes.push(new Flash(this.x, this.y, this.radius * 2));
                            
                            if (this.mass > largestMass) {
                                largestMass = this.mass;
                                largestParticle = this;
                                document.getElementById('largestMass').textContent = largestMass.toFixed(1);
                            }
                        }
                        continue;
                    }

                    const softenedDistSq = distSq + SOFTENING * (1 + Math.log10(this.mass + other.mass));
                    const force = G * this.mass * other.mass / softenedDistSq;
                    const dampening = 1 / (1 + dist * 0.0001);
                    fx += force * dx / dist * dampening;
                    fy += force * dy / dist * dampening;
                }

                const massDamping = 1 / (1 + Math.log10(this.mass) * 0.5);
                const ax = (fx / this.mass) * massDamping;
                const ay = (fy / this.mass) * massDamping;
                
                this.vx += ax * TIME_STEP;
                this.vy += ay * TIME_STEP;
                
                this.circularizeOrbit();
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > MAX_VELOCITY) {
                    const scale = MAX_VELOCITY / speed;
                    this.vx *= scale;
                    this.vy *= scale;
                }
                
                const posDamping = 1 / (1 + Math.log10(this.mass) * 0.2);
                this.x += this.vx * TIME_STEP * posDamping;
                this.y += this.vy * TIME_STEP * posDamping;

                if (this.x < 0) this.x = WORLD_SIZE;
                if (this.x > WORLD_SIZE) this.x = 0;
                if (this.y < 0) this.y = WORLD_SIZE;
                if (this.y > WORLD_SIZE) this.y = 0;

                this.orbitDirection = this.getOrbitDirection();
            }

            draw() {
                if (this.merged) return;

                const screenX = (transformCoordinate(this.x, cameraX) - cameraX) * zoom + canvas.width / 2;
                const screenY = (transformCoordinate(this.y, cameraY) - cameraY) * zoom + canvas.height / 2;

                if (screenX < -100 || screenX > canvas.width + 100 ||
                    screenY < -100 || screenY > canvas.height + 100) return;

                const renderedSize = Math.max(MIN_PARTICLE_SIZE, this.radius * zoom);

                ctx.beginPath();
                ctx.arc(screenX, screenY, renderedSize, 0, Math.PI * 2);
                
                if (this === largestParticle) {
                    ctx.fillStyle = LARGEST_COLOR;
                } else {
                    switch (this.orbitDirection) {
                        case 1:  ctx.fillStyle = CLOCKWISE_COLOR; break;
                        case -1: ctx.fillStyle = ANTICLOCKWISE_COLOR; break;
                        default: ctx.fillStyle = 'white';
                    }
                }
                ctx.fill();
            }
        }

        let particles = [];

        function initParticles() {
            particles = [];
            flashes = [];
            largestMass = 1;
            largestParticle = null;
            document.getElementById('largestMass').textContent = largestMass.toFixed(1);
            
            const centerX = WORLD_SIZE / 2;
            const centerY = WORLD_SIZE / 2;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(Math.random()) * INITIAL_RADIUS;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                particles.push(new Particle(x, y));
            }
        }

        function toggleCenterTracking() {
            trackCenter = !trackCenter;
            if (trackCenter) {
                recenterView();
            }
        }

        function updateParticles() {
            if (isPaused) return;
            
            for (let particle of particles) {
                particle.update(particles);
            }
            
            particles = particles.filter(p => !p.merged);
            document.getElementById('particleCount').textContent = particles.length;

            if (!isDragging && trackCenter && largestParticle) {
                targetCameraX = largestParticle.x;
                targetCameraY = largestParticle.y;
                
                // Smooth camera movement
                const cameraDampening = 0.1;
                cameraX += (targetCameraX - cameraX) * cameraDampening;
                cameraY += (targetCameraY - cameraY) * cameraDampening;
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let particle of particles) {
                particle.draw();
            }

            flashes = flashes.filter(flash => flash.draw());
            
            // Draw pulsing circle around largest mass
            drawCenterIndicator();

            requestAnimationFrame(draw);
        }

        function togglePause() {
            isPaused = !isPaused;
        }

        function updatePopulation(value) {
            particleCount = parseInt(value);
            document.getElementById('populationValue').textContent = particleCount;
            resetSimulation();
        }

        function updateViewScale(value) {
            viewScale = parseFloat(value);
            const logBase = 1 + (9 * ((viewScale - 1) / 9));
            const scaleType = viewScale === 1 ? 'Linear' : `Log${logBase.toFixed(1)}`;
            document.getElementById('viewScaleValue').textContent = scaleType;
        }

        function resetSimulation() {
            initParticles();
            recenterView();
        }

        function updateZoom(value) {
            zoom = parseFloat(value);
            document.getElementById('zoomValue').textContent = zoom.toFixed(3) + 'x';
        }

        function updateTimeStep(value) {
            timeMultiplier = parseFloat(value);
            TIME_STEP = BASE_TIME_STEP * timeMultiplier;
            document.getElementById('timeValue').textContent = timeMultiplier.toFixed(1) + 'x';
        }

        function updateGravity(value) {
            gravityMultiplier = parseFloat(value);
            G = BASE_G * gravityMultiplier;
            document.getElementById('gravityValue').textContent = gravityMultiplier.toFixed(1) + 'x';
        }

        // Initialize simulation
        initParticles();
        setInterval(updateParticles, 1000 / 60);
        draw();
    </script>
</body>
</html>

Version 2 of 2