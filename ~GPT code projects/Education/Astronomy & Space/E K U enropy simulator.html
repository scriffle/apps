<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universe Evolution: From Hot Soup to Heat Death</title>
    <style>
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #000;
            color: #fff;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        #container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 24px;
            margin: 0 0 20px 0;
        }
        
        #controls {
            background: #111;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover:not(:disabled) {
            background: #444;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background: #111;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .stat-label {
            font-size: 12px;
            color: #888;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        #universe {
            position: relative;
            width: 100%;
            height: 600px;
            background: #000;
            border: 1px solid #333;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #timeline {
            margin-top: 20px;
            background: #111;
            padding: 15px;
            border-radius: 8px;
        }
        
        #phase {
            font-size: 14px;
            color: #0ff;
            margin-bottom: 10px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        #log {
            margin-top: 20px;
            background: #111;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #888;
        }
        
        .log-entry.important {
            color: #0ff;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Universe Evolution Simulator</h1>
        
        <div id="controls">
            <button id="startBtn" onclick="startSimulation()">Start</button>
            <button id="pauseBtn" onclick="pauseSimulation()" disabled>Pause</button>
            <button id="resetBtn" onclick="resetSimulation()">Reset</button>
            <button id="gravityBtn" onclick="toggleGravity()">Enable Gravity</button>
            <button id="speedBtn" onclick="cycleSpeed()">Speed: 1x</button>
            <div class="slider-container">
                <label>Expansion Rate:</label>
                <input type="range" id="expansionRate" min="0" max="100" value="10" onchange="updateExpansion()">
                <span id="expansionValue">10</span>
            </div>
        </div>
        
        <div id="stats">
            <div class="stat-box">
                <div class="stat-label">Total Energy (E)</div>
                <div class="stat-value" id="totalEnergy">0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Kinetic Energy (K)</div>
                <div class="stat-value" id="kineticEnergy">0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Potential Energy (U)</div>
                <div class="stat-value" id="potentialEnergy">0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Temperature (K)</div>
                <div class="stat-value" id="temperature">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Entropy (S/k)</div>
                <div class="stat-value" id="entropy">0.00</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Radiated Energy</div>
                <div class="stat-value" id="radiatedEnergy">0.00</div>
            </div>
        </div>
        
        <div id="universe">
            <canvas id="gravityCanvas"></canvas>
            <canvas id="particleCanvas"></canvas>
            <canvas id="photonCanvas"></canvas>
            <canvas id="starCanvas"></canvas>
        </div>
        
        <div id="timeline">
            <div id="phase">Phase: Initial Hot Soup</div>
            <div class="slider-container">
                <label>Time:</label>
                <input type="range" id="timeSlider" min="0" max="1000" value="0" onchange="jumpToTime()">
                <span id="timeValue">0 Gyr</span>
            </div>
        </div>
        
        <div id="log">
            <div class="log-entry important">Simulation ready. Universe initialized at 1/1024 screen size.</div>
        </div>
    </div>
    
    <script>
        // Physical constants
        const G = 1.0;
        const k_B = 1.0;
        const c = 10.0; // Reduced for visible photons
        
        // Simulation state
        let particles = [];
        let stars = [];
        let blackHoles = [];
        let photons = [];
        let running = false;
        let gravityEnabled = false;
        let simulationTime = 0;
        let speed = 1;
        let animationId = null;
        let expansionRate = 0.01;
        let universeSize = 32; // Start at 1/1024 of screen
        let radiatedEnergy = 0;
        
        // Canvas setup
        const gravityCanvas = document.getElementById('gravityCanvas');
        const particleCanvas = document.getElementById('particleCanvas');
        const photonCanvas = document.getElementById('photonCanvas');
        const starCanvas = document.getElementById('starCanvas');
        const gCtx = gravityCanvas.getContext('2d');
        const pCtx = particleCanvas.getContext('2d');
        const phCtx = photonCanvas.getContext('2d');
        const sCtx = starCanvas.getContext('2d');
        
        function resizeCanvas() {
            const container = document.getElementById('universe');
            gravityCanvas.width = particleCanvas.width = photonCanvas.width = starCanvas.width = container.clientWidth;
            gravityCanvas.height = particleCanvas.height = photonCanvas.height = starCanvas.height = container.clientHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        function initializeParticles() {
            particles = [];
            stars = [];
            blackHoles = [];
            photons = [];
            radiatedEnergy = 0;
            universeSize = 32;
            
            const numParticles = 200;
            const initialTemp = 1e10;
            const centerX = particleCanvas.width / 2;
            const centerY = particleCanvas.height / 2;
            
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * universeSize / 2;
                const speed = Math.sqrt(2 * k_B * initialTemp) * 1e-6;
                const vAngle = Math.random() * 2 * Math.PI;
                
                particles.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle),
                    vx: speed * Math.cos(vAngle),
                    vy: speed * Math.sin(vAngle),
                    mass: 1.0,
                    temperature: initialTemp
                });
            }
            
            updateEnergies();
            log("Universe initialized in 1/1024 screen volume", true);
        }
        
        function updateEnergies() {
            let kineticE = 0;
            let potentialE = 0;
            
            particles.forEach(p => {
                const v2 = p.vx * p.vx + p.vy * p.vy;
                kineticE += 0.5 * p.mass * v2;
            });
            
            stars.forEach(s => {
                kineticE += s.internalEnergy * (1 - s.age / s.lifetime);
            });
            
            if (gravityEnabled) {
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const r = Math.sqrt(dx * dx + dy * dy) + 0.1;
                        potentialE -= G * particles[i].mass * particles[j].mass / r;
                    }
                }
                
                stars.forEach(s => {
                    potentialE += s.bindingEnergy;
                });
            }
            
            const totalE = kineticE + potentialE - radiatedEnergy;
            
            let temperature = 0;
            if (particles.length > 0) {
                let totalKE = 0;
                particles.forEach(p => {
                    const v2 = p.vx * p.vx + p.vy * p.vy;
                    totalKE += 0.5 * p.mass * v2;
                });
                temperature = totalKE / (particles.length * k_B) * 1e12;
            }
            
            const entropy = particles.length * Math.log(Math.max(1, universeSize)) + 
                          stars.length * 10 + blackHoles.length * 100;
            
            document.getElementById('totalEnergy').textContent = totalE.toFixed(2);
            document.getElementById('kineticEnergy').textContent = kineticE.toFixed(2);
            document.getElementById('potentialEnergy').textContent = potentialE.toFixed(2);
            document.getElementById('temperature').textContent = temperature.toExponential(2);
            document.getElementById('entropy').textContent = entropy.toFixed(2);
            document.getElementById('radiatedEnergy').textContent = radiatedEnergy.toFixed(2);
        }
        
        function updatePhysics(dt) {
            const centerX = particleCanvas.width / 2;
            const centerY = particleCanvas.height / 2;
            
            // Universe expansion
            universeSize *= (1 + expansionRate * 0.0001 * dt);
            universeSize = Math.min(universeSize, Math.min(particleCanvas.width, particleCanvas.height) * 0.9);
            
            // Update particles
            particles = particles.filter(p => {
                // Check if within universe bounds
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const r = Math.sqrt(dx * dx + dy * dy);
                
                if (r > universeSize / 2) {
                    return false; // Remove particle
                }
                
                if (gravityEnabled) {
                    let ax = 0, ay = 0;
                    
                    particles.forEach(p2 => {
                        if (p !== p2) {
                            const dx = p2.x - p.x;
                            const dy = p2.y - p.y;
                            const r2 = dx * dx + dy * dy + 0.01;
                            const r = Math.sqrt(r2);
                            const f = G * p2.mass / r2;
                            ax += f * dx / r;
                            ay += f * dy / r;
                        }
                    });
                    
                    stars.forEach(s => {
                        const dx = s.x - p.x;
                        const dy = s.y - p.y;
                        const r2 = dx * dx + dy * dy + 1;
                        const r = Math.sqrt(r2);
                        const f = G * s.mass / r2;
                        ax += f * dx / r;
                        ay += f * dy / r;
                    });
                    
                    blackHoles.forEach(bh => {
                        const dx = bh.x - p.x;
                        const dy = bh.y - p.y;
                        const r2 = dx * dx + dy * dy + 0.01;
                        const r = Math.sqrt(r2);
                        
                        if (r < bh.radius * 2) {
                            p.captured = true; // Mark for removal
                        } else {
                            const f = G * bh.mass / r2;
                            ax += f * dx / r;
                            ay += f * dy / r;
                        }
                    });
                    
                    p.vx += ax * dt;
                    p.vy += ay * dt;
                }
                
                // Hubble flow (expansion)
                const hubbleVx = (p.x - centerX) * expansionRate * 0.00001;
                const hubbleVy = (p.y - centerY) * expansionRate * 0.00001;
                p.vx += hubbleVx;
                p.vy += hubbleVy;
                
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                
                // Cooling due to expansion
                p.vx *= 0.9999;
                p.vy *= 0.9999;
                
                return !p.captured;
            });
            
            // Star formation check
            if (gravityEnabled && Math.random() < 0.002 && particles.length > 20) {
                checkStarFormation();
            }
            
            // Update stars
            stars = stars.filter(s => {
                s.age += dt;
                const ageRatio = s.age / s.lifetime;
                s.luminosity = s.mass * Math.pow(1 - ageRatio, 2);
                
                // Emit photons
                if (Math.random() < s.luminosity * 0.1) {
                    const angle = Math.random() * 2 * Math.PI;
                    const energy = s.luminosity * 0.01;
                    photons.push({
                        x: s.x,
                        y: s.y,
                        vx: Math.cos(angle) * c,
                        vy: Math.sin(angle) * c,
                        energy: energy,
                        wavelength: 550, // nm, will be redshifted
                        age: 0
                    });
                    radiatedEnergy += energy;
                }
                
                if (s.age > s.lifetime) {
                    if (s.mass > 8) {
                        blackHoles.push({
                            x: s.x,
                            y: s.y,
                            mass: s.mass * 0.5,
                            radius: 2 * G * s.mass * 0.5 / (c * c),
                            temperature: 1 / (8 * Math.PI * G * s.mass * 0.5)
                        });
                        log(`Black hole formed, mass=${(s.mass * 0.5).toFixed(1)}`, true);
                    }
                    
                    // Supernova ejecta
                    for (let i = 0; i < 10; i++) {
                        const angle = (i / 10) * 2 * Math.PI;
                        const speed = 0.5;
                        particles.push({
                            x: s.x,
                            y: s.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            mass: s.mass / 20,
                            temperature: 1e8
                        });
                    }
                    return false;
                }
                return true;
            });
            
            // Update black holes
            blackHoles = blackHoles.filter(bh => {
                // Hawking radiation
                const T_hawking = bh.temperature;
                const evapRate = T_hawking * T_hawking * dt * 1e-10;
                bh.mass -= evapRate;
                
                // Emit Hawking radiation photons
                if (Math.random() < T_hawking * 0.1) {
                    const angle = Math.random() * 2 * Math.PI;
                    photons.push({
                        x: bh.x,
                        y: bh.y,
                        vx: Math.cos(angle) * c,
                        vy: Math.sin(angle) * c,
                        energy: T_hawking,
                        wavelength: 1240 / T_hawking, // Energy to wavelength
                        age: 0,
                        hawking: true
                    });
                    radiatedEnergy += T_hawking;
                }
                
                if (bh.mass < 0.1) {
                    log(`Black hole evaporated via Hawking radiation`, true);
                    // Final burst
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * 2 * Math.PI;
                        photons.push({
                            x: bh.x,
                            y: bh.y,
                            vx: Math.cos(angle) * c * 2,
                            vy: Math.sin(angle) * c * 2,
                            energy: bh.mass / 20,
                            wavelength: 400,
                            age: 0,
                            hawking: true
                        });
                    }
                    return false;
                }
                
                bh.radius = 2 * G * bh.mass / (c * c);
                bh.temperature = 1 / (8 * Math.PI * G * bh.mass);
                return true;
            });
            
            // Update photons
            photons = photons.filter(ph => {
                ph.x += ph.vx * dt;
                ph.y += ph.vy * dt;
                ph.age += dt;
                
                // Redshift due to expansion
                ph.wavelength *= (1 + expansionRate * 0.00001);
                
                // Remove if outside universe or too old
                const dx = ph.x - centerX;
                const dy = ph.y - centerY;
                const r = Math.sqrt(dx * dx + dy * dy);
                
                return r < universeSize && ph.age < 1000;
            });
            
            simulationTime += dt * speed * 1e6;
            updateEnergies();
            updatePhase();
        }
        
        function checkStarFormation() {
            const centerX = particleCanvas.width / 2;
            const centerY = particleCanvas.height / 2;
            const gridSize = 20;
            const grid = {};
            
            particles.forEach(p => {
                const gx = Math.floor(p.x / gridSize);
                const gy = Math.floor(p.y / gridSize);
                const key = `${gx},${gy}`;
                if (!grid[key]) grid[key] = [];
                grid[key].push(p);
            });
            
            Object.values(grid).forEach(cell => {
                if (cell.length > 8) {
                    let totalMass = 0;
                    let cx = 0, cy = 0;
                    let cvx = 0, cvy = 0;
                    
                    cell.forEach(p => {
                        totalMass += p.mass;
                        cx += p.x * p.mass;
                        cy += p.y * p.mass;
                        cvx += p.vx * p.mass;
                        cvy += p.vy * p.mass;
                    });
                    
                    cx /= totalMass;
                    cy /= totalMass;
                    cvx /= totalMass;
                    cvy /= totalMass;
                    
                    const dx = cx - centerX;
                    const dy = cy - centerY;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (totalMass > 3 && r < universeSize / 2) {
                        stars.push({
                            x: cx,
                            y: cy,
                            vx: cvx,
                            vy: cvy,
                            mass: totalMass,
                            radius: Math.pow(totalMass, 0.8) * 3,
                            age: 0,
                            lifetime: 1e10 / Math.pow(totalMass, 2.5),
                            luminosity: Math.pow(totalMass, 3.5),
                            internalEnergy: totalMass * 0.007,
                            bindingEnergy: -G * totalMass * totalMass / (Math.pow(totalMass, 0.8) * 3)
                        });
                        
                        cell.forEach(p => {
                            const idx = particles.indexOf(p);
                            if (idx > -1) particles.splice(idx, 1);
                        });
                        
                        log(`Star formed: mass=${totalMass.toFixed(1)}, lifetime=${(1e10 / Math.pow(totalMass, 2.5) / 1e9).toFixed(1)} Gyr`, true);
                    }
                }
            });
        }
        
        function updatePhase() {
            const phaseElement = document.getElementById('phase');
            let phase = "Phase: ";
            
            if (simulationTime < 1e8) {
                phase += "Initial Hot Soup";
            } else if (!gravityEnabled) {
                phase += "Expanding Universe (Enable Gravity!)";
            } else if (stars.length === 0 && blackHoles.length === 0) {
                phase += "Gravitational Collapse Era";
            } else if (stars.length > blackHoles.length) {
                phase += "Stellar Era";
            } else if (blackHoles.length > 0 && stars.length === 0) {
                phase += "Black Hole Era";
            } else if (particles.length < 10) {
                phase += "Heat Death Approaching";
            }
            
            phaseElement.textContent = phase;
            document.getElementById('timeValue').textContent = (simulationTime / 1e9).toFixed(2) + ' Gyr';
            document.getElementById('timeSlider').value = simulationTime / 1e9;
        }
        
        function render() {
            const centerX = particleCanvas.width / 2;
            const centerY = particleCanvas.height / 2;
            
            // Clear canvases
            gCtx.clearRect(0, 0, gravityCanvas.width, gravityCanvas.height);
            pCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            pCtx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
            phCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            phCtx.fillRect(0, 0, photonCanvas.width, photonCanvas.height);
            sCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
            
            // Draw universe boundary
            pCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            pCtx.beginPath();
            pCtx.arc(centerX, centerY, universeSize / 2, 0, 2 * Math.PI);
            pCtx.stroke();
            
            // Draw gravitational field
            if (gravityEnabled && (stars.length > 0 || blackHoles.length > 0)) {
                const gridStep = 30;
                const sources = [...stars, ...blackHoles];
                
                for (let x = centerX - universeSize/2; x < centerX + universeSize/2; x += gridStep) {
                    for (let y = centerY - universeSize/2; y < centerY + universeSize/2; y += gridStep) {
                        let potential = 0;
                        
                        sources.forEach(s => {
                            const dx = x - s.x;
                            const dy = y - s.y;
                            const r = Math.sqrt(dx * dx + dy * dy) + 1;
                            potential += -G * s.mass / r;
                        });
                        
                        const intensity = Math.min(255, Math.abs(potential) * 50);
                        gCtx.fillStyle = `rgba(0, ${intensity}, ${intensity/2}, 0.3)`;
                        gCtx.fillRect(x - gridStep/2, y - gridStep/2, gridStep, gridStep);
                    }
                }
            }
            
            // Draw particles
            particles.forEach(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const r = Math.sqrt(dx * dx + dy * dy);
                
                if (r < universeSize / 2) {
                    const v = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    const temp = v * 1e13;
                    const hue = 240 - Math.min(240, temp / 1e8 * 240);
                    pCtx.fillStyle = `hsla(${hue}, 100%, 50%, 0.8)`;
                    pCtx.beginPath();
                    pCtx.arc(p.x, p.y, Math.max(0.5, p.mass), 0, 2 * Math.PI);
                    pCtx.fill();
                }
            });
            
            // Draw photons
            photons.forEach(ph => {
                let hue;
                if (ph.hawking) {
                    hue = 280; // Purple for Hawking radiation
                } else {
                    // Redshift: blue (400nm) to red (700nm)
                    hue = 240 - (ph.wavelength - 400) / 300 * 240;
                }
                phCtx.fillStyle = `hsla(${hue}, 100%, 50%, ${1 - ph.age / 1000})`;
                phCtx.fillRect(ph.x - 1, ph.y - 1, 2, 2);
            });
            
            // Draw stars
            stars.forEach(s => {
                const ageRatio = s.age / s.lifetime;
                const temp = 10000 * (1 - ageRatio * 0.5);
                const hue = 60 - temp / 10000 * 60;
                
                const gradient = sCtx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius);
                gradient.addColorStop(0, `hsla(${hue}, 100%, 80%, ${s.luminosity / s.mass})`);
                gradient.addColorStop(0.5, `hsla(${hue}, 80%, 50%, ${s.luminosity / s.mass * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                sCtx.fillStyle = gradient;
                sCtx.beginPath();
                sCtx.arc(s.x, s.y, s.radius, 0, 2 * Math.PI);
                sCtx.fill();
            });
            
            // Draw black holes
            blackHoles.forEach(bh => {
                // Event horizon
                sCtx.fillStyle = '#000';
                sCtx.beginPath();
                sCtx.arc(bh.x, bh.y, Math.max(2, bh.radius * 10), 0, 2 * Math.PI);
                sCtx.fill();
                
                // Accretion disk effect
                sCtx.strokeStyle = '#ff00ff';
                sCtx.lineWidth = 2;
                sCtx.beginPath();
                sCtx.arc(bh.x, bh.y, Math.max(3, bh.radius * 15), 0, 2 * Math.PI);
                sCtx.stroke();
            });
        }
        
        function animate() {
            if (running) {
                updatePhysics(16);
                render();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function startSimulation() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                animate();
            }
        }
        
        function pauseSimulation() {
            running = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetSimulation() {
            pauseSimulation();
            initializeParticles();
            render();
        }
        
        function toggleGravity() {
            gravityEnabled = !gravityEnabled;
            document.getElementById('gravityBtn').textContent = gravityEnabled ? "Disable Gravity" : "Enable Gravity";
            log(`Gravity ${gravityEnabled ? "enabled" : "disabled"}`, true);
        }
        
        function cycleSpeed() {
            const speeds = [1, 10, 100, 1000];
            const currentIndex = speeds.indexOf(speed);
            speed = speeds[(currentIndex + 1) % speeds.length];
            document.getElementById('speedBtn').textContent = `Speed: ${speed}x`;
        }
        
        function updateExpansion() {
            expansionRate = parseFloat(document.getElementById('expansionRate').value) / 100;
            document.getElementById('expansionValue').textContent = document.getElementById('expansionRate').value;
        }
        
        function jumpToTime() {
            simulationTime = parseFloat(document.getElementById('timeSlider').value) * 1e9;
            updateEnergies();
        }
        
        function log(message, important = false) {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = important ? 'log-entry important' : 'log-entry';
            entry.textContent = `[${(simulationTime / 1e9).toFixed(2)} Gyr] ${message}`;
            logDiv.insertBefore(entry, logDiv.firstChild);
            
            while (logDiv.children.length > 50) {
                logDiv.removeChild(logDiv.lastChild);
            }
        }
        
        // Initialize
        initializeParticles();
        render();
    </script>
</body>
</html>