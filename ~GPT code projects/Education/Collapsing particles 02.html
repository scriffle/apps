<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Disc Accretion Simulation (Barnes–Hut)</title>
<style>
  body {
    font-family: sans-serif;
    margin: 20px;
    max-width: 800px;
  }

  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 1em;
  }
  #controls label {
    display: inline-flex;
    align-items: center;
  }

  #computeControls, #replayControls {
    margin: 10px 0;
  }

  #progressBarContainer {
    width: 300px;
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    height: 20px;
    position: relative;
    margin-bottom: 10px;
  }
  #progressBar {
    background-color: #76c7c0;
    height: 100%;
    width: 0%;
    transition: width 0.2s;
  }

  .hidden {
    display: none;
  }

  /* Canvas for 2D rendering (600×600) */
  #replayCanvas {
    border: 1px solid #aaa;
    background: #000;
    display: block;
    width: 600px;
    height: 600px;
  }

  #sliderContainer {
    width: 600px;
  }
  #scrubSlider {
    width: 100%;
    box-sizing: border-box;
  }

  #memoryInfo {
    font-size: 0.9em;
    color: #444;
    margin-left: 10px;
  }
  #particleCountLive {
    margin-left: 10px;
    font-size: 0.9em;
    color: #444;
  }
</style>
</head>
<body>
<h1>Disc Accretion Simulation (Barnes–Hut)</h1>

<div id="controls">
  <label>Particles:
    <input type="number" id="particleCount" value="1000" style="width:80px;" />
  </label>
  <label>Steps:
    <input type="number" id="numSteps" value="50000" style="width:80px;" />
  </label>
  <label>Δt:
    <input type="number" id="timeStep" value="0.05" step="0.01" style="width:60px;" />
  </label>
  <label>ε:
    <input type="number" id="softening" value="0.01" step="0.001" style="width:60px;" />
  </label>
  <label>θ:
    <input type="number" id="theta" value="0.5" step="0.1" style="width:50px;" />
  </label>
  <label>G:
    <input type="number" id="gravConst" value="1.0" step="0.1" style="width:50px;" />
  </label>
  <label>Spread:
    <input type="number" id="initialSpread" value="700" style="width:70px;" />
  </label>
  <label>
    <input type="checkbox" id="immediatelyCalculate" checked />
    Immediately Calculate
  </label>
</div>

<div id="computeControls">
  <button id="startBtn">Start Calculation</button>
  <button id="stopBtn">Stop Calculation</button>
  <span id="memoryInfo">Memory Used: 0 MB / 200 MB</span>
  <span id="particleCountLive">Particles: 0</span>
</div>

<div id="progressBarContainer">
  <div id="progressBar"></div>
</div>

<hr/>

<div id="replayControls" class="hidden">
  <div style="margin-bottom:10px;">
    <button id="replayStartBtn">Start Replay</button>
    <button id="replayStopBtn">Stop Replay</button>
    <label style="margin-left:10px;">Speed:
      <!-- Resets to "1" each new calculation, up to 500× -->
      <input type="range" id="speedSlider" min="0" max="500" step="0.1" value="1" />
      <span id="speedValue">1.0x</span>
    </label>
    <span id="particleCountLiveReplay" style="margin-left:10px; font-size:0.9em; color:#444;">
      Particles: 0
    </span>
  </div>
  <div id="sliderContainer">
    <label>Frame:
      <input type="range" id="scrubSlider" min="0" max="0" step="1" value="0" />
    </label>
  </div>
</div>

<canvas id="replayCanvas" width="600" height="600"></canvas>

<script>
/* ================== Global & UI References ===================== */
const DB_NAME = 'GravityDiscDB';
const STORE_NAME = 'particleSnapshots';
let db = null;

// Simulation parameters
let particleCount    = 1000;
let totalSteps       = 50000;
let dt               = 0.05;
let softening        = 0.01;
let barnesHutTheta   = 0.5;
let G                = 1.0;
let initialSpread    = 700;

let isComputing      = false;
let currentStep      = 0;
let maxStep          = 0;
let batchSize        = 50;
let simulationParticles = [];

// Memory usage
let approximateMaxBytes = 200 * 1024 * 1024; // 200 MB
let currentStoredBytes  = 0;
let alertThresholdRatio = 0.95; // 95% => auto-stop
let memoryInfoEl        = null;
let particleCountLiveEl = null;
let particleCountLiveReplayEl = null;

// Replay
let isReplaying     = false;
let replayFrame     = 0;
let replayInterval  = null;
const replayBatchSize = 500;
let replayCache     = {};
let replayCacheStart= 0;
let replayCacheEnd  = -1;
let replayCanvas, ctx2D;
let speedMultiplier = 1.0;

// Quadtree Safeguards
const MIN_HALF_SIZE = 1e-10;
const MAX_DEPTH     = 50;

/* ================== Utility Functions ===================== */
function $(id) {
  return document.getElementById(id);
}
function showElement(elem) {
  elem.classList.remove("hidden");
}
function hideElement(elem) {
  elem.classList.add("hidden");
}
function formatMB(bytes){
  return (bytes / (1024*1024)).toFixed(1);
}
function updateMemoryUsage(){
  const usedMB = formatMB(currentStoredBytes);
  const maxMB  = formatMB(approximateMaxBytes);
  memoryInfoEl.textContent = `Memory Used: ${usedMB} MB / ${maxMB} MB`;
}
function updateProgressBar(){
  const pct = (currentStep / totalSteps)*100;
  $("progressBar").style.width = pct.toFixed(2) + "%";
}

/* ================== IndexedDB Setup ===================== */
function openDatabase() {
  return new Promise((resolve,reject)=>{
    const request = indexedDB.open(DB_NAME,1);
    request.onupgradeneeded = (e)=>{
      db = e.target.result;
      if(!db.objectStoreNames.contains(STORE_NAME)){
        db.createObjectStore(STORE_NAME, { keyPath:"timestep" });
      }
    };
    request.onsuccess = (e)=>{
      db = e.target.result;
      resolve(db);
    };
    request.onerror = (err)=>reject(err);
  });
}

async function clearParticleData(){
  if(!db) return;
  return new Promise((resolve,reject)=>{
    const tx = db.transaction([STORE_NAME],'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const req = store.clear();
    req.onsuccess = ()=>resolve(true);
    req.onerror   = (err)=>reject(err);
  });
}

async function storeTimestep(step, floatArray){
  return new Promise((resolve,reject)=>{
    if(!db){ reject("DB not initialized"); return; }
    const tx   = db.transaction([STORE_NAME],'readwrite');
    const store= tx.objectStore(STORE_NAME);
    const data = { timestep:step, particles: floatArray };
    const req  = store.put(data);
    req.onsuccess=()=>resolve(true);
    req.onerror  =(err)=>reject(err);
  });
}

async function getTimestepsRange(startStep, endStep){
  if(!db) throw "DB not initialized";
  if(startStep> endStep) return [];
  return new Promise((resolve,reject)=>{
    const tx = db.transaction([STORE_NAME],"readonly");
    const store = tx.objectStore(STORE_NAME);
    const range= IDBKeyRange.bound(startStep,endStep);
    const req  = store.openCursor(range);
    const results=[];
    req.onsuccess=(e)=>{
      const cursor = e.target.result;
      if(cursor){
        results.push(cursor.value);
        cursor.continue();
      } else {
        resolve(results);
      }
    };
    req.onerror=(err)=>reject(err);
  });
}

/* ================== Barnes–Hut Quadtree Logic ===================== */
class QuadNode {
  constructor(xMid,yMid,halfSize){
    this.xMid     = xMid;
    this.yMid     = yMid;
    this.halfSize = halfSize;

    this.mass = 0;
    this.cmx  = 0;
    this.cmy  = 0;

    this.isLeaf = true;
    this.particleIndex=-1;
    this.children=[null,null,null,null];
  }
}

function buildQuadTree(particles){
  if(particles.length===0) return null;
  let minX= Infinity, maxX=-Infinity;
  let minY= Infinity, maxY=-Infinity;
  for(const p of particles){
    if(p.x< minX) minX=p.x;
    if(p.x> maxX) maxX=p.x;
    if(p.y< minY) minY=p.y;
    if(p.y> maxY) maxY=p.y;
  }
  const centerX = 0.5*(minX+maxX);
  const centerY = 0.5*(minY+maxY);
  let halfSize  = 0.5* Math.max(maxX-minX, maxY-minY);
  if(halfSize<1e-6) halfSize=1e-6;
  const root = new QuadNode(centerX,centerY,halfSize);

  for(let i=0; i<particles.length; i++){
    insertParticle(root, particles, i,0);
  }
  return root;
}

function insertParticle(node, particles, i, depth){
  const p = particles[i];
  // empty leaf
  if(node.isLeaf && node.particleIndex<0){
    node.particleIndex = i;
    node.mass = p.mass;
    node.cmx  = p.x*p.mass;
    node.cmy  = p.y*p.mass;
    return;
  }
  // leaf + occupied => subdivide
  if(node.isLeaf && node.particleIndex>=0){
    const oldIndex= node.particleIndex;
    node.particleIndex=-1;
    node.isLeaf=false;

    insertIntoChild(node, particles, oldIndex, depth+1);
    insertIntoChild(node, particles, i, depth+1);
    updateNodeMassCOM(node);
    return;
  }
  // internal => insert child
  insertIntoChild(node, particles, i, depth+1);
  updateNodeMassCOM(node);
}

function insertIntoChild(node, particles, i, depth){
  const p = particles[i];
  if(node.halfSize<MIN_HALF_SIZE || depth>MAX_DEPTH){
    if(node.isLeaf && node.particleIndex<0){
      node.particleIndex = i;
      node.mass = p.mass;
      node.cmx  = p.x*p.mass;
      node.cmy  = p.y*p.mass;
    }
    else if(node.isLeaf && node.particleIndex>=0){
      const oldP   = particles[node.particleIndex];
      const newMass= oldP.mass + p.mass;
      const px_i   = oldP.mass*oldP.vx;
      const py_i   = oldP.mass*oldP.vy;
      const px_j   = p.mass*p.vx;
      const py_j   = p.mass*p.vy;
      oldP.mass    = newMass;
      oldP.vx      = (px_i+px_j)/newMass;
      oldP.vy      = (py_i+py_j)/newMass;
      oldP.radius  = Math.cbrt(newMass);

      node.mass    = oldP.mass;
      node.cmx     = oldP.x* oldP.mass;
      node.cmy     = oldP.y* oldP.mass;
    }
    return;
  }
  const midX= node.xMid, midY=node.yMid;
  const half= node.halfSize/2;
  const isNorth= (p.y>= midY);
  const isWest = (p.x< midX);

  let childIndex=0; // NW=0, NE=1, SW=2, SE=3
  if(isNorth && !isWest) childIndex=1;
  else if(!isNorth && isWest) childIndex=2;
  else if(!isNorth && !isWest) childIndex=3;

  if(!node.children[childIndex]){
    let cx= midX, cy= midY;
    if(childIndex===0){ cx= midX-half; cy= midY+half; }
    if(childIndex===1){ cx= midX+half; cy= midY+half; }
    if(childIndex===2){ cx= midX-half; cy= midY-half; }
    if(childIndex===3){ cx= midX+half; cy= midY-half; }
    node.children[childIndex]= new QuadNode(cx,cy,half);
    node.isLeaf=false;
  }
  insertParticle(node.children[childIndex], particles, i, depth+1);
}

function updateNodeMassCOM(node){
  node.mass=0; node.cmx=0; node.cmy=0;
  if(node.isLeaf && node.particleIndex>=0){
    const p= simulationParticles[node.particleIndex];
    node.mass= p.mass;
    node.cmx = p.x*p.mass;
    node.cmy = p.y*p.mass;
    return;
  }
  for(let c=0; c<4; c++){
    const child= node.children[c];
    if(child && child.mass>0){
      node.mass+= child.mass;
      node.cmx += child.cmx;
      node.cmy += child.cmy;
    }
  }
}

function computeForcesBarnesHut(particles, root, theta){
  for(let i=0; i<particles.length; i++){
    const p= particles[i];
    p.fx=0; p.fy=0;
    const [fx, fy]= computeForceOnParticle(p, root, theta);
    p.fx= fx; p.fy= fy;
  }
}

function computeForceOnParticle(p, node, theta){
  if(!node|| node.mass<=0) return [0,0];
  if(node.isLeaf && node.particleIndex>=0){
    if(node.particleIndex===p.index) return [0,0];
    return directForce(p, simulationParticles[node.particleIndex]);
  }
  const dx= (node.cmx/node.mass)- p.x;
  const dy= (node.cmy/node.mass)- p.y;
  const dist= Math.sqrt(dx*dx+dy*dy)+ 1e-12;
  if((node.halfSize*2)/dist< theta){
    const fMag= (G*p.mass*node.mass)/(dist*dist + softening*softening);
    const fx  = fMag*(dx/dist);
    const fy  = fMag*(dy/dist);
    return [fx, fy];
  } else {
    let fxSum=0, fySum=0;
    for(let c=0; c<4; c++){
      const child= node.children[c];
      if(child && child.mass>0){
        const [cx,cy]= computeForceOnParticle(p, child, theta);
        fxSum+= cx; fySum+= cy;
      }
    }
    return [fxSum, fySum];
  }
}

function directForce(p1, p2){
  const dx= p2.x- p1.x;
  const dy= p2.y- p1.y;
  const r2= dx*dx+ dy*dy+ softening*softening;
  const r= Math.sqrt(r2);
  if(r<1e-12) return [0,0];
  const f= (G*p1.mass*p2.mass)/ r2;
  const fx= f*(dx/r);
  const fy= f*(dy/r);
  return [fx, fy];
}

function integrate(particles){
  for(const p of particles){
    p.vx += (p.fx/p.mass)*dt;
    p.vy += (p.fy/p.mass)*dt;
    p.x  += p.vx*dt;
    p.y  += p.vy*dt;
  }
}

function handleCollisions(particles){
  const n= particles.length;
  const toRemove= new Set();
  for(let i=0; i<n; i++){
    if(toRemove.has(i)) continue;
    for(let j=i+1; j<n; j++){
      if(toRemove.has(j)) continue;
      const pi=particles[i], pj=particles[j];
      const rSum= pi.radius+ pj.radius;
      const dx  = pj.x- pi.x;
      const dy  = pj.y- pi.y;
      if(dx*dx+dy*dy< (rSum*rSum)){
        // merge
        const totalMass= pi.mass+ pj.mass;
        const px_i= pi.mass*pi.vx; const py_i= pi.mass*pi.vy;
        const px_j= pj.mass*pj.vx; const py_j= pj.mass*pj.vy;
        pi.mass= totalMass;
        pi.vx  = (px_i+ px_j)/ totalMass;
        pi.vy  = (py_i+ py_j)/ totalMass;
        pi.radius= Math.cbrt(totalMass);
        toRemove.add(j);
      }
    }
  }
  if(toRemove.size>0){
    return particles.filter((_, idx)=> !toRemove.has(idx));
  }
  return particles;
}

function packParticles(particles){
  const n= particles.length;
  const floatArray= new Float32Array(n*6);
  for(let i=0; i<n; i++){
    const off= i*6; 
    const p= particles[i];
    floatArray[off+0]= p.x;
    floatArray[off+1]= p.y;
    floatArray[off+2]= p.vx;
    floatArray[off+3]= p.vy;
    floatArray[off+4]= p.radius;
    floatArray[off+5]= p.mass;
  }
  return floatArray;
}

/* ================== Main Simulation Loop ===================== */
async function runSimulation(){
  if(isComputing) return;
  isComputing= true;

  // Always show progress bar
  $("progressBarContainer").style.display = "";

  // Reset replay UI & Canvas
  hideElement($("replayControls"));
  stopReplay();
  ctx2D.clearRect(0,0,replayCanvas.width,replayCanvas.height);
  $("scrubSlider").min=0; 
  $("scrubSlider").max=0; 
  $("scrubSlider").value=0;

  // Also reset speed slider to 1 for a fresh run
  $("speedSlider").value = "1";
  $("speedValue").textContent = "1.0x";
  speedMultiplier = 1.0;

  // read UI
  particleCount   = parseInt($("particleCount").value,10);
  totalSteps      = parseInt($("numSteps").value,10);
  dt              = parseFloat($("timeStep").value);
  softening       = parseFloat($("softening").value);
  barnesHutTheta  = parseFloat($("theta").value);
  G               = parseFloat($("gravConst").value);
  initialSpread   = parseFloat($("initialSpread").value);

  // Clear old data
  await clearParticleData();
  replayCache     = {};
  replayCacheStart=0;
  replayCacheEnd  =-1;
  currentStep     =0;
  maxStep         =0;
  currentStoredBytes=0;
  updateMemoryUsage();

  // Generate new particles
  simulationParticles= [];
  for(let i=0; i< particleCount; i++){
    const rr= Math.sqrt(Math.random())* initialSpread;
    const ang= Math.random()*2*Math.PI;
    const x= rr*Math.cos(ang);
    const y= rr*Math.sin(ang);
    const vx=0, vy=0, mass=1.0;
    const radius= Math.cbrt(mass);
    simulationParticles.push({
      index:i, x,y, vx,vy, mass, radius, fx:0, fy:0
    });
  }

  // init progress
  updateProgressBar();

  (async function loopStep(){
    if(!isComputing){
      // Stopped => partial replay
      maxStep= (currentStep>0)? (currentStep-1) : 0;
      $("progressBarContainer").style.display = "none";
      showReplayUI();
      startReplay();
      return;
    }

    // Real-time particle count
    particleCountLiveEl.textContent = "Particles: " + simulationParticles.length;

    const limit= Math.min(currentStep+batchSize, totalSteps);
    for(; currentStep< limit; currentStep++){
      // Quadtree
      const root= buildQuadTree(simulationParticles);
      computeForcesBarnesHut(simulationParticles, root, barnesHutTheta);
      integrate(simulationParticles);
      simulationParticles= handleCollisions(simulationParticles);

      // store
      const floatArray= packParticles(simulationParticles);
      try{
        await storeTimestep(currentStep, floatArray);
      } catch(err){
        console.error("IndexedDB store error:", err);
        isComputing= false;
        break;
      }

      // memory usage
      currentStoredBytes += floatArray.length*4; // 4 bytes per float
      updateMemoryUsage();
      if(currentStoredBytes >= approximateMaxBytes*alertThresholdRatio){
        // auto-stop => partial replay
        isComputing= false;
        break;
      }

      // update progress
      updateProgressBar();
    }

    if(currentStep< totalSteps && isComputing){
      setTimeout(loopStep,0);
    } else {
      // finished or forced stop
      isComputing= false;
      maxStep= (currentStep>0)? (currentStep-1) : 0;
      $("progressBarContainer").style.display = "none";
      showReplayUI();
      startReplay();
    }
  })();
}

/* ================== Replay Logic ===================== */
function showReplayUI(){
  showElement($("replayControls"));
  $("scrubSlider").min=0;
  $("scrubSlider").max=maxStep;
  $("scrubSlider").value=0;
}

async function loadReplayBatch(startFrame, endFrame){
  const data= await getTimestepsRange(startFrame, endFrame);
  data.sort((a,b)=> a.timestep- b.timestep);
  return data;
}

async function ensureReplayCache(frame){
  if(frame< replayCacheStart || frame> replayCacheEnd){
    const newStart= frame;
    const newEnd  = Math.min(frame+ replayBatchSize-1, maxStep);
    const batchData= await loadReplayBatch(newStart,newEnd);

    replayCache={};
    for(const record of batchData){
      replayCache[record.timestep]= record;
    }
    replayCacheStart= newStart;
    replayCacheEnd  = newEnd;
  }
}

function unpackParticles(floatArray){
  const n= floatArray.length/6;
  const arr= [];
  for(let i=0; i<n; i++){
    const off= i*6;
    arr.push({
      x: floatArray[off+0],
      y: floatArray[off+1],
      vx: floatArray[off+2],
      vy: floatArray[off+3],
      radius: floatArray[off+4],
      mass: floatArray[off+5]
    });
  }
  return arr;
}

/* ================== 2D Canvas Rendering =====================
   Circle the 5 largest masses in green if particles ≥ 100
*/
function drawFrame2D(particles){
  if(!ctx2D) return;
  ctx2D.clearRect(0,0,replayCanvas.width,replayCanvas.height);

  // Real-time particle count during replay
  $("particleCountLiveReplay").textContent = "Particles: " + particles.length;

  // If we have ≥100, highlight top 5
  let top5 = new Set();
  if(particles.length >= 100){
    // sort desc by mass, take 5
    const biggest = [...particles].sort((a,b)=> b.mass - a.mass).slice(0,5);
    for(const p of biggest) top5.add(p);
  }

  const scale= 600/(2* initialSpread);
  const cx= replayCanvas.width/2;
  const cy= replayCanvas.height/2;

  for(const p of particles){
    const sx= cx + p.x* scale;
    const sy= cy - p.y* scale;
    const r = Math.max(1, p.radius* scale);

    // White fill
    ctx2D.fillStyle= "white";
    ctx2D.beginPath();
    ctx2D.arc(sx, sy, r, 0, 2*Math.PI);
    ctx2D.fill();

    // If top5 => green ring
    if(top5.has(p)){
      ctx2D.strokeStyle= "limegreen";
      ctx2D.lineWidth  = 2;
      ctx2D.beginPath();
      ctx2D.arc(sx, sy, r+2, 0, 2*Math.PI);
      ctx2D.stroke();
    }
  }
}

async function startReplay(){
  if(isReplaying) return;
  isReplaying= true;

  replayFrame= parseInt($("scrubSlider").value,10)||0;
  await ensureReplayCache(replayFrame);

  // If user adjusts speed, we reconfigure the interval
  if(replayInterval) {
    clearInterval(replayInterval);
  }
  replayInterval= setInterval(async ()=>{
    if(!isReplaying) return;
    await ensureReplayCache(replayFrame);

    const record= replayCache[replayFrame];
    if(record && record.particles){
      const arr= unpackParticles(record.particles);
      drawFrame2D(arr);
    }

    replayFrame++;
    $("scrubSlider").value= replayFrame;
    if(replayFrame> maxStep){
      stopReplay();
    }
  }, 100/speedMultiplier);
}

function stopReplay(){
  if(replayInterval){
    clearInterval(replayInterval);
    replayInterval=null;
  }
  isReplaying= false;
}

/* ================== Event Handlers & Initialization ===================== */
function initUI(){
  $("startBtn").addEventListener("click", ()=>{
    if(!isComputing) runSimulation();
  });
  $("stopBtn").addEventListener("click", ()=>{
    isComputing= false;
  });
  $("replayStartBtn").addEventListener("click", ()=>{
    // re-read speed slider, restart interval
    stopReplay();
    speedMultiplier = parseFloat($("speedSlider").value);
    startReplay();
  });
  $("replayStopBtn").addEventListener("click", ()=>{
    stopReplay();
  });
  $("speedSlider").addEventListener("input", (e)=>{
    speedMultiplier= parseFloat(e.target.value);
    $("speedValue").textContent= speedMultiplier.toFixed(1)+"x";
    // If replay is running, reset the interval
    if(isReplaying){
      stopReplay();
      startReplay();
    }
  });
  $("scrubSlider").addEventListener("input", async(e)=>{
    replayFrame= parseInt(e.target.value,10);
    if(!isReplaying){
      await ensureReplayCache(replayFrame);
      const record= replayCache[replayFrame];
      if(record){
        const arr= unpackParticles(record.particles);
        drawFrame2D(arr);
      }
    }
  });

  memoryInfoEl = $("memoryInfo");
  particleCountLiveEl = $("particleCountLive");
  particleCountLiveReplayEl = $("particleCountLiveReplay");
}

window.addEventListener("load", async ()=>{
  await openDatabase();
  initUI();

  replayCanvas = $("replayCanvas");
  ctx2D        = replayCanvas.getContext("2d");

  // If “Immediately Calculate” is checked, start sim on page load
  if($("immediatelyCalculate").checked){
    runSimulation();
  } else {
    $("progressBarContainer").style.display = "none";
  }
});
</script>
</body>
</html>