<!DOCTYPE html>
<html>
<head>
    <title>Gravitational Accretion Simulation - Orbital Motion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        canvas {
            border: 1px solid #333;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: inline-block;
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="togglePause()">Pause/Play</button>
        <button onclick="resetSimulation()">Reset</button>
        <div>Particles: <span id="particleCount">0</span></div>
        <div>Largest Mass: <span id="largestMass">1.0</span></div>
        <div class="slider-container">
            <label>Zoom: </label>
            <input type="range" min="0.01" max="0.2" step="0.01" value="0.05" oninput="updateZoom(this.value)">
            <span id="zoomValue">0.05x</span>
        </div>
        <div class="slider-container">
            <label>Time Speed: </label>
            <input type="range" min="0.1" max="5" step="0.1" value="1" oninput="updateTimeStep(this.value)">
            <span id="timeValue">1.0x</span>
        </div>
        <div class="slider-container">
            <label>Gravity Strength: </label>
            <input type="range" min="0.1" max="5" step="0.1" value="1" oninput="updateGravity(this.value)">
            <span id="gravityValue">1.0x</span>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isPaused = false;
        let zoom = 0.05;
        let timeMultiplier = 1;
        let gravityMultiplier = 1;
        let largestMass = 1;
        let largestParticle = null;
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        const WORLD_SIZE = 25000;
        const PARTICLE_COUNT = 2000;
        const BASE_G = 6.67430e-11 * 1e13;
        let G = BASE_G;
        const SOFTENING = 100;
        const BASE_TIME_STEP = 0.2;
        let TIME_STEP = BASE_TIME_STEP;
        const BASE_RADIUS = 8;
        const MAX_VELOCITY = 1000;
        const FLASH_DURATION = 20;
        const CLOCKWISE_COLOR = '#ff4444';    // Bright red
        const ANTICLOCKWISE_COLOR = '#4444ff'; // Bright blue
        const LARGEST_COLOR = '#ffff00';      // Bright yellow

        class Flash {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.life = FLASH_DURATION;
            }

            draw() {
                if (this.life <= 0) return false;
                
                const screenX = (this.x - cameraX) * zoom + canvas.width / 2;
                const screenY = (this.y - cameraY) * zoom + canvas.height / 2;
                
                const alpha = this.life / FLASH_DURATION;
                const size = this.size * (2 - alpha) * zoom;
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
                
                this.life--;
                return true;
            }
        }

        let flashes = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let cameraX = WORLD_SIZE / 2;
        let cameraY = WORLD_SIZE / 2;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                cameraX -= dx / zoom;
                cameraY -= dy / zoom;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.mass = 1;
                this.radius = Math.sqrt(this.mass) * BASE_RADIUS;
                this.merged = false;
                this.orbitDirection = 0; // 1 for clockwise, -1 for anticlockwise, 0 for undetermined
            }

            getOrbitDirection() {
                if (!largestParticle || this === largestParticle) return 0;

                // Calculate relative position and velocity vectors
                const dx = this.x - largestParticle.x;
                const dy = this.y - largestParticle.y;
                const dvx = this.vx - largestParticle.vx;
                const dvy = this.vy - largestParticle.vy;

                // Cross product of position and velocity determines rotation direction
                const crossProduct = dx * dvy - dy * dvx;

                return Math.sign(crossProduct);
            }

            update(particles) {
                if (this.merged) return;

                let fx = 0;
                let fy = 0;

                for (let other of particles) {
                    if (other === this || other.merged) continue;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);

                    if (dist < (this.radius + other.radius)) {
                        if (this.mass >= other.mass) {
                            const oldMass = this.mass;
                            this.mass += other.mass;
                            this.radius = Math.sqrt(this.mass) * BASE_RADIUS;
                            
                            const totalMass = this.mass;
                            const massRatio = other.mass / totalMass;
                            this.vx = this.vx * (1 - massRatio) + other.vx * massRatio;
                            this.vy = this.vy * (1 - massRatio) + other.vy * massRatio;
                            
                            other.merged = true;
                            
                            flashes.push(new Flash(this.x, this.y, this.radius * 2));
                            
                            if (this.mass > largestMass) {
                                largestMass = this.mass;
                                largestParticle = this;
                                document.getElementById('largestMass').textContent = largestMass.toFixed(1);
                            }
                        }
                        continue;
                    }

                    const softenedDistSq = distSq + SOFTENING * (1 + Math.log10(this.mass + other.mass));
                    const force = G * this.mass * other.mass / softenedDistSq;
                    const dampening = 1 / (1 + dist * 0.0001);
                    fx += force * dx / dist * dampening;
                    fy += force * dy / dist * dampening;
                }

                const massDamping = 1 / (1 + Math.log10(this.mass) * 0.5);
                const ax = (fx / this.mass) * massDamping;
                const ay = (fy / this.mass) * massDamping;
                
                this.vx += ax * TIME_STEP;
                this.vy += ay * TIME_STEP;
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > MAX_VELOCITY) {
                    const scale = MAX_VELOCITY / speed;
                    this.vx *= scale;
                    this.vy *= scale;
                }
                
                const posDamping = 1 / (1 + Math.log10(this.mass) * 0.2);
                this.x += this.vx * TIME_STEP * posDamping;
                this.y += this.vy * TIME_STEP * posDamping;

                if (this.x < 0) this.x = WORLD_SIZE;
                if (this.x > WORLD_SIZE) this.x = 0;
                if (this.y < 0) this.y = WORLD_SIZE;
                if (this.y > WORLD_SIZE) this.y = 0;

                // Update orbit direction
                this.orbitDirection = this.getOrbitDirection();
            }

            draw() {
                if (this.merged) return;

                const screenX = (this.x - cameraX) * zoom + canvas.width / 2;
                const screenY = (this.y - cameraY) * zoom + canvas.height / 2;

                if (screenX < -100 || screenX > canvas.width + 100 ||
                    screenY < -100 || screenY > canvas.height + 100) return;

                const renderedSize = Math.max(1, this.radius * zoom);

                ctx.beginPath();
                ctx.arc(screenX, screenY, renderedSize, 0, Math.PI * 2);
                
                if (this === largestParticle) {
                    ctx.fillStyle = LARGEST_COLOR;
                } else {
                    switch (this.orbitDirection) {
                        case 1:  ctx.fillStyle = CLOCKWISE_COLOR; break;
                        case -1: ctx.fillStyle = ANTICLOCKWISE_COLOR; break;
                        default: ctx.fillStyle = 'white';
                    }
                }
                ctx.fill();
            }
        }

        let particles = [];
        function initParticles() {
            particles = [];
            flashes = [];
            largestMass = 1;
            largestParticle = null;
            document.getElementById('largestMass').textContent = largestMass.toFixed(1);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = Math.random() * WORLD_SIZE;
                const y = Math.random() * WORLD_SIZE;
                particles.push(new Particle(x, y));
            }
        }

        function updateParticles() {
            if (isPaused) return;
            
            for (let particle of particles) {
                particle.update(particles);
            }
            
            particles = particles.filter(p => !p.merged);
            document.getElementById('particleCount').textContent = particles.length;

            let totalMass = 0;
            let centerX = 0;
            let centerY = 0;
            
            for (let particle of particles) {
                totalMass += particle.mass;
                centerX += particle.x * particle.mass;
                centerY += particle.y * particle.mass;
            }
            
            if (totalMass > 0 && !isDragging) {
                cameraX = centerX / totalMass;
                cameraY = centerY / totalMass;
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let particle of particles) {
                particle.draw();
            }

            flashes = flashes.filter(flash => flash.draw());

            requestAnimationFrame(draw);
        }

        function togglePause() {
            isPaused = !isPaused;
        }

        function resetSimulation() {
            initParticles();
        }

        function updateZoom(value) {
            zoom = parseFloat(value);
            document.getElementById('zoomValue').textContent = zoom.toFixed(2) + 'x';
        }

        function updateTimeStep(value) {
            timeMultiplier = parseFloat(value);
            TIME_STEP = BASE_TIME_STEP * timeMultiplier;
            document.getElementById('timeValue').textContent = timeMultiplier.toFixed(1) + 'x';
        }

        function updateGravity(value) {
            gravityMultiplifier = parseFloat(value);
            G = BASE_G * gravityMultiplifier;
            document.getElementById('gravityValue').textContent = gravityMultiplifier.toFixed(1) + 'x';
        }

        initParticles();
        setInterval(updateParticles, 1000 / 60);
        draw();
    </script>
</body>
</html>
