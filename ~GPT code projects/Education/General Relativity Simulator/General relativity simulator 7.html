<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic 3D Grid with Space Warping and Time Dilation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
        }
        canvas { 
            display: block; 
        }
        .panel {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
            font-family: Arial, sans-serif;
            color: #fff;
            width: auto;
            min-width: 200px;
        }
        #controls {
            bottom: 20px;
            left: 20px;
        }
        #info-panel {
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
        }
        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }
        .control-group label {
            min-width: 100px;
            user-select: none;
        }
        .checkbox-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 5px 0;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        input[type="range"] {
            width: 150px;
            accent-color: #00f;
        }
        input[type="checkbox"] {
            cursor: pointer;
        }
        select {
            width: 150px;
            padding: 5px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        .value-display {
            min-width: 40px;
            text-align: right;
        }
        #meshContainer {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
        .draggable-handle {
            cursor: move;
            padding: 5px 10px;
            text-align: center;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close-button {
            cursor: pointer;
            padding: 0 5px;
            color: #666;
        }
        .close-button:hover {
            color: #fff;
        }
        button {
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #3a3a3a;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        .mass-info {
            margin: 10px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 0.9em;
        }
        .info-section {
            margin-bottom: 15px;
        }
        .info-section h3 {
            margin: 0 0 8px 0;
            color: #4444ff;
        }
        .info-section p {
            margin: 0 0 8px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="meshContainer"></div>
    
    <div id="controls" class="panel">
        <div class="draggable-handle">Controls</div>
        <div class="mass-info">
            Mass Location: <span id="massLocation">0, 0, 0</span><br>
            Max Time Dilation: <span id="maxDilation">1.00</span>x
        </div>
        <div class="control-group">
            <label for="motionPattern">Motion: </label>
            <select id="motionPattern">
                <option value="stationary">Stationary Center</option>
                <option value="sine" selected>Sine Oscillation</option>
                <option value="circular">Circular Motion</option>
            </select>
        </div>
        <div class="control-group">
            <label for="sizeSlider">Grid Size: </label>
            <input type="range" id="sizeSlider" min="3" max="8" value="5" step="1">
            <span id="sizeValue" class="value-display">5</span>
        </div>
        <div class="control-group">
            <label for="warpSlider">Warp Strength: </label>
            <input type="range" id="warpSlider" min="1" max="10" value="3" step="0.5">
            <span id="warpValue" class="value-display">3.0</span>
        </div>
        <div class="control-group">
            <label for="zoomSlider">Zoom: </label>
            <input type="range" id="zoomSlider" min="3" max="20" value="8" step="0.5">
            <span id="zoomValue" class="value-display">8.0</span>
        </div>
        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="showClocks" checked>
                Show Clocks
            </label>
            <label>
                <input type="checkbox" id="showGrid" checked>
                Show Grid
            </label>
        </div>
        <div class="button-group">
            <button id="toggleAnimation">Pause Mass</button>
            <button id="resetSimulation">Reset All</button>
        </div>
    </div>

    <div id="info-panel" class="panel">
        <div class="draggable-handle">
            About This Simulation
            <span class="close-button">×</span>
        </div>
        <div class="info-section">
            <h3>What You're Seeing</h3>
            <p>This visualization demonstrates Einstein's Theory of General Relativity, showing how massive objects warp spacetime and affect the flow of time. The yellow sphere represents a massive object (100 solar masses), the grid shows space warping, and the clocks show time dilation effects.</p>
        </div>
        <div class="info-section">
            <h3>Time Dilation</h3>
            <p>The clocks near the massive object run slower than those far away, demonstrating gravitational time dilation. The color intensity of the clock numbers indicates the strength of the time dilation effect.</p>
        </div>
        <div class="info-section">
            <h3>Space Warping</h3>
            <p>The grid lines show how space itself is warped by the massive object. The stronger the warping, the closer the grid lines bunch together near the mass.</p>
        </div>
        <div class="info-section">
            <h3>Controls</h3>
            <p>• Click and drag to rotate the view<br>
               • Use the zoom slider to adjust distance<br>
               • Try different motion patterns for the mass<br>
               • Adjust warp strength to see different effects<br>
               • Toggle clocks and grid visibility</p>
        </div>
        <div class="info-section">
            <h3>Physics</h3>
            <p>The simulation uses real gravitational equations from General Relativity, though the effects are exaggerated for visualization purposes. The time dilation and space warping effects are proportional to the mass of the object and inverse to the distance from it.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, massiveObject;
        const clocks = [];
        const lines = [];
        let gridSize = 5;
        const gridSpacing = 1.2;
        const sphereMass = 100 * 1.989e30;
        const G = 6.67430e-11;
        const c = 3e8;
        let scalingFactor = 1e6;
        let warpStrength = 3.0;
        let isAnimating = true;
        let showClocks = true;
        let showGrid = true;
        const startTime = Date.now();
        let lastKnownPosition = new THREE.Vector3();
        let motionPattern = 'sine';
function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('meshContainer').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            createMesh(gridSize);

            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            setupEventListeners();
            setupControls();
            makeAllPanelsDraggable();
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('meshContainer').addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            document.getElementById('toggleAnimation').addEventListener('click', toggleAnimation);
            document.getElementById('resetSimulation').addEventListener('click', resetSimulation);
            
            document.getElementById('showClocks').addEventListener('change', (e) => {
                showClocks = e.target.checked;
                clocks.forEach(clock => {
                    clock.visible = showClocks;
                });
            });
            
            document.getElementById('showGrid').addEventListener('change', (e) => {
                showGrid = e.target.checked;
                lines.forEach(line => {
                    line.visible = showGrid;
                });
            });

            document.getElementById('motionPattern').addEventListener('change', (e) => {
                motionPattern = e.target.value;
                resetMassPosition();
            });

            document.querySelector('#info-panel .close-button').addEventListener('click', () => {
                document.getElementById('info-panel').style.display = 'none';
            });
        }

        function makeAllPanelsDraggable() {
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                const handle = panel.querySelector('.draggable-handle');
                let isDragging = false;
                let offset = { x: 0, y: 0 };

                handle.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('close-button')) return;
                    isDragging = true;
                    offset.x = e.clientX - panel.getBoundingClientRect().left;
                    offset.y = e.clientY - panel.getBoundingClientRect().top;
                    panel.style.transition = 'none';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const x = e.clientX - offset.x;
                    const y = e.clientY - offset.y;
                    
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    panel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
                    panel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
                    panel.style.right = 'auto';
                    panel.style.bottom = 'auto';
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    panel.style.transition = 'background-color 0.3s';
                });

                handle.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            });
        }

        function setupControls() {
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            const warpSlider = document.getElementById('warpSlider');
            const warpValue = document.getElementById('warpValue');
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');

            sizeSlider.addEventListener('input', () => {
                gridSize = parseInt(sizeSlider.value);
                sizeValue.textContent = gridSize;
                resetScene();
                createMesh(gridSize);
            });

            warpSlider.addEventListener('input', () => {
                warpStrength = parseFloat(warpSlider.value);
                warpValue.textContent = warpStrength.toFixed(1);
            });

            zoomSlider.addEventListener('input', () => {
                const zoomLevel = parseFloat(zoomSlider.value);
                zoomValue.textContent = zoomLevel.toFixed(1);
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(zoomLevel));
            });
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('toggleAnimation').textContent = isAnimating ? 'Pause Mass' : 'Resume Mass';
            if (!isAnimating) {
                lastKnownPosition.copy(massiveObject.position);
            }
        }

        function resetSimulation() {
            isAnimating = true;
            document.getElementById('toggleAnimation').textContent = 'Pause Mass';
            
            clocks.forEach(clock => {
                clock.userData.startTime = Date.now();
                clock.userData.elapsedTime = 0;
            });

            if (massiveObject) {
                massiveObject.position.set(0, 0, 0);
                lastKnownPosition.set(0, 0, 0);
            }

            const currentZoom = camera.position.length();
            const direction = new THREE.Vector3(8, 6, 8).normalize();
            camera.position.copy(direction.multiplyScalar(currentZoom));
            camera.lookAt(0, 0, 0);
            
            scene.quaternion.identity();
        }

        function updateMassPosition(elapsedTime, meshWidth) {
            switch(motionPattern) {
                case 'stationary':
                    massiveObject.position.set(0, 0, 0);
                    break;
                case 'sine':
                    massiveObject.position.x = Math.sin(elapsedTime * 0.5) * (meshWidth / 1.5);
                    break;
                case 'circular':
                    const radius = meshWidth / 2;
                    massiveObject.position.x = Math.cos(elapsedTime * 0.5) * radius;
                    massiveObject.position.z = Math.sin(elapsedTime * 0.5) * radius;
                    break;
            }
            lastKnownPosition.copy(massiveObject.position);
        }
function createMesh(size) {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        const position = new THREE.Vector3(
                            (x - (size - 1) / 2) * gridSpacing,
                            (y - (size - 1) / 2) * gridSpacing,
                            (z - (size - 1) / 2) * gridSpacing
                        );
                        
                        const clock = createClock();
                        clock.position.copy(position);
                        clock.userData.startTime = Date.now();
                        clock.userData.elapsedTime = 0;
                        clock.userData.originalPosition = position.clone();
                        scene.add(clock);
                        clocks.push(clock);

                        if (x < size - 1 || y < size - 1 || z < size - 1) {
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xffffff,
                                transparent: true,
                                opacity: 0.5
                            });

                            if (x < size - 1) {
                                const nextX = new THREE.Vector3((x + 1 - (size - 1) / 2) * gridSpacing, position.y, position.z);
                                lines.push(drawLine(position, nextX, lineMaterial));
                            }
                            if (y < size - 1) {
                                const nextY = new THREE.Vector3(position.x, (y + 1 - (size - 1) / 2) * gridSpacing, position.z);
                                lines.push(drawLine(position, nextY, lineMaterial));
                            }
                            if (z < size - 1) {
                                const nextZ = new THREE.Vector3(position.x, position.y, (z + 1 - (size - 1) / 2) * gridSpacing);
                                lines.push(drawLine(position, nextZ, lineMaterial));
                            }
                        }
                    }
                }
            }

            const massiveObjectGeometry = new THREE.SphereGeometry(gridSpacing / 6, 32, 32);
            const massiveObjectMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9,
                shininess: 100
            });
            massiveObject = new THREE.Mesh(massiveObjectGeometry, massiveObjectMaterial);
            scene.add(massiveObject);
        }

        function drawLine(start, end, material) {
            const points = [start.clone(), end.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            line.visible = showGrid;
            scene.add(line);
            return line;
        }

        function createClock() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#4444ff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("00:00", canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            
            const clockMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            const clockGeometry = new THREE.PlaneGeometry(1, 0.5);
            const clock = new THREE.Mesh(clockGeometry, clockMaterial);
            clock.visible = showClocks;
            
            clock.userData = { 
                texture, 
                canvas, 
                ctx, 
                startTime: 0, 
                elapsedTime: 0, 
                timeDilationFactor: 1, 
                originalPosition: null
            };

            return clock;
        }

        function updateClockDisplay(clock, timeDilationFactor) {
            const adjustedElapsedTime = Math.floor(clock.userData.elapsedTime / 1000);
            const minutes = Math.floor(adjustedElapsedTime / 60).toString().padStart(2, '0');
            const seconds = (adjustedElapsedTime % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;

            const ctx = clock.userData.ctx;
            const canvas = clock.userData.canvas;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const intensity = Math.max(0, 1 - timeDilationFactor);
            ctx.fillStyle = `rgb(${68 + intensity * 187}, 68, 255)`;
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeString, canvas.width / 2, canvas.height / 2);

            clock.userData.texture.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000;
            const meshWidth = gridSize * gridSpacing;
            
            if (isAnimating) {
                updateMassPosition(elapsedTime, meshWidth);
            } else {
                massiveObject.position.copy(lastKnownPosition);
            }
            
            document.getElementById('massLocation').textContent = 
                `${massiveObject.position.x.toFixed(2)}, ${massiveObject.position.y.toFixed(2)}, ${massiveObject.position.z.toFixed(2)}`;

            let maxDilation = 1;

            // Update camera matrices
            camera.updateMatrixWorld();
            
            clocks.forEach(clock => {
                const distance = clock.userData.originalPosition.distanceTo(massiveObject.position) * scalingFactor;
                const timeDilationFactor = Math.sqrt(1 - (2 * G * sphereMass) / (c * c * distance));
                
                if (timeDilationFactor < maxDilation) maxDilation = timeDilationFactor;

                // Apply space warping regardless of visibility
                const warpVector = new THREE.Vector3().subVectors(clock.userData.originalPosition, massiveObject.position);
                const distanceFromMass = Math.max(warpVector.length(), 0.1);
                const warpAmount = warpStrength / (distanceFromMass * distanceFromMass + 1e-5);
                warpVector.multiplyScalar(Math.min(warpAmount, 1));
                
                const targetPosition = clock.userData.originalPosition.clone().sub(warpVector);
                clock.position.lerp(targetPosition, 0.1);

                if (clock.visible) {
                    clock.userData.timeDilationFactor = isNaN(timeDilationFactor) || timeDilationFactor >= 1 ? 1 : timeDilationFactor;
                    
                    if (isAnimating) {
                        clock.userData.elapsedTime += (currentTime - clock.userData.startTime) * clock.userData.timeDilationFactor;
                    }
                    clock.userData.startTime = currentTime;

                    updateClockDisplay(clock, timeDilationFactor);

                    // Billboard the clock to face camera perfectly
                    const lookAtMatrix = new THREE.Matrix4();
                    lookAtMatrix.lookAt(
                        clock.position,
                        camera.position,
                        new THREE.Vector3(0, 1, 0)
                    );
                    clock.quaternion.setFromRotationMatrix(lookAtMatrix);
                    clock.rotateY(Math.PI);
                }
            });

            document.getElementById('maxDilation').textContent = maxDilation.toFixed(3);
            
            // Always update lines when animating, regardless of clock visibility
            if (isAnimating) {
                updateLines();
            }
            
            renderer.render(scene, camera);
        }

        function updateLines() {
            let lineIndex = 0;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const index = x * gridSize * gridSize + y * gridSize + z;
                        const clock = clocks[index];

                        if (x < gridSize - 1) {
                            const nextClockX = clocks[index + gridSize * gridSize];
                            updateLine(lines[lineIndex], clock.position, nextClockX.position);
                            lineIndex++;
                        }

                        if (y < gridSize - 1) {
                            const nextClockY = clocks[index + gridSize];
                            updateLine(lines[lineIndex], clock.position, nextClockY.position);
                            lineIndex++;
                        }

                        if (z < gridSize - 1) {
                            const nextClockZ = clocks[index + 1];
                            updateLine(lines[lineIndex], clock.position, nextClockZ.position);
                            lineIndex++;
                        }
                    }
                }
            }
        }

        function updateLine(line, start, end) {
            const positions = line.geometry.attributes.position.array;
            positions[0] = start.x;
            positions[1] = start.y;
            positions[2] = start.z;
            positions[3] = end.x;
            positions[4] = end.y;
            positions[5] = end.z;
            line.geometry.attributes.position.needsUpdate = true;
        }

        function resetScene() {
            while (scene.children.length > 0) {
                const object = scene.children[0];
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
                scene.remove(object);
            }
            clocks.length = 0;
            lines.length = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = 0.005;

        function onMouseDown(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel')) return;
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            const rotationQuaternion = new THREE.Quaternion();
            rotationQuaternion.setFromEuler(
                new THREE.Euler(
                    deltaMove.y * rotationSpeed,
                    deltaMove.x * rotationSpeed,
                    0,
                    'XYZ'
                )
            );
            scene.quaternion.multiplyQuaternions(rotationQuaternion, scene.quaternion);

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        init();
        animate();
    </script>
</body>
</html>