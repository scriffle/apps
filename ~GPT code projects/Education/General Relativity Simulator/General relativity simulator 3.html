<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic 3D Grid with Space Warping and Time Dilation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
            font-family: Arial, sans-serif;
            color: #fff;
            width: auto;
            min-width: 200px;
        }
        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }
        .control-group label {
            min-width: 100px;
        }
        input[type="range"] {
            width: 150px;
            accent-color: #00f;
        }
        .value-display {
            min-width: 40px;
            text-align: right;
        }
        #meshContainer {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .draggable-handle {
            cursor: move;
            padding: 5px;
            text-align: center;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">
        Mass Location: <span id="massLocation">0, 0, 0</span><br>
        Max Time Dilation: <span id="maxDilation">1.00</span>x
    </div>
    <div id="meshContainer"></div>
    <div id="controls">
        <div class="draggable-handle">Controls</div>
        <div class="control-group">
            <label for="sizeSlider">Grid Size: </label>
            <input type="range" id="sizeSlider" min="3" max="8" value="5" step="1">
            <span id="sizeValue" class="value-display">5</span>
        </div>
        <div class="control-group">
            <label for="warpSlider">Warp Strength: </label>
            <input type="range" id="warpSlider" min="1" max="10" value="3" step="0.5">
            <span id="warpValue" class="value-display">3.0</span>
        </div>
        <div class="control-group">
            <label for="zoomSlider">Zoom: </label>
            <input type="range" id="zoomSlider" min="3" max="20" value="8" step="0.5">
            <span id="zoomValue" class="value-display">8.0</span>
        </div>
    </div>
    <script>
        let scene, camera, renderer, massiveObject;
        const clocks = [];
        const lines = [];
        let gridSize = 5;
        const gridSpacing = 1.2;
        const sphereMass = 100 * 1.989e30;
        const G = 6.67430e-11;
        const c = 3e8;
        let scalingFactor = 1e6;
        let warpStrength = 3.0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('meshContainer').appendChild(renderer.domElement);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            createMesh(gridSize);

            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            setupEventListeners();
            setupControls();
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('meshContainer').addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
        }

        function setupControls() {
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            const warpSlider = document.getElementById('warpSlider');
            const warpValue = document.getElementById('warpValue');
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');

            sizeSlider.addEventListener('input', () => {
                gridSize = parseInt(sizeSlider.value);
                sizeValue.textContent = gridSize;
                resetScene();
                createMesh(gridSize);
            });

            warpSlider.addEventListener('input', () => {
                warpStrength = parseFloat(warpSlider.value);
                warpValue.textContent = warpStrength.toFixed(1);
            });

            zoomSlider.addEventListener('input', () => {
                const zoomLevel = parseFloat(zoomSlider.value);
                zoomValue.textContent = zoomLevel.toFixed(1);
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(zoomLevel));
            });
        }

        function createMesh(size) {
            // Create grid with enhanced visuals
            const geometry = new THREE.SphereGeometry(gridSpacing / 12, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: 0x4444ff, shininess: 100 });

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        const position = new THREE.Vector3(
                            (x - (size - 1) / 2) * gridSpacing,
                            (y - (size - 1) / 2) * gridSpacing,
                            (z - (size - 1) / 2) * gridSpacing
                        );
                        
                        const clock = createClock();
                        clock.position.copy(position);
                        clock.userData.startTime = Date.now();
                        clock.userData.elapsedTime = 0;
                        clock.userData.originalPosition = position.clone();
                        scene.add(clock);
                        clocks.push(clock);

                        // Create thicker white lines
                        if (x < size - 1 || y < size - 1 || z < size - 1) {
                            const tubeRadius = 0.01; // Adjust this value to change line thickness
                            
                            if (x < size - 1) {
                                const nextX = new THREE.Vector3((x + 1 - (size - 1) / 2) * gridSpacing, position.y, position.z);
                                lines.push(createThickLine(position, nextX, tubeRadius));
                            }
                            if (y < size - 1) {
                                const nextY = new THREE.Vector3(position.x, (y + 1 - (size - 1) / 2) * gridSpacing, position.z);
                                lines.push(createThickLine(position, nextY, tubeRadius));
                            }
                            if (z < size - 1) {
                                const nextZ = new THREE.Vector3(position.x, position.y, (z + 1 - (size - 1) / 2) * gridSpacing);
                                lines.push(createThickLine(position, nextZ, tubeRadius));
                            }
                        }
                    }
                }
            }

            // Create massive object
            const massiveObjectGeometry = new THREE.SphereGeometry(gridSpacing / 6, 32, 32);
            const massiveObjectMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9,
                shininess: 100
            });
            massiveObject = new THREE.Mesh(massiveObjectGeometry, massiveObjectMaterial);
            scene.add(massiveObject);
        }

        function createThickLine(start, end, radius) {
            const path = new THREE.LineCurve3(start, end);
            const tubeGeometry = new THREE.TubeGeometry(path, 1, radius, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tube);
            return tube;
        }

        function createClock() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Make background fully transparent
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw time with bright blue color
            ctx.fillStyle = '#4444ff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("00:00", canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            
            const clockMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                depthWrite: false
            });
            const clockGeometry = new THREE.PlaneGeometry(1, 0.5);
            const clock = new THREE.Mesh(clockGeometry, clockMaterial);
            
            clock.userData = { 
                texture, 
                canvas, 
                ctx, 
                startTime: 0, 
                elapsedTime: 0, 
                timeDilationFactor: 1, 
                originalPosition: null 
            };
            
            return clock;
        }

        function updateClockDisplay(clock, timeDilationFactor) {
            const adjustedElapsedTime = Math.floor(clock.userData.elapsedTime / 1000);
            const minutes = Math.floor(adjustedElapsedTime / 60).toString().padStart(2, '0');
            const seconds = (adjustedElapsedTime % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;

            const ctx = clock.userData.ctx;
            const canvas = clock.userData.canvas;

            // Clear the canvas completely
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw time with color based on time dilation
            const intensity = Math.max(0, 1 - timeDilationFactor);
            ctx.fillStyle = `rgb(${68 + intensity * 187}, 68, 255)`;
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeString, canvas.width / 2, canvas.height / 2);

            clock.userData.texture.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const elapsedTime = currentTime / 1000;
            const meshWidth = gridSize * gridSpacing;
            
            // Update massive object position with smooth oscillation
            massiveObject.position.x = Math.sin(elapsedTime * 0.5) * (meshWidth / 1.5);
            
            document.getElementById('massLocation').textContent = 
                `${massiveObject.position.x.toFixed(2)}, ${massiveObject.position.y.toFixed(2)}, ${massiveObject.position.z.toFixed(2)}`;

            let maxDilation = 1;

            clocks.forEach(clock => {
                const distance = clock.userData.originalPosition.distanceTo(massiveObject.position) * scalingFactor;
                const timeDilationFactor = Math.sqrt(1 - (2 * G * sphereMass) / (c * c * distance));
                
                if (timeDilationFactor < maxDilation) maxDilation = timeDilationFactor;

                clock.userData.timeDilationFactor = isNaN(timeDilationFactor) || timeDilationFactor >= 1 ? 1 : timeDilationFactor;
                
                clock.userData.elapsedTime += (currentTime - clock.userData.startTime) * clock.userData.timeDilationFactor;
                clock.userData.startTime = currentTime;

                updateClockDisplay(clock, timeDilationFactor);

                const warpVector = new THREE.Vector3().subVectors(clock.userData.originalPosition, massiveObject.position);
                const distanceFromMass = Math.max(warpVector.length(), 0.1);
                const warpAmount = warpStrength / (distanceFromMass * distanceFromMass + 1e-5);
                const oscillation = Math.sin(Date.now() * 0.001) * 0.1;
                warpVector.multiplyScalar(Math.min(warpAmount + oscillation, 1));
                
                const currentPosition = clock.position.clone();
                const targetPosition = clock.userData.originalPosition.clone().sub(warpVector);
                clock.position.lerp(targetPosition, 0.1);

                clock.quaternion.slerp(camera.quaternion, 0.1);
            });

            document.getElementById('maxDilation').textContent = maxDilation.toFixed(3);
            updateLines();
            renderer.render(scene, camera);
        }

        function updateLines() {
            let lineIndex = 0;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const index = x * gridSize * gridSize + y * gridSize + z;
                        const clock = clocks[index];

                        if (x < gridSize - 1) {
                            const nextClockX = clocks[index + gridSize * gridSize];
                            updateThickLine(lines[lineIndex], clock.position, nextClockX.position);
                            lineIndex++;
                        }

                        if (y < gridSize - 1) {
                            const nextClockY = clocks[index + gridSize];
                            updateThickLine(lines[lineIndex], clock.position, nextClockY.position);
                            lineIndex++;
                        }

                        if (z < gridSize - 1) {
                            const nextClockZ = clocks[index + 1];
                            updateThickLine(lines[lineIndex], clock.position, nextClockZ.position);
                            lineIndex++;
                        }
                    }
                }
            }
        }

        function updateThickLine(tube, start, end) {
            // Update the tube geometry to connect the new positions
            const path = new THREE.LineCurve3(start, end);
            const newGeometry = new THREE.TubeGeometry(path, 1, tube.geometry.parameters.radius, 8, false);
            tube.geometry.dispose();
            tube.geometry = newGeometry;
        }

        function resetScene() {
            while (scene.children.length > 0) {
                const object = scene.children[0];
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
                scene.remove(object);
            }
            clocks.length = 0;
            lines.length = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = 0.005;

        function onMouseDown(event) {
            if (event.target.closest('#controls')) return; // Ignore if clicking controls
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            // Apply smooth rotation with quaternions
            const rotationQuaternion = new THREE.Quaternion();
            rotationQuaternion.setFromEuler(
                new THREE.Euler(
                    deltaMove.y * rotationSpeed,
                    deltaMove.x * rotationSpeed,
                    0,
                    'XYZ'
                )
            );
            scene.quaternion.multiplyQuaternions(rotationQuaternion, scene.quaternion);

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        // Make controls draggable
        const controls = document.getElementById('controls');
        const handle = controls.querySelector('.draggable-handle');
        let isDraggingControls = false;
        let controlsOffset = { x: 0, y: 0 };

        handle.addEventListener('mousedown', (e) => {
            isDraggingControls = true;
            controlsOffset.x = e.clientX - controls.getBoundingClientRect().left;
            controlsOffset.y = e.clientY - controls.getBoundingClientRect().top;
            controls.style.transition = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingControls) {
                const x = e.clientX - controlsOffset.x;
                const y = e.clientY - controlsOffset.y;
                
                // Keep the controls panel within the window bounds
                const maxX = window.innerWidth - controls.offsetWidth;
                const maxY = window.innerHeight - controls.offsetHeight;
                
                controls.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
                controls.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
                controls.style.transform = 'none';
                e.preventDefault();
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingControls = false;
            controls.style.transition = 'background-color 0.3s';
        });

        // Prevent text selection during dragging
        handle.addEventListener('dragstart', (e) => {
            e.preventDefault();
        });

        init();
        animate();
    </script>
</body>
</html>