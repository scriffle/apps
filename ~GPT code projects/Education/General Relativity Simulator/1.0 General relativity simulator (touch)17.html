<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General Relativity Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            touch-action: none;
        }
        canvas { 
            display: block; 
            touch-action: none;
        }
        #title {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 1.2em;
            z-index: 100;
            opacity: 0.8;
            pointer-events: none;
        }
        .panel {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
            font-family: Arial, sans-serif;
            color: #fff;
            width: auto;
            min-width: 200px;
            transition: all 0.3s ease;
            touch-action: none;
        }
        #controls {
            bottom: 20px;
            left: 20px;
        }
        #controls.minimized {
            max-height: 40px;
            overflow: hidden;
        }
        #info-panel {
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }
        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            padding: 2px;
        }
        .control-group label {
            min-width: 80px;
            user-select: none;
            font-size: 0.9em;
        }
        .checkbox-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 2px 0;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 120px;
            accent-color: #00f;
        }
        input[type="checkbox"] {
            cursor: pointer;
        }
        select {
            width: 120px;
            padding: 3px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .value-display {
            min-width: 35px;
            text-align: right;
            font-size: 0.9em;
        }
        #meshContainer {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            touch-action: none;
        }
        .draggable-handle {
            cursor: move;
            padding: 3px 8px;
            text-align: center;
            border-bottom: 1px solid #333;
            margin-bottom: 5px;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }
        .minimize-button {
            cursor: pointer;
            color: #666;
            margin-right: 5px;
        }
        .minimize-button:hover {
            color: #fff;
        }
        .mass-info {
            margin: 5px 0;
            padding: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 0.85em;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .mass-info > div {
            flex: 1 1 auto;
            white-space: nowrap;
            padding: 0 5px;
        }
        .button-group {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 5px;
        }
        button {
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }
        button:hover {
            background: #3a3a3a;
        }
        .info-section {
            margin-bottom: 12px;
        }
        .info-section h3 {
            margin: 0 0 6px 0;
            color: #4444ff;
            font-size: 1em;
        }
        .info-section p {
            margin: 0 0 6px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="title">General Relativity Simulator</div>
    <div id="meshContainer"></div>
    
    <div id="controls" class="panel">
        <div class="draggable-handle">
            Controls
            <span class="minimize-button">−</span>
        </div>
        <div class="mass-info">
            <div>Loc: <span id="massLocation">0, 0, 0</span></div>
            <div>Dil: <span id="maxDilation">1.00</span>x</div>
            <div>FPS: <span id="fps">60</span></div>
        </div>
        <div class="control-group">
            <label for="motionPattern">Motion: </label>
            <select id="motionPattern">
                <option value="stationary" selected>Stationary Center</option>
                <option value="sine">Sine Oscillation</option>
                <option value="circular">Circular Motion XZ</option>
                <option value="circularVertical">Circular Motion YZ</option>
                <option value="cubeEdge">Cube Edge Tracing</option>
            </select>
        </div>
        <div class="control-group">
            <label for="presetSelect">Preset: </label>
            <select id="presetSelect">
                <option value="default">Default Settings</option>
                <option value="extreme">Extreme Warping</option>
                <option value="subtle">Subtle Effects</option>
                <option value="massive">Massive Object</option>
                <option value="dense">Dense Grid</option>
                <option value="sparse">Sparse Grid</option>
                <option value="timeDilation">Time Dilation Focus</option>
                <option value="contrast">Maximum Contrast</option>
                <option value="minimal">Minimal Effect</option>
                <option value="edgeObserver">Edge Observer</option>
                <option value="coreObserver">Core Observer</option>
            </select>
        </div>
        <div class="control-group">
            <label for="massSlider">Mass: </label>
            <input type="range" id="massSlider" min="50" max="500" value="100" step="10">
            <span id="massValue" class="value-display">100%</span>
        </div>
        <div class="control-group">
            <label for="sizeSlider">Grid: </label>
            <input type="range" id="sizeSlider" min="3" max="8" value="5" step="1">
            <span id="sizeValue" class="value-display">5</span>
        </div>
        <div class="control-group">
            <label for="warpSlider">Warp: </label>
            <input type="range" id="warpSlider" min="1" max="10" value="3" step="0.5">
            <span id="warpValue" class="value-display">3.0</span>
        </div>
        <div class="control-group">
            <label for="zoomSlider">Zoom: </label>
            <input type="range" id="zoomSlider" min="3" max="20" value="8" step="0.5">
            <span id="zoomValue" class="value-display">8.0</span>
        </div>
        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="showClocks" checked>
                Clocks
            </label>
            <label>
                <input type="checkbox" id="showGrid" checked>
                Grid
            </label>
            <label>
                <input type="checkbox" id="useGradient">
                Gradient
            </label>
        </div>
        <div class="button-group">
            <button id="resetSimulation">Reset All</button>
            <button id="explain">Explain</button>
        </div>
    </div>

    <div id="info-panel" class="panel">
        <div class="draggable-handle">
            About This Simulation
            <span class="close-button">×</span>
        </div>
        <div class="info-section">
            <h3>Overview</h3>
            <p>Explore how massive objects affect space and time according to Einstein's Theory of General Relativity. Watch as space bends and time flows at different rates throughout the grid. For illustrative means, assume each clock has a point mass.</p>
        </div>
        <div class="info-section">
            <h3>Visualization Elements</h3>
            <p>• Yellow Sphere: The massive object<br>
               • White Grid: The fabric of spacetime<br>
               • Digital Clocks: Time dilation across space</p>
        </div>
        <div class="info-section">
            <h3>Controls</h3>
            <p>• Choose different motion patterns<br>
               • Apply presets or customize settings<br>
               • Drag to rotate, zoom to explore<br>
               • Toggle grid and clock displays<br>
               • Use gradient colors to visualize time flow</p>
        </div>
        <div class="info-section">
            <h3>Physics Concepts</h3>
            <p>The simulation demonstrates key relativistic effects: stronger gravity leads to slower time flow and more pronounced spatial warping. Watch how these effects vary with mass and distance.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, massiveObject;
        const clocks = [];
        const lines = [];
        let gridSize = 5;
        const gridSpacing = 1.2;
        const baseMass = 100 * 1.989e30;
        let currentMassPercent = 100;
        const G = 6.67430e-11;
        const c = 3e8;
        let scalingFactor = 1e6;
        let warpStrength = 3.0;
        let showClocks = true;
        let showGrid = true;
        let useGradient = false;
        const startTime = Date.now();
        let lastKnownPosition = new THREE.Vector3();
        let motionPattern = 'stationary';
        let cubeEdgeProgress = 0;
        const baseRadius = gridSpacing / 6;
        let lastTime = performance.now();
        let frameCount = 0;
        let currentMaxDilation = 1;
        let currentMinDilation = 1;
        let lastTouchDistance = 0;
        let initialTouchDistance = 0;
        let initialZoom = 8;
        let touchZoomSpeed = 0.02;

        const defaultSettings = {
            gridSize: 5,
            massPercent: 100,
            warpStrength: 3.0,
            zoom: 8,
            motionPattern: 'stationary',
            showClocks: true,
            showGrid: true,
            useGradient: false
        };

        const presets = {
            default: {
                warpStrength: 3,
                mass: 100,
                gridSize: 5,
                motionPattern: 'stationary'
            },
            extreme: {
                warpStrength: 10,
                mass: 500,
                gridSize: 5,
                motionPattern: 'sine'
            },
            subtle: {
                warpStrength: 1,
                mass: 50,
                gridSize: 5,
                motionPattern: 'stationary'
            },
            massive: {
                warpStrength: 5,
                mass: 500,
                gridSize: 6,
                motionPattern: 'circular'
            },
            dense: {
                warpStrength: 3,
                mass: 100,
                gridSize: 8,
                motionPattern: 'stationary'
            },
            sparse: {
                warpStrength: 3,
                mass: 100,
                gridSize: 3,
                motionPattern: 'stationary'
            },
            timeDilation: {
                warpStrength: 7,
                mass: 400,
                gridSize: 4,
                motionPattern: 'sine'
            },
            contrast: {
                warpStrength: 8,
                mass: 450,
                gridSize: 6,
                motionPattern: 'circular'
            },
            minimal: {
                warpStrength: 1,
                mass: 75,
                gridSize: 4,
                motionPattern: 'stationary'
            },
            edgeObserver: {
                warpStrength: 5,
                mass: 300,
                gridSize: 7,
                motionPattern: 'cubeEdge'
            },
            coreObserver: {
                warpStrength: 6,
                mass: 350,
                gridSize: 5,
                motionPattern: 'circularVertical'
            }
        };

        function getClockColor(totalTimeElapsed, minTime, maxTime) {
            if (!useGradient) return '#4444ff';
            const normalized = (totalTimeElapsed - minTime) / (maxTime - minTime || 1);
            if (normalized <= 0.5) {
                const g = Math.floor(255 * (normalized * 2));
                return `rgb(255, ${g}, 0)`;
            } else {
                const r = Math.floor(255 * (2 - normalized * 2));
                return `rgb(${r}, 255, 0)`;
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('meshContainer').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            createMesh(gridSize);

            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            setupEventListeners();
            setupControls();
            makeAllPanelsDraggable();
        }

        function onTouchStart(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel')) return;
            
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            } else if (event.touches.length === 2) {
                isDragging = false;
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                initialTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoom = camera.position.length();
            }
            
            event.preventDefault();
        }

        function onTouchMove(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel')) return;

            if (event.touches.length === 1 && isDragging) {
                const deltaMove = {
                    x: event.touches[0].clientX - previousMousePosition.x,
                    y: event.touches[0].clientY - previousMousePosition.y
                };

                const rotationQuaternion = new THREE.Quaternion();
                rotationQuaternion.setFromEuler(
                    new THREE.Euler(
                        deltaMove.y * rotationSpeed,
                        deltaMove.x * rotationSpeed,
                        0,
                        'XYZ'
                    )
                );
                scene.quaternion.multiplyQuaternions(rotationQuaternion, scene.quaternion);

                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            } else if (event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const currentTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                if (initialTouchDistance > 0) {
                    const distanceRatio = currentTouchDistance / initialTouchDistance;
                    const newZoom = Math.min(Math.max(3, initialZoom / distanceRatio), 20);
                    const zoomSlider = document.getElementById('zoomSlider');
                    zoomSlider.value = newZoom;
                    document.getElementById('zoomValue').textContent = newZoom.toFixed(1);
                    const direction = camera.position.clone().normalize();
                    camera.position.copy(direction.multiplyScalar(newZoom));
                }
            }

            event.preventDefault();
        }

        function onTouchEnd(event) {
            isDragging = false;
            initialTouchDistance = 0;
            event.preventDefault();
        }

        function createClock() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#4444ff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("00:00", canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            
            const clockMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            const clockGeometry = new THREE.PlaneGeometry(1, 0.5);
            const clock = new THREE.Mesh(clockGeometry, clockMaterial);
            clock.visible = showClocks;
            
            clock.userData = { 
                texture, 
                canvas, 
                ctx, 
                startTime: 0, 
                elapsedTime: 0,
                totalTimeElapsed: 0,
                timeDilationFactor: 1, 
                originalPosition: null
            };
            
            clock.lookAt(8, 6, 8);

            return clock;
        }

        function updateClockDisplayWithColor(clock, totalTimeElapsed, minTime, maxTime) {
            const adjustedElapsedTime = Math.floor(clock.userData.elapsedTime / 1000);
            const minutes = Math.floor(adjustedElapsedTime / 60).toString().padStart(2, '0');
            const seconds = (adjustedElapsedTime % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;

            const ctx = clock.userData.ctx;
            const canvas = clock.userData.canvas;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = getClockColor(totalTimeElapsed, minTime, maxTime);
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeString, canvas.width / 2, canvas.height / 2);

            clock.userData.texture.needsUpdate = true;
        }

        function updateClockDisplay(clock, timeDilationFactor) {
            const adjustedElapsedTime = Math.floor(clock.userData.elapsedTime / 1000);
            const minutes = Math.floor(adjustedElapsedTime / 60).toString().padStart(2, '0');
            const seconds = (adjustedElapsedTime % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;

            const ctx = clock.userData.ctx;
            const canvas = clock.userData.canvas;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#4444ff';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeString, canvas.width / 2, canvas.height / 2);

            clock.userData.texture.needsUpdate = true;
        }
function animate() {
            requestAnimationFrame(animate);
            updateFPS();

            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000;
            const meshWidth = gridSize * gridSpacing;
            
            updateMassPosition(elapsedTime, meshWidth);
            
            document.getElementById('massLocation').textContent = 
                `${massiveObject.position.x.toFixed(2)}, ${massiveObject.position.y.toFixed(2)}, ${massiveObject.position.z.toFixed(2)}`;

            let minTotalTime = Infinity;
            let maxTotalTime = -Infinity;
            
            clocks.forEach(clock => {
                if (clock.userData.totalTimeElapsed < minTotalTime) {
                    minTotalTime = clock.userData.totalTimeElapsed;
                }
                if (clock.userData.totalTimeElapsed > maxTotalTime) {
                    maxTotalTime = clock.userData.totalTimeElapsed;
                }
            });

            clocks.forEach(clock => {
                const distance = clock.userData.originalPosition.distanceTo(massiveObject.position) * scalingFactor;
                const currentMass = baseMass * (currentMassPercent / 100);
                const timeDilationFactor = Math.sqrt(1 - (2 * G * currentMass) / (c * c * distance));

                const warpVector = new THREE.Vector3().subVectors(clock.userData.originalPosition, massiveObject.position);
                const distanceFromMass = Math.max(warpVector.length(), 0.1);
                const warpAmount = warpStrength / (distanceFromMass * distanceFromMass + 1e-5);
                warpVector.multiplyScalar(Math.min(warpAmount, 1));
                
                const targetPosition = clock.userData.originalPosition.clone().sub(warpVector);
                clock.position.lerp(targetPosition, 0.1);

                if (clock.visible) {
                    clock.userData.timeDilationFactor = isNaN(timeDilationFactor) || timeDilationFactor >= 1 ? 1 : timeDilationFactor;
                    const frameTime = (currentTime - clock.userData.startTime) * clock.userData.timeDilationFactor;
                    clock.userData.elapsedTime += frameTime;
                    clock.userData.totalTimeElapsed += frameTime;
                    clock.userData.startTime = currentTime;

                    if (useGradient) {
                        updateClockDisplayWithColor(clock, clock.userData.totalTimeElapsed, minTotalTime, maxTotalTime);
                    } else {
                        updateClockDisplay(clock, timeDilationFactor);
                    }
                }
            });

            document.getElementById('maxDilation').textContent = currentMinDilation.toFixed(3);
            updateLines();
            renderer.render(scene, camera);
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('meshContainer').addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            // Touch events
            document.getElementById('meshContainer').addEventListener('touchstart', onTouchStart, false);
            document.getElementById('meshContainer').addEventListener('touchmove', onTouchMove, false);
            document.getElementById('meshContainer').addEventListener('touchend', onTouchEnd, false);
            
            document.getElementById('resetSimulation').addEventListener('click', resetToDefaults);
            document.getElementById('explain').addEventListener('click', toggleExplanation);
            
            document.querySelector('.minimize-button').addEventListener('click', (e) => {
                const controls = document.getElementById('controls');
                const button = e.target;
                if (controls.classList.toggle('minimized')) {
                    button.textContent = '+';
                } else {
                    button.textContent = '−';
                }
            });

            document.getElementById('showClocks').addEventListener('change', (e) => {
                showClocks = e.target.checked;
                clocks.forEach(clock => {
                    clock.visible = showClocks;
                });
            });
            
            document.getElementById('showGrid').addEventListener('change', (e) => {
                showGrid = e.target.checked;
                lines.forEach(line => {
                    line.visible = showGrid;
                });
            });

            document.getElementById('useGradient').addEventListener('change', (e) => {
                useGradient = e.target.checked;
            });

            document.getElementById('motionPattern').addEventListener('change', (e) => {
                motionPattern = e.target.value;
                cubeEdgeProgress = 0;
                resetMassPosition();
            });

            document.getElementById('presetSelect').addEventListener('change', (e) => {
                applyPreset(e.target.value);
            });

            document.getElementById('massSlider').addEventListener('input', (e) => {
                currentMassPercent = parseFloat(e.target.value);
                document.getElementById('massValue').textContent = `${currentMassPercent}%`;
                updateMassiveObjectSize();
            });

            document.querySelector('#info-panel .close-button').addEventListener('click', () => {
                document.getElementById('info-panel').style.display = 'none';
                document.getElementById('explain').textContent = 'Explain';
            });
        }

        function createMesh(size) {
            currentMaxDilation = 1;
            currentMinDilation = 1;

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    for (let z = 0; z < size; z++) {
                        const position = new THREE.Vector3(
                            (x - (size - 1) / 2) * gridSpacing,
                            (y - (size - 1) / 2) * gridSpacing,
                            (z - (size - 1) / 2) * gridSpacing
                        );
                        
                        const clock = createClock();
                        clock.position.copy(position);
                        clock.userData.startTime = Date.now();
                        clock.userData.elapsedTime = 0;
                        clock.userData.originalPosition = position.clone();
                        scene.add(clock);
                        clocks.push(clock);

                        if (x < size - 1 || y < size - 1 || z < size - 1) {
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xffffff,
                                transparent: true,
                                opacity: 0.5
                            });

                            if (x < size - 1) {
                                const nextX = new THREE.Vector3((x + 1 - (size - 1) / 2) * gridSpacing, position.y, position.z);
                                lines.push(drawLine(position, nextX, lineMaterial));
                            }
                            if (y < size - 1) {
                                const nextY = new THREE.Vector3(position.x, (y + 1 - (size - 1) / 2) * gridSpacing, position.z);
                                lines.push(drawLine(position, nextY, lineMaterial));
                            }
                            if (z < size - 1) {
                                const nextZ = new THREE.Vector3(position.x, position.y, (z + 1 - (size - 1) / 2) * gridSpacing);
                                lines.push(drawLine(position, nextZ, lineMaterial));
                            }
                        }
                    }
                }
            }

            const massiveObjectGeometry = new THREE.SphereGeometry(baseRadius, 32, 32);
            const massiveObjectMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9,
                shininess: 100
            });
            massiveObject = new THREE.Mesh(massiveObjectGeometry, massiveObjectMaterial);
            scene.add(massiveObject);
            updateMassiveObjectSize();
        }

function drawLine(start, end, material) {
            const points = [start.clone(), end.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            line.visible = showGrid;
            scene.add(line);
            return line;
        }

        function updateLines() {
            let lineIndex = 0;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const index = x * gridSize * gridSize + y * gridSize + z;
                        const clock = clocks[index];

                        if (x < gridSize - 1) {
                            const nextClockX = clocks[index + gridSize * gridSize];
                            updateLine(lines[lineIndex], clock.position, nextClockX.position);
                            lineIndex++;
                        }

                        if (y < gridSize - 1) {
                            const nextClockY = clocks[index + gridSize];
                            updateLine(lines[lineIndex], clock.position, nextClockY.position);
                            lineIndex++;
                        }

                        if (z < gridSize - 1) {
                            const nextClockZ = clocks[index + 1];
                            updateLine(lines[lineIndex], clock.position, nextClockZ.position);
                            lineIndex++;
                        }
                    }
                }
            }
        }

        function updateLine(line, start, end) {
            const positions = line.geometry.attributes.position.array;
            positions[0] = start.x;
            positions[1] = start.y;
            positions[2] = start.z;
            positions[3] = end.x;
            positions[4] = end.y;
            positions[5] = end.z;
            line.geometry.attributes.position.needsUpdate = true;
        }

        function calculateCubeEdgePosition(progress) {
            const halfSize = (gridSize - 1) * gridSpacing / 2;
            const totalEdges = 12;
            const edgeProgress = (progress * totalEdges) % totalEdges;
            const edge = Math.floor(edgeProgress);
            const t = edgeProgress - edge;

            const vertices = [
                new THREE.Vector3(-halfSize, -halfSize, -halfSize),
                new THREE.Vector3(halfSize, -halfSize, -halfSize),
                new THREE.Vector3(halfSize, -halfSize, halfSize),
                new THREE.Vector3(-halfSize, -halfSize, halfSize),
                new THREE.Vector3(-halfSize, halfSize, -halfSize),
                new THREE.Vector3(halfSize, halfSize, -halfSize),
                new THREE.Vector3(halfSize, halfSize, halfSize),
                new THREE.Vector3(-halfSize, halfSize, halfSize)
            ];

            const edges = [
                [0, 1], [1, 2], [2, 3], [3, 0],
                [4, 5], [5, 6], [6, 7], [7, 4],
                [0, 4], [1, 5], [2, 6], [3, 7]
            ];

            const currentEdge = edges[edge];
            const start = vertices[currentEdge[0]];
            const end = vertices[currentEdge[1]];

            return new THREE.Vector3().lerpVectors(start, end, t);
        }

        function updateMassPosition(elapsedTime, meshWidth) {
            const halfSize = (gridSize - 1) * gridSpacing / 2;
            
            switch(motionPattern) {
                case 'stationary':
                    massiveObject.position.set(0, 0, 0);
                    break;
                case 'sine':
                    massiveObject.position.x = Math.sin(elapsedTime * 0.5) * (meshWidth / 1.5);
                    break;
                case 'circular':
                    const radius = meshWidth / 2;
                    massiveObject.position.x = Math.cos(elapsedTime * 0.5) * radius;
                    massiveObject.position.z = Math.sin(elapsedTime * 0.5) * radius;
                    break;
                case 'circularVertical':
                    const vRadius = meshWidth / 2;
                    massiveObject.position.y = Math.cos(elapsedTime * 0.5) * vRadius;
                    massiveObject.position.z = Math.sin(elapsedTime * 0.5) * vRadius;
                    break;
                case 'cubeEdge':
                    cubeEdgeProgress = (elapsedTime * 0.05) % 1;
                    const newPosition = calculateCubeEdgePosition(cubeEdgeProgress);
                    massiveObject.position.copy(newPosition);
                    break;
            }
            lastKnownPosition.copy(massiveObject.position);
        }

        function updateMassiveObjectSize() {
            const massRatio = currentMassPercent / 100;
            const newRadius = baseRadius * Math.pow(massRatio, 1/3);
            const newGeometry = new THREE.SphereGeometry(newRadius, 32, 32);
            const oldGeometry = massiveObject.geometry;
            massiveObject.geometry = newGeometry;
            oldGeometry.dispose();
        }

        function resetScene() {
            while (scene.children.length > 0) {
                const object = scene.children[0];
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
                scene.remove(object);
            }
            clocks.length = 0;
            lines.length = 0;
            cubeEdgeProgress = 0;
        }

        function resetMassPosition() {
            massiveObject.position.set(0, 0, 0);
            lastKnownPosition.set(0, 0, 0);
        }

        function resetToDefaults() {
            document.getElementById('sizeSlider').value = defaultSettings.gridSize;
            document.getElementById('sizeValue').textContent = defaultSettings.gridSize;
            document.getElementById('massSlider').value = defaultSettings.massPercent;
            document.getElementById('massValue').textContent = `${defaultSettings.massPercent}%`;
            document.getElementById('warpSlider').value = defaultSettings.warpStrength;
            document.getElementById('warpValue').textContent = defaultSettings.warpStrength.toFixed(1);
            document.getElementById('zoomSlider').value = defaultSettings.zoom;
            document.getElementById('zoomValue').textContent = defaultSettings.zoom.toFixed(1);
            document.getElementById('motionPattern').value = defaultSettings.motionPattern;
            document.getElementById('presetSelect').value = 'default';
            document.getElementById('showClocks').checked = defaultSettings.showClocks;
            document.getElementById('showGrid').checked = defaultSettings.showGrid;
            document.getElementById('useGradient').checked = defaultSettings.useGradient;

            gridSize = defaultSettings.gridSize;
            currentMassPercent = defaultSettings.massPercent;
            warpStrength = defaultSettings.warpStrength;
            motionPattern = defaultSettings.motionPattern;
            showClocks = defaultSettings.showClocks;
            showGrid = defaultSettings.showGrid;
            useGradient = defaultSettings.useGradient;

            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            scene.quaternion.identity();
            cubeEdgeProgress = 0;

            resetScene();
            createMesh(gridSize);
        }
function applyPreset(presetName) {
            const preset = presets[presetName];
            if (!preset) return;

            document.getElementById('warpSlider').value = preset.warpStrength;
            document.getElementById('warpValue').textContent = preset.warpStrength.toFixed(1);
            warpStrength = preset.warpStrength;

            document.getElementById('massSlider').value = preset.mass;
            document.getElementById('massValue').textContent = `${preset.mass}%`;
            currentMassPercent = preset.mass;
            updateMassiveObjectSize();

            document.getElementById('motionPattern').value = preset.motionPattern;
            motionPattern = preset.motionPattern;

            if (gridSize !== preset.gridSize) {
                document.getElementById('sizeSlider').value = preset.gridSize;
                document.getElementById('sizeValue').textContent = preset.gridSize;
                gridSize = preset.gridSize;
                resetScene();
                createMesh(gridSize);
            }

            resetMassPosition();
        }

        function toggleExplanation() {
            const infoPanel = document.getElementById('info-panel');
            const isVisible = infoPanel.style.display !== 'none';
            infoPanel.style.display = isVisible ? 'none' : 'flex';
            document.getElementById('explain').textContent = isVisible ? 'Explain' : 'Hide';
        }

        function makeAllPanelsDraggable() {
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                const handle = panel.querySelector('.draggable-handle');
                let isDragging = false;
                let offset = { x: 0, y: 0 };

                handle.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('close-button') || 
                        e.target.classList.contains('minimize-button')) return;
                    isDragging = true;
                    offset.x = e.clientX - panel.getBoundingClientRect().left;
                    offset.y = e.clientY - panel.getBoundingClientRect().top;
                    panel.style.transition = 'none';
                    e.preventDefault();
                });

                handle.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('close-button') || 
                        e.target.classList.contains('minimize-button')) return;
                    isDragging = true;
                    const touch = e.touches[0];
                    offset.x = touch.clientX - panel.getBoundingClientRect().left;
                    offset.y = touch.clientY - panel.getBoundingClientRect().top;
                    panel.style.transition = 'none';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const x = e.clientX - offset.x;
                    const y = e.clientY - offset.y;
                    
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    panel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
                    panel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
                    panel.style.right = 'auto';
                    panel.style.bottom = 'auto';
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const touch = e.touches[0];
                    const x = touch.clientX - offset.x;
                    const y = touch.clientY - offset.y;
                    
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    panel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
                    panel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
                    panel.style.right = 'auto';
                    panel.style.bottom = 'auto';
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    panel.style.transition = 'background-color 0.3s';
                });

                document.addEventListener('touchend', () => {
                    isDragging = false;
                    panel.style.transition = 'background-color 0.3s';
                });

                handle.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            });
        }

        function setupControls() {
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            const warpSlider = document.getElementById('warpSlider');
            const warpValue = document.getElementById('warpValue');
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');

            sizeSlider.addEventListener('input', () => {
                gridSize = parseInt(sizeSlider.value);
                sizeValue.textContent = gridSize;
                resetScene();
                createMesh(gridSize);
            });

            warpSlider.addEventListener('input', () => {
                warpStrength = parseFloat(warpSlider.value);
                warpValue.textContent = warpStrength.toFixed(1);
            });

            zoomSlider.addEventListener('input', () => {
                const zoomLevel = parseFloat(zoomSlider.value);
                zoomValue.textContent = zoomLevel.toFixed(1);
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(zoomLevel));
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateFPS() {
            const now = performance.now();
            frameCount++;

            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = 0.005;

        function onMouseDown(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel')) return;
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            const rotationQuaternion = new THREE.Quaternion();
            rotationQuaternion.setFromEuler(
                new THREE.Euler(
                    deltaMove.y * rotationSpeed,
                    deltaMove.x * rotationSpeed,
                    0,
                    'XYZ'
                )
            );
            scene.quaternion.multiplyQuaternions(rotationQuaternion, scene.quaternion);

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        init();
        animate();
    </script>
</body>
</html>