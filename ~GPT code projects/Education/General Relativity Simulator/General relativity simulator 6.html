<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic 3D Grid with Space Warping and Time Dilation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
        }
        canvas { 
            display: block; 
        }
        .panel {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
            font-family: Arial, sans-serif;
            color: #fff;
            width: auto;
            min-width: 200px;
        }
        #controls {
            bottom: 20px;
            left: 20px;
        }
        #info-panel {
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
        }
        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }
        .control-group label {
            min-width: 100px;
            user-select: none;
        }
        .checkbox-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 5px 0;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        input[type="range"] {
            width: 150px;
            accent-color: #00f;
        }
        input[type="checkbox"] {
            cursor: pointer;
        }
        select {
            width: 150px;
            padding: 5px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        .value-display {
            min-width: 40px;
            text-align: right;
        }
        #meshContainer {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
        .draggable-handle {
            cursor: move;
            padding: 5px 10px;
            text-align: center;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close-button {
            cursor: pointer;
            padding: 0 5px;
            color: #666;
        }
        .close-button:hover {
            color: #fff;
        }
        button {
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #3a3a3a;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        .mass-info {
            margin: 10px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 0.9em;
        }
        .info-section {
            margin-bottom: 15px;
        }
        .info-section h3 {
            margin: 0 0 8px 0;
            color: #4444ff;
        }
        .info-section p {
            margin: 0 0 8px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="meshContainer"></div>
    
    <div id="controls" class="panel">
        <div class="draggable-handle">Controls</div>
        <div class="mass-info">
            Mass Location: <span id="massLocation">0, 0, 0</span><br>
            Max Time Dilation: <span id="maxDilation">1.00</span>x
        </div>
        <div class="control-group">
            <label for="motionPattern">Motion: </label>
            <select id="motionPattern">
                <option value="stationary">Stationary Center</option>
                <option value="sine" selected>Sine Oscillation</option>
                <option value="circular">Circular Motion</option>
            </select>
        </div>
        <div class="control-group">
            <label for="sizeSlider">Grid Size: </label>
            <input type="range" id="sizeSlider" min="3" max="8" value="5" step="1">
            <span id="sizeValue" class="value-display">5</span>
        </div>
        <div class="control-group">
            <label for="warpSlider">Warp Strength: </label>
            <input type="range" id="warpSlider" min="1" max="10" value="3" step="0.5">
            <span id="warpValue" class="value-display">3.0</span>
        </div>
        <div class="control-group">
            <label for="zoomSlider">Zoom: </label>
            <input type="range" id="zoomSlider" min="3" max="20" value="8" step="0.5">
            <span id="zoomValue" class="value-display">8.0</span>
        </div>
        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="showClocks" checked>
                Show Clocks
            </label>
            <label>
                <input type="checkbox" id="showGrid" checked>
                Show Grid
            </label>
        </div>
        <div class="button-group">
            <button id="toggleAnimation">Pause Mass</button>
            <button id="resetSimulation">Reset All</button>
        </div>
    </div>

    <div id="info-panel" class="panel">
        <div class="draggable-handle">
            About This Simulation
            <span class="close-button">×</span>
        </div>
        <div class="info-section">
            <h3>What You're Seeing</h3>
            <p>This visualization demonstrates Einstein's Theory of General Relativity, showing how massive objects warp spacetime and affect the flow of time. The yellow sphere represents a massive object (100 solar masses), the grid shows space warping, and the clocks show time dilation effects.</p>
        </div>
        <div class="info-section">
            <h3>Time Dilation</h3>
            <p>The clocks near the massive object run slower than those far away, demonstrating gravitational time dilation. The color intensity of the clock numbers indicates the strength of the time dilation effect.</p>
        </div>
        <div class="info-section">
            <h3>Space Warping</h3>
            <p>The grid lines show how space itself is warped by the massive object. The stronger the warping, the closer the grid lines bunch together near the mass.</p>
        </div>
        <div class="info-section">
            <h3>Controls</h3>
            <p>• Click and drag to rotate the view<br>
               • Use the zoom slider to adjust distance<br>
               • Try different motion patterns for the mass<br>
               • Adjust warp strength to see different effects<br>
               • Toggle clocks and grid visibility</p>
        </div>
        <div class="info-section">
            <h3>Physics</h3>
            <p>The simulation uses real gravitational equations from General Relativity, though the effects are exaggerated for visualization purposes. The time dilation and space warping effects are proportional to the mass of the object and inverse to the distance from it.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, massiveObject;
        const clocks = [];
        const lines = [];
        let gridSize = 5;
        const gridSpacing = 1.2;
        const sphereMass = 100 * 1.989e30;
        const G = 6.67430e-11;
        const c = 3e8;
        let scalingFactor = 1e6;
        let warpStrength = 3.0;
        let isAnimating = true;
        let showClocks = true;
        let showGrid = true;
        const startTime = Date.now();
        let lastKnownPosition = new THREE.Vector3();
        let motionPattern = 'sine';

function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('meshContainer').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            createMesh(gridSize);

            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            setupEventListeners();
            setupControls();
            makeAllPanelsDraggable();
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('meshContainer').addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            document.getElementById('toggleAnimation').addEventListener('click', toggleAnimation);
            document.getElementById('resetSimulation').addEventListener('click', resetSimulation);
            
            document.getElementById('showClocks').addEventListener('change', (e) => {
                showClocks = e.target.checked;
                clocks.forEach(clock => {
                    clock.visible = showClocks;
                });
            });
            
            document.getElementById('showGrid').addEventListener('change', (e) => {
                showGrid = e.target.checked;
                lines.forEach(line => {
                    line.visible = showGrid;
                });
            });

            document.getElementById('motionPattern').addEventListener('change', (e) => {
                motionPattern = e.target.value;
                resetMassPosition();
            });

            // Setup info panel close button
            document.querySelector('#info-panel .close-button').addEventListener('click', () => {
                document.getElementById('info-panel').style.display = 'none';
            });
        }

        function makeAllPanelsDraggable() {
            const panels = document.querySelectorAll('.panel');
            panels.forEach(panel => {
                const handle = panel.querySelector('.draggable-handle');
                let isDragging = false;
                let offset = { x: 0, y: 0 };

                handle.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('close-button')) return;
                    isDragging = true;
                    offset.x = e.clientX - panel.getBoundingClientRect().left;
                    offset.y = e.clientY - panel.getBoundingClientRect().top;
                    panel.style.transition = 'none';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const x = e.clientX - offset.x;
                    const y = e.clientY - offset.y;
                    
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    panel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
                    panel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
                    panel.style.right = 'auto';
                    panel.style.bottom = 'auto';
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    panel.style.transition = 'background-color 0.3s';
                });

                handle.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            });
        }

        function updateMassPosition(elapsedTime, meshWidth) {
            switch(motionPattern) {
                case 'stationary':
                    massiveObject.position.set(0, 0, 0);
                    break;
                case 'sine':
                    massiveObject.position.x = Math.sin(elapsedTime * 0.5) * (meshWidth / 1.5);
                    break;
                case 'circular':
                    const radius = meshWidth / 2;
                    massiveObject.position.x = Math.cos(elapsedTime * 0.5) * radius;
                    massiveObject.position.z = Math.sin(elapsedTime * 0.5) * radius;
                    break;
            }
            lastKnownPosition.copy(massiveObject.position);
        }

        function resetMassPosition() {
            if (motionPattern === 'stationary') {
                massiveObject.position.set(0, 0, 0);
            } else if (motionPattern === 'circular') {
                massiveObject.position.set(meshWidth / 2, 0, 0);
            } else {
                massiveObject.position.set(0, 0, 0);
            }
            lastKnownPosition.copy(massiveObject.position);
        }

        // [Previous functions remain the same: createMesh, drawLine, createClock, updateClockDisplay...]

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000;
            const meshWidth = gridSize * gridSpacing;
            
            if (isAnimating) {
                updateMassPosition(elapsedTime, meshWidth);
            } else {
                massiveObject.position.copy(lastKnownPosition);
            }
            
            document.getElementById('massLocation').textContent = 
                `${massiveObject.position.x.toFixed(2)}, ${massiveObject.position.y.toFixed(2)}, ${massiveObject.position.z.toFixed(2)}`;

            let maxDilation = 1;

            // Update camera matrices
            camera.updateMatrixWorld();
            const viewMatrix = camera.matrixWorldInverse.clone();
            
            clocks.forEach(clock => {
                const distance = clock.userData.originalPosition.distanceTo(massiveObject.position) * scalingFactor;
                const timeDilationFactor = Math.sqrt(1 - (2 * G * sphereMass) / (c * c * distance));
                
                if (timeDilationFactor < maxDilation) maxDilation = timeDilationFactor;

                if (clock.visible) {
                    clock.userData.timeDilationFactor = isNaN(timeDilationFactor) || timeDilationFactor >= 1 ? 1 : timeDilationFactor;
                    
                    if (isAnimating) {
                        clock.userData.elapsedTime += (currentTime - clock.userData.startTime) * clock.userData.timeDilationFactor;
                    }
                    clock.userData.startTime = currentTime;

                    updateClockDisplay(clock, timeDilationFactor);
                }

                // Always update positions for warping
                const warpVector = new THREE.Vector3().subVectors(clock.userData.originalPosition, massiveObject.position);
                const distanceFromMass = Math.max(warpVector.length(), 0.1);
                const warpAmount = warpStrength / (distanceFromMass * distanceFromMass + 1e-5);
                warpVector.multiplyScalar(Math.min(warpAmount, 1));
                
                const targetPosition = clock.userData.originalPosition.clone().sub(warpVector);
                clock.position.lerp(targetPosition, 0.1);

                // Perfect billboard alignment
                if (clock.visible) {
                    clock.lookAt(camera.position);
                    clock.rotateY(Math.PI);
                    
                    // Ensure horizontal orientation
                    const up = new THREE.Vector3(0, 1, 0);
                    clock.quaternion.setFromRotationMatrix(
                        new THREE.Matrix4().lookAt(
                            clock.position,
                            camera.position,
                            up
                        )
                    );
                }
            });

            document.getElementById('maxDilation').textContent = maxDilation.toFixed(3);
            
            if (isAnimating) {
                updateLines();
            }
            
            renderer.render(scene, camera);
        }

        // [Previous functions remain the same: updateLines, updateLine, resetScene, onWindowResize, mouse controls...]

        init();
        animate();
    </script>
</body>
</html>