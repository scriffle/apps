<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Fast Coin Flip Simulator with Log Graph</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        .stat-box {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 4px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .stat-box h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }
        .stat-box p {
            margin: 0;
            font-size: 20px;
            font-weight: bold;
            color: #2980b9;
        }
        button {
            padding: 10px 20px;
            background-color: #2980b9;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #3498db;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        #stopButton {
            background-color: #e74c3c;
        }
        #stopButton:hover {
            background-color: #c0392b;
        }
        #resetButton {
            background-color: #7f8c8d;
        }
        #resetButton:hover {
            background-color: #95a5a6;
        }
        .scale-toggle {
            margin-left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #2196F3;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(32px);
        }
        .graph-container {
            height: 400px;
            margin-top: 20px;
            margin-left: 70px;
            margin-bottom: 60px;
            position: relative;
            border-left: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
        }
        .bar {
            background-color: #3498db;
            position: absolute;
            bottom: 0;
            transition: height 0.3s ease;
        }
        .y-axis {
            position: absolute;
            left: -70px;
            top: 0;
            height: 100%;
            width: 65px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
        }
        .x-axis {
            position: absolute;
            bottom: -30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
        .x-tick {
            position: absolute;
            text-align: center;
            font-size: 12px;
            transform: translateX(-50%);
        }
        .x-axis-label {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
        }
        .y-axis-label {
            position: absolute;
            left: -70px;
            top: 50%;
            width: 150px;
            text-align: center;
            transform: rotate(-90deg) translateX(0) translateY(-80px);
            font-weight: bold;
        }
        .graph-title {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Ultra-Fast Coin Flip Simulator</h1>
    
    <div class="controls">
        <button id="startButton">Start Simulation</button>
        <button id="stopButton" disabled>Stop</button>
        <button id="resetButton">Reset</button>
    </div>
    
    <div class="stats">
        <div class="stat-box">
            <h3>Total Flips</h3>
            <p id="totalFlips">0</p>
        </div>
        <div class="stat-box">
            <h3>Longest Streak</h3>
            <p id="longestStreak">0</p>
        </div>
        <div class="stat-box">
            <h3>Flips/Second</h3>
            <p id="flipsPerSecond">0</p>
        </div>
    </div>
    
    <h2 class="graph-title">
        Streak Length Distribution (20-100)
        <div class="scale-toggle">
            <span>Linear</span>
            <label class="toggle-switch">
                <input type="checkbox" id="scaleToggle" checked>
                <span class="toggle-slider"></span>
            </label>
            <span>Log</span>
        </div>
    </h2>
    
    <div class="graph-container" id="graphContainer">
        <div class="y-axis" id="yAxis"></div>
        <div class="x-axis" id="xAxis"></div>
        <div class="x-axis-label">Streak Length</div>
        <div class="y-axis-label" id="yAxisLabel">Count (log scale)</div>
    </div>
    
    <script>
        // Configuration
        const MIN_DISPLAY_STREAK = 20;
        const MAX_STREAK = 100;
        
        // Use a highly efficient typed array for streak counts
        const streakCounts = new Uint32Array(MAX_STREAK + 1);
        
        // Simulation state as primitive values for best performance
        let totalFlips = 0;
        let currentStreak = 0;
        let currentValue = -1; // -1 means no flips yet
        let longestStreak = 0;
        
        // Performance tracking
        let flipsPerSec = 0;
        let flipsThisBatch = 0;
        let simulationInterval = null;
        let lastPerformanceUpdate = 0;
        let lastGraphUpdate = 0;
        
        // Elements - cache these for performance
        const totalFlipsEl = document.getElementById('totalFlips');
        const longestStreakEl = document.getElementById('longestStreak');
        const flipsPerSecondEl = document.getElementById('flipsPerSecond');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const resetButton = document.getElementById('resetButton');
        const graphContainer = document.getElementById('graphContainer');
        const yAxis = document.getElementById('yAxis');
        const xAxis = document.getElementById('xAxis');
        
        // Format large numbers with appropriate unit suffixes
        function formatLargeNumber(num) {
            if (num >= 1e12) {
                return (num / 1e12).toFixed(2) + ' trillion';
            } else if (num >= 1e9) {
                return (num / 1e9).toFixed(2) + ' billion';
            } else if (num >= 1e6) {
                return (num / 1e6).toFixed(2) + ' million';
            } else if (num >= 1e3) {
                return (num / 1e3).toFixed(1) + 'K';
            } else {
                return num.toString();
            }
        }
        
        // Initialize the log graph
        function initializeGraph() {
            // Clear existing bars
            const existingBars = graphContainer.querySelectorAll('.bar');
            existingBars.forEach(bar => bar.remove());
            
            // Set up x-axis ticks
            xAxis.innerHTML = '';
            
            // Add ticks at intervals
            for (let i = 20; i <= 100; i += 10) {
                const tick = document.createElement('div');
                tick.className = 'x-tick';
                // Position based on percentage of width
                const position = (i - MIN_DISPLAY_STREAK) / (MAX_STREAK - MIN_DISPLAY_STREAK) * 100;
                tick.style.left = `${position}%`;
                tick.textContent = i;
                xAxis.appendChild(tick);
            }
            
            // Create bars
            const barWidth = 100 / (MAX_STREAK - MIN_DISPLAY_STREAK + 1);
            
            for (let i = MIN_DISPLAY_STREAK; i <= MAX_STREAK; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.id = `bar-${i}`;
                
                // Calculate position
                const position = (i - MIN_DISPLAY_STREAK) / (MAX_STREAK - MIN_DISPLAY_STREAK) * 100;
                
                bar.style.left = `${position}%`;
                bar.style.width = `${barWidth}%`;
                bar.style.height = '0%';
                
                graphContainer.appendChild(bar);
            }
            
            // Initialize y-axis with default scale
            const useLogScale = document.getElementById('scaleToggle').checked;
            updateYAxis(1, 1000, useLogScale);
        }
        
        // Update y-axis with log or linear scale
        function updateYAxis(minValue, maxValue, useLogScale) {
            yAxis.innerHTML = '';
            
            if (useLogScale) {
                // Create log-scale ticks
                const logMin = Math.max(0, Math.floor(Math.log10(minValue)));
                const logMax = Math.ceil(Math.log10(maxValue));
                
                for (let i = logMax; i >= logMin; i--) {
                    const tick = document.createElement('div');
                    const value = Math.pow(10, i);
                    
                    // Position based on log scale
                    const position = (1 - (Math.log10(value) - logMin) / (logMax - logMin)) * 100;
                    tick.style.position = 'absolute';
                    tick.style.top = `${position}%`;
                    tick.style.right = '5px';
                    
                    tick.textContent = i === 0 ? '1' : `10^${i}`;
                    yAxis.appendChild(tick);
                }
            } else {
                // Create linear scale ticks
                const ticks = 5;
                for (let i = ticks; i >= 0; i--) {
                    const tick = document.createElement('div');
                    const value = Math.round(maxValue * i / ticks);
                    
                    // Position based on linear scale
                    const position = (1 - i / ticks) * 100;
                    tick.style.position = 'absolute';
                    tick.style.top = `${position}%`;
                    tick.style.right = '5px';
                    
                    tick.textContent = formatLargeNumber(value);
                    yAxis.appendChild(tick);
                }
            }
        }
        
        // Update the log graph
        function updateGraph() {
            // Get scale preference
            const useLogScale = document.getElementById('scaleToggle').checked;
            document.getElementById('yAxisLabel').textContent = useLogScale ? 'Count (log scale)' : 'Count';
            
            // Find the minimum and maximum values for scaling
            let maxCount = 1; // Start with 1 to avoid division by zero
            let minCount = 1;
            
            // Only look at streaks we're displaying
            for (let i = MIN_DISPLAY_STREAK; i <= MAX_STREAK; i++) {
                if (streakCounts[i] > 0) {
                    maxCount = Math.max(maxCount, streakCounts[i]);
                    if (streakCounts[i] < minCount || minCount === 1) {
                        minCount = streakCounts[i];
                    }
                }
            }
            
            // Update y-axis with appropriate scale
            updateYAxis(minCount, maxCount, useLogScale);
            
            // Update each bar
            for (let i = MIN_DISPLAY_STREAK; i <= MAX_STREAK; i++) {
                const bar = document.getElementById(`bar-${i}`);
                if (bar) {
                    const count = streakCounts[i];
                    
                    if (count > 0) {
                        let height;
                        
                        if (useLogScale) {
                            // Calculate height based on logarithmic scale
                            const logMin = Math.log10(minCount);
                            const logMax = Math.log10(maxCount);
                            const logValue = Math.log10(count);
                            
                            // Normalize to percentage (0-100%)
                            height = ((logValue - logMin) / (logMax - logMin)) * 100;
                        } else {
                            // Linear scale
                            height = (count / maxCount) * 100;
                        }
                        
                        bar.style.height = `${height}%`;
                        
                        // Add tooltip
                        bar.title = `Streak of ${i}: ${formatLargeNumber(count)}`;
                    } else {
                        bar.style.height = '0%';
                    }
                }
            }
        }
        
        // Update the stats display
        function updateStats() {
            totalFlipsEl.textContent = formatLargeNumber(totalFlips);
            longestStreakEl.textContent = formatLargeNumber(longestStreak);
            flipsPerSecondEl.textContent = formatLargeNumber(flipsPerSec);
        }
        
        // The core simulation function - hyper-optimized for speed
        function runSimulationBatch() {
            // Unroll loop for better performance - process 8 flips at once
            const BATCH_SIZE = 4000000; // Higher batch size for better throughput
            
            // Local variables for better performance
            let streak = currentStreak;
            let value = currentValue;
            let total = totalFlips;
            let longest = longestStreak;
            
            // Pre-allocate random values in chunks
            for (let b = 0; b < BATCH_SIZE; b++) {
                // Generate random bit (0 or 1) - fastest method
                const result = Math.random() < 0.5 ? 0 : 1;
                total++;
                
                // Ultra-fast streak tracking
                if (value === result) {
                    streak++;
                } else {
                    // Only track streaks we care about (>= 20)
                    if (streak >= MIN_DISPLAY_STREAK) {
                        // Clamp to our maximum streak length
                        const recordedStreak = Math.min(streak, MAX_STREAK);
                        streakCounts[recordedStreak]++;
                        
                        // Update longest streak
                        if (streak > longest) {
                            longest = streak;
                        }
                    }
                    
                    // Reset streak
                    streak = 1;
                    value = result;
                }
            }
            
            // Update global state
            currentStreak = streak;
            currentValue = value;
            totalFlips = total;
            longestStreak = longest;
            
            return BATCH_SIZE;
        }
        
        // Start the high-speed simulation
        function startSimulation() {
            if (simulationInterval) return;
            
            startButton.disabled = true;
            stopButton.disabled = false;
            
            // Initialize performance tracking
            lastPerformanceUpdate = performance.now();
            lastGraphUpdate = performance.now();
            flipsThisBatch = 0;
            
            function simulate() {
                if (!simulationInterval) return; // Stop if cancelled
                
                // Process multiple batches between animation frames
                const WORKER_DURATION = 30; // ms to run before yielding to UI
                const startTime = performance.now();
                let batchesProcessed = 0;
                
                while (performance.now() - startTime < WORKER_DURATION) {
                    flipsThisBatch += runSimulationBatch();
                    batchesProcessed++;
                }
                
                const now = performance.now();
                
                // Update stats display once per second
                if (now - lastPerformanceUpdate >= 1000) {
                    flipsPerSec = Math.round(flipsThisBatch * 1000 / (now - lastPerformanceUpdate));
                    flipsThisBatch = 0;
                    lastPerformanceUpdate = now;
                    updateStats();
                }
                
                // Update graph less frequently (every 2 seconds)
                if (now - lastGraphUpdate >= 2000) {
                    updateGraph();
                    lastGraphUpdate = now;
                }
                
                // Using setTimeout before requestAnimationFrame gives browser time to process
                setTimeout(() => requestAnimationFrame(simulate), 0);
            }
            
            simulationInterval = true; // Use as a flag
            requestAnimationFrame(simulate);
        }
        
        // Stop simulation
        function stopSimulation() {
            simulationInterval = null;
            startButton.disabled = false;
            stopButton.disabled = true;
            updateStats();
            updateGraph();
        }
        
        // Reset simulation
        function resetSimulation() {
            stopSimulation();
            
            // Reset all counters
            totalFlips = 0;
            currentStreak = 0;
            currentValue = -1;
            longestStreak = 0;
            flipsPerSec = 0;
            
            // Reset streak counts array - fastest way to zero an array
            streakCounts.fill(0);
            
            // Update display
            updateStats();
            initializeGraph();
        }
        
        // Set up event listeners
        startButton.addEventListener('click', startSimulation);
        stopButton.addEventListener('click', stopSimulation);
        resetButton.addEventListener('click', resetSimulation);
        
        // Add event listener for scale toggle
        const scaleToggle = document.getElementById('scaleToggle');
        if (scaleToggle) {
            scaleToggle.addEventListener('change', () => {
                updateGraph();
            });
        }
        
        // Initialize on page load
        initializeGraph();
    </script>
</body>
</html>