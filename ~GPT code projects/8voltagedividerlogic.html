<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voltage Divider Circuit Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Nunito:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-dark: #0f1419;
            --bg-panel: #1a1f26;
            --bg-component: #252d38;
            --bg-slot: #1e2530;
            --border: #2d3848;
            --border-active: #4a90d9;
            
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            
            --accent-blue: #4a90d9;
            --accent-orange: #f0883e;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
            
            --voltage-high: #3fb950;
            --voltage-low: #6e7681;
            
            --font-mono: 'JetBrains Mono', monospace;
            --font-body: 'Nunito', sans-serif;
            
            --touch-target: 44px;
            --radius: 8px;
            --radius-lg: 12px;
            --transition: 0.2s ease;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .header h1 {
            font-size: clamp(14px, 3vw, 18px);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header h1 span {
            color: var(--accent-orange);
        }

        .mode-toggle {
            display: flex;
            background: var(--bg-dark);
            border-radius: var(--radius);
            padding: 3px;
            gap: 2px;
        }

        .mode-btn {
            padding: 6px 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: 13px;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
            min-height: var(--touch-target);
            display: flex;
            align-items: center;
        }

        .mode-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .mode-btn:hover:not(.active) {
            background: var(--bg-component);
        }

        .advanced-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .toggle-switch {
            width: 40px;
            height: 22px;
            background: var(--bg-dark);
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            transition: var(--transition);
        }

        .toggle-switch.active {
            background: var(--accent-blue);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: var(--transition);
        }

        .toggle-switch.active::after {
            left: 20px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        /* Component Tray */
        .component-tray {
            width: clamp(100px, 20vw, 140px);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 12px 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
        }

        .tray-section {
            margin-bottom: 8px;
        }

        .tray-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 6px;
            padding-left: 4px;
        }

        .component-item {
            background: var(--bg-component);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 8px;
            cursor: grab;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-height: var(--touch-target);
            user-select: none;
            touch-action: none;
        }

        .component-item:hover {
            border-color: var(--border-active);
            transform: translateY(-2px);
        }

        .component-item:active {
            cursor: grabbing;
        }

        .component-item.dragging {
            opacity: 0.5;
        }

        .component-item.in-use {
            opacity: 0.3;
            pointer-events: none;
        }

        .component-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .component-icon svg {
            width: 100%;
            height: 100%;
        }

        .component-name {
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Input components */
        .component-item[data-type="ldr"] { border-color: var(--accent-yellow); }
        .component-item[data-type="thermistor"] { border-color: var(--accent-red); }
        .component-item[data-type="fixed"] { border-color: var(--accent-blue); }
        
        /* Output components */
        .component-item[data-type="led"] { border-color: var(--accent-green); }
        .component-item[data-type="buzzer"] { border-color: var(--accent-purple); }
        .component-item[data-type="binary"] { border-color: var(--accent-orange); }

        /* Circuit Area */
        .circuit-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            gap: 12px;
            overflow-y: auto;
        }

        .circuit-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }

        .circuit-wrapper {
            display: flex;
            align-items: stretch;
            gap: 24px;
            /* Add padding to account for output zones on the right */
            padding-right: 80px;
        }

        /* Stimulus Column - left side, aligns with circuit */
        .stimulus-column {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-width: 160px;
            padding-top: 30px; /* Align with circuit starting below voltage label */
        }

        .stimulus-column.hidden {
            visibility: hidden;
        }

        .stimulus-column.align-top .stimulus-wrapper {
            margin-top: 0;
        }

        .stimulus-column.align-bottom .stimulus-wrapper {
            margin-top: 100px; /* Push down to align with bottom slot */
        }

        .stimulus-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 10px 12px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            transition: margin-top 0.3s ease;
        }

        .stimulus-wrapper .stimulus-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stimulus-track {
            width: 140px;
            height: 50px;
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bg-dark);
            border-radius: var(--radius);
            padding: 4px;
        }

        .stimulus-source {
            width: 44px;
            height: 44px;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            touch-action: none;
            user-select: none;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stimulus-source:active {
            cursor: grabbing;
        }

        .stimulus-source svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 6px var(--accent-yellow));
        }

        .stimulus-source.heat svg {
            filter: drop-shadow(0 0 6px var(--accent-red));
        }

        .stimulus-target {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.6;
        }

        .stimulus-target svg {
            width: 100%;
            height: 100%;
        }

        .distance-label {
            font-size: 11px;
            color: var(--text-secondary);
            font-family: var(--font-mono);
        }

        /* Circuit Schematic */
        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            position: relative;
        }

        .voltage-label {
            font-family: var(--font-mono);
            font-size: 14px;
            font-weight: 600;
            padding: 6px 12px;
            background: var(--accent-green);
            color: var(--bg-dark);
            border-radius: var(--radius);
            margin-bottom: 4px;
        }

        .wire {
            width: 4px;
            height: 20px;
            background: var(--text-secondary);
        }

        .circuit-slot {
            width: 120px;
            min-height: 80px;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: var(--transition);
            position: relative;
            background: var(--bg-slot);
        }

        .circuit-slot.drag-over {
            border-color: var(--accent-blue);
            background: rgba(74, 144, 217, 0.1);
        }

        .circuit-slot .slot-label {
            font-size: 11px;
            color: var(--text-muted);
            position: absolute;
            top: 4px;
            left: 8px;
        }

        .circuit-slot.filled {
            border-style: solid;
            background: var(--bg-component);
        }

        .circuit-slot .placed-component {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
        }

        .placed-component .component-icon {
            width: 40px;
            height: 40px;
        }

        .placed-component .component-info {
            text-align: center;
        }

        .placed-component .component-info .name {
            font-size: 12px;
            font-weight: 600;
        }

        .placed-component .component-info .value {
            font-size: 11px;
            font-family: var(--font-mono);
            color: var(--accent-orange);
        }

        .slot-voltage {
            position: absolute;
            right: -70px;
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: 500;
            padding: 4px 8px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            white-space: nowrap;
        }

        /* Output Connection Zone */
        .output-zone {
            position: absolute;
            right: -155px;
            width: 70px;
            height: 60px;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: var(--text-muted);
            background: var(--bg-slot);
            transition: var(--transition);
        }

        .output-zone.drag-over {
            border-color: var(--accent-green);
            background: rgba(63, 185, 80, 0.1);
        }

        .output-zone.filled {
            border-style: solid;
            background: var(--bg-component);
        }

        .output-zone .placed-output {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .output-zone .placed-output .component-icon {
            width: 28px;
            height: 28px;
        }

        .output-zone .placed-output .name {
            font-size: 9px;
            font-weight: 600;
        }

        .output-indicator {
            position: absolute;
            left: -24px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            transition: var(--transition);
        }

        .output-indicator.active {
            background: var(--accent-green);
            border-color: var(--accent-green);
            box-shadow: 0 0 12px var(--accent-green);
        }

        .ground-label {
            font-family: var(--font-mono);
            font-size: 14px;
            font-weight: 600;
            padding: 6px 12px;
            background: var(--text-muted);
            color: var(--bg-dark);
            border-radius: var(--radius);
            margin-top: 4px;
        }

        /* Stimulus Area - inline with slots */
        .stimulus-track {
            width: 140px;
            height: 50px;
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 4px 8px;
        }

        .stimulus-source {
            width: 44px;
            height: 44px;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            transition: filter 0.1s;
            touch-action: none;
            user-select: none;
            z-index: 2;
        }

        .stimulus-source:active {
            cursor: grabbing;
        }

        .stimulus-source svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 8px var(--accent-yellow));
        }

        .stimulus-source.heat svg {
            filter: drop-shadow(0 0 8px var(--accent-red));
        }

        .stimulus-target {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stimulus-target svg {
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }

        .distance-label {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Readings Panel */
        .readings-panel {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .reading-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .reading-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
        }

        .reading-value {
            font-family: var(--font-mono);
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-orange);
        }

        .reading-item.voltage .reading-value {
            color: var(--accent-green);
        }

        /* Formula display (advanced mode) */
        .formula-display {
            display: none;
            background: var(--bg-component);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 12px;
            font-family: var(--font-mono);
            font-size: 13px;
            text-align: center;
        }

        .formula-display.visible {
            display: block;
        }

        .formula-display .formula {
            color: var(--accent-blue);
            margin-bottom: 8px;
        }

        .formula-display .calculation {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .advanced-note {
            display: none;
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 8px;
        }

        .advanced-note.visible {
            display: block;
        }

        /* Advanced Controls */
        .advanced-controls {
            display: none;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 12px;
            gap: 12px;
        }

        .advanced-controls.visible {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-group label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .control-group input {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 13px;
        }

        .control-group input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Predict Mode */
        /* Predict Mode Panel - replaces component tray on left */
        .predict-container {
            display: none;
            flex-direction: column;
            width: clamp(200px, 25vw, 280px);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            overflow: hidden;
            flex-shrink: 0;
        }

        .predict-container.visible {
            display: flex;
        }

        .predict-header {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
            background: var(--bg-component);
            border-bottom: 1px solid var(--border);
        }

        .predict-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-purple);
        }

        .difficulty-select {
            display: flex;
            gap: 3px;
            background: var(--bg-dark);
            padding: 3px;
            border-radius: var(--radius);
        }

        .difficulty-btn {
            flex: 1;
            padding: 5px 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: 10px;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--transition);
        }

        .difficulty-btn.active {
            background: var(--accent-purple);
            color: white;
        }

        .predict-body {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .predict-scenario {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .predict-question {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-yellow);
            flex-shrink: 0;
        }

        .stimulus-hint {
            font-size: 11px;
            color: var(--text-primary);
            padding: 8px;
            background: var(--bg-dark);
            border-radius: var(--radius);
            border-left: 3px solid var(--accent-orange);
            line-height: 1.4;
            flex-shrink: 0;
        }

        .stimulus-hint strong {
            color: var(--accent-orange);
        }

        .stimulus-hint small {
            color: var(--text-secondary);
            display: block;
            margin-top: 4px;
            font-size: 10px;
        }

        .chip-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 6px;
            background: var(--bg-dark);
            border: 2px dashed var(--border);
            border-radius: var(--radius);
        }

        .chip-container.answer-zone {
            background: var(--bg-slot);
            border-color: var(--accent-blue);
        }

        .chip-zones-wrapper {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            gap: 6px;
        }

        .chip-zone-section {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            gap: 2px;
        }

        .chip-pool-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }

        .logic-chip {
            padding: 5px 8px;
            background: var(--bg-component);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 10px;
            font-weight: 500;
            cursor: grab;
            transition: background 0.15s, border-color 0.15s, transform 0.15s;
            user-select: none;
            touch-action: none;
            line-height: 1.3;
        }

        .logic-chip:hover {
            border-color: var(--accent-blue);
        }

        .logic-chip.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }

        .logic-chip.drop-above {
            border-top: 2px solid var(--accent-blue);
            margin-top: -1px;
        }

        .logic-chip.drop-below {
            border-bottom: 2px solid var(--accent-blue);
            margin-bottom: -1px;
        }

        .logic-chip.correct {
            border-color: var(--accent-green);
            background: rgba(63, 185, 80, 0.15);
        }

        .logic-chip.incorrect {
            border-color: var(--accent-red);
            background: rgba(248, 81, 73, 0.15);
        }

        .predict-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
            flex-shrink: 0;
        }

        .predict-actions .btn {
            flex: 1;
            min-width: 60px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: var(--radius);
            font-family: var(--font-body);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            min-height: 34px;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            background: #5a9fe9;
        }

        .btn-secondary {
            background: var(--bg-component);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--accent-blue);
        }

        .btn-success {
            background: var(--accent-green);
            color: var(--bg-dark);
        }

        .predict-result {
            padding: 8px;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 12px;
            text-align: center;
            display: none;
            margin-top: 6px;
            flex-shrink: 0;
        }

        .predict-result.visible {
            display: block;
        }

        .predict-result.success {
            background: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }

        .predict-result.error {
            background: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            padding: 12px 20px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 13px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease;
        }

        .toast.success {
            border-color: var(--accent-green);
        }

        .toast.error {
            border-color: var(--accent-red);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 700px) {
            .circuit-wrapper {
                gap: 16px;
                padding-right: 60px;
            }
            
            .stimulus-column {
                min-width: 130px;
            }
            
            .stimulus-track {
                width: 120px;
            }
            
            .slot-voltage {
                right: -60px;
                font-size: 11px;
                padding: 3px 6px;
            }
            
            .output-zone {
                right: -130px;
                width: 55px;
                height: 50px;
            }
        }
        
        @media (max-width: 500px) {
            .circuit-wrapper {
                flex-direction: column;
                gap: 12px;
                padding-right: 60px;
            }
            
            .stimulus-column {
                order: 2;
            }
            
            .stimulus-column.align-top .stimulus-wrapper,
            .stimulus-column.align-bottom .stimulus-wrapper {
                margin-top: 0;
            }
            
            .slot-voltage {
                right: -55px;
            }
            
            .output-zone {
                right: -115px;
                width: 50px;
                height: 45px;
            }
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Clear button for slots */
        .clear-slot {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            border: none;
            background: var(--accent-red);
            color: white;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            opacity: 0;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .circuit-slot:hover .clear-slot,
        .output-zone:hover .clear-slot {
            opacity: 1;
        }

        /* Audio context indicator */
        .audio-indicator {
            display: none;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: var(--accent-purple);
        }

        .audio-indicator.active {
            display: flex;
        }

        .audio-indicator .pulse {
            width: 8px;
            height: 8px;
            background: var(--accent-purple);
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <h1>‚ö° <span>Voltage Divider</span> Lab</h1>
        <div class="mode-toggle">
            <button class="mode-btn active" data-mode="free">Free Mode</button>
            <button class="mode-btn" data-mode="predict">Predict Mode</button>
        </div>
        <div class="advanced-toggle">
            <span>Advanced</span>
            <div class="toggle-switch" id="advancedToggle"></div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Component Tray -->
        <aside class="component-tray" id="componentTray">
            <div class="tray-section">
                <div class="tray-label">Input Sensors</div>
                <div class="component-item" data-type="ldr" data-category="input" draggable="true">
                    <div class="component-icon">
                        <svg viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="8" y="12" width="24" height="16" rx="2" fill="none"/>
                            <line x1="4" y1="20" x2="8" y2="20"/>
                            <line x1="32" y1="20" x2="36" y2="20"/>
                            <path d="M2 8 L6 12 M6 8 L2 12" stroke="#d29922"/>
                            <path d="M2 28 L6 32 M6 28 L2 32" stroke="#d29922"/>
                        </svg>
                    </div>
                    <span class="component-name">LDR</span>
                </div>
                <div class="component-item" data-type="thermistor" data-category="input" draggable="true">
                    <div class="component-icon">
                        <svg viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="8" y="12" width="24" height="16" rx="2" fill="none"/>
                            <line x1="4" y1="20" x2="8" y2="20"/>
                            <line x1="32" y1="20" x2="36" y2="20"/>
                            <text x="20" y="24" font-size="10" fill="#f85149" text-anchor="middle">-t¬∞</text>
                        </svg>
                    </div>
                    <span class="component-name">Thermistor</span>
                </div>
            </div>
            <div class="tray-section">
                <div class="tray-label">Fixed Resistor</div>
                <div class="component-item" data-type="fixed" data-category="resistor" draggable="true">
                    <div class="component-icon">
                        <svg viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="8" y="14" width="24" height="12" rx="1" fill="none"/>
                            <line x1="4" y1="20" x2="8" y2="20"/>
                            <line x1="32" y1="20" x2="36" y2="20"/>
                        </svg>
                    </div>
                    <span class="component-name">10kŒ©</span>
                </div>
            </div>
            <div class="tray-section">
                <div class="tray-label">Output Devices</div>
                <div class="component-item" data-type="led" data-category="output" draggable="true">
                    <div class="component-icon">
                        <svg viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="12,12 28,20 12,28" fill="none"/>
                            <line x1="28" y1="12" x2="28" y2="28"/>
                            <line x1="4" y1="20" x2="12" y2="20"/>
                            <line x1="28" y1="20" x2="36" y2="20"/>
                            <path d="M30 10 L34 6" stroke="#3fb950"/>
                            <path d="M32 14 L36 10" stroke="#3fb950"/>
                        </svg>
                    </div>
                    <span class="component-name">LED</span>
                </div>
                <div class="component-item" data-type="buzzer" data-category="output" draggable="true">
                    <div class="component-icon">
                        <svg viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="20" cy="20" r="10" fill="none"/>
                            <circle cx="20" cy="20" r="4" fill="none"/>
                            <line x1="4" y1="20" x2="10" y2="20"/>
                            <line x1="30" y1="20" x2="36" y2="20"/>
                        </svg>
                    </div>
                    <span class="component-name">Buzzer</span>
                </div>
                <div class="component-item" data-type="binary" data-category="output" draggable="true">
                    <div class="component-icon">
                        <svg viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="10" y="10" width="20" height="20" rx="3" fill="none"/>
                            <circle cx="20" cy="20" r="5" fill="#f0883e"/>
                            <line x1="4" y1="20" x2="10" y2="20"/>
                            <line x1="30" y1="20" x2="36" y2="20"/>
                        </svg>
                    </div>
                    <span class="component-name">Switch</span>
                </div>
            </div>
            <div class="audio-indicator" id="audioIndicator">
                <div class="pulse"></div>
                <span>Sound Active</span>
            </div>
        </aside>

        <!-- Predict Mode Panel (replaces component tray) -->
        <aside class="predict-container" id="predictMode">
            <div class="predict-header">
                <div class="predict-title">üß† Predict Mode</div>
                <div class="difficulty-select">
                    <button class="difficulty-btn active" data-level="simple">Simple</button>
                    <button class="difficulty-btn" data-level="medium">Medium</button>
                    <button class="difficulty-btn" data-level="complex">Complex</button>
                </div>
            </div>
            <div class="predict-body">
                <div class="predict-scenario" id="predictScenario">
                    <div class="stimulus-hint" id="stimulusHint">
                        <!-- Filled by JS: "When light increases..." -->
                    </div>
                    <div class="predict-question">
                        Arrange the logic steps in order:
                    </div>
                    <div class="chip-zones-wrapper">
                        <div class="chip-zone-section">
                            <div class="chip-pool-label">Your Answer ‚Üì</div>
                            <div class="chip-container answer-zone" id="answerZone">
                                <!-- Drop zone for ordered chips -->
                            </div>
                        </div>
                        <div class="chip-zone-section">
                            <div class="chip-pool-label">Available Steps ‚Üì</div>
                            <div class="chip-container" id="chipPool">
                                <!-- Available chips -->
                            </div>
                        </div>
                    </div>
                    <div class="predict-actions">
                        <button class="btn btn-primary" id="checkAnswer">Check</button>
                        <button class="btn btn-secondary" id="newScenario">New</button>
                        <button class="btn btn-secondary" id="resetChips">Reset</button>
                    </div>
                    <div class="predict-result" id="predictResult"></div>
                </div>
            </div>
        </aside>

        <!-- Free Mode Container -->
        <div class="circuit-area" id="freeMode">
            <div class="circuit-container">
                <div class="circuit-wrapper">
                    <!-- Stimulus Column (left side) -->
                    <div class="stimulus-column" id="stimulusColumn">
                        <div class="stimulus-wrapper">
                            <div class="stimulus-label">Stimulus</div>
                            <div class="stimulus-track" id="stimulusTrack">
                                <div class="stimulus-source" id="stimulusSource"></div>
                                <div class="stimulus-target" id="stimulusTarget"></div>
                            </div>
                            <div class="distance-label" id="distanceLabel">Far</div>
                        </div>
                    </div>

                    <!-- Circuit Schematic -->
                    <div class="circuit-schematic">
                        <div class="voltage-label" id="supplyVoltage">12.0 V</div>
                        <div class="wire"></div>
                        
                        <!-- Top Slot -->
                        <div class="circuit-slot" id="topSlot" data-position="top">
                            <span class="slot-label">TOP</span>
                            <span class="slot-voltage" id="topVoltage">‚Äî V</span>
                            <div class="output-zone" id="topOutput" data-position="top">
                                Output
                            </div>
                        </div>
                        
                        <div class="wire"></div>
                        
                        <!-- Bottom Slot -->
                        <div class="circuit-slot" id="bottomSlot" data-position="bottom">
                            <span class="slot-label">BOTTOM</span>
                            <span class="slot-voltage" id="bottomVoltage">‚Äî V</span>
                        <div class="output-zone" id="bottomOutput" data-position="bottom">
                            Output
                        </div>
                    </div>
                    
                    <div class="wire"></div>
                    <div class="ground-label">GND 0.0 V</div>
                </div>
                </div>
            </div>

            <!-- Readings Panel -->
            <div class="readings-panel" id="readingsPanel">
                <div class="reading-item">
                    <span class="reading-label">Input Sensor</span>
                    <span class="reading-value" id="sensorResistance">‚Äî</span>
                </div>
                <div class="reading-item">
                    <span class="reading-label">Fixed Resistor</span>
                    <span class="reading-value" id="fixedResistance">10.0 kŒ©</span>
                </div>
                <div class="reading-item voltage">
                    <span class="reading-label">Vout</span>
                    <span class="reading-value" id="voutDisplay">‚Äî V</span>
                </div>
                <div class="reading-item">
                    <span class="reading-label">Output State</span>
                    <span class="reading-value" id="outputState">‚Äî</span>
                </div>
            </div>

            <!-- Formula Display (Advanced) -->
            <div class="formula-display" id="formulaDisplay">
                <div class="formula">Vout = Vin √ó R<sub>bottom</sub> / (R<sub>top</sub> + R<sub>bottom</sub>)</div>
                <div class="calculation" id="formulaCalc">‚Äî</div>
            </div>

            <!-- Advanced Controls -->
            <div class="advanced-controls" id="advancedControls">
                <div class="control-group">
                    <label>Supply Voltage (V)</label>
                    <input type="number" id="inputVoltage" value="12" min="1" max="24" step="0.5">
                </div>
                <div class="control-group">
                    <label>Fixed Resistor (kŒ©)</label>
                    <input type="number" id="inputFixedR" value="10" min="1" max="100" step="1">
                </div>
                <div class="control-group">
                    <label>Binary Threshold (V)</label>
                    <input type="number" id="inputThreshold" value="6" min="0.5" max="12" step="0.5">
                </div>
            </div>

            <div class="advanced-note" id="advancedNote">
                ‚ö†Ô∏è Note: This simulation ignores loading effects from the output device. In real circuits, connecting a load would slightly affect Vout.
            </div>
        </div>
    </main>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ===========================================
        // STATE MANAGEMENT
        // ===========================================
        
        const state = {
            mode: 'free', // 'free' or 'predict'
            advancedMode: false,
            
            // Circuit values (user customizable in advanced mode)
            circuitValues: {
                supplyVoltage: 12,
                fixedResistance: 10000, // ohms
                binaryThreshold: 6,
            },
            
            // Free mode circuit state (component placement)
            freeCircuit: {
                topSlot: null, // { type: 'ldr'|'thermistor'|'fixed', category: 'input'|'resistor' }
                bottomSlot: null,
                outputSlot: null, // { position: 'top'|'bottom', type: 'led'|'buzzer'|'binary' }
                stimulusDistance: 1, // 0 (close) to 1 (far)
            },
            
            // Predict mode circuit state (separate from free mode)
            predictCircuit: {
                topSlot: null,
                bottomSlot: null,
                outputSlot: null,
                stimulusDistance: 1,
            },
            
            // Predict mode game state
            predict: {
                difficulty: 'simple',
                scenario: null,
                correctOrder: [],
                userOrder: [],
            },
            
            // Undo/redo
            history: [],
            historyIndex: -1,
        };
        
        // Helper to get current circuit state based on mode
        function getCircuit() {
            return state.mode === 'free' ? state.freeCircuit : state.predictCircuit;
        }
        
        // Helper to get circuit values
        function getCircuitValues() {
            return state.circuitValues;
        }

        // Transducer resistance ranges (ohms)
        const TRANSDUCER_RANGES = {
            ldr: { min: 1000, max: 50000, stimulusEffect: 'decrease' }, // light increases -> R decreases
            thermistor: { min: 1000, max: 30000, stimulusEffect: 'decrease' }, // heat increases -> R decreases (NTC)
        };

        // ===========================================
        // DOM REFERENCES
        // ===========================================
        const dom = {
            // Mode toggles
            modeBtns: document.querySelectorAll('.mode-btn'),
            advancedToggle: document.getElementById('advancedToggle'),
            
            // Containers
            freeMode: document.getElementById('freeMode'),
            predictMode: document.getElementById('predictMode'),
            componentTray: document.getElementById('componentTray'),
            
            // Circuit elements
            topSlot: document.getElementById('topSlot'),
            bottomSlot: document.getElementById('bottomSlot'),
            topOutput: document.getElementById('topOutput'),
            bottomOutput: document.getElementById('bottomOutput'),
            
            // Displays
            supplyVoltage: document.getElementById('supplyVoltage'),
            topVoltage: document.getElementById('topVoltage'),
            bottomVoltage: document.getElementById('bottomVoltage'),
            sensorResistance: document.getElementById('sensorResistance'),
            fixedResistance: document.getElementById('fixedResistance'),
            voutDisplay: document.getElementById('voutDisplay'),
            outputState: document.getElementById('outputState'),
            
            // Stimulus (single element that aligns with active sensor)
            stimulusColumn: document.getElementById('stimulusColumn'),
            stimulusTrack: document.getElementById('stimulusTrack'),
            stimulusSource: document.getElementById('stimulusSource'),
            stimulusTarget: document.getElementById('stimulusTarget'),
            distanceLabel: document.getElementById('distanceLabel'),
            
            // Readings panel
            readingsPanel: document.getElementById('readingsPanel'),
            
            // Advanced
            formulaDisplay: document.getElementById('formulaDisplay'),
            formulaCalc: document.getElementById('formulaCalc'),
            advancedControls: document.getElementById('advancedControls'),
            advancedNote: document.getElementById('advancedNote'),
            inputVoltage: document.getElementById('inputVoltage'),
            inputFixedR: document.getElementById('inputFixedR'),
            inputThreshold: document.getElementById('inputThreshold'),
            
            // Predict mode
            difficultyBtns: document.querySelectorAll('.difficulty-btn'),
            stimulusHint: document.getElementById('stimulusHint'),
            answerZone: document.getElementById('answerZone'),
            chipPool: document.getElementById('chipPool'),
            checkAnswer: document.getElementById('checkAnswer'),
            newScenario: document.getElementById('newScenario'),
            resetChips: document.getElementById('resetChips'),
            predictResult: document.getElementById('predictResult'),
            
            // Toast
            toastContainer: document.getElementById('toastContainer'),
            
            // Audio indicator
            audioIndicator: document.getElementById('audioIndicator'),
        };

        // ===========================================
        // AUDIO CONTEXT (for buzzer)
        // ===========================================
        let audioContext = null;
        let oscillator = null;
        let gainNode = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = 0;
            }
        }

        function playBuzzer(volume) {
            initAudio();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            if (!oscillator) {
                oscillator = audioContext.createOscillator();
                oscillator.type = 'square';
                oscillator.frequency.value = 440; // Fixed frequency
                oscillator.connect(gainNode);
                oscillator.start();
            }
            
            // Clamp volume: 0 = silent (0dB), 1 = full volume (100%)
            const clampedVolume = clamp(volume, 0, 1);
            gainNode.gain.setTargetAtTime(clampedVolume, audioContext.currentTime, 0.1);
            
            dom.audioIndicator.classList.toggle('active', clampedVolume > 0.05);
        }

        function stopBuzzer() {
            if (gainNode) {
                gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
            }
            dom.audioIndicator.classList.remove('active');
        }

        // ===========================================
        // UTILITY FUNCTIONS
        // ===========================================
        function toast(message, type = 'info') {
            const t = document.createElement('div');
            t.className = `toast ${type}`;
            t.textContent = message;
            dom.toastContainer.appendChild(t);
            setTimeout(() => t.remove(), 3000);
        }

        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // ===========================================
        // CIRCUIT CALCULATIONS
        // ===========================================
        function getTransducerResistance(type) {
            if (!type || !TRANSDUCER_RANGES[type]) return null;
            
            const range = TRANSDUCER_RANGES[type];
            const distance = getCircuit().stimulusDistance;
            
            // Distance 0 = stimulus close (bright/hot), Distance 1 = far (dark/cold)
            // For LDR and NTC thermistor: close stimulus = lower resistance
            if (range.stimulusEffect === 'decrease') {
                return lerp(range.min, range.max, distance);
            } else {
                return lerp(range.max, range.min, distance);
            }
        }

        function calculateCircuit() {
            const top = getCircuit().topSlot;
            const bottom = getCircuit().bottomSlot;
            const output = getCircuit().outputSlot;
            const values = getCircuitValues();
            
            if (!top || !bottom) {
                return { valid: false };
            }
            
            // Get resistances
            let rTop, rBottom;
            let sensorResistance = null;
            let sensorPosition = null;
            
            if (top.category === 'input') {
                rTop = getTransducerResistance(top.type);
                sensorResistance = rTop;
                sensorPosition = 'top';
                rBottom = values.fixedResistance;
            } else if (bottom.category === 'input') {
                rTop = values.fixedResistance;
                rBottom = getTransducerResistance(bottom.type);
                sensorResistance = rBottom;
                sensorPosition = 'bottom';
            } else {
                // Both are fixed (shouldn't happen in normal use)
                rTop = values.fixedResistance;
                rBottom = values.fixedResistance;
            }
            
            const vin = values.supplyVoltage;
            const vBottom = vin * rBottom / (rTop + rBottom);
            const vTop = vin - vBottom;
            
            // Determine Vout based on output position
            let vout = null;
            if (output) {
                vout = output.position === 'bottom' ? vBottom : vTop;
            }
            
            return {
                valid: true,
                rTop,
                rBottom,
                vTop,
                vBottom,
                vout,
                sensorResistance,
                sensorPosition,
                outputPosition: output?.position,
                outputType: output?.type,
            };
        }

        // Calculate the min and max possible Vout for the current circuit configuration
        function calculateVoutRange() {
            const top = getCircuit().topSlot;
            const bottom = getCircuit().bottomSlot;
            const output = getCircuit().outputSlot;
            const values = getCircuitValues();
            
            if (!top || !bottom || !output) {
                return { min: 0, max: values.supplyVoltage };
            }
            
            // Find the transducer and its range
            let transducerType = null;
            let transducerPosition = null;
            
            if (top.category === 'input') {
                transducerType = top.type;
                transducerPosition = 'top';
            } else if (bottom.category === 'input') {
                transducerType = bottom.type;
                transducerPosition = 'bottom';
            }
            
            if (!transducerType || !TRANSDUCER_RANGES[transducerType]) {
                return { min: 0, max: values.supplyVoltage };
            }
            
            const range = TRANSDUCER_RANGES[transducerType];
            const fixedR = values.fixedResistance;
            const vin = values.supplyVoltage;
            
            // Calculate Vout at min and max transducer resistance
            let voutAtMinR, voutAtMaxR;
            
            if (transducerPosition === 'top') {
                // Transducer is R_top
                // Vout_bottom = Vin √ó R_fixed / (R_trans + R_fixed)
                // Vout_top = Vin - Vout_bottom
                const vBottomAtMinR = vin * fixedR / (range.min + fixedR);
                const vBottomAtMaxR = vin * fixedR / (range.max + fixedR);
                
                if (output.position === 'bottom') {
                    voutAtMinR = vBottomAtMinR; // High (transducer small)
                    voutAtMaxR = vBottomAtMaxR; // Low (transducer large)
                } else {
                    voutAtMinR = vin - vBottomAtMinR; // Low
                    voutAtMaxR = vin - vBottomAtMaxR; // High
                }
            } else {
                // Transducer is R_bottom
                // Vout_bottom = Vin √ó R_trans / (R_fixed + R_trans)
                const vBottomAtMinR = vin * range.min / (fixedR + range.min);
                const vBottomAtMaxR = vin * range.max / (fixedR + range.max);
                
                if (output.position === 'bottom') {
                    voutAtMinR = vBottomAtMinR; // Low (transducer small)
                    voutAtMaxR = vBottomAtMaxR; // High (transducer large)
                } else {
                    voutAtMinR = vin - vBottomAtMinR; // High
                    voutAtMaxR = vin - vBottomAtMaxR; // Low
                }
            }
            
            return {
                min: Math.min(voutAtMinR, voutAtMaxR),
                max: Math.max(voutAtMinR, voutAtMaxR)
            };
        }

        // ===========================================
        // UI UPDATE FUNCTIONS
        // ===========================================
        function updateCircuitDisplay() {
            const calc = calculateCircuit();
            const values = getCircuitValues();
            
            // Update voltage displays
            if (calc.valid) {
                dom.topVoltage.textContent = `${calc.vTop.toFixed(2)} V`;
                dom.bottomVoltage.textContent = `${calc.vBottom.toFixed(2)} V`;
                
                if (calc.sensorResistance !== null) {
                    const kOhms = calc.sensorResistance / 1000;
                    dom.sensorResistance.textContent = `${kOhms.toFixed(1)} kŒ©`;
                } else {
                    dom.sensorResistance.textContent = '‚Äî';
                }
                
                if (calc.vout !== null) {
                    dom.voutDisplay.textContent = `${calc.vout.toFixed(2)} V`;
                    updateOutputDevice(calc);
                } else {
                    dom.voutDisplay.textContent = '‚Äî V';
                    dom.outputState.textContent = '‚Äî';
                    stopBuzzer();
                }
                
                // Update formula calculation (advanced mode)
                if (state.advancedMode) {
                    const rTopK = (calc.rTop / 1000).toFixed(1);
                    const rBotK = (calc.rBottom / 1000).toFixed(1);
                    dom.formulaCalc.innerHTML = `Vout = ${values.supplyVoltage}V √ó ${rBotK}kŒ© / (${rTopK}kŒ© + ${rBotK}kŒ©) = <strong>${calc.vBottom.toFixed(2)}V</strong>`;
                }
            } else {
                dom.topVoltage.textContent = '‚Äî V';
                dom.bottomVoltage.textContent = '‚Äî V';
                dom.sensorResistance.textContent = '‚Äî';
                dom.voutDisplay.textContent = '‚Äî V';
                dom.outputState.textContent = '‚Äî';
                stopBuzzer();
            }
            
            // Update supply voltage display
            dom.supplyVoltage.textContent = `${values.supplyVoltage.toFixed(1)} V`;
            dom.fixedResistance.textContent = `${(values.fixedResistance / 1000).toFixed(1)} kŒ©`;
        }

        function updateOutputDevice(calc) {
            if (!calc.vout || !calc.outputType) {
                dom.outputState.textContent = '‚Äî';
                stopBuzzer();
                return;
            }
            
            // Calculate the actual achievable Vout range for normalization
            const voutRange = calculateVoutRange();
            const rangeSpan = voutRange.max - voutRange.min;
            
            // Normalize Vout to 0-1 based on achievable range (clamped)
            let normalizedVout = 0;
            if (rangeSpan > 0) {
                normalizedVout = (calc.vout - voutRange.min) / rangeSpan;
                normalizedVout = Math.max(0, Math.min(1, normalizedVout));
            }
            
            // Update output indicators
            const topIndicator = dom.topOutput.querySelector('.output-indicator');
            const bottomIndicator = dom.bottomOutput.querySelector('.output-indicator');
            
            switch (calc.outputType) {
                case 'led':
                    const brightness = Math.round(normalizedVout * 100);
                    dom.outputState.textContent = `${brightness}% brightness`;
                    
                    // Visual feedback on output zone
                    if (calc.outputPosition === 'top' && topIndicator) {
                        topIndicator.style.background = `rgba(63, 185, 80, ${normalizedVout})`;
                        topIndicator.classList.toggle('active', normalizedVout > 0.3);
                    } else if (calc.outputPosition === 'bottom' && bottomIndicator) {
                        bottomIndicator.style.background = `rgba(63, 185, 80, ${normalizedVout})`;
                        bottomIndicator.classList.toggle('active', normalizedVout > 0.3);
                    }
                    stopBuzzer();
                    break;
                    
                case 'buzzer':
                    const volume = Math.round(normalizedVout * 100);
                    dom.outputState.textContent = `${volume}% volume`;
                    playBuzzer(normalizedVout);
                    break;
                    
                case 'binary':
                    const isOn = calc.vout >= getCircuitValues().binaryThreshold;
                    dom.outputState.textContent = isOn ? 'ON' : 'OFF';
                    dom.outputState.style.color = isOn ? 'var(--accent-green)' : 'var(--text-muted)';
                    
                    if (calc.outputPosition === 'top' && topIndicator) {
                        topIndicator.classList.toggle('active', isOn);
                    } else if (calc.outputPosition === 'bottom' && bottomIndicator) {
                        bottomIndicator.classList.toggle('active', isOn);
                    }
                    stopBuzzer();
                    break;
            }
        }

        function updateStimulusDisplay() {
            const top = getCircuit().topSlot;
            const bottom = getCircuit().bottomSlot;
            
            // Find the input transducer
            let inputType = null;
            let sensorPosition = null;
            if (top?.category === 'input') {
                inputType = top.type;
                sensorPosition = 'top';
            } else if (bottom?.category === 'input') {
                inputType = bottom.type;
                sensorPosition = 'bottom';
            }
            
            if (!inputType) {
                dom.stimulusColumn.classList.add('hidden');
                return;
            }
            
            dom.stimulusColumn.classList.remove('hidden');
            
            // Align stimulus with sensor position
            dom.stimulusColumn.classList.remove('align-top', 'align-bottom');
            dom.stimulusColumn.classList.add(sensorPosition === 'top' ? 'align-top' : 'align-bottom');
            
            // Update stimulus source icon
            const isLight = inputType === 'ldr';
            dom.stimulusSource.innerHTML = isLight ? `
                <svg viewBox="0 0 50 50" fill="none">
                    <circle cx="25" cy="20" r="12" fill="#fbbf24" stroke="#f59e0b" stroke-width="2"/>
                    <rect x="20" y="32" width="10" height="8" fill="#9ca3af" rx="1"/>
                    <line x1="25" y1="8" x2="25" y2="2" stroke="#fbbf24" stroke-width="2"/>
                    <line x1="12" y1="12" x2="8" y2="8" stroke="#fbbf24" stroke-width="2"/>
                    <line x1="38" y1="12" x2="42" y2="8" stroke="#fbbf24" stroke-width="2"/>
                </svg>
            ` : `
                <svg viewBox="0 0 50 50" fill="none">
                    <ellipse cx="25" cy="35" rx="15" ry="8" fill="#ef4444" opacity="0.3"/>
                    <path d="M15 30 Q25 10 35 30" stroke="#ef4444" stroke-width="3" fill="none"/>
                    <path d="M18 28 Q25 15 32 28" stroke="#f97316" stroke-width="2" fill="none"/>
                    <path d="M21 26 Q25 18 29 26" stroke="#fbbf24" stroke-width="2" fill="none"/>
                </svg>
            `;
            dom.stimulusSource.classList.toggle('heat', !isLight);
            
            // Update target icon
            dom.stimulusTarget.innerHTML = inputType === 'ldr' ? `
                <svg viewBox="0 0 40 40" fill="none" stroke="#d29922" stroke-width="2">
                    <rect x="8" y="12" width="24" height="16" rx="2" fill="none"/>
                    <path d="M2 8 L6 12 M6 8 L2 12"/>
                </svg>
            ` : `
                <svg viewBox="0 0 40 40" fill="none" stroke="#f85149" stroke-width="2">
                    <rect x="8" y="12" width="24" height="16" rx="2" fill="none"/>
                    <text x="20" y="24" font-size="10" fill="#f85149" text-anchor="middle">-t¬∞</text>
                </svg>
            `;
            
            // Update distance label
            const distance = getCircuit().stimulusDistance;
            let distanceText = 'Far';
            if (distance < 0.33) distanceText = 'Close';
            else if (distance < 0.66) distanceText = 'Medium';
            
            const stimulusType = isLight ? 'Light' : 'Heat';
            dom.distanceLabel.textContent = `${stimulusType}: ${distanceText}`;
        }

        function updateComponentTray() {
            const components = dom.componentTray.querySelectorAll('.component-item');
            
            components.forEach(comp => {
                const type = comp.dataset.type;
                const category = comp.dataset.category;
                
                let inUse = false;
                
                if (category === 'input' || category === 'resistor') {
                    inUse = (getCircuit().topSlot?.type === type) || 
                            (getCircuit().bottomSlot?.type === type);
                } else if (category === 'output') {
                    inUse = getCircuit().outputSlot?.type === type;
                }
                
                comp.classList.toggle('in-use', inUse);
            });
        }

        function renderSlot(slotEl, slotData, position) {
            // Clear existing content except label
            const label = slotEl.querySelector('.slot-label');
            const voltageDisplay = slotEl.querySelector('.slot-voltage');
            const outputZone = slotEl.querySelector('.output-zone');
            
            slotEl.innerHTML = '';
            slotEl.appendChild(label);
            
            if (slotData) {
                slotEl.classList.add('filled');
                
                const placed = document.createElement('div');
                placed.className = 'placed-component';
                
                const icon = document.createElement('div');
                icon.className = 'component-icon';
                icon.innerHTML = getComponentIcon(slotData.type);
                
                const info = document.createElement('div');
                info.className = 'component-info';
                info.innerHTML = `
                    <div class="name">${getComponentName(slotData.type)}</div>
                    <div class="value" id="${position}Value"></div>
                `;
                
                placed.appendChild(icon);
                placed.appendChild(info);
                slotEl.appendChild(placed);
                
                // Add clear button
                const clearBtn = document.createElement('button');
                clearBtn.className = 'clear-slot';
                clearBtn.innerHTML = '√ó';
                clearBtn.onclick = (e) => {
                    e.stopPropagation();
                    clearSlot(position);
                };
                slotEl.appendChild(clearBtn);
            } else {
                slotEl.classList.remove('filled');
                const placeholder = document.createElement('span');
                placeholder.style.cssText = 'color: var(--text-muted); font-size: 12px;';
                placeholder.textContent = 'Drop component here';
                slotEl.appendChild(placeholder);
            }
            
            slotEl.appendChild(voltageDisplay);
            slotEl.appendChild(outputZone);
            
            // Re-render output zone
            renderOutputZone(position);
        }

        function renderOutputZone(position) {
            const outputZone = position === 'top' ? dom.topOutput : dom.bottomOutput;
            const outputData = getCircuit().outputSlot;
            
            outputZone.innerHTML = '';
            
            if (outputData && outputData.position === position) {
                outputZone.classList.add('filled');
                
                const placed = document.createElement('div');
                placed.className = 'placed-output';
                
                const indicator = document.createElement('div');
                indicator.className = 'output-indicator';
                
                const icon = document.createElement('div');
                icon.className = 'component-icon';
                icon.innerHTML = getComponentIcon(outputData.type);
                
                const name = document.createElement('span');
                name.className = 'name';
                name.textContent = getComponentName(outputData.type);
                
                placed.appendChild(icon);
                placed.appendChild(name);
                outputZone.appendChild(indicator);
                outputZone.appendChild(placed);
                
                // Add clear button
                const clearBtn = document.createElement('button');
                clearBtn.className = 'clear-slot';
                clearBtn.innerHTML = '√ó';
                clearBtn.onclick = (e) => {
                    e.stopPropagation();
                    clearOutputSlot();
                };
                outputZone.appendChild(clearBtn);
            } else {
                outputZone.classList.remove('filled');
                outputZone.textContent = 'Output';
            }
        }

        function getComponentIcon(type) {
            const icons = {
                ldr: `<svg viewBox="0 0 40 40" fill="none" stroke="#d29922" stroke-width="2">
                    <rect x="8" y="12" width="24" height="16" rx="2" fill="none"/>
                    <line x1="4" y1="20" x2="8" y2="20"/>
                    <line x1="32" y1="20" x2="36" y2="20"/>
                    <path d="M2 8 L6 12 M6 8 L2 12"/>
                </svg>`,
                thermistor: `<svg viewBox="0 0 40 40" fill="none" stroke="#f85149" stroke-width="2">
                    <rect x="8" y="12" width="24" height="16" rx="2" fill="none"/>
                    <line x1="4" y1="20" x2="8" y2="20"/>
                    <line x1="32" y1="20" x2="36" y2="20"/>
                    <text x="20" y="24" font-size="10" fill="#f85149" text-anchor="middle">-t¬∞</text>
                </svg>`,
                fixed: `<svg viewBox="0 0 40 40" fill="none" stroke="#4a90d9" stroke-width="2">
                    <rect x="8" y="14" width="24" height="12" rx="1" fill="none"/>
                    <line x1="4" y1="20" x2="8" y2="20"/>
                    <line x1="32" y1="20" x2="36" y2="20"/>
                </svg>`,
                led: `<svg viewBox="0 0 40 40" fill="none" stroke="#3fb950" stroke-width="2">
                    <polygon points="12,12 28,20 12,28" fill="none"/>
                    <line x1="28" y1="12" x2="28" y2="28"/>
                    <path d="M30 10 L34 6 M32 14 L36 10"/>
                </svg>`,
                buzzer: `<svg viewBox="0 0 40 40" fill="none" stroke="#a371f7" stroke-width="2">
                    <circle cx="20" cy="20" r="10" fill="none"/>
                    <circle cx="20" cy="20" r="4" fill="none"/>
                </svg>`,
                binary: `<svg viewBox="0 0 40 40" fill="none" stroke="#f0883e" stroke-width="2">
                    <rect x="10" y="10" width="20" height="20" rx="3" fill="none"/>
                    <circle cx="20" cy="20" r="5" fill="#f0883e"/>
                </svg>`,
            };
            return icons[type] || '';
        }

        function getComponentName(type) {
            const names = {
                ldr: 'LDR',
                thermistor: 'Thermistor',
                fixed: 'Fixed R',
                led: 'LED',
                buzzer: 'Buzzer',
                binary: 'Switch',
            };
            return names[type] || type;
        }

        function clearSlot(position) {
            if (position === 'top') {
                getCircuit().topSlot = null;
            } else {
                getCircuit().bottomSlot = null;
            }
            
            // Also clear output if it was connected to this slot
            if (getCircuit().outputSlot?.position === position) {
                getCircuit().outputSlot = null;
            }
            
            updateAll();
            saveState();
        }

        function clearOutputSlot() {
            getCircuit().outputSlot = null;
            stopBuzzer();
            updateAll();
            saveState();
        }

        function updateAll() {
            renderSlot(dom.topSlot, getCircuit().topSlot, 'top');
            renderSlot(dom.bottomSlot, getCircuit().bottomSlot, 'bottom');
            updateComponentTray();
            updateStimulusDisplay();
            updateCircuitDisplay();
            syncStimulusPosition(); // Sync visual position with state
        }

        // ===========================================
        // DRAG AND DROP
        // ===========================================
        let draggedComponent = null;
        let draggedChip = null;

        function initDragDrop() {
            // Component items
            const components = dom.componentTray.querySelectorAll('.component-item');
            
            components.forEach(comp => {
                comp.addEventListener('dragstart', handleDragStart);
                comp.addEventListener('dragend', handleDragEnd);
                
                // Touch support
                comp.addEventListener('touchstart', handleTouchStart, { passive: false });
                comp.addEventListener('touchmove', handleTouchMove, { passive: false });
                comp.addEventListener('touchend', handleTouchEnd);
            });
            
            // Drop zones
            [dom.topSlot, dom.bottomSlot].forEach(slot => {
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('dragleave', handleDragLeave);
                slot.addEventListener('drop', handleDrop);
            });
            
            [dom.topOutput, dom.bottomOutput].forEach(zone => {
                zone.addEventListener('dragover', handleDragOver);
                zone.addEventListener('dragleave', handleDragLeave);
                zone.addEventListener('drop', handleOutputDrop);
            });
        }

        function handleDragStart(e) {
            draggedComponent = {
                type: e.target.dataset.type,
                category: e.target.dataset.category,
            };
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedComponent = null;
            
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (!draggedComponent) return;
            
            const position = e.currentTarget.dataset.position;
            const category = draggedComponent.category;
            
            // Only allow input or resistor components in main slots
            if (category !== 'input' && category !== 'resistor') {
                toast('Drop output devices on the Output zones', 'error');
                return;
            }
            
            // Check if we're replacing something
            const otherPosition = position === 'top' ? 'bottom' : 'top';
            const circuit = getCircuit();
            const otherSlot = circuit[`${otherPosition}Slot`];
            
            // Prevent same type in both slots
            if (otherSlot?.type === draggedComponent.type) {
                toast('This component is already placed', 'error');
                return;
            }
            
            circuit[`${position}Slot`] = {
                type: draggedComponent.type,
                category: draggedComponent.category,
            };
            
            updateAll();
            saveState();
            toast(`${getComponentName(draggedComponent.type)} placed in ${position} slot`);
        }

        function handleOutputDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (!draggedComponent) return;
            
            if (draggedComponent.category !== 'output') {
                toast('Only output devices can be dropped here', 'error');
                return;
            }
            
            const position = e.currentTarget.dataset.position;
            
            // Check if there's a component in this slot to measure
            const circuit = getCircuit();
            const slotData = circuit[`${position}Slot`];
            if (!slotData) {
                toast('Place a component in this slot first', 'error');
                return;
            }
            
            circuit.outputSlot = {
                position,
                type: draggedComponent.type,
            };
            
            updateAll();
            saveState();
            toast(`${getComponentName(draggedComponent.type)} connected across ${position}`);
        }

        // Touch drag support
        let touchClone = null;
        let touchStartX, touchStartY;

        function handleTouchStart(e) {
            if (e.target.closest('.component-item').classList.contains('in-use')) return;
            
            const touch = e.touches[0];
            const comp = e.target.closest('.component-item');
            
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            
            draggedComponent = {
                type: comp.dataset.type,
                category: comp.dataset.category,
            };
            
            // Create visual clone
            touchClone = comp.cloneNode(true);
            touchClone.style.cssText = `
                position: fixed;
                left: ${touch.clientX - 40}px;
                top: ${touch.clientY - 40}px;
                width: 80px;
                opacity: 0.8;
                pointer-events: none;
                z-index: 1000;
                transform: scale(1.1);
            `;
            document.body.appendChild(touchClone);
            
            comp.classList.add('dragging');
        }

        function handleTouchMove(e) {
            if (!touchClone) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            touchClone.style.left = `${touch.clientX - 40}px`;
            touchClone.style.top = `${touch.clientY - 40}px`;
            
            // Highlight drop zones
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            
            const dropZone = elemBelow?.closest('.circuit-slot, .output-zone');
            if (dropZone) {
                dropZone.classList.add('drag-over');
            }
        }

        function handleTouchEnd(e) {
            if (!touchClone) return;
            
            const touch = e.changedTouches[0];
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            
            const circuitSlot = elemBelow?.closest('.circuit-slot');
            const outputZone = elemBelow?.closest('.output-zone');
            
            if (circuitSlot) {
                handleDrop({ 
                    preventDefault: () => {}, 
                    currentTarget: circuitSlot 
                });
            } else if (outputZone) {
                handleOutputDrop({ 
                    preventDefault: () => {}, 
                    currentTarget: outputZone 
                });
            }
            
            // Cleanup
            touchClone.remove();
            touchClone = null;
            draggedComponent = null;
            
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        // ===========================================
        // STIMULUS DRAGGING (horizontal)
        // ===========================================
        function initStimulusDrag() {
            const track = dom.stimulusTrack;
            const source = dom.stimulusSource;
            
            let isDragging = false;
            
            function updatePosition(clientX) {
                const rect = track.getBoundingClientRect();
                const minX = 0;
                const maxX = rect.width - 90; // Account for source and target size
                
                let x = clientX - rect.left - 22;
                x = clamp(x, minX, maxX);
                
                source.style.left = `${x}px`;
                
                // Calculate distance (0 = close to target at right, 1 = far away at left)
                getCircuit().stimulusDistance = 1 - (x / maxX);
                getCircuit().stimulusDistance = clamp(getCircuit().stimulusDistance, 0, 1);
                
                updateCircuitDisplay();
                updateStimulusDisplay();
            }
            
            // Mouse events
            source.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    updatePosition(e.clientX);
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Touch events
            source.addEventListener('touchstart', (e) => {
                isDragging = true;
                e.preventDefault();
            }, { passive: false });
            
            source.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    updatePosition(e.touches[0].clientX);
                }
                e.preventDefault();
            }, { passive: false });
            
            source.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            // Initialize position (far left = far from sensor)
            source.style.left = '0px';
        }

        // Sync visual position with state (used when state changes programmatically)
        function syncStimulusPosition() {
            const track = dom.stimulusTrack;
            const source = dom.stimulusSource;
            
            if (!track || !source) return;
            
            const distance = getCircuit().stimulusDistance;
            
            // distance: 0 = close (right), 1 = far (left)
            // Calculate left position from distance
            const rect = track.getBoundingClientRect();
            if (rect.width === 0) return; // Track not yet rendered
            
            const maxX = rect.width - 90;
            const x = (1 - distance) * maxX;
            
            source.style.left = `${x}px`;
        }

        // ===========================================
        // MODE SWITCHING
        // ===========================================
        function initModes() {
            dom.modeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    setMode(mode);
                });
            });
            
            dom.advancedToggle.addEventListener('click', () => {
                state.advancedMode = !state.advancedMode;
                updateAdvancedMode();
                saveState();
            });
        }

        function setMode(mode) {
            state.mode = mode;
            
            dom.modeBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            
            // Circuit area stays visible in both modes
            dom.freeMode.classList.remove('hidden');
            
            // Show/hide predict floating panel
            dom.predictMode.classList.toggle('visible', mode === 'predict');
            
            // Hide component tray in predict mode (circuit is pre-populated)
            dom.componentTray.classList.toggle('hidden', mode === 'predict');
            
            // Hide readings panel and advanced controls in predict mode
            dom.readingsPanel.classList.toggle('hidden', mode === 'predict');
            dom.formulaDisplay.classList.toggle('hidden', mode === 'predict');
            dom.advancedControls.classList.toggle('hidden', mode === 'predict');
            dom.advancedNote.classList.toggle('hidden', mode === 'predict');
            
            if (mode === 'predict') {
                stopBuzzer();
                generateScenario();
            } else {
                // Refresh the circuit display with free mode state
                updateAll();
            }
            
            saveState();
        }

        function updateAdvancedMode() {
            dom.advancedToggle.classList.toggle('active', state.advancedMode);
            dom.formulaDisplay.classList.toggle('visible', state.advancedMode);
            dom.advancedControls.classList.toggle('visible', state.advancedMode);
            dom.advancedNote.classList.toggle('visible', state.advancedMode);
            
            updateCircuitDisplay();
        }

        // ===========================================
        // ADVANCED CONTROLS
        // ===========================================
        function initAdvancedControls() {
            dom.inputVoltage.addEventListener('change', () => {
                state.circuitValues.supplyVoltage = parseFloat(dom.inputVoltage.value) || 12;
                state.circuitValues.supplyVoltage = clamp(state.circuitValues.supplyVoltage, 1, 24);
                updateCircuitDisplay();
                saveState();
            });
            
            dom.inputFixedR.addEventListener('change', () => {
                state.circuitValues.fixedResistance = (parseFloat(dom.inputFixedR.value) || 10) * 1000;
                state.circuitValues.fixedResistance = clamp(state.circuitValues.fixedResistance, 1000, 100000);
                updateCircuitDisplay();
                saveState();
            });
            
            dom.inputThreshold.addEventListener('change', () => {
                state.circuitValues.binaryThreshold = parseFloat(dom.inputThreshold.value) || 6;
                state.circuitValues.binaryThreshold = clamp(state.circuitValues.binaryThreshold, 0.5, state.circuitValues.supplyVoltage);
                updateCircuitDisplay();
                saveState();
            });
        }

        // ===========================================
        // PREDICT MODE
        // ===========================================
        const LOGIC_TEMPLATES = {
            simple: {
                setup: {
                    inputType: 'ldr',
                    inputPosition: 'bottom',
                    outputType: 'led',
                    stimulusChange: 'increases',
                },
                chips: [
                    'Light on LDR {stimulus}',
                    'Resistance of LDR {rChange}',
                    'Voltage over LDR {vSensorChange}',
                    'Voltage over Fixed R {vFixedChange}',
                    'Vout (over {voutOver}) {voutChange}',
                    'LED {outputAction}',
                ],
            },
            medium: {
                randomize: ['inputType', 'inputPosition'],
                chips: [
                    '{stimulus} on {inputName} {stimulusDirection}',
                    'Resistance of {inputName} {rChange}',
                    'Voltage over {inputName} {vSensorChange}',
                    'Voltage over Fixed R {vFixedChange}',
                    'Vout (over {voutOver}) {voutChange}',
                    '{outputName} {outputAction}',
                ],
            },
            complex: {
                randomize: ['inputType', 'inputPosition', 'outputType', 'outputPosition'],
                chips: [
                    '{stimulus} on {inputName} {stimulusDirection}',
                    'Resistance of {inputName} {rChange}',
                    'Voltage over {inputName} {vSensorChange}',
                    'Voltage over Fixed R {vFixedChange}',
                    'Vout (over {voutOver}) {voutChange}',
                    '{outputName} {outputAction}',
                ],
            },
        };

        function generateScenario() {
            const difficulty = state.predict.difficulty;
            
            // Generate random scenario parameters
            const scenario = {
                inputType: 'ldr',
                inputPosition: 'bottom',
                outputType: 'led',
                outputPosition: 'bottom', // Vout is across this component
                stimulusChange: Math.random() > 0.5 ? 'increases' : 'decreases',
            };
            
            if (difficulty === 'medium' || difficulty === 'complex') {
                scenario.inputType = Math.random() > 0.5 ? 'ldr' : 'thermistor';
                scenario.inputPosition = Math.random() > 0.5 ? 'top' : 'bottom';
            }
            
            if (difficulty === 'complex') {
                scenario.outputType = ['led', 'buzzer', 'binary'][Math.floor(Math.random() * 3)];
                scenario.outputPosition = Math.random() > 0.5 ? 'top' : 'bottom';
            }
            
            // Populate the predict circuit with the scenario
            const inputSlot = { type: scenario.inputType, category: 'input' };
            const fixedSlot = { type: 'fixed', category: 'resistor' };
            
            if (scenario.inputPosition === 'top') {
                state.predictCircuit.topSlot = inputSlot;
                state.predictCircuit.bottomSlot = fixedSlot;
            } else {
                state.predictCircuit.topSlot = fixedSlot;
                state.predictCircuit.bottomSlot = inputSlot;
            }
            
            state.predictCircuit.outputSlot = {
                position: scenario.outputPosition,
                type: scenario.outputType,
            };
            
            // Set stimulus position to match the question:
            // If asking "what happens when stimulus increases?" -> start far (low stimulus), move closer to increase
            // If asking "what happens when stimulus decreases?" -> start close (high stimulus), move farther to decrease
            if (scenario.stimulusChange === 'increases') {
                state.predictCircuit.stimulusDistance = 1; // Far = low light/heat, ready to increase
            } else {
                state.predictCircuit.stimulusDistance = 0; // Close = high light/heat, ready to decrease
            }
            
            // Calculate the logic chain
            const inputName = scenario.inputType === 'ldr' ? 'LDR' : 'Thermistor';
            const outputName = getComponentName(scenario.outputType);
            const stimulus = scenario.inputType === 'ldr' ? 'Light' : 'Heat';
            
            // Both LDR and NTC thermistor: stimulus increases -> R decreases
            const rChange = scenario.stimulusChange === 'increases' ? 'decreases' : 'increases';
            
            // Voltage over sensor follows resistance (Ohm's law in divider context)
            const vSensorChange = rChange; // If R decreases, V across it decreases
            
            // Voltage over fixed R is opposite
            const vFixedChange = vSensorChange === 'decreases' ? 'increases' : 'decreases';
            
            // Determine which component Vout is across
            const voutOverComponent = scenario.outputPosition === scenario.inputPosition ? inputName : 'Fixed R';
            
            // Vout change depends on which component it's across
            let voutChange;
            if (scenario.outputPosition === scenario.inputPosition) {
                // Vout is across the input sensor
                voutChange = vSensorChange;
            } else {
                // Vout is across the fixed resistor
                voutChange = vFixedChange;
            }
            
            // Output action - specific to output type
            let outputAction;
            if (scenario.outputType === 'binary') {
                outputAction = voutChange === 'increases' ? 'switches ON' : 'switches OFF';
            } else if (scenario.outputType === 'led') {
                outputAction = voutChange === 'increases' ? 'gets brighter' : 'gets dimmer';
            } else {
                outputAction = voutChange === 'increases' ? 'gets louder' : 'gets quieter';
            }
            
            // Build correct order - 5 steps with specific names
            const correctOrder = [
                `${stimulus} on ${inputName} ${scenario.stimulusChange}`,
                `${inputName} resistance ${rChange}`,
                `Voltage over ${inputName} ${vSensorChange}`,
                `Vout (over ${voutOverComponent}) ${voutChange}`,
                `${outputName} ${outputAction}`,
            ];
            
            state.predict.scenario = scenario;
            state.predict.correctOrder = correctOrder;
            state.predict.userOrder = [];
            
            // Update the circuit display with the new scenario
            updateAll();
            
            renderScenario();
        }

        function renderScenario() {
            const scenario = state.predict.scenario;
            const correctOrder = state.predict.correctOrder;
            
            // Setup display - just show the stimulus action hint
            const inputName = scenario.inputType === 'ldr' ? 'LDR' : 'Thermistor';
            const stimulus = scenario.inputType === 'ldr' ? 'Light' : 'Heat';
            const dragDirection = scenario.stimulusChange === 'increases' ? 'right (closer)' : 'left (farther)';
            
            dom.stimulusHint.innerHTML = `
                <strong>Question:</strong> What happens when <strong>${stimulus} ${scenario.stimulusChange}</strong>?
                <br><small>Drag stimulus ${dragDirection} to test. Arrange the logic steps below.</small>
            `;
            
            // Fisher-Yates shuffle for proper randomization
            const shuffled = [...correctOrder];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            dom.chipPool.innerHTML = '';
            shuffled.forEach((text, idx) => {
                const chip = createChip(text, idx);
                dom.chipPool.appendChild(chip);
            });
            
            dom.answerZone.innerHTML = '';
            dom.predictResult.classList.remove('visible');
            
            // Reset chip states
            document.querySelectorAll('.logic-chip').forEach(c => {
                c.classList.remove('correct', 'incorrect');
            });
        }

        function createChip(text, id) {
            const chip = document.createElement('div');
            chip.className = 'logic-chip';
            chip.textContent = text;
            chip.dataset.id = id;
            chip.draggable = true;
            
            chip.addEventListener('dragstart', (e) => {
                draggedChip = chip;
                chip.classList.add('dragging');
                // Set drag image to just this chip
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', text);
            });
            
            chip.addEventListener('dragend', () => {
                chip.classList.remove('dragging');
                draggedChip = null;
                // Remove any drop indicators
                document.querySelectorAll('.logic-chip.drop-above, .logic-chip.drop-below').forEach(c => {
                    c.classList.remove('drop-above', 'drop-below');
                });
            });
            
            // Dragover on chips for reordering within answer zone
            chip.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (!draggedChip || draggedChip === chip) return;
                if (chip.parentElement !== dom.answerZone) return;
                
                const rect = chip.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                
                // Remove previous indicators
                document.querySelectorAll('.logic-chip.drop-above, .logic-chip.drop-below').forEach(c => {
                    c.classList.remove('drop-above', 'drop-below');
                });
                
                if (e.clientY < midY) {
                    chip.classList.add('drop-above');
                } else {
                    chip.classList.add('drop-below');
                }
            });
            
            chip.addEventListener('dragleave', () => {
                chip.classList.remove('drop-above', 'drop-below');
            });
            
            chip.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!draggedChip || draggedChip === chip) return;
                
                const rect = chip.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                
                if (e.clientY < midY) {
                    chip.parentElement.insertBefore(draggedChip, chip);
                } else {
                    chip.parentElement.insertBefore(draggedChip, chip.nextSibling);
                }
                
                chip.classList.remove('drop-above', 'drop-below');
            });
            
            // Touch support for chips
            chip.addEventListener('touchstart', handleChipTouchStart, { passive: false });
            chip.addEventListener('touchmove', handleChipTouchMove, { passive: false });
            chip.addEventListener('touchend', handleChipTouchEnd);
            
            // Click to toggle between zones
            chip.addEventListener('click', () => {
                const inAnswer = chip.parentElement === dom.answerZone;
                if (inAnswer) {
                    dom.chipPool.appendChild(chip);
                } else {
                    dom.answerZone.appendChild(chip);
                }
            });
            
            return chip;
        }

        let chipTouchClone = null;

        function handleChipTouchStart(e) {
            const chip = e.target.closest('.logic-chip');
            if (!chip) return;
            
            draggedChip = chip;
            
            const touch = e.touches[0];
            chipTouchClone = chip.cloneNode(true);
            chipTouchClone.style.cssText = `
                position: fixed;
                left: ${touch.clientX - 50}px;
                top: ${touch.clientY - 20}px;
                opacity: 0.8;
                pointer-events: none;
                z-index: 1000;
            `;
            document.body.appendChild(chipTouchClone);
            
            chip.classList.add('dragging');
            e.preventDefault();
        }

        function handleChipTouchMove(e) {
            if (!chipTouchClone) return;
            
            const touch = e.touches[0];
            chipTouchClone.style.left = `${touch.clientX - 50}px`;
            chipTouchClone.style.top = `${touch.clientY - 20}px`;
            
            e.preventDefault();
        }

        function handleChipTouchEnd(e) {
            if (!chipTouchClone || !draggedChip) return;
            
            const touch = e.changedTouches[0];
            chipTouchClone.style.display = 'none'; // Hide clone to get element below
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            chipTouchClone.style.display = '';
            
            const answerZone = elemBelow?.closest('#answerZone');
            const chipPool = elemBelow?.closest('#chipPool');
            const targetChip = elemBelow?.closest('.logic-chip');
            
            // If dropping on another chip in answer zone, insert relative to it
            if (targetChip && targetChip !== draggedChip && targetChip.parentElement === dom.answerZone) {
                const rect = targetChip.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                
                if (touch.clientY < midY) {
                    dom.answerZone.insertBefore(draggedChip, targetChip);
                } else {
                    dom.answerZone.insertBefore(draggedChip, targetChip.nextSibling);
                }
            } else if (answerZone && draggedChip.parentElement !== answerZone) {
                dom.answerZone.appendChild(draggedChip);
            } else if (chipPool && draggedChip.parentElement !== chipPool) {
                dom.chipPool.appendChild(draggedChip);
            }
            
            chipTouchClone.remove();
            chipTouchClone = null;
            draggedChip.classList.remove('dragging');
            draggedChip = null;
        }

        // Drop zones for chips
        function initChipDropZones() {
            [dom.answerZone, dom.chipPool].forEach(zone => {
                zone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    // Only handle if not dropped on a chip (chip handler uses stopPropagation)
                    if (draggedChip) {
                        zone.appendChild(draggedChip);
                    }
                });
            });
        }

        function checkPrediction() {
            const userChips = [...dom.answerZone.querySelectorAll('.logic-chip')];
            const userOrder = userChips.map(c => c.textContent);
            const correctOrder = state.predict.correctOrder;
            
            if (userOrder.length !== correctOrder.length) {
                dom.predictResult.textContent = `Place all ${correctOrder.length} chips in order!`;
                dom.predictResult.className = 'predict-result visible error';
                return;
            }
            
            let allCorrect = true;
            userChips.forEach((chip, idx) => {
                const isCorrect = chip.textContent === correctOrder[idx];
                chip.classList.toggle('correct', isCorrect);
                chip.classList.toggle('incorrect', !isCorrect);
                if (!isCorrect) allCorrect = false;
            });
            
            if (allCorrect) {
                dom.predictResult.textContent = 'üéâ Perfect! You understand the logic chain!';
                dom.predictResult.className = 'predict-result visible success';
            } else {
                dom.predictResult.textContent = '‚ùå Some chips are in the wrong position. Try again!';
                dom.predictResult.className = 'predict-result visible error';
            }
        }

        function initPredictMode() {
            dom.difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    dom.difficultyBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.predict.difficulty = btn.dataset.level;
                    generateScenario();
                });
            });
            
            dom.checkAnswer.addEventListener('click', checkPrediction);
            dom.newScenario.addEventListener('click', generateScenario);
            dom.resetChips.addEventListener('click', renderScenario);
            
            initChipDropZones();
        }

        // ===========================================
        // PERSISTENCE
        // ===========================================
        function saveState() {
            const saveData = {
                mode: state.mode,
                advancedMode: state.advancedMode,
                circuitValues: state.circuitValues,
                freeCircuit: state.freeCircuit,
                predictCircuit: state.predictCircuit,
                predict: {
                    difficulty: state.predict.difficulty,
                },
            };
            
            try {
                localStorage.setItem('voltageDividerLab', JSON.stringify(saveData));
            } catch (e) {
                console.warn('Could not save state:', e);
            }
        }

        function loadState() {
            try {
                const saved = localStorage.getItem('voltageDividerLab');
                if (saved) {
                    const data = JSON.parse(saved);
                    
                    state.mode = data.mode || 'free';
                    state.advancedMode = data.advancedMode || false;
                    
                    if (data.circuitValues) {
                        Object.assign(state.circuitValues, data.circuitValues);
                    }
                    
                    if (data.freeCircuit) {
                        Object.assign(state.freeCircuit, data.freeCircuit);
                    }
                    
                    if (data.predictCircuit) {
                        Object.assign(state.predictCircuit, data.predictCircuit);
                    }
                    
                    if (data.predict) {
                        state.predict.difficulty = data.predict.difficulty || 'simple';
                    }
                    
                    // Update UI with circuit values
                    dom.inputVoltage.value = state.circuitValues.supplyVoltage;
                    dom.inputFixedR.value = state.circuitValues.fixedResistance / 1000;
                    dom.inputThreshold.value = state.circuitValues.binaryThreshold;
                    
                    // Set difficulty button
                    dom.difficultyBtns.forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.level === state.predict.difficulty);
                    });
                }
            } catch (e) {
                console.warn('Could not load state:', e);
            }
        }

        // ===========================================
        // KEYBOARD SHORTCUTS
        // ===========================================
        function initKeyboard() {
            document.addEventListener('keydown', (e) => {
                // Escape to clear selection / close panels
                if (e.key === 'Escape') {
                    stopBuzzer();
                }
                
                // 1/2 for mode switching
                if (e.key === '1') setMode('free');
                if (e.key === '2') setMode('predict');
                
                // A for advanced toggle
                if (e.key === 'a' || e.key === 'A') {
                    if (!e.target.matches('input')) {
                        state.advancedMode = !state.advancedMode;
                        updateAdvancedMode();
                        saveState();
                    }
                }
            });
        }

        // ===========================================
        // EASTER EGG: Konami Code
        // ===========================================
        // EASTER EGG: Enter the Konami code to unlock a rainbow mode
        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        let konamiIndex = 0;

        document.addEventListener('keydown', (e) => {
            if (e.key === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    activateRainbowMode();
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });

        function activateRainbowMode() {
            toast('üåà Rainbow Mode Activated!', 'success');
            document.body.style.animation = 'rainbow 2s linear infinite';
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes rainbow {
                    0% { filter: hue-rotate(0deg); }
                    100% { filter: hue-rotate(360deg); }
                }
            `;
            document.head.appendChild(style);
            
            setTimeout(() => {
                document.body.style.animation = '';
                style.remove();
            }, 10000);
        }

        // ===========================================
        // INITIALIZATION
        // ===========================================
        function init() {
            loadState();
            initDragDrop();
            initStimulusDrag();
            initModes();
            initAdvancedControls();
            initPredictMode();
            initKeyboard();
            
            // Set initial mode
            setMode(state.mode);
            updateAdvancedMode();
            updateAll();
            
            // Save on page unload
            window.addEventListener('beforeunload', saveState);
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    saveState();
                    stopBuzzer();
                }
            });
        }

        // Start the app
        init();
    </script>
</body>
</html>