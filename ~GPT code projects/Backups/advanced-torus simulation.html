<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 3D Torus Electron Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        #canvas-container { width: 800px; height: 600px; }
        canvas { display: block; }
        #controls { margin-top: 20px; }
        .slider { width: 500px; }
        .checkbox-group { margin-top: 10px; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="controls">
        <label for="electronSlider">Number of Electrons: </label>
        <input type="range" id="electronSlider" class="slider" min="0" max="500" value="50">
        <span id="electronCount">50</span>
        <br><br>
        <label for="brownianSlider">Brownian Motion Strength: </label>
        <input type="range" id="brownianSlider" class="slider" min="0" max="100" value="10">
        <span id="brownianStrength">0.01</span>
        <br><br>
        <label for="dampingSlider">Electron Damping: </label>
        <input type="range" id="dampingSlider" class="slider" min="0" max="100" value="95">
        <span id="dampingValue">0.95</span>
        <br><br>
        <label for="frequencySlider">Electron Source Frequency (/sec): </label>
        <input type="range" id="frequencySlider" class="slider" min="0" max="100" value="10">
        <span id="frequencyValue">1</span>
        <br><br>
        <label for="elongationSlider">Torus Elongation: </label>
        <input type="range" id="elongationSlider" class="slider" min="50" max="200" value="100">
        <span id="elongationValue">100</span>
        <br><br>
        <label for="girth0Slider">Girth at 0°: </label>
        <input type="range" id="girth0Slider" class="slider" min="10" max="100" value="40">
        <span id="girth0Value">40</span>
        <br><br>
        <label for="girth90Slider">Girth at 90°: </label>
        <input type="range" id="girth90Slider" class="slider" min="10" max="100" value="40">
        <span id="girth90Value">40</span>
        <br><br>
        <label for="girth180Slider">Girth at 180°: </label>
        <input type="range" id="girth180Slider" class="slider" min="10" max="100" value="40">
        <span id="girth180Value">40</span>
        <br><br>
        <label for="girth270Slider">Girth at 270°: </label>
        <input type="range" id="girth270Slider" class="slider" min="10" max="100" value="40">
        <span id="girth270Value">40</span>
        <br><br>
        <div class="checkbox-group">
            <label><input type="checkbox" id="rotateXCheck"> Rotate X</label>
            <label><input type="checkbox" id="rotateYCheck"> Rotate Y</label>
            <label><input type="checkbox" id="rotateZCheck"> Rotate Z</label>
            <label><input type="checkbox" id="sourceActive" checked> Electron Source</label>
            <label><input type="checkbox" id="sinkActive"> Electron Sink</label>
        </div>
    </div>

    <script>
        let electrons = [];
        let brownianStrength = 0.01;
        let damping = 0.95;
        let sourceFrequency = 1;
        const COULOMB_CONSTANT = 5000;
        let TORUS_RADIUS = 100;
        let TUBE_RADIUS = [40, 40, 40, 40]; // Girth at 0°, 90°, 180°, 270°
        const ELECTRON_SPEED = 0.02;
        const SINK_ATTRACTION = 5000;
        const MAX_FORCE = 1000; // Maximum force cap
        const MIN_DISTANCE = 1; // Minimum distance for force calculation
        let autoRotationX = 0, autoRotationY = 0, autoRotationZ = 0;
        let userRotationX = 0;
        let userRotationY = 0;
        let dragStartX, dragStartY;
        let lastSourceTime = 0;
        let electronSource, electronSink;
        let canvas;

        const RESISTIVE_RING_WIDTH = 0.1;

        function setup() {
            canvas = createCanvas(800, 600, WEBGL);
            canvas.parent('canvas-container');
            updateElectronCount();
            electronSource = new ElectronSource(0, PI/4);
            electronSink = new ElectronSink(PI, PI);
        }

        function draw() {
            background(220);
            
            camera(0, 0, 400);
            ambientLight(100);
            pointLight(255, 255, 255, 0, 0, 400);

            rotateX(userRotationY + autoRotationX);
            rotateY(userRotationX + autoRotationY);
            rotateZ(autoRotationZ);

            if (document.getElementById('rotateXCheck').checked) autoRotationX += 0.005;
            if (document.getElementById('rotateYCheck').checked) autoRotationY += 0.005;
            if (document.getElementById('rotateZCheck').checked) autoRotationZ += 0.005;

            drawDistortedTorus();

            drawResistiveRing();

            if (document.getElementById('sourceActive').checked) {
                electronSource.display();
                if (millis() - lastSourceTime > 1000 / sourceFrequency && electrons.length < 500) {
                    electrons.push(new Electron(electronSource.theta, electronSource.phi));
                    lastSourceTime = millis();
                }
            }

            if (document.getElementById('sinkActive').checked) {
                electronSink.display();
            }

            fill(0, 255, 0);  // Changed to green color
            for (let i = electrons.length - 1; i >= 0; i--) {
                electrons[i].update();
                electrons[i].display();
                if (document.getElementById('sinkActive').checked && electronSink.checkCollision(electrons[i])) {
                    electrons.splice(i, 1);
                }
            }

            updateDisplays();
        }

        function drawDistortedTorus() {
            noStroke();
            fill(200);
            
            const detailX = 64;
            const detailY = 64;
            
            for (let i = 0; i < detailX; i++) {
                const u = i / detailX;
                const nextU = (i + 1) / detailX;
                beginShape(TRIANGLE_STRIP);
                for (let j = 0; j <= detailY; j++) {
                    const v = j / detailY;
                    const theta = u * TWO_PI;
                    const nextTheta = nextU * TWO_PI;
                    const phi = v * TWO_PI;
                    
                    const r1 = getInterpolatedRadius(theta);
                    const r2 = getInterpolatedRadius(nextTheta);
                    
                    const x1 = (TORUS_RADIUS + r1 * cos(phi)) * cos(theta);
                    const y1 = (TORUS_RADIUS + r1 * cos(phi)) * sin(theta);
                    const z1 = r1 * sin(phi);
                    
                    const x2 = (TORUS_RADIUS + r2 * cos(phi)) * cos(nextTheta);
                    const y2 = (TORUS_RADIUS + r2 * cos(phi)) * sin(nextTheta);
                    const z2 = r2 * sin(phi);
                    
                    vertex(x1, y1, z1);
                    vertex(x2, y2, z2);
                }
                endShape();
            }
        }

        function getInterpolatedRadius(theta) {
            const normalizedTheta = (theta + TWO_PI) % TWO_PI;
            const index = floor(normalizedTheta / HALF_PI);
            const t = (normalizedTheta % HALF_PI) / HALF_PI;
            const r1 = TUBE_RADIUS[index];
            const r2 = TUBE_RADIUS[(index + 1) % 4];
            return lerp(r1, r2, t);
        }

        function drawResistiveRing() {
            push();
            stroke(255, 0, 0);
            strokeWeight(3);
            noFill();
            translate(TORUS_RADIUS, 0, 0);
            rotateY(HALF_PI);
            circle(0, 0, TUBE_RADIUS[0] * 2);
            pop();
        }

        function updateDisplays() {
            document.getElementById('electronCount').textContent = electrons.length;
            document.getElementById('brownianStrength').textContent = brownianStrength.toFixed(3);
            document.getElementById('dampingValue').textContent = damping.toFixed(2);
            document.getElementById('frequencyValue').textContent = sourceFrequency.toFixed(1);
            document.getElementById('elongationValue').textContent = TORUS_RADIUS.toFixed(0);
            document.getElementById('girth0Value').textContent = TUBE_RADIUS[0].toFixed(0);
            document.getElementById('girth90Value').textContent = TUBE_RADIUS[1].toFixed(0);
            document.getElementById('girth180Value').textContent = TUBE_RADIUS[2].toFixed(0);
            document.getElementById('girth270Value').textContent = TUBE_RADIUS[3].toFixed(0);
        }

        function updateElectronCount() {
            let targetCount = parseInt(document.getElementById('electronSlider').value);
            while (electrons.length < targetCount) {
                electrons.push(new Electron());
            }
            while (electrons.length > targetCount) {
                electrons.pop();
            }
        }

        function updateBrownianStrength() {
            brownianStrength = document.getElementById('brownianSlider').value / 10000;
        }

        function updateDamping() {
            damping = 1 - document.getElementById('dampingSlider').value / 100;
        }

        function updateFrequency() {
            sourceFrequency = document.getElementById('frequencySlider').value / 10;
        }

        function updateElongation() {
            TORUS_RADIUS = parseInt(document.getElementById('elongationSlider').value);
        }

        function updateGirth(index) {
            TUBE_RADIUS[index] = parseInt(document.getElementById(`girth${index * 90}Slider`).value);
        }

        class Electron {
            constructor(theta = random(TWO_PI), phi = random(TWO_PI)) {
                this.theta = theta;
                this.phi = phi;
                this.velocity = createVector(0, 0);
            }

            update() {
                this.velocity.add(p5.Vector.random2D().mult(brownianStrength));
                
                let totalForce = createVector(0, 0);
                for (let other of electrons) {
                    if (other !== this) {
                        let force = this.calculateForce(other);
                        totalForce.add(force);
                    }
                }

                if (document.getElementById('sinkActive').checked) {
                    let sinkForce = electronSink.calculateAttraction(this);
                    totalForce.add(sinkForce);
                }

                this.velocity.add(totalForce);

                let newTheta = this.theta + this.velocity.x * ELECTRON_SPEED;
                if (abs(newTheta) < RESISTIVE_RING_WIDTH / 2 || 
                    abs(newTheta - PI) < RESISTIVE_RING_WIDTH / 2 ||
                    abs(newTheta - TWO_PI) < RESISTIVE_RING_WIDTH / 2) {
                    this.velocity.x *= -1;
                } else {
                    this.theta = newTheta;
                }

                this.phi += this.velocity.y * ELECTRON_SPEED;

                this.theta = (this.theta + TWO_PI) % TWO_PI;
                this.phi = constrain(this.phi, 0, TWO_PI);

                this.velocity.mult(1 - damping);
            }

            calculateForce(other) {
                let d_theta = (this.theta - other.theta + TWO_PI) % TWO_PI;
                let d_phi = (this.phi - other.phi + TWO_PI) % TWO_PI;
                
                if (d_theta > PI) d_theta -= TWO_PI;
                if (d_phi > PI) d_phi -= TWO_PI;

                let r = TORUS_RADIUS + getInterpolatedRadius(this.theta) * cos(this.phi);
                let dx = r * d_theta;
                let dy = getInterpolatedRadius(this.theta) * d_phi;
                let distSq = dx * dx + dy * dy;

                if (distSq < MIN_DISTANCE * MIN_DISTANCE) distSq = MIN_DISTANCE * MIN_DISTANCE;

                let force = min(COULOMB_CONSTANT / distSq, MAX_FORCE);

                let forceTheta = force * dx / sqrt(distSq);
                let forcePhi = force * dy / sqrt(distSq);

                return createVector(forceTheta, forcePhi);
            }

            display() {
                let r = getInterpolatedRadius(this.theta);
                let x = (TORUS_RADIUS + r * cos(this.phi)) * cos(this.theta);
                let y = (TORUS_RADIUS + r * cos(this.phi)) * sin(this.theta);
                let z = r * sin(this.phi);
                push();
                translate(x, y, z);
                sphere(3);
                pop();
            }
        }

        class ElectronSource {
            constructor(theta, phi) {
                this.theta = theta;
                this.phi = phi;
            }

            display() {
                let r = getInterpolatedRadius(this.theta);
                let x = (TORUS_RADIUS + r * cos(this.phi)) * cos(this.theta);
                let y = (TORUS_RADIUS + r * cos(this.phi)) * sin(this.theta);
                let z = r * sin(this.phi);
                push();
                translate(x, y, z);
                fill(0);
                sphere(5);
                pop();
            }
        }

        class ElectronSink {
            constructor(theta, phi) {
                this.theta = theta;
                this.phi = phi;
            }

            display() {
                let r = getInterpolatedRadius(this.theta);
  let x = (TORUS_RADIUS + r * cos(this.phi)) * cos(this.theta);
                let y = (TORUS_RADIUS + r * cos(this.phi)) * sin(this.theta);
                let z = r * sin(this.phi);
                push();
                translate(x, y, z);
                fill(255);
                sphere(5);
                pop();
            }

            calculateAttraction(electron) {
                let d_theta = (this.theta - electron.theta + TWO_PI) % TWO_PI;
                let d_phi = (this.phi - electron.phi + TWO_PI) % TWO_PI;
                
                if (d_theta > PI) d_theta -= TWO_PI;
                if (d_phi > PI) d_phi -= TWO_PI;

                let r = TORUS_RADIUS + getInterpolatedRadius(electron.theta) * cos(electron.phi);
                let dx = r * d_theta;
                let dy = getInterpolatedRadius(electron.theta) * d_phi;
                let distSq = dx * dx + dy * dy;

                if (distSq < MIN_DISTANCE * MIN_DISTANCE) distSq = MIN_DISTANCE * MIN_DISTANCE;

                let force = min(SINK_ATTRACTION / distSq, MAX_FORCE);

                let forceTheta = force * dx / sqrt(distSq);
                let forcePhi = force * dy / sqrt(distSq);

                return createVector(forceTheta, forcePhi);
            }

            checkCollision(electron) {
                let d_theta = (this.theta - electron.theta + TWO_PI) % TWO_PI;
                let d_phi = (this.phi - electron.phi + TWO_PI) % TWO_PI;
                
                if (d_theta > PI) d_theta -= TWO_PI;
                if (d_phi > PI) d_phi -= TWO_PI;

                let r = TORUS_RADIUS + getInterpolatedRadius(electron.theta) * cos(electron.phi);
                let dx = r * d_theta;
                let dy = getInterpolatedRadius(electron.theta) * d_phi;
                let distSq = dx * dx + dy * dy;

                return distSq < 25;
            }
        }

        function mousePressed() {
            if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) {
                dragStartX = mouseX;
                dragStartY = mouseY;
            }
        }

        function mouseDragged() {
            if (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height) {
                userRotationX += (mouseX - dragStartX) * 0.01;
                userRotationY += (mouseY - dragStartY) * 0.01;
                dragStartX = mouseX;
                dragStartY = mouseY;
            }
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            document.getElementById('electronSlider').addEventListener('input', updateElectronCount);
            document.getElementById('brownianSlider').addEventListener('input', updateBrownianStrength);
            document.getElementById('dampingSlider').addEventListener('input', updateDamping);
            document.getElementById('frequencySlider').addEventListener('input', updateFrequency);
            document.getElementById('elongationSlider').addEventListener('input', updateElongation);
            document.getElementById('girth0Slider').addEventListener('input', () => updateGirth(0));
            document.getElementById('girth90Slider').addEventListener('input', () => updateGirth(1));
            document.getElementById('girth180Slider').addEventListener('input', () => updateGirth(2));
            document.getElementById('girth270Slider').addEventListener('input', () => updateGirth(3));
        });
    </script>
</body>
</html>