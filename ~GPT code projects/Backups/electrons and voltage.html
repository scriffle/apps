<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Electron Simulation with Resizable Bar</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 1px solid black;
    }
    #controls {
      margin-top: 20px;
      width: 500px; /* Set width for the controls container */
    }
    label {
      font-size: 16px;
      margin-right: 10px;
    }
    input[type="number"] {
      width: 80px;
    }
    #voltageSlider {
      width: 500px; /* Set voltage slider width to 500px */
    }
    #resetButton {
      margin-top: 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="barCanvas"></canvas>

  <div id="controls">
    <label for="voltageSlider">Voltage: </label>
    <input type="range" id="voltageSlider" min="0" max="500" value="10">
    <input type="number" id="voltageNumber" min="0" max="500" value="10">
    <span id="voltageValue"></span>
    <br><br>
    <label for="temperatureSlider">Temperature: </label>
    <input type="range" id="temperatureSlider" min="0" max="2" step="0.1" value="0.5">
    <span id="temperatureValue">0.5</span>
  </div>

  <button id="resetButton">Reset Simulation</button>

  <script>
    // Get canvas and set its size dynamically
    const canvas = document.getElementById('barCanvas');
    const ctx = canvas.getContext('2d');
    let canvasWidth = window.innerWidth * 0.8;
    let canvasHeight = 300;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Variables for the metal bar and electrons
    let barStartX = 50;
    let barEndX = canvasWidth - 50;
    let barStartY = 100;
    let barEndY = 200;
    const minBarWidth = 50;
    const minBarHeight = 50;
    const electronRadius = 5;
    const gradientRadius = electronRadius * 5; // Radius for gradient effect around electrons
    let numElectrons = 10; // Starting with 10 electrons
    const maxElectrons = 500;
    let brownianMotionIntensity = 0.5; // Initial temperature setting
    let electrons = [];
    let draggedElectron = null; // Track the dragged electron
    let isDragging = false; // Flag for dragging
    let isResizing = { left: false, right: false, top: false, bottom: false }; // Flags for resizing

    // Helper function to generate random blue shades
    function randomBlueShade() {
      const blueValue = Math.floor(150 + Math.random() * 100);
      return `rgb(0, 0, ${blueValue})`;
    }

    // Electron object
    class Electron {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.color = randomBlueShade(); // Each electron gets a unique blue shade
        this.dragging = false;
      }

      draw() {
        // Draw the green gradient around the electron
        const gradient = ctx.createRadialGradient(this.x, this.y, electronRadius, this.x, this.y, gradientRadius);
        gradient.addColorStop(0, 'rgba(0, 255, 0, 0.2)'); // Light green at the center
        gradient.addColorStop(1, 'rgba(0, 255, 0, 0)'); // Fade to transparent
        ctx.beginPath();
        ctx.arc(this.x, this.y, gradientRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.closePath();

        // Draw the electron itself
        ctx.beginPath();
        ctx.arc(this.x, this.y, electronRadius, 0, Math.PI * 2);
        ctx.fillStyle = this.dragging ? 'red' : this.color; // Electron is red when dragged
        ctx.fill();
        ctx.closePath();
      }

      update(electrons) {
        if (!this.dragging) {
          // Brownian motion (random movements depending on temperature)
          this.vx += (Math.random() - 0.5) * brownianMotionIntensity;
          this.vy += (Math.random() - 0.5) * brownianMotionIntensity;

          // Repulsive forces due to other electrons (inverse square law)
          electrons.forEach(otherElectron => {
            if (otherElectron !== this) {
              const dx = this.x - otherElectron.x;
              const dy = this.y - otherElectron.y;
              let distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < electronRadius * 2) distance = electronRadius * 2; // Preventing too close contact

              const force = 100 / (distance * distance); // Repulsion intensity is constant
              this.vx += (dx / distance) * force;
              this.vy += (dy / distance) * force;
            }
          });

          // Update position without wrapping (contain within the bar)
          this.x += this.vx;
          this.y += this.vy;

          // Contain within horizontal and vertical boundaries of the bar
          if (this.x < barStartX + electronRadius) this.x = barStartX + electronRadius;
          if (this.x > barEndX - electronRadius) this.x = barEndX - electronRadius;
          if (this.y < barStartY + electronRadius) this.y = barStartY + electronRadius;
          if (this.y > barEndY - electronRadius) this.y = barEndY - electronRadius;

          // Dampen velocity slightly to simulate friction
          this.vx *= 0.99;
          this.vy *= 0.99;
        }
      }
    }

    // Initialize electrons in random positions, in order
    function initializeElectrons(count) {
      electrons = [];
      for (let i = 0; i < count; i++) {
        const x = Math.random() * (barEndX - barStartX) + barStartX;
        const y = Math.random() * (barEndY - barStartY) + barStartY;
        electrons.push(new Electron(x, y));
      }
    }

    // Add a new electron at a random position
    function addElectron() {
      const x = Math.random() * (barEndX - barStartX) + barStartX;
      const y = Math.random() * (barEndY - barStartY) + barStartY;
      electrons.push(new Electron(x, y));
    }

    // Remove the last electron
    function removeElectron() {
      electrons.pop();
    }

    // Main animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the metal bar with a lighter gray color
      ctx.fillStyle = '#d3d3d3';
      ctx.fillRect(barStartX, barStartY, barEndX - barStartX, barEndY - barStartY);

      // Draw a thicker border on each side for resizing
      ctx.fillStyle = '#a9a9a9'; // Slightly darker shade for the border
      ctx.fillRect(barEndX - 10, barStartY, 10, barEndY - barStartY); // Right border
      ctx.fillRect(barStartX, barStartY, 10, barEndY - barStartY); // Left border
      ctx.fillRect(barStartX, barStartY, barEndX - barStartX, 10); // Top border
      ctx.fillRect(barStartX, barEndY - 10, barEndX - barStartX, 10); // Bottom border

      // Update and draw electrons
      electrons.forEach(electron => {
        electron.update(electrons);
        electron.draw();
      });

      requestAnimationFrame(animate);
    }

    // Initialize and start the simulation
    initializeElectrons(numElectrons);
    animate();

    // Handle voltage slider and number input (for controlling number of electrons)
    const voltageSlider = document.getElementById('voltageSlider');
    const voltageNumber = document.getElementById('voltageNumber');
    const voltageValueDisplay = document.getElementById('voltageValue');

    function updateVoltage(newNumElectrons) {
      voltageSlider.value = newNumElectrons;
      voltageNumber.value = newNumElectrons;
      voltageValueDisplay.textContent = newNumElectrons;

      // Add or remove electrons dynamically
      if (newNumElectrons > numElectrons) {
        while (numElectrons < newNumElectrons) {
          addElectron();
          numElectrons++;
        }
      } else if (newNumElectrons < numElectrons) {
        while (numElectrons > newNumElectrons) {
          removeElectron();
          numElectrons--;
        }
      }
    }

    voltageSlider.addEventListener('input', (e) => {
      updateVoltage(parseInt(e.target.value, 10));
    });

    voltageNumber.addEventListener('input', (e) => {
      updateVoltage(parseInt(e.target.value, 10));
    });

    // Handle temperature slider (for controlling brownian motion)
    const temperatureSlider = document.getElementById('temperatureSlider');
    const temperatureValueDisplay = document.getElementById('temperatureValue');
    temperatureSlider.addEventListener('input', (e) => {
      brownianMotionIntensity = parseFloat(e.target.value);
      temperatureValueDisplay.textContent = brownianMotionIntensity.toFixed(1);
    });

    // Reset the simulation
    const resetButton = document.getElementById('resetButton');
    resetButton.addEventListener('click', () => {
      numElectrons = 10;
      brownianMotionIntensity = 0.5;
      voltageSlider.value = 10;
      voltageNumber.value = 10;
      temperatureSlider.value = 0.5;
      voltageValueDisplay.textContent = '10';
      temperatureValueDisplay.textContent = '0.5';

      barStartX = 50;
      barEndX = canvasWidth - 50;
      barStartY = 100;
      barEndY = 200;

      initializeElectrons(numElectrons);
    });

    // Handle mouse events for dragging electrons and resizing the bar
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Detect if resizing bar
      if (Math.abs(mouseX - barEndX) < 10 && mouseY > barStartY && mouseY < barEndY) {
        isResizing.right = true;
      } else if (Math.abs(mouseX - barStartX) < 10 && mouseY > barStartY && mouseY < barEndY) {
        isResizing.left = true;
      } else if (Math.abs(mouseY - barStartY) < 10 && mouseX > barStartX && mouseX < barEndX) {
        isResizing.top = true;
      } else if (Math.abs(mouseY - barEndY) < 10 && mouseX > barStartX && mouseX < barEndX) {
        isResizing.bottom = true;
      } else {
        // Find the electron that was clicked
        electrons.forEach(electron => {
          const dx = mouseX - electron.x;
          const dy = mouseY - electron.y;
          if (Math.sqrt(dx * dx + dy * dy) < electronRadius) {
            draggedElectron = electron;
            electron.dragging = true;
            isDragging = true;
          }
        });
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Handle resizing bar
      if (isResizing.right) {
        barEndX = mouseX;
        if (barEndX < barStartX + minBarWidth) barEndX = barStartX + minBarWidth; // Set minimum bar width
      } else if (isResizing.left) {
        barStartX = mouseX;
        if (barStartX > barEndX - minBarWidth) barStartX = barEndX - minBarWidth; // Set minimum bar width
      } else if (isResizing.top) {
        barStartY = mouseY;
        if (barStartY > barEndY - minBarHeight) barStartY = barEndY - minBarHeight; // Set minimum bar height
      } else if (isResizing.bottom) {
        barEndY = mouseY;
        if (barEndY < barStartY + minBarHeight) barEndY = barStartY + minBarHeight; // Set minimum bar height
      }

      // Handle dragging electrons
      if (isDragging && draggedElectron) {
        draggedElectron.x = mouseX;
        draggedElectron.y = mouseY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      isResizing = { left: false, right: false, top: false, bottom: false };

      if (isDragging && draggedElectron) {
        draggedElectron.dragging = false;
        draggedElectron = null;
        isDragging = false;
      }
    });

    canvas.addEventListener('mouseleave', () => {
      isResizing = { left: false, right: false, top: false, bottom: false };

      if (isDragging && draggedElectron) {
        draggedElectron.dragging = false;
        draggedElectron = null;
        isDragging = false;
      }
    });

  </script>
</body>
</html>
