<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inverted Pendulum and Block Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
      background-color: #eee;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="addBlock">Add Block</button>
    <button id="addPendulum">Add Pendulum</button>
    <button id="deleteSelected">Delete Selected</button>
    <br>
    <label for="bobDistance">Bob Distance from Pivot: <span id="distanceValue">150</span></label>
    <input type="range" id="bobDistance" min="50" max="300" step="1" value="150">
  </div>

  <canvas id="simulationCanvas"></canvas>

  <script>
    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');
    const controls = document.getElementById('controls');
    let selectedObject = null; // Object that is selected by the user
    let isDragging = false; // To track dragging
    let mouseX = 0, mouseY = 0;

    // Resize canvas dynamically
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Basic physics constants
    const gravity = 9.81; // m/s^2
    const timeStep = 0.02; // Time step for simulation

    // Helper function to check if the mouse is inside a rectangle
    function isMouseInside(x, y, width, height) {
      return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;
    }

    // Helper function to check if two objects overlap
    function doObjectsOverlap(obj1, obj2) {
      return obj1.x < obj2.x + obj2.width &&
             obj1.x + obj1.width > obj2.x &&
             obj1.y < obj2.y + obj2.height &&
             obj1.y + obj1.height > obj2.y;
    }

    // Block Class
    class Block {
      constructor(x, y, width, height, mass) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.mass = mass;
        this.velocity = 0;
        this.force = 0;
        this.isSelected = false;
      }

      // Update block's position
      update() {
        const acceleration = this.force / this.mass;
        this.velocity += acceleration;
        this.x += this.velocity;
        this.force = 0;
        this.velocity *= 0.99; // Friction-like effect
      }

      applyForce(force) {
        this.force += force;
      }

      draw() {
        ctx.fillStyle = this.isSelected ? 'rgba(0, 0, 255, 0.3)' : '#555';
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Draw selection border if selected
        if (this.isSelected) {
          ctx.strokeStyle = '#00f';
          ctx.lineWidth = 3;
          ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
      }

      isInside(mouseX, mouseY) {
        return isMouseInside(this.x, this.y, this.width, this.height);
      }
    }

    // Pendulum Class (Inverted Pendulum)
    class Pendulum {
      constructor(x, y, length, block = null) {
        this.originX = x;
        this.originY = y;
        this.length = length;  // Bob distance from the pivot (pendulum length)
        this.angle = Math.PI / 4;
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.weight = 10; // Constant bob radius
        this.block = block;
        this.isSelected = false;
      }

      // Update pendulum's physics
      update() {
        if (this.block) {
          this.originX = this.block.x + this.block.width / 2;
          this.originY = this.block.y + this.block.height + this.length; // Inverted, bob at the top
        }

        const force = (-gravity / this.length) * Math.sin(this.angle);
        this.angularAcceleration = force;
        this.angularVelocity += this.angularAcceleration;
        this.angle += this.angularVelocity;

        // Simulate a driving force by preventing decay
        this.angularVelocity *= 1; // No damping for a driven pendulum
      }

      draw() {
        const bobX = this.originX + this.length * Math.sin(this.angle);
        const bobY = this.originY - this.length * Math.cos(this.angle); // Inverted pendulum

        // Draw pendulum line
        ctx.beginPath();
        ctx.moveTo(this.originX, this.originY);
        ctx.lineTo(bobX, bobY);
        ctx.strokeStyle = '#000';
        ctx.stroke();

        // Draw bob
        ctx.beginPath();
        ctx.arc(bobX, bobY, this.weight, 0, Math.PI * 2);
        ctx.fillStyle = this.isSelected ? 'rgba(0, 0, 255, 0.3)' : '#f00';
        ctx.fill();

        // Draw bounding box for selection
        ctx.strokeStyle = this.isSelected ? '#00f' : '#000';
        ctx.lineWidth = this.isSelected ? 2 : 1;
        ctx.strokeRect(bobX - this.weight - 10, bobY - this.weight - 10, this.weight * 2 + 20, this.weight * 2 + 20);
      }

      applyForceToBlock() {
        if (this.block) {
          const forceOnBlock = Math.sin(this.angle) * this.weight;
          this.block.applyForce(forceOnBlock);
        }
      }

      // Check if the mouse is inside the pendulum's bounding box
      isInside(mouseX, mouseY) {
        const bobX = this.originX + this.length * Math.sin(this.angle);
        const bobY = this.originY - this.length * Math.cos(this.angle); // Inverted
        return isMouseInside(bobX - this.weight - 10, bobY - this.weight - 10, this.weight * 2 + 20, this.weight * 2 + 20);
      }
    }

    // Store blocks and pendulums
    const blocks = [];
    const pendulums = [];

    // Add some initial blocks and pendulums
    const block1 = new Block(canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 30, 50);
    blocks.push(block1);

    const pendulum1 = new Pendulum(block1.x + 100, block1.y + 10, 150, block1);
    pendulums.push(pendulum1);

    // Add new block and pendulum handlers
    document.getElementById('addBlock').addEventListener('click', () => {
      const newBlock = new Block(Math.random() * canvas.width, Math.random() * canvas.height, 200, 30, 50);
      blocks.push(newBlock);
    });

    document.getElementById('addPendulum').addEventListener('click', () => {
      const newPendulum = new Pendulum(Math.random() * canvas.width, Math.random() * canvas.height, 150, null);
      pendulums.push(newPendulum);
    });

    // Delete selected object
    document.getElementById('deleteSelected').addEventListener('click', () => {
      if (selectedObject instanceof Block) {
        blocks.splice(blocks.indexOf(selectedObject), 1);
      } else if (selectedObject instanceof Pendulum) {
        pendulums.splice(pendulums.indexOf(selectedObject), 1);
      }
      selectedObject = null;
    });

    // Adjust bob distance from pivot (pendulum length)
    const distanceSlider = document.getElementById('bobDistance');
    const distanceValue = document.getElementById('distanceValue');
    distanceSlider.addEventListener('input', () => {
      distanceValue.textContent = distanceSlider.value;
      if (selectedObject instanceof Pendulum) {
        selectedObject.length = Number(distanceSlider.value);
      }
    });

    // Mouse interaction for dragging and selection
    canvas.addEventListener('mousedown', (event) => {
      mouseX = event.clientX;
      mouseY = event.clientY;

      // Deselect all objects first
      blocks.forEach(block => block.isSelected = false);
      pendulums.forEach(pendulum => pendulum.isSelected = false);
      selectedObject = null;

      // Check if clicking on a pendulum or block
      for (let block of blocks) {
        if (block.isInside(mouseX, mouseY)) {
          selectedObject = block;
          block.isSelected = true;
          isDragging = true;
          return;
        }
      }
      for (let pendulum of pendulums) {
        if (pendulum.isInside(mouseX, mouseY)) {
          selectedObject = pendulum;
          pendulum.isSelected = true;
          isDragging = true;
          return;
        }
      }
    });

    canvas.addEventListener('mousemove', (event) => {
      const dx = event.clientX - mouseX;
      const dy = event.clientY - mouseY;
      if (isDragging && selectedObject) {
        if (selectedObject instanceof Block) {
          selectedObject.x += dx;
          selectedObject.y += dy;
        } else if (selectedObject instanceof Pendulum) {
          selectedObject.originX += dx;
          selectedObject.originY += dy;
        }
      }
      mouseX = event.clientX;
      mouseY = event.clientY;
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;

      // Check for overlaps between blocks and pendulums
      for (let i = 0; i < blocks.length; i++) {
        for (let j = i + 1; j < blocks.length; j++) {
          if (doObjectsOverlap(blocks[i], blocks[j])) {
            // Combine their masses if they overlap
            blocks[i].mass += blocks[j].mass;
            blocks.splice(j, 1); // Remove the second block
          }
        }
      }
    });

    // Main simulation loop
    function simulationLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

      blocks.forEach(block => {
        block.update();
        block.draw();
      });

      pendulums.forEach(pendulum => {
        pendulum.update();
        pendulum.draw();
        pendulum.applyForceToBlock();
      <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inverted Pendulum and Block Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
      background-color: #eee;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="addBlock">Add Block</button>
    <button id="addPendulum">Add Pendulum</button>
    <button id="deleteSelected">Delete Selected</button>
    <br>
    <label for="bobDistance">Bob Distance from Pivot: <span id="distanceValue">150</span></label>
    <input type="range" id="bobDistance" min="50" max="300" step="1" value="150">
  </div>

  <canvas id="simulationCanvas"></canvas>

  <script>
    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');
    const controls = document.getElementById('controls');
    let selectedObject = null; // Object that is selected by the user
    let isDragging = false; // To track dragging
    let mouseX = 0, mouseY = 0;

    // Resize canvas dynamically
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Basic physics constants
    const gravity = 9.81; // m/s^2
    const timeStep = 0.02; // Time step for simulation

    // Helper function to check if the mouse is inside a rectangle
    function isMouseInside(x, y, width, height) {
      return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;
    }

    // Helper function to check if two objects overlap
    function doObjectsOverlap(obj1, obj2) {
      return obj1.x < obj2.x + obj2.width &&
             obj1.x + obj1.width > obj2.x &&
             obj1.y < obj2.y + obj2.height &&
             obj1.y + obj1.height > obj2.y;
    }

    // Block Class
    class Block {
      constructor(x, y, width, height, mass) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.mass = mass;
        this.velocity = 0;
        this.force = 0;
        this.isSelected = false;
      }

      // Update block's position
      update() {
        const acceleration = this.force / this.mass;
        this.velocity += acceleration;
        this.x += this.velocity;
        this.force = 0;
        this.velocity *= 0.99; // Friction-like effect
      }

      applyForce(force) {
        this.force += force;
      }

      draw() {
        ctx.fillStyle = this.isSelected ? 'rgba(0, 0, 255, 0.3)' : '#555';
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Draw selection border if selected
        if (this.isSelected) {
          ctx.strokeStyle = '#00f';
          ctx.lineWidth = 3;
          ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
      }

      isInside(mouseX, mouseY) {
        return isMouseInside(this.x, this.y, this.width, this.height);
      }
    }

    // Pendulum Class (Inverted Pendulum)
    class Pendulum {
      constructor(x, y, length, block = null) {
        this.originX = x;
        this.originY = y;
        this.length = length;  // Bob distance from the pivot (pendulum length)
        this.angle = Math.PI / 4;
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.weight = 10; // Constant bob radius
        this.block = block;
        this.isSelected = false;
      }

      // Update pendulum's physics
      update() {
        if (this.block) {
          this.originX = this.block.x + this.block.width / 2;
          this.originY = this.block.y + this.block.height + this.length; // Inverted, bob at the top
        }

        const force = (-gravity / this.length) * Math.sin(this.angle);
        this.angularAcceleration = force;
        this.angularVelocity += this.angularAcceleration;
        this.angle += this.angularVelocity;

        // Simulate a driving force by preventing decay
        this.angularVelocity *= 1; // No damping for a driven pendulum
      }

      draw() {
        const bobX = this.originX + this.length * Math.sin(this.angle);
        const bobY = this.originY - this.length * Math.cos(this.angle); // Inverted pendulum

        // Draw pendulum line
        ctx.beginPath();
        ctx.moveTo(this.originX, this.originY);
        ctx.lineTo(bobX, bobY);
        ctx.strokeStyle = '#000';
        ctx.stroke();

        // Draw bob
        ctx.beginPath();
        ctx.arc(bobX, bobY, this.weight, 0, Math.PI * 2);
        ctx.fillStyle = this.isSelected ? 'rgba(0, 0, 255, 0.3)' : '#f00';
        ctx.fill();

        // Draw bounding box for selection
        ctx.strokeStyle = this.isSelected ? '#00f' : '#000';
        ctx.lineWidth = this.isSelected ? 2 : 1;
        ctx.strokeRect(bobX - this.weight - 10, bobY - this.weight - 10, this.weight * 2 + 20, this.weight * 2 + 20);
      }

      applyForceToBlock() {
        if (this.block) {
          const forceOnBlock = Math.sin(this.angle) * this.weight;
          this.block.applyForce(forceOnBlock);
        }
      }

      // Check if the mouse is inside the pendulum's bounding box
      isInside(mouseX, mouseY) {
        const bobX = this.originX + this.length * Math.sin(this.angle);
        const bobY = this.originY - this.length * Math.cos(this.angle); // Inverted
        return isMouseInside(bobX - this.weight - 10, bobY - this.weight - 10, this.weight * 2 + 20, this.weight * 2 + 20);
      }
    }

    // Store blocks and pendulums
    const blocks = [];
    const pendulums = [];

    // Add some initial blocks and pendulums
    const block1 = new Block(canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 30, 50);
    blocks.push(block1);

    const pendulum1 = new Pendulum(block1.x + 100, block1.y + 10, 150, block1);
    pendulums.push(pendulum1);

    // Add new block and pendulum handlers
    document.getElementById('addBlock').addEventListener('click', () => {
      const newBlock = new Block(Math.random() * canvas.width, Math.random() * canvas.height, 200, 30, 50);
      blocks.push(newBlock);
    });

    document.getElementById('addPendulum').addEventListener('click', () => {
      const newPendulum = new Pendulum(Math.random() * canvas.width, Math.random() * canvas.height, 150, null);
      pendulums.push(newPendulum);
    });

    // Delete selected object
    document.getElementById('deleteSelected').addEventListener('click', () => {
      if (selectedObject instanceof Block) {
        blocks.splice(blocks.indexOf(selectedObject), 1);
      } else if (selectedObject instanceof Pendulum) {
        pendulums.splice(pendulums.indexOf(selectedObject), 1);
      }
      selectedObject = null;
    });

    // Adjust bob distance from pivot (pendulum length)
    const distanceSlider = document.getElementById('bobDistance');
    const distanceValue = document.getElementById('distanceValue');
    distanceSlider.addEventListener('input', () => {
      distanceValue.textContent = distanceSlider.value;
      if (selectedObject instanceof Pendulum) {
        selectedObject.length = Number(distanceSlider.value);
      }
    });

    // Mouse interaction for dragging and selection
    canvas.addEventListener('mousedown', (event) => {
      mouseX = event.clientX;
      mouseY = event.clientY;

      // Deselect all objects first
      blocks.forEach(block => block.isSelected = false);
      pendulums.forEach(pendulum => pendulum.isSelected = false);
      selectedObject = null;

      // Check if clicking on a pendulum or block
      for (let block of blocks) {
        if (block.isInside(mouseX, mouseY)) {
          selectedObject = block;
          block.isSelected = true;
          isDragging = true;
          return;
        }
      }
      for (let pendulum of pendulums) {
        if (pendulum.isInside(mouseX, mouseY)) {
          selectedObject = pendulum;
          pendulum.isSelected = true;
          isDragging = true;
          return;
        }
      }
    });

    canvas.addEventListener('mousemove', (event) => {
      const dx = event.clientX - mouseX;
      const dy = event.clientY - mouseY;
      if (isDragging && selectedObject) {
        if (selectedObject instanceof Block) {
          selectedObject.x += dx;
          selectedObject.y += dy;
        } else if (selectedObject instanceof Pendulum) {
          selectedObject.originX += dx;
          selectedObject.originY += dy;
        }
      }
      mouseX = event.clientX;
      mouseY = event.clientY;
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;

      // Check for overlaps between blocks and pendulums
      for (let i = 0; i < blocks.length; i++) {
        for (let j = i + 1; j < blocks.length; j++) {
          if (doObjectsOverlap(blocks[i], blocks[j])) {
            // Combine their masses if they overlap
            blocks[i].mass += blocks[j].mass;
            blocks.splice(j, 1); // Remove the second block
          }
        }
      }
    });

    // Main simulation loop
    function simulationLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

      blocks.forEach(block => {
        block.update();
        block.draw();
      });

      pendulums.forEach(pendulum => {
        pendulum.update();
        pendulum.draw();
        pendulum.applyForceToBlock();
      });

      requestAnimationFrame(simulationLoop);
    }

    // Start the simulation
    simulationLoop();
  </script>
</body>
</html>


      requestAnimationFrame(simulationLoop);
    }

    // Start the simulation
    simulationLoop();
  </script>
</body>
</html>
