<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBC Micro - Matrix Explorer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');
        
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #ffff00;
            font-family: 'Courier Prime', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .computer-frame {
            background-color: #444;
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #666;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        .screen {
            background-color: #000;
            border: 2px solid #333;
            padding: 10px;
            border-radius: 5px;
            position: relative;
        }

        .title {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffff00;
            text-shadow: 1px 1px 0px #ff0000;
        }

        #gameCanvas {
            border: 1px solid #ffff00;
            background-color: #000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .controls {
            margin-top: 15px;
            text-align: center;
            font-size: 12px;
            color: #00ff00;
        }

        .status {
            margin-top: 10px;
            text-align: center;
            font-size: 11px;
            color: #ff00ff;
        }

        .codes-display {
            margin-top: 8px;
            text-align: center;
            font-size: 10px;
            color: #00ffff;
            max-height: 60px;
            overflow-y: auto;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 255, 0, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
        }

        .question-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #000;
            border: 2px solid #ffff00;
            padding: 20px;
            max-width: 300px;
            z-index: 100;
            display: none;
        }

        .question-text {
            color: #ffff00;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.4;
        }

        .answer-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .answer-btn {
            background-color: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 12px;
            font-family: inherit;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .answer-btn:hover {
            background-color: #00ff00;
            color: #000;
        }

        .room-transition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .room-transition.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="computer-frame">
        <div class="screen">
            <div class="scanlines"></div>
            <div class="title">BBC MICRO - MATRIX EXPLORER</div>
            <canvas id="gameCanvas" width="400" height="300"></canvas>
            <div class="room-transition" id="transition"></div>
            <div class="question-panel" id="questionPanel">
                <div class="question-text" id="questionText"></div>
                <div class="answer-options" id="answerOptions"></div>
            </div>
            <div class="controls">
                ARROW KEYS TO MOVE • SPACE TO INTERACT WITH DOORS
            </div>
            <div class="status" id="status">
                ROOM: [0,0] CENTRAL HUB • DOORS UNLOCKED: 1/25 • SCORE: 0000
            </div>
            <div class="codes-display" id="codesDisplay">
                CODES COLLECTED: 1/25 | 01A
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const codesDisplay = document.getElementById('codesDisplay');
        const questionPanel = document.getElementById('questionPanel');
        const questionText = document.getElementById('questionText');
        const answerOptions = document.getElementById('answerOptions');
        const transition = document.getElementById('transition');

        // BBC Micro inspired color palette
        const colors = {
            black: '#000000',
            red: '#ff0000',
            green: '#00ff00',
            yellow: '#ffff00',
            blue: '#0000ff',
            magenta: '#ff00ff',
            cyan: '#00ffff',
            white: '#ffffff',
            gray: '#808080',
            darkGreen: '#008000',
            darkBlue: '#000080',
            darkRed: '#800000',
            orange: '#ff8000',
            purple: '#8000ff',
            lime: '#80ff00'
        };

        // Room color themes - each room has a unique color scheme
        const roomThemes = [
            // Row 0
            { floor: colors.green, wall: colors.gray, name: 'CENTRAL HUB' },
            { floor: colors.red, wall: colors.darkRed, name: 'CRIMSON CHAMBER' },
            { floor: colors.blue, wall: colors.darkBlue, name: 'AZURE ARCHIVES' },
            { floor: colors.yellow, wall: colors.orange, name: 'GOLDEN GALLERY' },
            { floor: colors.magenta, wall: colors.purple, name: 'MYSTIC MATRIX' },
            // Row 1
            { floor: colors.cyan, wall: colors.blue, name: 'CRYSTAL CAVERN' },
            { floor: colors.lime, wall: colors.darkGreen, name: 'NEON NEXUS' },
            { floor: colors.orange, wall: colors.red, name: 'AMBER ALCOVE' },
            { floor: colors.purple, wall: colors.magenta, name: 'VIOLET VAULT' },
            { floor: colors.white, wall: colors.gray, name: 'PEARL PAVILION' },
            // Row 2
            { floor: colors.darkGreen, wall: colors.green, name: 'FOREST FORUM' },
            { floor: colors.darkBlue, wall: colors.cyan, name: 'OCEAN OFFICE' },
            { floor: colors.darkRed, wall: colors.yellow, name: 'RUBY RESEARCH' },
            { floor: colors.gray, wall: colors.white, name: 'STEEL SANCTUM' },
            { floor: colors.green, wall: colors.lime, name: 'JADE JUNCTION' },
            // Row 3
            { floor: colors.blue, wall: colors.magenta, name: 'SAPPHIRE STUDY' },
            { floor: colors.red, wall: colors.cyan, name: 'GARNET GATEWAY' },
            { floor: colors.yellow, wall: colors.blue, name: 'TOPAZ TERMINAL' },
            { floor: colors.magenta, wall: colors.green, name: 'AMETHYST ATRIUM' },
            { floor: colors.cyan, wall: colors.red, name: 'TURQUOISE TOWER' },
            // Row 4
            { floor: colors.orange, wall: colors.purple, name: 'COPPER CORE' },
            { floor: colors.purple, wall: colors.orange, name: 'PRISM PORTAL' },
            { floor: colors.lime, wall: colors.red, name: 'EMERALD ENGINE' },
            { floor: colors.white, wall: colors.black, name: 'MARBLE MAINFRAME' },
            { floor: colors.black, wall: colors.white, name: 'OBSIDIAN ORACLE' }
        ];

        // Generate randomized room codes (numbers 1-25 and letters A-Y)
        function generateRoomCodes() {
            const numbers = Array.from({length: 25}, (_, i) => i + 1);
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXY'.split('');
            
            // Shuffle numbers and letters
            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }
            
            for (let i = letters.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [letters[i], letters[j]] = [letters[j], letters[i]];
            }
            
            // Assign to rooms
            const roomCodes = {};
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const index = y * 5 + x;
                    roomCodes[`${x},${y}`] = {
                        number: numbers[index],
                        letter: letters[index],
                        code: numbers[index].toString().padStart(2, '0') + letters[index]
                    };
                }
            }
            return roomCodes;
        }

        const roomCodes = generateRoomCodes();
        let collectedCodes = new Set();
        
        // Start with the first room's code collected
        const startCode = roomCodes['0,0'];
        collectedCodes.add(startCode.code);

        // Dummy questions for each door
        const questions = [
            { q: "What is 2 + 2?", answers: ["3", "4", "5", "6"], correct: 1 },
            { q: "Which planet is closest to the sun?", answers: ["Venus", "Mercury", "Earth", "Mars"], correct: 1 },
            { q: "What is the capital of France?", answers: ["London", "Berlin", "Paris", "Rome"], correct: 2 },
            { q: "How many bits in a byte?", answers: ["4", "6", "8", "10"], correct: 2 },
            { q: "What year was the BBC Micro released?", answers: ["1979", "1981", "1983", "1985"], correct: 1 },
            { q: "Primary colors in RGB?", answers: ["Red Green Blue", "Red Yellow Blue", "Blue Green Yellow", "Cyan Magenta Yellow"], correct: 0 },
            { q: "What is 16 in binary?", answers: ["1010", "1100", "10000", "1111"], correct: 2 },
            { q: "Which is not a programming language?", answers: ["BASIC", "Pascal", "Fortran", "Calculator"], correct: 3 },
            { q: "How many sides does a hexagon have?", answers: ["5", "6", "7", "8"], correct: 1 },
            { q: "What does CPU stand for?", answers: ["Central Processing Unit", "Computer Personal Unit", "Central Program Utility", "Computer Processing Utility"], correct: 0 }
        ];

        // Game state
        let player = { x: 5, y: 5 };
        let currentRoom = { x: 0, y: 0 };
        let unlockedRooms = new Set(['0,0']); // Start with room [0,0] unlocked
        let score = 0;
        let isTransitioning = false;
        let pendingDoor = null;

        // Room layout template (same for all rooms, doors vary)
        const roomTemplate = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1]
        ];

        // Generate doors for current room
        function getDoors(roomX, roomY) {
            const doors = [];
            
            // North door
            if (roomY > 0) {
                doors.push({ x: 5, y: 0, direction: 'north', targetRoom: { x: roomX, y: roomY - 1 } });
            }
            
            // South door  
            if (roomY < 4) {
                doors.push({ x: 5, y: 8, direction: 'south', targetRoom: { x: roomX, y: roomY + 1 } });
            }
            
            // West door
            if (roomX > 0) {
                doors.push({ x: 0, y: 4, direction: 'west', targetRoom: { x: roomX - 1, y: roomY } });
            }
            
            // East door
            if (roomX < 4) {
                doors.push({ x: 9, y: 4, direction: 'east', targetRoom: { x: roomX + 1, y: roomY } });
            }
            
            return doors;
        }

        // Isometric projection functions
        function isoToScreen(x, y) {
            const tileWidth = 32;
            const tileHeight = 16;
            const offsetX = canvas.width / 2;
            const offsetY = 50;
            
            return {
                x: offsetX + (x - y) * (tileWidth / 2),
                y: offsetY + (x + y) * (tileHeight / 2)
            };
        }

        function drawIsoTile(x, y, color, height = 1) {
            const screen = isoToScreen(x, y);
            const tileWidth = 32;
            const tileHeight = 16;
            
            ctx.fillStyle = color;
            
            // Draw top face
            ctx.beginPath();
            ctx.moveTo(screen.x, screen.y);
            ctx.lineTo(screen.x + tileWidth/2, screen.y + tileHeight/2);
            ctx.lineTo(screen.x, screen.y + tileHeight);
            ctx.lineTo(screen.x - tileWidth/2, screen.y + tileHeight/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw sides for walls
            if (height > 0) {
                const wallHeight = 20;
                
                // Right side
                ctx.fillStyle = adjustBrightness(color, -30);
                ctx.beginPath();
                ctx.moveTo(screen.x + tileWidth/2, screen.y + tileHeight/2);
                ctx.lineTo(screen.x + tileWidth/2, screen.y + tileHeight/2 + wallHeight);
                ctx.lineTo(screen.x, screen.y + tileHeight + wallHeight);
                ctx.lineTo(screen.x, screen.y + tileHeight);
                ctx.closePath();
                ctx.fill();
                
                // Left side
                ctx.fillStyle = adjustBrightness(color, -50);
                ctx.beginPath();
                ctx.moveTo(screen.x - tileWidth/2, screen.y + tileHeight/2);
                ctx.lineTo(screen.x - tileWidth/2, screen.y + tileHeight/2 + wallHeight);
                ctx.lineTo(screen.x, screen.y + tileHeight + wallHeight);
                ctx.lineTo(screen.x, screen.y + tileHeight);
                ctx.closePath();
                ctx.fill();
            }
        }

        function adjustBrightness(hex, percent) {
            const num = parseInt(hex.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }

        function drawPlayer(x, y) {
            const screen = isoToScreen(x, y);
            
            // Draw player as a simple character
            ctx.fillStyle = colors.yellow;
            ctx.fillRect(screen.x - 6, screen.y - 20, 12, 16);
            
            // Head
            ctx.fillStyle = colors.white;
            ctx.fillRect(screen.x - 4, screen.y - 24, 8, 8);
            
            // Simple face
            ctx.fillStyle = colors.black;
            ctx.fillRect(screen.x - 2, screen.y - 22, 1, 1);
            ctx.fillRect(screen.x + 1, screen.y - 22, 1, 1);
            ctx.fillRect(screen.x - 1, screen.y - 19, 2, 1);
        }

        function drawPlayer(x, y) {
            const screen = isoToScreen(x, y);
            
            // Draw player as a simple character
            ctx.fillStyle = colors.yellow;
            ctx.fillRect(screen.x - 6, screen.y - 20, 12, 16);
            
            // Head
            ctx.fillStyle = colors.white;
            ctx.fillRect(screen.x - 4, screen.y - 24, 8, 8);
            
            // Simple face
            ctx.fillStyle = colors.black;
            ctx.fillRect(screen.x - 2, screen.y - 22, 1, 1);
            ctx.fillRect(screen.x + 1, screen.y - 22, 1, 1);
            ctx.fillRect(screen.x - 1, screen.y - 19, 2, 1);
        }

        function drawDoor(door) {
            const screen = isoToScreen(door.x, door.y);
            const isUnlocked = unlockedRooms.has(`${door.targetRoom.x},${door.targetRoom.y}`);
            
            // Door token
            ctx.fillStyle = isUnlocked ? colors.green : colors.red;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Question mark or checkmark
            ctx.fillStyle = colors.black;
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(isUnlocked ? '✓' : '?', screen.x, screen.y - 1);
        }

        function drawRoomCode() {
            const roomKey = `${currentRoom.x},${currentRoom.y}`;
            const code = roomCodes[roomKey];
            
            // Draw code in top-left corner
            ctx.fillStyle = colors.yellow;
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`CODE: ${code.code}`, 10, 25);
            
            // Draw code components separately for clarity
            ctx.fillStyle = colors.cyan;
            ctx.font = '12px monospace';
            ctx.fillText(`(${code.number}-${code.letter})`, 10, 40);
        }
            const screen = isoToScreen(door.x, door.y);
            const isUnlocked = unlockedRooms.has(`${door.targetRoom.x},${door.targetRoom.y}`);
            
            // Door token
            ctx.fillStyle = isUnlocked ? colors.green : colors.red;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Question mark or checkmark
            ctx.fillStyle = colors.black;
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(isUnlocked ? '✓' : '?', screen.x, screen.y - 1);
        }

        function updateCodesDisplay() {
            const sortedCodes = Array.from(collectedCodes).sort();
            const codesText = sortedCodes.join(' ');
            codesDisplay.textContent = `CODES COLLECTED: ${collectedCodes.size}/25 | ${codesText}`;
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = colors.black;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const theme = roomThemes[currentRoom.y * 5 + currentRoom.x];
            
            // Draw room tiles
            for (let y = 0; y < roomTemplate.length; y++) {
                for (let x = 0; x < roomTemplate[y].length; x++) {
                    if (roomTemplate[y][x] === 1) {
                        drawIsoTile(x, y, theme.wall, 1);
                    } else {
                        drawIsoTile(x, y, theme.floor, 0);
                    }
                }
            }
            
            // Draw doors
            const doors = getDoors(currentRoom.x, currentRoom.y);
            doors.forEach(drawDoor);
            
            // Draw player
            drawPlayer(player.x, player.y);
            
            // Draw room code
            drawRoomCode();
            
            // Update status
            const theme_name = theme.name;
            const roomsUnlocked = unlockedRooms.size;
            statusDiv.textContent = `ROOM: [${currentRoom.x},${currentRoom.y}] ${theme_name} • ROOMS: ${roomsUnlocked}/25 • SCORE: ${score.toString().padStart(4, '0')}`;
            
            // Update codes display
            updateCodesDisplay();
        }

        function showQuestion(door) {
            const questionIndex = Math.floor(Math.random() * questions.length);
            const question = questions[questionIndex];
            
            questionText.textContent = question.q;
            answerOptions.innerHTML = '';
            
            question.answers.forEach((answer, index) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = `${index + 1}. ${answer}`;
                btn.onclick = () => answerQuestion(index === question.correct, door);
                answerOptions.appendChild(btn);
            });
            
            questionPanel.style.display = 'block';
        }

        function answerQuestion(correct, door) {
            questionPanel.style.display = 'none';
            
            if (correct) {
                score += 50;
                unlockedRooms.add(`${door.targetRoom.x},${door.targetRoom.y}`);
                transitionToRoom(door.targetRoom);
            } else {
                // Wrong answer - could add penalty or retry logic
                score = Math.max(0, score - 10);
                render();
            }
        }

        function transitionToRoom(newRoom) {
            if (isTransitioning) return;
            
            isTransitioning = true;
            transition.classList.add('active');
            
            setTimeout(() => {
                currentRoom = newRoom;
                // Reset player position to center of new room
                player.x = 5;
                player.y = 4;
                
                // Collect the room code if not already collected
                const roomKey = `${currentRoom.x},${currentRoom.y}`;
                const roomCode = roomCodes[roomKey];
                if (!collectedCodes.has(roomCode.code)) {
                    collectedCodes.add(roomCode.code);
                    score += 25; // Bonus for discovering new room
                }
                
                render();
                
                setTimeout(() => {
                    transition.classList.remove('active');
                    isTransitioning = false;
                }, 250);
            }, 250);
        }

        function movePlayer(dx, dy) {
            if (isTransitioning) return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Check bounds and walls
            if (newY >= 0 && newY < roomTemplate.length && 
                newX >= 0 && newX < roomTemplate[newY].length && 
                roomTemplate[newY][newX] === 0) {
                player.x = newX;
                player.y = newY;
                render();
            }
        }

        function interact() {
            if (isTransitioning) return;
            
            const doors = getDoors(currentRoom.x, currentRoom.y);
            const nearbyDoor = doors.find(door => 
                Math.abs(door.x - player.x) <= 1 && 
                Math.abs(door.y - player.y) <= 1
            );
            
            if (nearbyDoor) {
                const isUnlocked = unlockedRooms.has(`${nearbyDoor.targetRoom.x},${nearbyDoor.targetRoom.y}`);
                
                if (isUnlocked) {
                    transitionToRoom(nearbyDoor.targetRoom);
                } else {
                    showQuestion(nearbyDoor);
                }
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (questionPanel.style.display === 'block') return;
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
                case ' ':
                    e.preventDefault();
                    interact();
                    break;
            }
        });

        // Touch controls for mobile
        let touchStartX, touchStartY;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!touchStartX || !touchStartY || questionPanel.style.display === 'block') return;
            
            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            
            if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
                interact(); // Tap to interact
            } else if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 10) movePlayer(1, 0);
                else if (deltaX < -10) movePlayer(-1, 0);
            } else {
                if (deltaY > 10) movePlayer(0, 1);
                else if (deltaY < -10) movePlayer(0, -1);
            }
            
            touchStartX = touchStartY = null;
        });

        // Initialize game
        updateCodesDisplay();
        render();
    </script>
</body>
</html>