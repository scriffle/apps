<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cube Snake – Smooth Camera & Dynamic Arrow Keys</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: #222;
    }
    #score {
      position: absolute; top: 10px; left: 10px;
      color: #fff; font-family: sans-serif; font-size: 20px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <!-- Three.js is loaded via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /**********************************************************************
     * Overview:
     *
     * This version of Cube Snake makes two key improvements:
     *
     * 1. The arrow keys are now reinterpreted every frame according to the
     *    current face that the snake head occupies. That is, pressing “up”
     *    always makes the snake move upward on the screen—even if the snake
     *    has just wrapped to a new face.
     *
     * 2. The camera now moves smoothly (via interpolation) so that the snake’s
     *    head remains centered in the view. The camera’s desired position is
     *    computed relative to the current face’s orientation and then smoothly
     *    approached.
     *
     * (Other aspects—such as the snake moving on a 10×10 grid on each face,
     *  neighbor mapping for wrapping, food, scoring, etc.—remain as before.)
     **********************************************************************/

    // Global parameters
    const gridSize = 10;  // 10 cells per face (each face is 10x10)
    const L = gridSize;   // Cube side length (10 units)
    const cellSize = 1;   // Each cell is 1 unit square

    // Define each face’s local coordinate system.
    // For each face we define:
    //  • center: the center of the face (world space)
    //  • right: direction in which cell index i increases
    //  • down: direction in which cell index j increases (so top row is j=0)
    //  • normal: outward normal (pointing outside the cube)
    //  • viewUp: desired “up” vector for the camera when viewing that face.
    const faceData = {
      "front": {
        center: new THREE.Vector3(0, 0, L/2),
        right:  new THREE.Vector3(1, 0, 0),
        down:   new THREE.Vector3(0, -1, 0),
        normal: new THREE.Vector3(0, 0, 1),
        viewUp: new THREE.Vector3(0, 1, 0)
      },
      "back": {
        center: new THREE.Vector3(0, 0, -L/2),
        right:  new THREE.Vector3(-1, 0, 0),
        down:   new THREE.Vector3(0, -1, 0),
        normal: new THREE.Vector3(0, 0, -1),
        viewUp: new THREE.Vector3(0, 1, 0)
      },
      "right": {
        center: new THREE.Vector3(L/2, 0, 0),
        right:  new THREE.Vector3(0, 0, -1),
        down:   new THREE.Vector3(0, -1, 0),
        normal: new THREE.Vector3(1, 0, 0),
        viewUp: new THREE.Vector3(0, 1, 0)
      },
      "left": {
        center: new THREE.Vector3(-L/2, 0, 0),
        right:  new THREE.Vector3(0, 0, 1),
        down:   new THREE.Vector3(0, -1, 0),
        normal: new THREE.Vector3(-1, 0, 0),
        viewUp: new THREE.Vector3(0, 1, 0)
      },
      "top": {
        center: new THREE.Vector3(0, L/2, 0),
        right:  new THREE.Vector3(1, 0, 0),
        down:   new THREE.Vector3(0, 0, -1),
        normal: new THREE.Vector3(0, 1, 0),
        viewUp: new THREE.Vector3(0, 0, 1)
      },
      "bottom": {
        center: new THREE.Vector3(0, -L/2, 0),
        right:  new THREE.Vector3(1, 0, 0),
        down:   new THREE.Vector3(0, 0, 1),
        normal: new THREE.Vector3(0, -1, 0),
        viewUp: new THREE.Vector3(0, 0, -1)
      }
    };

    // Convert a given cell (face, i, j) into its world-space center.
    function localToWorld(face, i, j) {
      const fd = faceData[face];
      const offsetX = (i + 0.5 - gridSize/2) * cellSize;
      const offsetY = (j + 0.5 - gridSize/2) * cellSize;
      let pos = fd.center.clone();
      pos.add(fd.right.clone().multiplyScalar(offsetX));
      pos.add(fd.down.clone().multiplyScalar(offsetY));
      return pos;
    }

    // ------------------------------------------------------------
    // Neighbor Mapping (for wrapping the snake onto adjacent faces)
    // (One possible mapping for a cube unfolded as:
    //         [TOP]
    // [LEFT] [FRONT] [RIGHT] [BACK]
    //         [BOTTOM]
    // )
    // Each mapping specifies:
    //   • the adjacent face,
    //   • a transform function for (i,j),
    //   • and a new local direction (0,1,2,3) for the snake.
    const neighborMapping = {
      "front": {
        0: { face: "top",    transform: (i, j) => ({ i: i,     j: gridSize - 1 }), newDir: 0 },
        1: { face: "right",  transform: (i, j) => ({ i: 0,     j: j }),           newDir: 1 },
        2: { face: "bottom", transform: (i, j) => ({ i: i,     j: 0 }),               newDir: 2 },
        3: { face: "left",   transform: (i, j) => ({ i: gridSize - 1, j: j }),         newDir: 3 }
      },
      "back": {
        0: { face: "top",    transform: (i, j) => ({ i: gridSize - 1 - i, j: 0 }),         newDir: 2 },
        1: { face: "left",   transform: (i, j) => ({ i: 0,             j: j }),           newDir: 1 },
        2: { face: "bottom", transform: (i, j) => ({ i: gridSize - 1 - i, j: gridSize - 1 }), newDir: 0 },
        3: { face: "right",  transform: (i, j) => ({ i: gridSize - 1,   j: j }),           newDir: 3 }
      },
      "right": {
        0: { face: "top",    transform: (i, j) => ({ i: j,             j: gridSize - 1 }), newDir: 0 },
        1: { face: "back",   transform: (i, j) => ({ i: 0,             j: gridSize - 1 - j }), newDir: 1 },
        2: { face: "bottom", transform: (i, j) => ({ i: gridSize - 1 - j, j: 0 }),           newDir: 2 },
        3: { face: "front",  transform: (i, j) => ({ i: gridSize - 1,   j: j }),           newDir: 3 }
      },
      "left": {
        0: { face: "top",    transform: (i, j) => ({ i: gridSize - 1 - j, j: gridSize - 1 }), newDir: 0 },
        1: { face: "front",  transform: (i, j) => ({ i: 0,             j: j }),           newDir: 1 },
        2: { face: "bottom", transform: (i, j) => ({ i: j,             j: 0 }),               newDir: 2 },
        3: { face: "back",   transform: (i, j) => ({ i: gridSize - 1,   j: gridSize - 1 - j }), newDir: 3 }
      },
      "top": {
        0: { face: "back",   transform: (i, j) => ({ i: gridSize - 1 - i, j: gridSize - 1 }), newDir: 0 },
        1: { face: "right",  transform: (i, j) => ({ i: gridSize - 1,   j: i }),             newDir: 1 },
        2: { face: "front",  transform: (i, j) => ({ i: i,             j: 0 }),                 newDir: 2 },
        3: { face: "left",   transform: (i, j) => ({ i: 0,             j: gridSize - 1 - i }), newDir: 3 }
      },
      "bottom": {
        0: { face: "front",  transform: (i, j) => ({ i: i,             j: gridSize - 1 }), newDir: 0 },
        1: { face: "right",  transform: (i, j) => ({ i: 0,             j: gridSize - 1 - i }), newDir: 1 },
        2: { face: "back",   transform: (i, j) => ({ i: gridSize - 1 - i, j: 0 }),           newDir: 2 },
        3: { face: "left",   transform: (i, j) => ({ i: gridSize - 1,   j: i }),             newDir: 3 }
      }
    };

    // ------------------------------------------------------------
    // Compute Arrow-Key Mapping for the current face.
    //
    // For the current face, we want the keys to be interpreted relative to
    // the viewer’s orientation. We compute the desired direction vectors for
    // each arrow key (using the camera’s “up” and an approximated “right” vector)
    // and then choose which of the local grid directions (up, right, down, left)
    // they best match.
    //
    // Local grid directions (in world space) are defined as:
    //   grid-up    = –(face.down)
    //   grid-right =  face.right
    //   grid-down  =  face.down
    //   grid-left  = –(face.right)
    //
    // These will be mapped to codes 0, 1, 2, 3 respectively.
    function computeKeyMapping(face) {
      let fd = faceData[face];
      // Approximate the camera's orientation for this face:
      // Use the face's viewUp as camera up.
      let camUp = fd.viewUp.clone().normalize();
      // For forward, we assume the camera is roughly looking along -fd.normal.
      let forward = fd.normal.clone().negate().normalize();
      // Compute a right vector as: right = forward x camUp.
      let camRight = new THREE.Vector3().crossVectors(forward, camUp).normalize();
      // Desired directions (in world space) for the arrow keys:
      let desired = {
        ArrowUp: camUp.clone(),                   // upward on the screen
        ArrowRight: camRight.clone(),             // rightward on the screen
        ArrowDown: camUp.clone().negate(),         // down
        ArrowLeft: camRight.clone().negate()       // left
      };
      // Local grid directions for this face:
      let local = {
        up: fd.down.clone().negate().normalize(),    // local grid up (decrease j)
        right: fd.right.clone().normalize(),           // local grid right (increase i)
        down: fd.down.clone().normalize(),             // local grid down (increase j)
        left: fd.right.clone().negate().normalize()      // local grid left (decrease i)
      };
      // For each desired direction, pick the local direction whose dot product is highest.
      function bestMatch(desiredVec) {
        let best = null, bestDot = -Infinity;
        for (let [key, localVec] of Object.entries(local)) {
          let dot = desiredVec.dot(localVec);
          if (dot > bestDot) {
            bestDot = dot;
            best = key;
          }
        }
        // Map keys to our local direction codes:
        if (best === "up") return 0;
        if (best === "right") return 1;
        if (best === "down") return 2;
        if (best === "left") return 3;
      }
      return {
        ArrowUp: bestMatch(desired.ArrowUp),
        ArrowRight: bestMatch(desired.ArrowRight),
        ArrowDown: bestMatch(desired.ArrowDown),
        ArrowLeft: bestMatch(desired.ArrowLeft)
      };
    }

    // Global variable to hold the current key mapping (updated each frame).
    let currentKeyMapping = {};

    // ------------------------------------------------------------
    // Three.js Scene, Camera, and Renderer Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      60, window.innerWidth/window.innerHeight, 0.1, 1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a cube for context.
    // Increase opacity (0.8) so the faces are less translucent.
    const cubeGeometry = new THREE.BoxGeometry(L, L, L);
    const cubeMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      opacity: 0.8,
      transparent: true,
      depthWrite: false
    });
    const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
    scene.add(cubeMesh);

    // ------------------------------------------------------------
    // Draw Grid Lines on Each Face
    function drawGridOnFace(face) {
      const fd = faceData[face];
      const grid = new THREE.Group();
      const material = new THREE.LineBasicMaterial({ color: 0x888888 });
      // Horizontal grid lines.
      for (let j = 0; j <= gridSize; j++) {
        let points = [];
        for (let i = 0; i <= gridSize; i++) {
          let offsetX = (i - gridSize/2) * cellSize;
          let offsetY = (j - gridSize/2) * cellSize;
          let pt = fd.center.clone();
          pt.add(fd.right.clone().multiplyScalar(offsetX));
          pt.add(fd.down.clone().multiplyScalar(offsetY));
          points.push(pt);
        }
        let geometry = new THREE.BufferGeometry().setFromPoints(points);
        let line = new THREE.Line(geometry, material);
        grid.add(line);
      }
      // Vertical grid lines.
      for (let i = 0; i <= gridSize; i++) {
        let points = [];
        for (let j = 0; j <= gridSize; j++) {
          let offsetX = (i - gridSize/2) * cellSize;
          let offsetY = (j - gridSize/2) * cellSize;
          let pt = fd.center.clone();
          pt.add(fd.right.clone().multiplyScalar(offsetX));
          pt.add(fd.down.clone().multiplyScalar(offsetY));
          points.push(pt);
        }
        let geometry = new THREE.BufferGeometry().setFromPoints(points);
        let line = new THREE.Line(geometry, material);
        grid.add(line);
      }
      scene.add(grid);
    }
    for (let face in faceData) {
      drawGridOnFace(face);
    }

    // ------------------------------------------------------------
    // Snake Game State
    // Each segment is stored as { face, i, j, dir } (dir: 0=up, 1=right, 2=down, 3=left).
    let snake = [];
    // Start at the center of the front face.
    snake.push({
      face: "front",
      i: Math.floor(gridSize/2),
      j: Math.floor(gridSize/2),
      dir: 0
    });
    let snakeMeshes = [];
    function createSnakeMeshes() {
      snakeMeshes.forEach(mesh => scene.remove(mesh));
      snakeMeshes = [];
      const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      for (let seg of snake) {
        let mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
        snakeMeshes.push(mesh);
      }
    }
    createSnakeMeshes();

    // ------------------------------------------------------------
    // Food State
    let food = null;
    let foodMesh = null;
    function placeFood() {
      const faces = Object.keys(faceData);
      let valid = false, face, i, j;
      while (!valid) {
        face = faces[Math.floor(Math.random() * faces.length)];
        i = Math.floor(Math.random() * gridSize);
        j = Math.floor(Math.random() * gridSize);
        valid = true;
        for (let seg of snake) {
          if (seg.face === face && seg.i === i && seg.j === j) {
            valid = false;
            break;
          }
        }
      }
      food = { face, i, j };
      if (foodMesh) scene.remove(foodMesh);
      const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      foodMesh = new THREE.Mesh(geometry, material);
      scene.add(foodMesh);
      foodMesh.position.copy(localToWorld(face, i, j));
    }
    placeFood();
    let score = 0;
    document.getElementById("score").innerText = "Score: " + score;

    // ------------------------------------------------------------
    // Input Handling – Arrow keys (using the dynamic mapping)
    window.addEventListener("keydown", function(e) {
      // Only process arrow keys.
      if (!["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"].includes(e.key)) return;
      // Get the current mapping based on the snake head's face.
      let mapping = currentKeyMapping;
      let newDir = mapping[e.key];
      let head = snake[0];
      // Prevent 180° reversal.
      if ((head.dir + 2) % 4 === newDir) return;
      head.dir = newDir;
    });

    // ------------------------------------------------------------
    // Snake Movement Update
    function updateSnake() {
      const head = snake[0];
      let di = 0, dj = 0;
      // Interpret head.dir in local grid coordinates:
      // 0: up → decrease j; 1: right → increase i; 2: down → increase j; 3: left → decrease i.
      if (head.dir === 0) dj = -1;
      else if (head.dir === 1) di = 1;
      else if (head.dir === 2) dj = 1;
      else if (head.dir === 3) di = -1;
      let new_i = head.i + di;
      let new_j = head.j + dj;
      let new_face = head.face;
      let new_dir = head.dir;
      // If moving off the current face, use neighborMapping.
      if (new_i < 0 || new_i >= gridSize || new_j < 0 || new_j >= gridSize) {
        let mapping = neighborMapping[head.face][head.dir];
        new_face = mapping.face;
        let transformed = mapping.transform(head.i, head.j);
        new_i = transformed.i;
        new_j = transformed.j;
        new_dir = mapping.newDir;
      }
      const newHead = { face: new_face, i: new_i, j: new_j, dir: new_dir };

      // Check self-collision.
      for (let seg of snake) {
        if (seg.face === newHead.face && seg.i === newHead.i && seg.j === newHead.j) {
          alert("Game Over! Score: " + score);
          // Reset the game.
          snake = [];
          snake.push({
            face: "front",
            i: Math.floor(gridSize/2),
            j: Math.floor(gridSize/2),
            dir: 0
          });
          score = 0;
          document.getElementById("score").innerText = "Score: " + score;
          createSnakeMeshes();
          return;
        }
      }
      snake.unshift(newHead);
      // If food is eaten, increase score and place new food; otherwise, remove tail.
      if (newHead.face === food.face && newHead.i === food.i && newHead.j === food.j) {
        score++;
        document.getElementById("score").innerText = "Score: " + score;
        placeFood();
      } else {
        snake.pop();
      }
      createSnakeMeshes();
    }
    const gameInterval = setInterval(updateSnake, 300);

    // ------------------------------------------------------------
    // Rendering and Smooth Camera Tracking
    // We'll compute a desired camera position and target based on the snake head,
    // then interpolate (lerp) toward those values.
    function animate() {
      requestAnimationFrame(animate);

      // Update snake and food mesh positions.
      for (let i = 0; i < snake.length; i++) {
        const seg = snake[i];
        const pos = localToWorld(seg.face, seg.i, seg.j);
        snakeMeshes[i].position.copy(pos);
      }
      if (foodMesh) {
        foodMesh.position.copy(localToWorld(food.face, food.i, food.j));
      }

      // --- Update Current Key Mapping ---
      // Based on the current face of the snake's head.
      currentKeyMapping = computeKeyMapping(snake[0].face);

      // --- Compute Desired Camera Position and Target ---
      let head = snake[0];
      let fd = faceData[head.face];
      let headPos = localToWorld(head.face, head.i, head.j);
      // For movement vector in world space based on the current face's axes.
      let moveVec = new THREE.Vector3();
      if (head.dir === 0) moveVec.copy(fd.down).multiplyScalar(-1);
      else if (head.dir === 1) moveVec.copy(fd.right);
      else if (head.dir === 2) moveVec.copy(fd.down);
      else if (head.dir === 3) moveVec.copy(fd.right).multiplyScalar(-1);
      
      // Desired target is the snake head (so the head remains centered).
      let desiredTarget = headPos.clone();

      // Compute desired camera position:
      //  • Move out along the face's normal,
      //  • Then add an upward offset along viewUp,
      //  • And subtract a bit along the movement direction so we see behind the head.
      const normalDist = 12, upDist = 6, backDist = 8;
      let desiredCamPos = headPos.clone()
                            .add(fd.normal.clone().multiplyScalar(normalDist))
                            .add(fd.viewUp.clone().multiplyScalar(upDist))
                            .sub(moveVec.clone().multiplyScalar(backDist));

      // --- Smoothly Interpolate Camera Position and Target ---
      // (Using a lerp factor of 0.1 for smooth motion.)
      camera.position.lerp(desiredCamPos, 0.1);
      if (!camera.userData.target) {
        camera.userData.target = desiredTarget.clone();
      } else {
        camera.userData.target.lerp(desiredTarget, 0.1);
      }
      camera.lookAt(camera.userData.target);

      renderer.render(scene, camera);
    }
    animate();

    // Adjust renderer on window resize.
    window.addEventListener("resize", function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
