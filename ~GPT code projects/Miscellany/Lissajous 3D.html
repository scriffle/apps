<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lissajous Cube</n>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 4px; }
    #ui label { display: block; margin: 5px 0; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Frequency X: <input type="range" id="freqX" min="1" max="12" value="1"></label>
    <label>Frequency Y: <input type="range" id="freqY" min="1" max="12" value="1"></label>
    <label>Frequency Z: <input type="range" id="freqZ" min="1" max="12" value="1"></label>
    <label>Rotation Speed: <input type="range" id="rotSpeed" min="0" max="5" step="0.1" value="1"></label>
    <label><input type="radio" name="mode" id="modeLine" value="line" checked> Wireframe Curve</label>
    <label><input type="radio" name="mode" id="modeSolid" value="solid"> Solid Curve</label>
    <label><input type="checkbox" id="colorCurve" checked> Color Curve</label>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3, 3, 3);
    camera.lookAt(0, 0, 0);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Bounding box (static)
    const boxGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(2, 2, 2));
    const boxMat = new THREE.LineBasicMaterial({ color: 0xffffff });
    const boxWire = new THREE.LineSegments(boxGeo, boxMat);
    scene.add(boxWire);

    // Curve group
    const curveGroup = new THREE.Group();
    scene.add(curveGroup);

    // Wireframe curve
    const lineGeo = new THREE.BufferGeometry();
    const lineMat = new THREE.LineBasicMaterial({ vertexColors: true });
    const curveLine = new THREE.Line(lineGeo, lineMat);
    curveGroup.add(curveLine);

    // Solid tube curve
    let curveTube;
    const tubeMat = new THREE.MeshBasicMaterial({ vertexColors: true });
    function createInitialTube() {
      const geo = new THREE.BufferGeometry();
      curveTube = new THREE.Mesh(geo, tubeMat);
      curveGroup.add(curveTube);
    }
    createInitialTube();

    // UI elements
    const freqX = document.getElementById('freqX');
    const freqY = document.getElementById('freqY');
    const freqZ = document.getElementById('freqZ');
    const rotSpeed = document.getElementById('rotSpeed');
    const modeLine = document.getElementById('modeLine');
    const modeSolid = document.getElementById('modeSolid');
    const colorCurve = document.getElementById('colorCurve');

    // Handle resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Update curve data
    function updateCurve() {
      const a = +freqX.value;
      const b = +freqY.value;
      const c = +freqZ.value;
      const segments = 1000;
      const positions = [];
      const colors = [];

      // Generate path points
      const pathPoints = [];
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * Math.PI * 2;
        const x = Math.sin(a * t);
        const y = Math.sin(b * t);
        const z = Math.sin(c * t);
        positions.push(x, y, z);
        pathPoints.push(new THREE.Vector3(x, y, z));

        if (colorCurve.checked) {
          const col = new THREE.Color();
          col.setHSL(i / segments, 1, 0.5);
          colors.push(col.r, col.g, col.b);
        } else {
          colors.push(1, 0, 0);
        }
      }

      // Update wireframe line
      lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      lineGeo.attributes.position.needsUpdate = true;
      lineGeo.attributes.color.needsUpdate = true;

      // Update solid tube
      const radius = 0.02;
      const radialSegments = 8;
      // Dispose old geometry
      if (curveTube.geometry) curveTube.geometry.dispose();
      const tubeGeo = new THREE.TubeBufferGeometry(
        new THREE.CatmullRomCurve3(pathPoints),
        segments,
        radius,
        radialSegments,
        false
      );
      // Vertex colors for tube
      const posAttr = tubeGeo.attributes.position;
      const count = posAttr.count;
      const tubeColors = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const pathIndex = Math.floor(i / (radialSegments + 1));
        const hue = pathIndex / segments;
        const col = new THREE.Color();
        col.setHSL(hue, 1, 0.5);
        tubeColors[i * 3] = col.r;
        tubeColors[i * 3 + 1] = col.g;
        tubeColors[i * 3 + 2] = col.b;
      }
      tubeGeo.setAttribute('color', new THREE.Float32BufferAttribute(tubeColors, 3));
      curveTube.geometry = tubeGeo;

      // Toggle visibility
      curveLine.visible = modeLine.checked;
      curveTube.visible = modeSolid.checked;
    }

    // Event listeners
    [freqX, freqY, freqZ, colorCurve, modeLine, modeSolid].forEach(el => el.addEventListener('input', updateCurve));
    updateCurve();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      const speed = +rotSpeed.value * 0.01;
      curveGroup.rotation.x += speed;
      curveGroup.rotation.y += speed;
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
