<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabBoost - Level Up Your Words</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            padding: 10px;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.8em;
            display: inline-block;
        }

        .tagline {
            text-align: center;
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .header-row {
            text-align: center;
            margin-bottom: 15px;
        }

        .word-display {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
            text-align: center;
            border: 2px solid #667eea;
        }

        .current-word {
            font-size: 2.2em;
            color: #667eea;
            font-weight: bold;
            margin-bottom: 5px;
            animation: slideIn 0.5s ease-out;
            display: inline-block;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .phonetic {
            color: #888;
            font-size: 1em;
            font-style: italic;
            margin-bottom: 10px;
            display: inline-block;
            margin-left: 15px;
        }

        .micro-level-indicator {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            display: inline-block;
            font-weight: bold;
            font-size: 0.9em;
        }

        .word-line {
            margin-bottom: 10px;
        }

        .options-container {
            margin-bottom: 15px;
        }

        .option {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-size: 0.95em;
        }

        .option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option.correct {
            border-color: #4caf50;
            background: #e8f5e9;
            animation: correctPulse 0.6s ease;
        }

        .option.incorrect {
            border-color: #f44336;
            background: #ffebee;
            animation: shake 0.5s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .option-number {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            font-weight: bold;
            margin-right: 10px;
            font-size: 0.9em;
        }

        .option.correct .option-number {
            background: #4caf50;
        }

        .option.incorrect .option-number {
            background: #f44336;
        }

        .submit-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .submit-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .submit-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            flex-wrap: wrap;
            background: #f5f5f5;
            border-radius: 10px;
            padding: 10px;
        }

        .stat-box {
            text-align: center;
            flex: 1;
            margin: 0 5px;
            min-width: 100px;
        }

        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
            display: inline-block;
            margin-right: 5px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #666;
            display: inline-block;
        }

        .user-section {
            text-align: center;
            margin-bottom: 15px;
        }

        .user-name-input {
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #667eea;
            font-size: 0.95em;
            width: 200px;
        }

        .level-select {
            margin-bottom: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        select {
            padding: 8px 15px;
            font-size: 0.95em;
            border-radius: 8px;
            border: 2px solid #667eea;
            background: white;
            color: #333;
            cursor: pointer;
        }

        .level-locked {
            opacity: 0.6;
            background: #f0f0f0;
        }

        .progress-bar {
            width: 100%;
            height: 15px;
            background: #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .micro-progress-container {
            margin-bottom: 15px;
        }

        .micro-progress-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.85em;
        }

        .micro-progress-bar {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 0 10px;
            overflow: hidden;
        }

        .micro-progress-fill {
            height: 100%;
            background: #667eea;
            transition: width 0.3s ease;
        }

        .micro-progress-fill.complete {
            background: #4caf50;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .btn-secondary {
            padding: 8px 20px;
            background: #e0e0e0;
            color: #666;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
            transform: translateY(-1px);
        }

        .btn-secondary.active {
            background: #667eea;
            color: white;
        }

        .feedback {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 10px;
            font-weight: bold;
            animation: fadeIn 0.5s ease;
            font-size: 0.95em;
        }

        .feedback.correct {
            background: #e8f5e9;
            color: #4caf50;
        }

        .feedback.incorrect {
            background: #ffebee;
            color: #f44336;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .next-button {
            background: #4caf50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 5px;
        }

        .next-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .dashboard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .dashboard-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            margin: 0 auto;
            position: relative;
        }

        .close-dashboard {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.5em;
            cursor: pointer;
            color: #666;
        }

        .level-card {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid transparent;
        }

        .level-card.unlocked {
            border-color: #4caf50;
            background: #f8fff8;
        }

        .level-card.current {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .level-card.locked {
            opacity: 0.7;
        }

        .review-word-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #e0e0e0;
        }

        .review-word-card.incorrect {
            border-color: #f44336;
            background: #fff5f5;
        }

        .review-word-card.learned {
            border-color: #4caf50;
            background: #f5fff5;
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            .current-word {
                font-size: 1.8em;
            }
            
            .option {
                padding: 10px;
            }
            
            .phonetic {
                display: block;
                margin-left: 0;
                margin-top: 5px;
            }
            
            .stat-box {
                min-width: 80px;
            }
            
            .level-select {
                flex-wrap: wrap;
            }
            
            .control-buttons {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h1>VocabBoost üìö</h1>
        </div>
        <p class="tagline">Master vocabulary through smart multiple choice</p>

        <div id="wordDisplay" class="word-display">
            <div class="loading">Loading your first word...</div>
        </div>

        <div id="quizArea"></div>

        <div class="stats">
            <div class="stat-box">
                <span class="stat-number" id="totalWords">0</span>
                <span class="stat-label">Mastered</span>
            </div>
            <div class="stat-box">
                <span class="stat-number" id="currentScore">0</span>
                <span class="stat-label">Score</span>
            </div>
            <div class="stat-box">
                <span class="stat-number" id="accuracy">0%</span>
                <span class="stat-label">Accuracy</span>
            </div>
        </div>

        <div class="user-section">
            <input type="text" class="user-name-input" id="userName" placeholder="Enter your name" onchange="saveName()">
        </div>

        <div class="micro-progress-container" id="microProgressContainer">
            <!-- Micro level progress bars will be inserted here -->
        </div>

        <div class="control-buttons">
            <button class="btn-secondary" onclick="toggleMode('quiz')">Quiz Mode</button>
            <button class="btn-secondary" onclick="toggleMode('review')">Review Mode</button>
            <button class="btn-secondary" onclick="showDashboard()">Progress Dashboard</button>
        </div>

        <div class="level-select">
            <label>Difficulty:</label>
            <select id="difficultyLevel" onchange="changeDifficulty()">
                <option value="1">Level 1 - Beginner</option>
                <option value="2">Level 2 - Elementary</option>
                <option value="3">Level 3 - Intermediate</option>
                <option value="4">Level 4 - Advanced</option>
                <option value="5">Level 5 - Expert</option>
            </select>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="levelProgress" style="width: 0%"></div>
        </div>
        <p style="text-align: center; color: #666; font-size: 0.85em; margin: 0;" id="progressText">Level Progress: 0%</p>
    </div>

    <div class="dashboard-modal" id="dashboardModal">
        <div class="dashboard-content">
            <span class="close-dashboard" onclick="closeDashboard()">√ó</span>
            <h2>Progress Dashboard</h2>
            <div id="dashboardContent"></div>
        </div>
    </div>

    <script>
        // Word lists will be loaded from server
        let wordLists = {};
        let isLoadingWords = false;
        let wordListsLoaded = false;

        // Load word lists from server
        async function loadWordLists() {
            if (isLoadingWords || wordListsLoaded) return;
            
            isLoadingWords = true;
            
            try {
                // Load all levels in parallel
                const levels = [1, 2, 3, 4, 5, 'extreme'];
                const promises = levels.map(async (level) => {
                    const filename = level === 'extreme' ? 'level-extreme.json' : `level-${level}.json`;
                    const response = await fetch(`words/${filename}`);
                    if (!response.ok) {
                        throw new Error(`Failed to load words for level ${level}`);
                    }
                    const data = await response.json();
                    return { level: level === 'extreme' ? 6 : level, data };
                });
                
                const results = await Promise.all(promises);
                
                // Store word lists
                results.forEach(({ level, data }) => {
                    wordLists[level] = data.words;
                });
                
                wordListsLoaded = true;
                console.log('Word lists loaded successfully');
                
                // Update UI to show extreme level if loaded
                if (wordLists[6] && wordLists[6].length > 0) {
                    updateLevelSelector();
                }
                
            } catch (error) {
                console.error('Error loading word lists:', error);
                // Fallback to basic words if loading fails
                wordLists = {
                    1: [
                        {word: 'happy', pos: 'adjective'},
                        {word: 'brave', pos: 'adjective'},
                        {word: 'quick', pos: 'adjective'},
                        {word: 'simple', pos: 'adjective'},
                        {word: 'kind', pos: 'adjective'}
                    ],
                    2: [{word: 'achieve', pos: 'verb'}],
                    3: [{word: 'analyze', pos: 'verb'}],
                    4: [{word: 'hypothesis', pos: 'noun'}],
                    5: [{word: 'paradigm', pos: 'noun'}]
                };
                wordListsLoaded = true;
            } finally {
                isLoadingWords = false;
            }
        }

        // Update level selector to include extreme level if available
        function updateLevelSelector() {
            const levelSelect = document.getElementById('difficultyLevel');
            
            // Check if extreme option already exists
            const hasExtreme = Array.from(levelSelect.options).some(opt => opt.value === '6');
            
            if (!hasExtreme && wordLists[6] && wordLists[6].length > 0) {
                const option = document.createElement('option');
                option.value = '6';
                option.text = 'Level 6 - Extreme';
                levelSelect.appendChild(option);
                
                // Also update level unlocked state
                if (!appState.levelUnlocked[6]) {
                    appState.levelUnlocked[6] = false;
                }
            }
        }

        // Track recently used distractors to avoid repetition
        let recentDistracterWords = [];

        // App state
        let appState = {
            userName: '',
            currentMode: 'quiz', // 'quiz' or 'review'
            currentLevel: 1,
            currentMicroLevel: 2,
            currentWord: null,
            currentWordData: null,
            currentDefinitions: [],
            selectedOption: null,
            isAnswered: false,
            wordHistory: [], // Words shown in current session
            attemptHistory: [], // All attempts stored with full details
            levelScores: {}, // Scores for each level and micro-level
            levelUnlocked: {1: true, 2: false, 3: false, 4: false, 5: false}
        };

        // Initialize level scores structure
        function initializeLevelScores() {
            for (let level = 1; level <= 6; level++) {
                appState.levelScores[level] = {};
                for (let micro = 2; micro <= 6; micro++) {
                    appState.levelScores[level][micro] = {
                        correct: 0,
                        total: 0,
                        recentScores: [], // Last 20 scores for rolling average
                        percentage: 0
                    };
                }
            }
        }

        // Load state from localStorage
        function loadState() {
            const saved = localStorage.getItem('vocabQuizState');
            if (saved) {
                const savedState = JSON.parse(saved);
                appState = {...appState, ...savedState};
            }
            
            if (!appState.levelScores || Object.keys(appState.levelScores).length === 0) {
                initializeLevelScores();
            }
            
            // Load user name
            const savedName = localStorage.getItem('vocabUserName');
            if (savedName) {
                appState.userName = savedName;
                document.getElementById('userName').value = savedName;
            }
            
            updateUI();
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('vocabQuizState', JSON.stringify(appState));
        }

        // Save user name
        function saveName() {
            const name = document.getElementById('userName').value;
            appState.userName = name;
            localStorage.setItem('vocabUserName', name);
        }

        // Update UI elements
        function updateUI() {
            // Update basic stats
            const totalCorrect = appState.attemptHistory.filter(a => a.correct || a.learned).length;
            const totalAttempts = appState.attemptHistory.length;
            const accuracy = totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0;
            
            document.getElementById('totalWords').textContent = totalCorrect;
            document.getElementById('currentScore').textContent = totalCorrect;
            document.getElementById('accuracy').textContent = `${accuracy}%`;
            
            // Update level selector visual state
            const levelSelect = document.getElementById('difficultyLevel');
            const currentLevel = appState.currentLevel;
            
            // Update level options to show locked/unlocked state
            for (let i = 0; i < levelSelect.options.length; i++) {
                const level = i + 1;
                const option = levelSelect.options[i];
                if (!appState.levelUnlocked[level] && level !== currentLevel) {
                    option.classList.add('level-locked');
                    option.text = option.text.split(' (')[0] + ' (Locked)';
                } else {
                    option.classList.remove('level-locked');
                    option.text = option.text.split(' (')[0];
                }
            }
            
            // Update micro progress
            updateMicroProgress();
            
            // Update overall level progress
            updateLevelProgress();
            
            // Update mode buttons
            document.querySelectorAll('.control-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (appState.currentMode === 'quiz') {
                document.querySelector('.control-buttons button:first-child').classList.add('active');
            } else if (appState.currentMode === 'review') {
                document.querySelector('.control-buttons button:nth-child(2)').classList.add('active');
            }
        }

        // Update micro level progress display
        function updateMicroProgress() {
            const container = document.getElementById('microProgressContainer');
            container.innerHTML = '';
            
            const level = appState.currentLevel;
            for (let micro = 2; micro <= 6; micro++) {
                const score = appState.levelScores[level][micro];
                const percentage = score.percentage;
                const isComplete = percentage >= 95;
                
                const row = document.createElement('div');
                row.className = 'micro-progress-row';
                row.innerHTML = `
                    <span>${micro} Options:</span>
                    <div class="micro-progress-bar">
                        <div class="micro-progress-fill ${isComplete ? 'complete' : ''}" 
                             style="width: ${percentage}%"></div>
                    </div>
                    <span>${percentage}%</span>
                `;
                container.appendChild(row);
            }
        }

        // Update overall level progress
        function updateLevelProgress() {
            const level = appState.currentLevel;
            let totalPercentage = 0;
            let completedMicroLevels = 0;
            
            for (let micro = 2; micro <= 6; micro++) {
                const score = appState.levelScores[level][micro];
                totalPercentage += score.percentage;
                if (score.percentage >= 95) {
                    completedMicroLevels++;
                }
            }
            
            const averagePercentage = Math.round(totalPercentage / 5);
            document.getElementById('levelProgress').style.width = `${averagePercentage}%`;
            document.getElementById('progressText').textContent = 
                `Level Progress: ${averagePercentage}% (${completedMicroLevels}/5 micro-levels complete)`;
            
            // Check if level should be unlocked
            if (completedMicroLevels === 5) {
                const nextLevel = level + 1;
                const maxLevel = wordLists[6] ? 6 : 5;
                
                if (nextLevel <= maxLevel && !appState.levelUnlocked[nextLevel]) {
                    appState.levelUnlocked[nextLevel] = true;
                    saveState();
                }
            }
        }

        // Record an attempt
        function recordAttempt(correct) {
            const attempt = {
                word: appState.currentWord,
                level: appState.currentLevel,
                microLevel: appState.currentMicroLevel,
                definitions: appState.currentDefinitions,
                selectedIndex: appState.selectedOption,
                correctIndex: appState.currentDefinitions.indexOf(getDefinition(appState.currentWordData)),
                correct: correct,
                learned: false,
                timestamp: new Date().toISOString()
            };
            
            appState.attemptHistory.push(attempt);
            
            // Update scores
            const levelScore = appState.levelScores[appState.currentLevel][appState.currentMicroLevel];
            levelScore.total++;
            if (correct) {
                levelScore.correct++;
            }
            
            // Update rolling average (last 20)
            levelScore.recentScores.push(correct ? 1 : 0);
            if (levelScore.recentScores.length > 20) {
                levelScore.recentScores.shift();
            }
            
            // Calculate percentage based on recent scores
            if (levelScore.recentScores.length >= 20) {
                const recentCorrect = levelScore.recentScores.reduce((a, b) => a + b, 0);
                levelScore.percentage = Math.round((recentCorrect / 20) * 100);
            } else {
                levelScore.percentage = Math.round((levelScore.correct / levelScore.total) * 100);
            }
            
            saveState();
            updateUI();
        }

        // Toggle between quiz and review mode
        function toggleMode(mode) {
            appState.currentMode = mode;
            updateUI();
            
            if (mode === 'review') {
                displayReviewMode();
            } else {
                displayWord();
            }
        }

        // Display review mode
        function displayReviewMode() {
            const reviewWords = appState.attemptHistory.filter(a => 
                a.level === appState.currentLevel
            );
            
            if (reviewWords.length === 0) {
                document.getElementById('wordDisplay').innerHTML = `
                    <div class="loading">No words to review at this level yet</div>
                `;
                document.getElementById('quizArea').innerHTML = '';
                return;
            }
            
            // Group by word
            const wordGroups = {};
            reviewWords.forEach(attempt => {
                if (!wordGroups[attempt.word]) {
                    wordGroups[attempt.word] = [];
                }
                wordGroups[attempt.word].push(attempt);
            });
            
            document.getElementById('wordDisplay').innerHTML = `
                <h3>Review Mode - Level ${appState.currentLevel}</h3>
                <p>Click on any word to retry it</p>
            `;
            
            let reviewHTML = '<div class="review-container">';
            for (const word in wordGroups) {
                const attempts = wordGroups[word];
                const lastAttempt = attempts[attempts.length - 1];
                const wasLearned = attempts.some(a => a.learned);
                const isCorrect = lastAttempt.correct || wasLearned;
                
                reviewHTML += `
                    <div class="review-word-card ${isCorrect ? (wasLearned ? 'learned' : '') : 'incorrect'}" 
                         onclick="retryWord('${word}')">
                        <strong>${word}</strong>
                        <span style="float: right">
                            ${isCorrect ? '‚úì' : '‚úó'} 
                            ${wasLearned ? '(Learned)' : ''}
                        </span>
                    </div>
                `;
            }
            reviewHTML += '</div>';
            
            document.getElementById('quizArea').innerHTML = reviewHTML;
        }

        // Retry a word from review
        function retryWord(word) {
            appState.currentMode = 'quiz';
            appState.currentWord = word;
            updateUI();
            loadWordForRetry(word);
        }

        // Load a specific word for retry
        async function loadWordForRetry(word) {
            document.getElementById('wordDisplay').innerHTML = '<div class="loading">Loading word...</div>';
            document.getElementById('quizArea').innerHTML = '';
            
            const wordData = await fetchWord(word);
            if (!wordData) {
                displayWord();
                return;
            }
            
            // Find the word object to get part of speech
            const wordObj = wordLists[appState.currentLevel].find(w => w.word === word);
            const pos = wordObj ? wordObj.pos : 'word';
            
            appState.currentWord = word;
            appState.currentWordData = wordData;
            
            const correctDef = getDefinition(wordData);
            const wrongDefs = await getRandomDefinitions(appState.currentLevel, word, appState.currentMicroLevel);
            
            const allOptions = [correctDef, ...wrongDefs];
            appState.currentDefinitions = shuffleArray(allOptions);
            appState.selectedOption = null;
            appState.isAnswered = false;
            
            // Display word
            const phonetic = wordData.phonetic || '';
            document.getElementById('wordDisplay').innerHTML = `
                <div class="word-line">
                    <span class="micro-level-indicator">${appState.currentMicroLevel} Options (Retry)</span>
                </div>
                <div class="word-line">
                    <span class="current-word">${word}</span>
                    ${phonetic ? `<span class="phonetic">${phonetic}</span>` : ''}
                </div>
                <div class="word-line">
                    <span style="color: #666; font-size: 0.9em; font-style: italic;">(${pos})</span>
                </div>
            `;
            
            // Display options
            let optionsHTML = '<div class="options-container">';
            appState.currentDefinitions.forEach((def, index) => {
                optionsHTML += `
                    <div class="option" id="option-${index}" onclick="selectOption(${index})">
                        <span class="option-number">${index + 1}</span>
                        ${def}
                    </div>
                `;
            });
            optionsHTML += '</div>';
            optionsHTML += '<button class="submit-button" id="submitBtn" onclick="checkAnswer(true)" disabled>Submit Answer</button>';
            optionsHTML += '<div id="feedback"></div>';
            
            document.getElementById('quizArea').innerHTML = optionsHTML;
        }

        // Show progress dashboard
        function showDashboard() {
            const modal = document.getElementById('dashboardModal');
            const content = document.getElementById('dashboardContent');
            
            let html = '';
            const maxLevel = wordLists[6] ? 6 : 5;
            
            for (let level = 1; level <= maxLevel; level++) {
                const isUnlocked = appState.levelUnlocked[level];
                const isCurrent = level === appState.currentLevel;
                const levelName = level === 6 ? 'Extreme' : `Level ${level}`;
                
                html += `
                    <div class="level-card ${isUnlocked ? 'unlocked' : 'locked'} ${isCurrent ? 'current' : ''}">
                        <h3>${levelName} ${isUnlocked ? '' : 'üîí'}</h3>
                `;
                
                for (let micro = 2; micro <= 6; micro++) {
                    const score = appState.levelScores[level][micro];
                    html += `
                        <div class="micro-progress-row">
                            <span>${micro} Options:</span>
                            <div class="micro-progress-bar">
                                <div class="micro-progress-fill ${score.percentage >= 95 ? 'complete' : ''}" 
                                     style="width: ${score.percentage}%"></div>
                            </div>
                            <span>${score.correct}/${score.total} (${score.percentage}%)</span>
                        </div>
                    `;
                }
                
                html += '</div>';
            }
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }

        // Close dashboard
        function closeDashboard() {
            document.getElementById('dashboardModal').style.display = 'none';
        }

        // Fetch word from dictionary API
        async function fetchWord(word) {
            try {
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)}`;
                
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error('Word not found');
                const data = await response.json();
                
                return data[0];
            } catch (error) {
                console.error('Error fetching word:', error);
                return null;
            }
        }

        // Extract definition from word data
        function getDefinition(wordData) {
            if (!wordData || !wordData.meanings || wordData.meanings.length === 0) {
                return null;
            }
            
            // Try to find the most common/simple definition
            for (let meaning of wordData.meanings) {
                if (meaning.definitions && meaning.definitions.length > 0) {
                    // Get the first definition that seems reasonable (not too long or complex)
                    for (let def of meaning.definitions) {
                        if (def.definition && def.definition.length < 200) {
                            // Basic sanity check - definition should make sense
                            const definition = def.definition;
                            // Skip definitions that seem wrong or overly complex
                            if (!definition.includes('divine') && !definition.includes('supernatural')) {
                                return definition;
                            }
                        }
                    }
                }
            }
            
            // If all definitions seem problematic, return the first one
            const meaning = wordData.meanings[0];
            if (meaning.definitions && meaning.definitions.length > 0) {
                return meaning.definitions[0].definition;
            }
            
            return null;
        }
        
        // Fallback definitions for common words that might have API issues
        const fallbackDefinitions = {
            'imagine': 'To form a mental image or concept of something',
            'happy': 'Feeling or showing pleasure or contentment',
            'brave': 'Ready to face and endure danger or pain',
            'achieve': 'To successfully reach a goal or complete something',
            'balance': 'An even distribution of weight or a state of equilibrium'
        };

        // Generate plausible wrong definitions
        function generateWrongDefinitions(correctWord, correctDef, count) {
            const templates = [
                "The opposite of [WORD]",
                "To make something less [WORD]",
                "A person who lacks [WORD] qualities",
                "The state of being without [WORD]",
                "To pretend to be [WORD]",
                "Something that prevents being [WORD]",
                "The quality opposite to [WORD]",
                "To remove [WORD] characteristics",
                "Acting in a non-[WORD] manner",
                "The absence of being [WORD]"
            ];
            
            const wrongDefs = [];
            const usedTemplates = [];
            
            while (wrongDefs.length < count - 1) {
                let templateIndex = Math.floor(Math.random() * templates.length);
                while (usedTemplates.includes(templateIndex)) {
                    templateIndex = Math.floor(Math.random() * templates.length);
                }
                usedTemplates.push(templateIndex);
                
                const wrongDef = templates[templateIndex].replace('[WORD]', correctWord);
                wrongDefs.push(wrongDef);
            }
            
            return wrongDefs;
        }

        // Get random definitions from other words
        async function getRandomDefinitions(level, correctWord, count) {
            const words = wordLists[level];
            const definitions = [];
            const usedWords = [correctWord];
            let attempts = 0;
            
            if (recentDistracterWords.length > 10) {
                recentDistracterWords = recentDistracterWords.slice(-10);
            }
            
            const availableWords = words.filter(w => 
                !recentDistracterWords.includes(w.word) && 
                w.word !== correctWord
            );
            
            if (availableWords.length < count) {
                recentDistracterWords = [];
            }
            
            while (definitions.length < count - 1 && attempts < 30) {
                attempts++;
                
                const wordPool = availableWords.length > 0 ? availableWords : words;
                const randomWordObj = wordPool[Math.floor(Math.random() * wordPool.length)];
                
                if (!usedWords.includes(randomWordObj.word) && randomWordObj.word !== correctWord) {
                    usedWords.push(randomWordObj.word);
                    const wordData = await fetchWord(randomWordObj.word);
                    const def = getDefinition(wordData);
                    
                    if (def) {
                        if (!def.toLowerCase().includes(correctWord.toLowerCase())) {
                            definitions.push(def);
                            recentDistracterWords.push(randomWordObj.word);
                        }
                    }
                }
            }
            
            if (definitions.length < count - 1) {
                const correctDef = getDefinition(appState.currentWordData);
                if (correctDef) {
                    const generated = generateWrongDefinitions(correctWord, correctDef, count - definitions.length);
                    definitions.push(...generated);
                }
            }
            
            return definitions.slice(0, count - 1);
        }

        // Shuffle array
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Display word and options
        async function displayWord() {
            if (!wordListsLoaded) {
                await loadWordLists();
            }
            
            if (appState.currentMode === 'review') {
                displayReviewMode();
                return;
            }
            
            document.getElementById('wordDisplay').innerHTML = '<div class="loading">Finding a great word for you...</div>';
            document.getElementById('quizArea').innerHTML = '';
            
            let validWordFound = false;
            let attempts = 0;
            
            while (!validWordFound && attempts < 10) {
                attempts++;
                
                const words = wordLists[appState.currentLevel];
                if (!words || words.length === 0) {
                    document.getElementById('wordDisplay').innerHTML = `
                        <div class="error">
                            No words available for this level. Please select another level.
                        </div>
                    `;
                    return;
                }
                
                const availableWords = words.filter(w => !appState.wordHistory.includes(w.word));
                
                if (availableWords.length === 0) {
                    appState.wordHistory = [];
                }
                
                const wordObj = availableWords[Math.floor(Math.random() * availableWords.length)] || words[0];
                const word = wordObj.word;
                const pos = wordObj.pos;
                
                const wordData = await fetchWord(word);
                if (!wordData) {
                    continue;
                }
                
                let correctDef = getDefinition(wordData);
                
                // Use fallback if available and API definition seems wrong
                if (fallbackDefinitions[word] && (!correctDef || correctDef.length > 150 || correctDef.includes('divine'))) {
                    correctDef = fallbackDefinitions[word];
                }
                
                if (!correctDef) {
                    continue;
                }
                
                if (correctDef.toLowerCase().includes(word.toLowerCase())) {
                    console.log(`Skipping "${word}" - appears in its own definition`);
                    continue;
                }
                
                validWordFound = true;
                appState.currentWord = word;
                appState.currentWordData = wordData;
                appState.wordHistory.push(word);
                
                const wrongDefs = await getRandomDefinitions(appState.currentLevel, word, appState.currentMicroLevel);
                
                const allOptions = [correctDef, ...wrongDefs];
                appState.currentDefinitions = shuffleArray(allOptions);
                appState.selectedOption = null;
                appState.isAnswered = false;
                
                const phonetic = wordData.phonetic || '';
                document.getElementById('wordDisplay').innerHTML = `
                    <div class="word-line">
                        <span class="micro-level-indicator">${appState.currentMicroLevel} Options</span>
                    </div>
                    <div class="word-line">
                        <span class="current-word">${word}</span>
                        ${phonetic ? `<span class="phonetic">${phonetic}</span>` : ''}
                    </div>
                    <div class="word-line">
                        <span style="color: #666; font-size: 0.9em; font-style: italic;">(${pos})</span>
                    </div>
                `;
                
                let optionsHTML = '<div class="options-container">';
                appState.currentDefinitions.forEach((def, index) => {
                    optionsHTML += `
                        <div class="option" id="option-${index}" onclick="selectOption(${index})">
                            <span class="option-number">${index + 1}</span>
                            ${def}
                        </div>
                    `;
                });
                optionsHTML += '</div>';
                optionsHTML += '<button class="submit-button" id="submitBtn" onclick="checkAnswer()" disabled>Submit Answer</button>';
                optionsHTML += '<div id="feedback"></div>';
                
                document.getElementById('quizArea').innerHTML = optionsHTML;
            }
            
            if (!validWordFound) {
                document.getElementById('wordDisplay').innerHTML = `
                    <div class="error">
                        Unable to find a suitable word. Please try again or select a different level.
                    </div>
                `;
                setTimeout(() => displayWord(), 2000);
            }
        }

        // Select an option
        function selectOption(index) {
            if (appState.isAnswered) return;
            
            document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
            document.getElementById(`option-${index}`).classList.add('selected');
            appState.selectedOption = index;
            document.getElementById('submitBtn').disabled = false;
        }

        // Check answer
        function checkAnswer(isRetry = false) {
            if (appState.selectedOption === null || appState.isAnswered) return;
            
            appState.isAnswered = true;
            
            const correctDef = getDefinition(appState.currentWordData);
            const selectedDef = appState.currentDefinitions[appState.selectedOption];
            const isCorrect = selectedDef === correctDef;
            
            if (isCorrect) {
                document.getElementById(`option-${appState.selectedOption}`).classList.add('correct');
                
                // If this was a retry of a previously incorrect word, mark it as learned
                if (isRetry) {
                    const previousAttempts = appState.attemptHistory.filter(a => 
                        a.word === appState.currentWord && !a.correct
                    );
                    if (previousAttempts.length > 0) {
                        previousAttempts[previousAttempts.length - 1].learned = true;
                    }
                }
                
                document.getElementById('feedback').innerHTML = `
                    <div class="feedback correct">
                        üéâ Excellent. That's correct.
                        <button class="next-button" onclick="nextWord()">Next Word ‚Üí</button>
                    </div>
                `;
            } else {
                document.getElementById(`option-${appState.selectedOption}`).classList.add('incorrect');
                const correctIndex = appState.currentDefinitions.indexOf(correctDef);
                document.getElementById(`option-${correctIndex}`).classList.add('correct');
                document.getElementById('feedback').innerHTML = `
                    <div class="feedback incorrect">
                        ‚ùå Not quite. The correct answer is highlighted above.
                        <button class="next-button" onclick="nextWord()">Try Another ‚Üí</button>
                    </div>
                `;
            }
            
            document.getElementById('submitBtn').disabled = true;
            
            recordAttempt(isCorrect);
            
            // Update micro level progress
            appState.microLevelProgress++;
            if (appState.microLevelProgress >= 5) {
                if (appState.currentMicroLevel < 6) {
                    appState.currentMicroLevel++;
                    appState.microLevelProgress = 0;
                } else {
                    appState.currentMicroLevel = 2;
                    appState.microLevelProgress = 0;
                }
            }
        }

        // Next word
        function nextWord() {
            displayWord();
        }

        // Change difficulty
        function changeDifficulty() {
            appState.currentLevel = parseInt(document.getElementById('difficultyLevel').value);
            appState.wordHistory = [];
            appState.currentMicroLevel = 2;
            appState.microLevelProgress = 0;
            saveState();
            updateUI();
            displayWord();
        }

        // Initialize app
        async function init() {
            await loadWordLists();
            loadState();
            updateUI();
            displayWord();
        }

        // Start the app
        init();
    </script>
</body>
</html>