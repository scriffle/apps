<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Wippletree</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
      background: #fff;
    }
    .controls {
      margin: 10px;
    }
    .controls label, .controls select, .controls input, .controls button {
      margin: 5px;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <h1>Interactive Wippletree</h1>
  <canvas id="canvas" width="800" height="600"></canvas>
  <div class="controls">
    <label for="connectors">Number of Connectors:</label>
    <select id="connectors">
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4" selected>4</option>
      <option value="5">5</option>
      <option value="6">6</option>
    </select>
    <br>
    <label for="angleSlider">Bar Angle:</label>
    <input type="range" id="angleSlider" min="-90" max="90" value="0">
    <span id="angleDisplay">0°</span>
    <br>
    <button id="toggleMode">Switch to Compression Mode</button>
  </div>
  <script>
    // Get canvas and context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ----- Simulation parameters -----
    let mode = 'tension'; // "tension" or "compression"
    let pivot = { x: canvas.width / 2, y: 150 };  // central pivot (will be reset based on mode)
    let horizontalLineY = 400;  // y coordinate of output line (where rods end)
    
    let barAngle = 0;              // current bar angle (radians)
    let targetBarAngle = 0;        // target bar angle (for animation)
    const degToRad = Math.PI / 180;
    
    const barLength = 150;         // total length of the bar
    const rodLength = 300;         // fixed length of each rod (must be > |horizontalLineY - pivot.y|)
    
    let numConnectors = 4;         // default number of connectors

    // Connector offsets along the bar (relative to the bar’s center)
    let connectorOffsets = [];
    function updateConnectorOffsets() {
      connectorOffsets = [];
      // Evenly space from -barLength/2 to +barLength/2.
      // (For n=2 the connectors are at the two ends; for n=3 they are at left, center, right, etc.)
      if(numConnectors === 1) {
        connectorOffsets.push(0);
      } else {
        const spacing = barLength / (numConnectors - 1);
        for (let i = 0; i < numConnectors; i++) {
          connectorOffsets.push(-barLength / 2 + i * spacing);
        }
      }
    }
    updateConnectorOffsets();

    // Set up mode: adjust pivot and horizontal line positions.
    function setMode(newMode) {
      mode = newMode;
      if (mode === 'tension') {
        // In tension mode, the input force (pivot) is above the output line.
        pivot = { x: canvas.width / 2, y: 150 };
        horizontalLineY = 400;
        document.getElementById('toggleMode').textContent = 'Switch to Compression Mode';
      } else {
        // In compression mode, the input force (pivot) is below the output line.
        pivot = { x: canvas.width / 2, y: 400 };
        horizontalLineY = 150;
        document.getElementById('toggleMode').textContent = 'Switch to Tension Mode';
      }
    }
    setMode('tension');

    // ----- UI event listeners -----

    // Number-of-connectors dropdown
    document.getElementById('connectors').addEventListener('change', function () {
      numConnectors = parseInt(this.value);
      updateConnectorOffsets();
    });

    // Angle slider
    const angleSlider = document.getElementById('angleSlider');
    const angleDisplay = document.getElementById('angleDisplay');
    angleSlider.addEventListener('input', function () {
      const deg = parseFloat(this.value);
      targetBarAngle = deg * degToRad;
      angleDisplay.textContent = deg + '°';
    });

    // Mode toggle button
    document.getElementById('toggleMode').addEventListener('click', function () {
      if (mode === 'tension') {
        setMode('compression');
      } else {
        setMode('tension');
      }
    });

    // ----- Animation and drawing -----

    function animate() {
      // Smoothly adjust barAngle toward targetBarAngle
      const diff = targetBarAngle - barAngle;
      if (Math.abs(diff) > 0.001) {
        barAngle += diff * 0.1; // adjust factor for smoothness
      } else {
        barAngle = targetBarAngle;
      }
      draw();
      requestAnimationFrame(animate);
    }

    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw output horizontal line
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, horizontalLineY);
      ctx.lineTo(canvas.width, horizontalLineY);
      ctx.stroke();

      // Draw central pivot as a red circle
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(pivot.x, pivot.y, 8, 0, Math.PI * 2);
      ctx.fill();

      // Draw the central bar (blue line)
      // The bar is centered on pivot and rotated by barAngle.
      const half = barLength / 2;
      const cos = Math.cos(barAngle);
      const sin = Math.sin(barAngle);
      const barEnd1 = { x: pivot.x + (-half) * cos, y: pivot.y + (-half) * sin };
      const barEnd2 = { x: pivot.x + (half) * cos,  y: pivot.y + (half) * sin  };
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(barEnd1.x, barEnd1.y);
      ctx.lineTo(barEnd2.x, barEnd2.y);
      ctx.stroke();

      // Compute and draw the connection points on the bar (green circles)
      const connectionPoints = [];
      for (let i = 0; i < connectorOffsets.length; i++) {
        const offset = connectorOffsets[i];
        // In the bar’s local coordinates the point is (offset, 0); rotate it by barAngle.
        const cx = pivot.x + offset * cos;
        const cy = pivot.y + offset * sin;
        connectionPoints.push({ x: cx, y: cy });
        ctx.fillStyle = 'green';
        ctx.beginPath();
        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // For each connection point, compute the rod’s endpoint on the horizontal line.
      // We want the rod (orange line) to have a fixed length (rodLength).
      // The endpoint must lie on y = horizontalLineY.
      // Given a connection point (P_conn.x, P_conn.y), we have:
      //    (E_x - P_conn.x)² + (horizontalLineY - P_conn.y)² = rodLength².
      // So: E_x = P_conn.x ± sqrt(rodLength² - (horizontalLineY - P_conn.y)²).
      // We choose the sign so that the endpoints remain in order.
      ctx.strokeStyle = 'orange';
      ctx.lineWidth = 3;
      for (let i = 0; i < connectionPoints.length; i++) {
        const P_conn = connectionPoints[i];
        const dy = horizontalLineY - P_conn.y;
        const underSqrt = rodLength * rodLength - dy * dy;
        if (underSqrt < 0) {
          // Configuration impossible (the rod is too short for this vertical separation).
          continue;
        }
        const dx = Math.sqrt(underSqrt);
        // Choose sign:
        // If the connection point is to the left of the pivot, use the negative branch.
        // If to the right (or equal), use the positive branch.
        const sign = (P_conn.x < pivot.x) ? -1 : 1;
        const E_x = P_conn.x + sign * dx;
        const E_y = horizontalLineY;
        // Draw the rod from connection point to endpoint.
        ctx.beginPath();
        ctx.moveTo(P_conn.x, P_conn.y);
        ctx.lineTo(E_x, E_y);
        ctx.stroke();
        // Draw the endpoint as a purple circle.
        ctx.fillStyle = 'purple';
        ctx.beginPath();
        ctx.arc(E_x, E_y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Start animation loop
    animate();
  </script>
</body>
</html>
