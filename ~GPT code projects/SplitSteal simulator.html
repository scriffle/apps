<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split/Steal Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Space+Grotesk:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --bg-card: #15151f;
            --border: #2a2a3a;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --text-dim: #555566;
            --accent-split: #00ff88;
            --accent-steal: #ff3366;
            --accent-neutral: #6677ff;
            --accent-warn: #ffaa00;
            --glow-split: rgba(0, 255, 136, 0.15);
            --glow-steal: rgba(255, 51, 102, 0.15);
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.03;
            z-index: 1000;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }
        
        .app-container {
            display: grid;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
            padding: 1rem;
            gap: 1rem;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo-icon {
            width: 48px;
            height: 48px;
            position: relative;
        }
        
        .logo-icon::before,
        .logo-icon::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            transition: transform 0.3s ease;
        }
        
        .logo-icon::before {
            top: 4px;
            left: 4px;
            background: var(--accent-split);
            box-shadow: 0 0 20px var(--glow-split);
        }
        
        .logo-icon::after {
            bottom: 4px;
            right: 4px;
            background: var(--accent-steal);
            box-shadow: 0 0 20px var(--glow-steal);
        }
        
        .logo:hover .logo-icon::before {
            transform: translate(4px, 4px);
        }
        
        .logo:hover .logo-icon::after {
            transform: translate(-4px, -4px);
        }
        
        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }
        
        h1 span {
            color: var(--text-secondary);
            font-weight: 400;
        }
        
        .controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        
        button {
            font-family: inherit;
            font-size: 0.8rem;
            padding: 0.6rem 1.2rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            background: var(--bg-card);
            border-color: var(--text-dim);
        }
        
        button.primary {
            background: var(--accent-neutral);
            border-color: var(--accent-neutral);
            color: white;
        }
        
        button.primary:hover {
            filter: brightness(1.1);
        }
        
        button.running {
            background: var(--accent-steal);
            border-color: var(--accent-steal);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.8rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
        }
        
        .speed-control label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .speed-control input {
            width: 80px;
            accent-color: var(--accent-neutral);
        }
        
        .speed-value {
            font-size: 0.75rem;
            color: var(--text-primary);
            min-width: 50px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 1rem;
            overflow: hidden;
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }
        
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        
        .card-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }
        
        .card-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .stat-item {
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .stat-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }
        
        .stat-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .stat-value.split { color: var(--accent-split); }
        .stat-value.steal { color: var(--accent-steal); }
        .stat-value.neutral { color: var(--accent-neutral); }
        .stat-value.warn { color: var(--accent-warn); }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .legend-section {
            margin-bottom: 0.75rem;
        }
        
        .legend-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
        }
        
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.65rem;
        }
        
        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }
        
        .charts-area {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 1rem;
            overflow: hidden;
        }
        
        .chart-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
        }
        
        .chart-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .chart-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }
        
        .chart-subtitle {
            font-size: 0.65rem;
            color: var(--text-dim);
        }
        
        .chart-canvas-wrapper {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .chart-canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .tabs {
            display: flex;
            gap: 0.25rem;
            background: var(--bg-tertiary);
            padding: 0.25rem;
            border-radius: 6px;
        }
        
        .tab {
            padding: 0.35rem 0.75rem;
            font-size: 0.65rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tab.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .tab:hover:not(.active) {
            color: var(--text-primary);
        }
        
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 0.75rem 1.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.8rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-split), var(--accent-neutral));
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .agent-matrix {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            margin-top: 0.5rem;
        }
        
        .agent-cell {
            aspect-ratio: 1;
            border-radius: 2px;
            font-size: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        
        .agent-cell:hover {
            transform: scale(1.3);
            z-index: 10;
        }
        
        .tooltip {
            position: fixed;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.7rem;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.15s ease;
            max-width: 250px;
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tooltip-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.25rem;
        }
        
        .tooltip-label {
            color: var(--text-dim);
        }
        
        .tooltip-value {
            color: var(--text-primary);
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .sidebar .card {
                flex: 1;
                min-width: 280px;
            }
            
            .chart-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="noise-overlay"></div>
    
    <div class="app-container">
        <header>
            <div class="logo">
                <div class="logo-icon"></div>
                <h1>Split/Steal <span>Simulator</span></h1>
            </div>
            <div class="controls">
                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" id="speed" min="1" max="100" value="50">
                    <span class="speed-value" id="speed-display">~1k/s</span>
                </div>
                <button id="btn-run" class="primary">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg>
                    Run
                </button>
                <button id="btn-reset">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    Reset
                </button>
                <button id="btn-export">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    Export
                </button>
            </div>
        </header>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Games Completed</span>
                        <span class="card-value" id="total-games">0</span>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Victories</div>
                            <div class="stat-value split" id="stat-victories">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Shared Wins</div>
                            <div class="stat-value neutral" id="stat-shared">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Mutual Dest.</div>
                            <div class="stat-value steal" id="stat-destruction">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Avg Rounds</div>
                            <div class="stat-value warn" id="stat-rounds">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Games/sec</div>
                            <div class="stat-value" id="stat-gps">0</div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Agent Matrix</span>
                        <span class="card-subtitle">Bias × Strategy</span>
                    </div>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Y-Axis: Strategy Type</div>
                            <div class="legend-items" id="strategy-legend"></div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-title">X-Axis: Steal Bias (0.0 → 0.9)</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Color: Win Rate</div>
                            <div class="legend-items">
                                <div class="legend-item"><div class="legend-color" style="background: #1a1a25"></div> 0%</div>
                                <div class="legend-item"><div class="legend-color" style="background: #00ff88"></div> 100%</div>
                            </div>
                        </div>
                    </div>
                    <div class="agent-matrix" id="agent-matrix"></div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Top Performers</span>
                    </div>
                    <div id="top-performers"></div>
                </div>
            </div>
            
            <div class="charts-area">
                <div class="chart-row">
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">Win Rate by Bias</span>
                            <div class="tabs" id="tabs-winrate">
                                <button class="tab active" data-view="all">All</button>
                                <button class="tab" data-view="strategy">By Strategy</button>
                            </div>
                        </div>
                        <div class="chart-canvas-wrapper">
                            <canvas id="chart-winrate"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">Avg Coins by Bias</span>
                            <div class="tabs" id="tabs-coins">
                                <button class="tab active" data-view="all">All</button>
                                <button class="tab" data-view="strategy">By Strategy</button>
                            </div>
                        </div>
                        <div class="chart-canvas-wrapper">
                            <canvas id="chart-coins"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">Survival Rate by Bias</span>
                            <div class="tabs" id="tabs-survival">
                                <button class="tab active" data-view="all">All</button>
                                <button class="tab" data-view="strategy">By Strategy</button>
                            </div>
                        </div>
                        <div class="chart-canvas-wrapper">
                            <canvas id="chart-survival"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="chart-row">
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">Win Rate by Strategy</span>
                        </div>
                        <div class="chart-canvas-wrapper">
                            <canvas id="chart-strategy-winrate"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">Avg Coins by Strategy</span>
                        </div>
                        <div class="chart-canvas-wrapper">
                            <canvas id="chart-strategy-coins"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">Win Rate Over Time</span>
                        </div>
                        <div class="chart-canvas-wrapper">
                            <canvas id="chart-timeline"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    <div class="toast" id="toast"></div>

    <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const BIAS_LEVELS = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
    const STRATEGIES = [
        { id: 'pure', name: 'Pure', category: 'Simple', color: '#ff6b6b' },
        { id: 'nudged', name: 'Nudged', category: 'Simple', color: '#ff8e72' },
        { id: 'paranoid', name: 'Paranoid', category: 'Simple', color: '#ffa94d' },
        { id: 'tit-for-tat', name: 'Tit-for-Tat', category: 'Reactive', color: '#69db7c' },
        { id: 'grudger', name: 'Grudger', category: 'Reactive', color: '#38d9a9' },
        { id: 'pavlov', name: 'Pavlov', category: 'Reactive', color: '#3bc9db' },
        { id: 'short-memory', name: 'Short Mem', category: 'Weighted', color: '#748ffc' },
        { id: 'long-memory', name: 'Long Mem', category: 'Weighted', color: '#9775fa' },
        { id: 'decay-memory', name: 'Decay Mem', category: 'Weighted', color: '#da77f2' }
    ];
    
    const STARTING_COINS = 10;
    
    // ============================================
    // AGENT CLASS
    // ============================================
    class Agent {
        constructor(id, bias, strategy) {
            this.id = id;
            this.bias = bias;
            this.strategy = strategy;
            this.reset();
        }
        
        reset() {
            this.coins = STARTING_COINS;
            this.active = true;
            this.history = {}; // opponent id -> array of {myChoice, theirChoice, outcome}
            this.betrayedBy = new Set();
            this.lastAction = null;
            this.lastOutcome = null;
        }
        
        recordOutcome(opponentId, myChoice, theirChoice, outcome) {
            if (!this.history[opponentId]) {
                this.history[opponentId] = [];
            }
            this.history[opponentId].push({ myChoice, theirChoice, outcome });
            this.lastAction = myChoice;
            this.lastOutcome = outcome;
            
            if (theirChoice === 'STEAL') {
                this.betrayedBy.add(opponentId);
            }
        }
        
        decide(opponent) {
            const baseBias = this.bias;
            let stealProbability = baseBias;
            
            switch (this.strategy.id) {
                case 'pure':
                    // Pure bias, ignore history
                    stealProbability = baseBias;
                    break;
                    
                case 'nudged':
                    // History nudges bias ±15%
                    const opponentHistory = this.history[opponent.id] || [];
                    if (opponentHistory.length > 0) {
                        const betrayals = opponentHistory.filter(h => h.theirChoice === 'STEAL').length;
                        const betrayalRate = betrayals / opponentHistory.length;
                        stealProbability = Math.min(1, Math.max(0, baseBias + (betrayalRate - 0.5) * 0.3));
                    }
                    break;
                    
                case 'paranoid':
                    // Any betrayal permanently increases steal chance
                    if (this.betrayedBy.has(opponent.id)) {
                        stealProbability = Math.min(1, baseBias + 0.4);
                    }
                    break;
                    
                case 'tit-for-tat':
                    // Mirror opponent's last action
                    const tftHistory = this.history[opponent.id];
                    if (tftHistory && tftHistory.length > 0) {
                        const lastOpponentAction = tftHistory[tftHistory.length - 1].theirChoice;
                        return lastOpponentAction;
                    }
                    // First encounter: use bias
                    stealProbability = baseBias;
                    break;
                    
                case 'grudger':
                    // Split until betrayed, then always steal
                    if (this.betrayedBy.has(opponent.id)) {
                        return 'STEAL';
                    }
                    stealProbability = baseBias * 0.5; // More cooperative baseline
                    break;
                    
                case 'pavlov':
                    // Win-stay, lose-shift
                    if (this.lastOutcome !== null) {
                        const wasGoodOutcome = this.lastOutcome === 'BOTH_SPLIT' || 
                            (this.lastOutcome === 'I_STOLE' && this.lastAction === 'STEAL');
                        if (wasGoodOutcome) {
                            return this.lastAction || (Math.random() < baseBias ? 'STEAL' : 'SPLIT');
                        } else {
                            return this.lastAction === 'STEAL' ? 'SPLIT' : 'STEAL';
                        }
                    }
                    stealProbability = baseBias;
                    break;
                    
                case 'short-memory':
                    // Last 3 encounters weighted heavily
                    const shortHist = this.history[opponent.id] || [];
                    if (shortHist.length > 0) {
                        const recent = shortHist.slice(-3);
                        const recentBetrayals = recent.filter(h => h.theirChoice === 'STEAL').length;
                        stealProbability = baseBias + (recentBetrayals / recent.length) * 0.4;
                        stealProbability = Math.min(1, Math.max(0, stealProbability));
                    }
                    break;
                    
                case 'long-memory':
                    // All history, equal weight
                    const longHist = this.history[opponent.id] || [];
                    if (longHist.length > 0) {
                        const allBetrayals = longHist.filter(h => h.theirChoice === 'STEAL').length;
                        stealProbability = baseBias + (allBetrayals / longHist.length) * 0.3;
                        stealProbability = Math.min(1, Math.max(0, stealProbability));
                    }
                    break;
                    
                case 'decay-memory':
                    // Exponential decay (recent = important)
                    const decayHist = this.history[opponent.id] || [];
                    if (decayHist.length > 0) {
                        let weightedBetrayals = 0;
                        let totalWeight = 0;
                        const decay = 0.7;
                        for (let i = decayHist.length - 1; i >= 0; i--) {
                            const weight = Math.pow(decay, decayHist.length - 1 - i);
                            if (decayHist[i].theirChoice === 'STEAL') {
                                weightedBetrayals += weight;
                            }
                            totalWeight += weight;
                        }
                        stealProbability = baseBias + (weightedBetrayals / totalWeight) * 0.35;
                        stealProbability = Math.min(1, Math.max(0, stealProbability));
                    }
                    break;
            }
            
            return Math.random() < stealProbability ? 'STEAL' : 'SPLIT';
        }
        
        get name() {
            return `${this.strategy.name}-${this.bias.toFixed(1)}`;
        }
    }
    
    // ============================================
    // GAME ENGINE
    // ============================================
    class GameEngine {
        constructor(agents) {
            this.originalAgents = agents;
            this.reset();
        }
        
        reset() {
            this.agents = this.originalAgents.map(a => {
                a.reset();
                return a;
            });
            this.currentRound = 1;
            this.removedCoins = 0;
            this.previousPairs = new Set();
            this.lastAutoAdvanced = null;
            this.roundHistory = [];
        }
        
        getActivePlayers() {
            return this.agents.filter(a => a.active);
        }
        
        pairKey(a, b) {
            return [a.id, b.id].sort().join('-');
        }
        
        createPairings() {
            const active = this.getActivePlayers();
            const shuffled = [...active].sort(() => Math.random() - 0.5);
            const pairs = [];
            const assigned = new Set();
            let autoAdvance = null;
            
            for (let i = 0; i < shuffled.length; i++) {
                if (assigned.has(shuffled[i].id)) continue;
                
                let paired = false;
                for (let j = i + 1; j < shuffled.length; j++) {
                    if (assigned.has(shuffled[j].id)) continue;
                    
                    const key = this.pairKey(shuffled[i], shuffled[j]);
                    if (!this.previousPairs.has(key)) {
                        pairs.push({ player1: shuffled[i], player2: shuffled[j] });
                        assigned.add(shuffled[i].id);
                        assigned.add(shuffled[j].id);
                        paired = true;
                        break;
                    }
                }
                
                if (!paired && !assigned.has(shuffled[i].id)) {
                    // Try to pair with anyone
                    for (let j = i + 1; j < shuffled.length; j++) {
                        if (!assigned.has(shuffled[j].id)) {
                            pairs.push({ player1: shuffled[i], player2: shuffled[j] });
                            assigned.add(shuffled[i].id);
                            assigned.add(shuffled[j].id);
                            paired = true;
                            break;
                        }
                    }
                }
            }
            
            // Handle odd player
            const unassigned = shuffled.filter(p => !assigned.has(p.id));
            if (unassigned.length === 1) {
                const candidate = unassigned[0];
                if (this.lastAutoAdvanced !== candidate.id) {
                    autoAdvance = candidate;
                } else {
                    // Force different auto-advance if possible by swapping
                    if (pairs.length > 0) {
                        const lastPair = pairs[pairs.length - 1];
                        autoAdvance = lastPair.player2;
                        pairs[pairs.length - 1] = { player1: lastPair.player1, player2: candidate };
                    } else {
                        autoAdvance = candidate; // Forced
                    }
                }
            }
            
            // Update previous pairs
            this.previousPairs.clear();
            for (const pair of pairs) {
                this.previousPairs.add(this.pairKey(pair.player1, pair.player2));
            }
            
            if (autoAdvance) {
                this.lastAutoAdvanced = autoAdvance.id;
            }
            
            return { pairs, autoAdvance };
        }
        
        resolvePair(pair) {
            const { player1, player2 } = pair;
            const choice1 = player1.decide(player2);
            const choice2 = player2.decide(player1);
            
            let outcome;
            
            if (choice1 === 'SPLIT' && choice2 === 'SPLIT') {
                outcome = 'BOTH_SPLIT';
                player1.recordOutcome(player2.id, choice1, choice2, 'BOTH_SPLIT');
                player2.recordOutcome(player1.id, choice2, choice1, 'BOTH_SPLIT');
            } else if (choice1 === 'STEAL' && choice2 === 'SPLIT') {
                outcome = 'P1_STEALS';
                player1.coins += player2.coins;
                player2.coins = 0;
                player2.active = false;
                player1.recordOutcome(player2.id, choice1, choice2, 'I_STOLE');
                player2.recordOutcome(player1.id, choice2, choice1, 'THEY_STOLE');
            } else if (choice1 === 'SPLIT' && choice2 === 'STEAL') {
                outcome = 'P2_STEALS';
                player2.coins += player1.coins;
                player1.coins = 0;
                player1.active = false;
                player1.recordOutcome(player2.id, choice1, choice2, 'THEY_STOLE');
                player2.recordOutcome(player1.id, choice2, choice1, 'I_STOLE');
            } else {
                outcome = 'BOTH_STEAL';
                this.removedCoins += player1.coins + player2.coins;
                player1.coins = 0;
                player2.coins = 0;
                player1.active = false;
                player2.active = false;
                player1.recordOutcome(player2.id, choice1, choice2, 'BOTH_STEAL');
                player2.recordOutcome(player1.id, choice2, choice1, 'BOTH_STEAL');
            }
            
            return { player1, player2, choice1, choice2, outcome };
        }
        
        redistribute() {
            const active = this.getActivePlayers();
            if (this.removedCoins > 0 && active.length > 0) {
                const base = Math.floor(this.removedCoins / active.length);
                const remainder = this.removedCoins % active.length;
                
                for (const player of active) {
                    player.coins += base;
                }
                
                if (remainder > 0) {
                    const lucky = active[Math.floor(Math.random() * active.length)];
                    lucky.coins += remainder;
                }
                
                this.removedCoins = 0;
            }
        }
        
        playRound() {
            const { pairs, autoAdvance } = this.createPairings();
            const results = [];
            
            for (const pair of pairs) {
                results.push(this.resolvePair(pair));
            }
            
            this.redistribute();
            
            this.roundHistory.push({
                round: this.currentRound,
                results,
                autoAdvance: autoAdvance ? autoAdvance.id : null,
                activeAfter: this.getActivePlayers().length
            });
            
            this.currentRound++;
            
            return { results, autoAdvance };
        }
        
        isGameOver() {
            return this.getActivePlayers().length <= 1;
        }
        
        playGame() {
            while (!this.isGameOver()) {
                this.playRound();
            }
            
            const active = this.getActivePlayers();
            let outcome, winners;
            
            if (active.length === 0) {
                outcome = 'MUTUAL_DESTRUCTION';
                winners = [];
            } else if (active.length === 1) {
                outcome = 'VICTORY';
                winners = [active[0]];
                active[0].coins += this.removedCoins;
            } else {
                // Shouldn't happen, but handle 2+ remaining
                outcome = 'SHARED_VICTORY';
                winners = active;
            }
            
            return {
                outcome,
                winners,
                totalRounds: this.currentRound - 1,
                roundHistory: this.roundHistory,
                finalStates: this.agents.map(a => ({
                    id: a.id,
                    bias: a.bias,
                    strategy: a.strategy,
                    coins: a.coins,
                    active: a.active,
                    roundsLasted: this.getRoundsLasted(a)
                }))
            };
        }
        
        getRoundsLasted(agent) {
            if (agent.active) return this.currentRound - 1;
            
            for (let i = 0; i < this.roundHistory.length; i++) {
                const round = this.roundHistory[i];
                for (const result of round.results) {
                    if ((result.player1.id === agent.id || result.player2.id === agent.id) &&
                        (result.outcome !== 'BOTH_SPLIT')) {
                        if ((result.player1.id === agent.id && 
                             (result.outcome === 'P2_STEALS' || result.outcome === 'BOTH_STEAL')) ||
                            (result.player2.id === agent.id && 
                             (result.outcome === 'P1_STEALS' || result.outcome === 'BOTH_STEAL'))) {
                            return i + 1;
                        }
                    }
                }
            }
            return this.currentRound - 1;
        }
    }
    
    // ============================================
    // STATISTICS TRACKER
    // ============================================
    class StatsTracker {
        constructor(agents) {
            this.agents = agents;
            this.reset();
        }
        
        reset() {
            this.totalGames = 0;
            this.victories = 0;
            this.sharedVictories = 0;
            this.mutualDestructions = 0;
            this.totalRounds = 0;
            
            this.agentStats = {};
            for (const agent of this.agents) {
                this.agentStats[agent.id] = {
                    wins: 0,
                    sharedWins: 0,
                    totalCoins: 0,
                    totalRoundsLasted: 0,
                    gamesPlayed: 0
                };
            }
            
            this.timelineData = [];
        }
        
        recordGame(result) {
            this.totalGames++;
            this.totalRounds += result.totalRounds;
            
            if (result.outcome === 'VICTORY') {
                this.victories++;
                if (result.winners[0]) {
                    this.agentStats[result.winners[0].id].wins++;
                }
            } else if (result.outcome === 'SHARED_VICTORY') {
                this.sharedVictories++;
                for (const winner of result.winners) {
                    this.agentStats[winner.id].sharedWins++;
                }
            } else {
                this.mutualDestructions++;
            }
            
            for (const state of result.finalStates) {
                const stats = this.agentStats[state.id];
                stats.totalCoins += state.coins;
                stats.totalRoundsLasted += state.roundsLasted;
                stats.gamesPlayed++;
            }
            
            // Record timeline data every 100 games
            if (this.totalGames % 100 === 0) {
                this.timelineData.push({
                    games: this.totalGames,
                    winRateByBias: this.getWinRateByBias()
                });
            }
        }
        
        getWinRateByBias() {
            const byBias = {};
            for (const bias of BIAS_LEVELS) {
                byBias[bias] = { wins: 0, games: 0 };
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                byBias[agent.bias].wins += stats.wins + stats.sharedWins * 0.5;
                byBias[agent.bias].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const bias of BIAS_LEVELS) {
                result[bias] = byBias[bias].games > 0 ? 
                    byBias[bias].wins / byBias[bias].games : 0;
            }
            return result;
        }
        
        getWinRateByBiasAndStrategy() {
            const data = {};
            
            for (const strategy of STRATEGIES) {
                data[strategy.id] = {};
                for (const bias of BIAS_LEVELS) {
                    data[strategy.id][bias] = { wins: 0, games: 0 };
                }
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                data[agent.strategy.id][agent.bias].wins += stats.wins + stats.sharedWins * 0.5;
                data[agent.strategy.id][agent.bias].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const strategy of STRATEGIES) {
                result[strategy.id] = {};
                for (const bias of BIAS_LEVELS) {
                    const d = data[strategy.id][bias];
                    result[strategy.id][bias] = d.games > 0 ? d.wins / d.games : 0;
                }
            }
            return result;
        }
        
        getAvgCoinsByBias() {
            const byBias = {};
            for (const bias of BIAS_LEVELS) {
                byBias[bias] = { coins: 0, games: 0 };
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                byBias[agent.bias].coins += stats.totalCoins;
                byBias[agent.bias].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const bias of BIAS_LEVELS) {
                result[bias] = byBias[bias].games > 0 ? 
                    byBias[bias].coins / byBias[bias].games : 0;
            }
            return result;
        }
        
        getAvgCoinsByBiasAndStrategy() {
            const data = {};
            
            for (const strategy of STRATEGIES) {
                data[strategy.id] = {};
                for (const bias of BIAS_LEVELS) {
                    data[strategy.id][bias] = { coins: 0, games: 0 };
                }
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                data[agent.strategy.id][agent.bias].coins += stats.totalCoins;
                data[agent.strategy.id][agent.bias].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const strategy of STRATEGIES) {
                result[strategy.id] = {};
                for (const bias of BIAS_LEVELS) {
                    const d = data[strategy.id][bias];
                    result[strategy.id][bias] = d.games > 0 ? d.coins / d.games : 0;
                }
            }
            return result;
        }
        
        getSurvivalByBias() {
            const byBias = {};
            for (const bias of BIAS_LEVELS) {
                byBias[bias] = { rounds: 0, games: 0 };
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                byBias[agent.bias].rounds += stats.totalRoundsLasted;
                byBias[agent.bias].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const bias of BIAS_LEVELS) {
                result[bias] = byBias[bias].games > 0 ? 
                    byBias[bias].rounds / byBias[bias].games : 0;
            }
            return result;
        }
        
        getSurvivalByBiasAndStrategy() {
            const data = {};
            
            for (const strategy of STRATEGIES) {
                data[strategy.id] = {};
                for (const bias of BIAS_LEVELS) {
                    data[strategy.id][bias] = { rounds: 0, games: 0 };
                }
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                data[agent.strategy.id][agent.bias].rounds += stats.totalRoundsLasted;
                data[agent.strategy.id][agent.bias].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const strategy of STRATEGIES) {
                result[strategy.id] = {};
                for (const bias of BIAS_LEVELS) {
                    const d = data[strategy.id][bias];
                    result[strategy.id][bias] = d.games > 0 ? d.rounds / d.games : 0;
                }
            }
            return result;
        }
        
        getWinRateByStrategy() {
            const byStrategy = {};
            for (const strategy of STRATEGIES) {
                byStrategy[strategy.id] = { wins: 0, games: 0 };
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                byStrategy[agent.strategy.id].wins += stats.wins + stats.sharedWins * 0.5;
                byStrategy[agent.strategy.id].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const strategy of STRATEGIES) {
                result[strategy.id] = byStrategy[strategy.id].games > 0 ?
                    byStrategy[strategy.id].wins / byStrategy[strategy.id].games : 0;
            }
            return result;
        }
        
        getAvgCoinsByStrategy() {
            const byStrategy = {};
            for (const strategy of STRATEGIES) {
                byStrategy[strategy.id] = { coins: 0, games: 0 };
            }
            
            for (const agent of this.agents) {
                const stats = this.agentStats[agent.id];
                byStrategy[agent.strategy.id].coins += stats.totalCoins;
                byStrategy[agent.strategy.id].games += stats.gamesPlayed;
            }
            
            const result = {};
            for (const strategy of STRATEGIES) {
                result[strategy.id] = byStrategy[strategy.id].games > 0 ?
                    byStrategy[strategy.id].coins / byStrategy[strategy.id].games : 0;
            }
            return result;
        }
        
        getTopPerformers(n = 5) {
            const performers = this.agents.map(agent => {
                const stats = this.agentStats[agent.id];
                return {
                    agent,
                    winRate: stats.gamesPlayed > 0 ? 
                        (stats.wins + stats.sharedWins * 0.5) / stats.gamesPlayed : 0,
                    avgCoins: stats.gamesPlayed > 0 ?
                        stats.totalCoins / stats.gamesPlayed : 0
                };
            });
            
            return performers
                .sort((a, b) => b.winRate - a.winRate || b.avgCoins - a.avgCoins)
                .slice(0, n);
        }
        
        getAgentWinRate(agentId) {
            const stats = this.agentStats[agentId];
            return stats.gamesPlayed > 0 ?
                (stats.wins + stats.sharedWins * 0.5) / stats.gamesPlayed : 0;
        }
    }
    
    // ============================================
    // CHART RENDERER
    // ============================================
    class ChartRenderer {
        constructor() {
            this.charts = {};
            this.viewModes = {
                winrate: 'all',
                coins: 'all',
                survival: 'all'
            };
        }
        
        init() {
            this.setupChart('chart-winrate', 'line');
            this.setupChart('chart-coins', 'line');
            this.setupChart('chart-survival', 'line');
            this.setupChart('chart-strategy-winrate', 'bar');
            this.setupChart('chart-strategy-coins', 'bar');
            this.setupChart('chart-timeline', 'line');
            
            this.setupTabs();
        }
        
        setupChart(canvasId, type) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            this.charts[canvasId] = { canvas, ctx, type };
            
            const resize = () => {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            };
            
            resize();
            window.addEventListener('resize', resize);
        }
        
        setupTabs() {
            const tabGroups = ['tabs-winrate', 'tabs-coins', 'tabs-survival'];
            
            for (const groupId of tabGroups) {
                const group = document.getElementById(groupId);
                const type = groupId.split('-')[1];
                
                group.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        group.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        this.viewModes[type] = tab.dataset.view;
                    });
                });
            }
        }
        
        drawLineChart(canvasId, data, options = {}) {
            const { canvas, ctx } = this.charts[canvasId];
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            
            ctx.clearRect(0, 0, width, height);
            
            const padding = { top: 20, right: 20, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Draw grid
            ctx.strokeStyle = '#2a2a3a';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Y-axis labels
            ctx.fillStyle = '#555566';
            ctx.font = '10px JetBrains Mono';
            ctx.textAlign = 'right';
            
            const maxY = options.maxY || 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                const value = maxY - (maxY / 5) * i;
                ctx.fillText(options.formatY ? options.formatY(value) : value.toFixed(2), padding.left - 8, y + 3);
            }
            
            // X-axis labels
            ctx.textAlign = 'center';
            const xLabels = options.xLabels || BIAS_LEVELS;
            const xStep = chartWidth / (xLabels.length - 1);
            
            for (let i = 0; i < xLabels.length; i++) {
                const x = padding.left + i * xStep;
                ctx.fillText(String(xLabels[i]), x, height - padding.bottom + 20);
            }
            
            // Draw lines
            const lines = Array.isArray(data) ? data : [{ values: data, color: '#00ff88' }];
            
            for (const line of lines) {
                const values = Object.values(line.values);
                if (values.length === 0) continue;
                
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < values.length; i++) {
                    const x = padding.left + i * xStep;
                    const y = padding.top + chartHeight - (values[i] / maxY) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = line.color;
                for (let i = 0; i < values.length; i++) {
                    const x = padding.left + i * xStep;
                    const y = padding.top + chartHeight - (values[i] / maxY) * chartHeight;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        drawBarChart(canvasId, data, options = {}) {
            const { canvas, ctx } = this.charts[canvasId];
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            
            ctx.clearRect(0, 0, width, height);
            
            const padding = { top: 20, right: 20, bottom: 60, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const entries = Object.entries(data);
            const barWidth = chartWidth / entries.length * 0.7;
            const gap = chartWidth / entries.length * 0.3;
            
            const maxY = options.maxY || Math.max(...entries.map(e => e[1]), 1);
            
            // Draw grid
            ctx.strokeStyle = '#2a2a3a';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Y-axis labels
            ctx.fillStyle = '#555566';
            ctx.font = '10px JetBrains Mono';
            ctx.textAlign = 'right';
            
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                const value = maxY - (maxY / 5) * i;
                ctx.fillText(options.formatY ? options.formatY(value) : value.toFixed(2), padding.left - 8, y + 3);
            }
            
            // Draw bars
            entries.forEach(([key, value], i) => {
                const strategy = STRATEGIES.find(s => s.id === key);
                const x = padding.left + (barWidth + gap) * i + gap / 2;
                const barHeight = (value / maxY) * chartHeight;
                const y = padding.top + chartHeight - barHeight;
                
                // Bar
                ctx.fillStyle = strategy ? strategy.color : '#6677ff';
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Label
                ctx.save();
                ctx.translate(x + barWidth / 2, height - padding.bottom + 10);
                ctx.rotate(-Math.PI / 4);
                ctx.fillStyle = '#888888';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                ctx.fillText(strategy ? strategy.name : key, 0, 0);
                ctx.restore();
            });
        }
        
        drawTimelineChart(canvasId, timelineData) {
            const { canvas, ctx } = this.charts[canvasId];
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            
            ctx.clearRect(0, 0, width, height);
            
            if (timelineData.length < 2) {
                ctx.fillStyle = '#555566';
                ctx.font = '12px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText('Collecting data...', width / 2, height / 2);
                return;
            }
            
            const padding = { top: 20, right: 20, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Draw grid
            ctx.strokeStyle = '#2a2a3a';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Draw lines for each bias level
            const biasColors = [
                '#00ff88', '#22ee99', '#44ddaa', '#66ccbb', '#88bbcc',
                '#aaaadd', '#cc99ee', '#ee88ff', '#ff77ee', '#ff66dd'
            ];
            
            const xStep = chartWidth / (timelineData.length - 1);
            
            for (let b = 0; b < BIAS_LEVELS.length; b++) {
                const bias = BIAS_LEVELS[b];
                ctx.strokeStyle = biasColors[b];
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                for (let i = 0; i < timelineData.length; i++) {
                    const x = padding.left + i * xStep;
                    const value = timelineData[i].winRateByBias[bias] || 0;
                    const y = padding.top + chartHeight - value * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
            
            // X-axis labels
            ctx.fillStyle = '#555566';
            ctx.font = '10px JetBrains Mono';
            ctx.textAlign = 'center';
            
            const lastGames = timelineData[timelineData.length - 1].games;
            ctx.fillText('0', padding.left, height - padding.bottom + 20);
            ctx.fillText(lastGames.toLocaleString(), width - padding.right, height - padding.bottom + 20);
        }
        
        update(stats) {
            // Win rate by bias
            if (this.viewModes.winrate === 'all') {
                this.drawLineChart('chart-winrate', stats.getWinRateByBias(), { maxY: 0.15 });
            } else {
                const byStrategy = stats.getWinRateByBiasAndStrategy();
                const lines = STRATEGIES.map(s => ({
                    values: byStrategy[s.id],
                    color: s.color
                }));
                this.drawLineChart('chart-winrate', lines, { maxY: 0.15 });
            }
            
            // Avg coins by bias
            if (this.viewModes.coins === 'all') {
                this.drawLineChart('chart-coins', stats.getAvgCoinsByBias(), { 
                    maxY: 200,
                    formatY: v => v.toFixed(0)
                });
            } else {
                const byStrategy = stats.getAvgCoinsByBiasAndStrategy();
                const lines = STRATEGIES.map(s => ({
                    values: byStrategy[s.id],
                    color: s.color
                }));
                this.drawLineChart('chart-coins', lines, { 
                    maxY: 200,
                    formatY: v => v.toFixed(0)
                });
            }
            
            // Survival by bias
            if (this.viewModes.survival === 'all') {
                this.drawLineChart('chart-survival', stats.getSurvivalByBias(), {
                    maxY: 10,
                    formatY: v => v.toFixed(1)
                });
            } else {
                const byStrategy = stats.getSurvivalByBiasAndStrategy();
                const lines = STRATEGIES.map(s => ({
                    values: byStrategy[s.id],
                    color: s.color
                }));
                this.drawLineChart('chart-survival', lines, {
                    maxY: 10,
                    formatY: v => v.toFixed(1)
                });
            }
            
            // Strategy charts
            this.drawBarChart('chart-strategy-winrate', stats.getWinRateByStrategy(), { maxY: 0.15 });
            this.drawBarChart('chart-strategy-coins', stats.getAvgCoinsByStrategy(), {
                maxY: 200,
                formatY: v => v.toFixed(0)
            });
            
            // Timeline
            this.drawTimelineChart('chart-timeline', stats.timelineData);
        }
    }
    
    // ============================================
    // UI CONTROLLER
    // ============================================
    class UIController {
        constructor(agents, stats) {
            this.agents = agents;
            this.stats = stats;
            this.tooltip = document.getElementById('tooltip');
            this.toast = document.getElementById('toast');
        }
        
        init() {
            this.renderLegend();
            this.renderAgentMatrix();
            this.bindEvents();
        }
        
        renderLegend() {
            const legend = document.getElementById('strategy-legend');
            legend.innerHTML = STRATEGIES.map(s => `
                <div class="legend-item">
                    <div class="legend-color" style="background: ${s.color}"></div>
                    ${s.name}
                </div>
            `).join('');
        }
        
        renderAgentMatrix() {
            const matrix = document.getElementById('agent-matrix');
            matrix.innerHTML = '';
            
            // Create 9 rows (strategies) × 10 cols (biases)
            for (let s = 0; s < STRATEGIES.length; s++) {
                for (let b = 0; b < BIAS_LEVELS.length; b++) {
                    const agent = this.agents.find(a => 
                        a.strategy.id === STRATEGIES[s].id && a.bias === BIAS_LEVELS[b]
                    );
                    
                    const cell = document.createElement('div');
                    cell.className = 'agent-cell';
                    cell.dataset.agentId = agent.id;
                    cell.style.backgroundColor = STRATEGIES[s].color + '40';
                    
                    cell.addEventListener('mouseenter', (e) => this.showTooltip(e, agent));
                    cell.addEventListener('mouseleave', () => this.hideTooltip());
                    
                    matrix.appendChild(cell);
                }
            }
        }
        
        updateAgentMatrix() {
            const cells = document.querySelectorAll('.agent-cell');
            
            cells.forEach(cell => {
                const agentId = parseInt(cell.dataset.agentId);
                const winRate = this.stats.getAgentWinRate(agentId);
                
                // Color intensity based on win rate
                const intensity = Math.min(1, winRate * 10); // Scale for visibility
                const agent = this.agents.find(a => a.id === agentId);
                const baseColor = agent.strategy.color;
                
                // Interpolate from dark to strategy color
                cell.style.backgroundColor = this.interpolateColor('#1a1a25', baseColor, intensity);
            });
        }
        
        interpolateColor(color1, color2, factor) {
            const c1 = this.hexToRgb(color1);
            const c2 = this.hexToRgb(color2);
            
            const r = Math.round(c1.r + (c2.r - c1.r) * factor);
            const g = Math.round(c1.g + (c2.g - c1.g) * factor);
            const b = Math.round(c1.b + (c2.b - c1.b) * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        showTooltip(e, agent) {
            const stats = this.stats.agentStats[agent.id];
            const winRate = stats.gamesPlayed > 0 ?
                ((stats.wins + stats.sharedWins * 0.5) / stats.gamesPlayed * 100).toFixed(2) : '0.00';
            const avgCoins = stats.gamesPlayed > 0 ?
                (stats.totalCoins / stats.gamesPlayed).toFixed(1) : '0.0';
            const avgRounds = stats.gamesPlayed > 0 ?
                (stats.totalRoundsLasted / stats.gamesPlayed).toFixed(1) : '0.0';
            
            this.tooltip.innerHTML = `
                <div class="tooltip-title">${agent.name}</div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Strategy</span>
                    <span class="tooltip-value">${agent.strategy.name} (${agent.strategy.category})</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Steal Bias</span>
                    <span class="tooltip-value">${(agent.bias * 100).toFixed(0)}%</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Win Rate</span>
                    <span class="tooltip-value">${winRate}%</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Avg Coins</span>
                    <span class="tooltip-value">${avgCoins}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Avg Survival</span>
                    <span class="tooltip-value">${avgRounds} rounds</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Games</span>
                    <span class="tooltip-value">${stats.gamesPlayed.toLocaleString()}</span>
                </div>
            `;
            
            this.tooltip.style.left = `${e.clientX + 15}px`;
            this.tooltip.style.top = `${e.clientY + 15}px`;
            this.tooltip.classList.add('visible');
        }
        
        hideTooltip() {
            this.tooltip.classList.remove('visible');
        }
        
        updateStats(gps = 0) {
            document.getElementById('total-games').textContent = 
                this.stats.totalGames.toLocaleString();
            document.getElementById('stat-victories').textContent = 
                this.stats.victories.toLocaleString();
            document.getElementById('stat-shared').textContent = 
                this.stats.sharedVictories.toLocaleString();
            document.getElementById('stat-destruction').textContent = 
                this.stats.mutualDestructions.toLocaleString();
            document.getElementById('stat-rounds').textContent = 
                this.stats.totalGames > 0 ? 
                    (this.stats.totalRounds / this.stats.totalGames).toFixed(1) : '0';
            document.getElementById('stat-gps').textContent = 
                gps >= 1000 ? (gps / 1000).toFixed(1) + 'k' : gps;
        }
        
        updateTopPerformers() {
            const performers = this.stats.getTopPerformers(5);
            const container = document.getElementById('top-performers');
            
            container.innerHTML = performers.map((p, i) => `
                <div class="stat-item" style="margin-bottom: 0.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: ${p.agent.strategy.color}; font-size: 0.75rem;">
                            #${i + 1} ${p.agent.name}
                        </span>
                        <span style="color: var(--accent-split); font-size: 0.8rem;">
                            ${(p.winRate * 100).toFixed(2)}%
                        </span>
                    </div>
                    <div style="font-size: 0.65rem; color: var(--text-dim); margin-top: 0.25rem;">
                        Avg: ${p.avgCoins.toFixed(0)} coins
                    </div>
                </div>
            `).join('');
        }
        
        showToast(message) {
            this.toast.textContent = message;
            this.toast.classList.add('show');
            setTimeout(() => this.toast.classList.remove('show'), 3000);
        }
        
        bindEvents() {
            // Additional UI event bindings can go here
        }
    }
    
    // ============================================
    // MAIN APPLICATION
    // ============================================
    class App {
        constructor() {
            this.agents = this.createAgents();
            this.engine = new GameEngine(this.agents);
            this.stats = new StatsTracker(this.agents);
            this.charts = new ChartRenderer();
            this.ui = new UIController(this.agents, this.stats);
            
            this.running = false;
            this.speed = 50;
            this.gamesPerBatch = 10;
            this.timeoutId = null;
            this.lastUIUpdate = 0;
            this.currentGPS = 0;
        }
        
        createAgents() {
            const agents = [];
            let id = 0;
            
            for (const strategy of STRATEGIES) {
                for (const bias of BIAS_LEVELS) {
                    agents.push(new Agent(id++, bias, strategy));
                }
            }
            
            return agents;
        }
        
        init() {
            this.charts.init();
            this.ui.init();
            this.bindControls();
            this.updateUI();
            
            // EASTER EGG: Konami code reveals hidden stats
            this.konamiCode = [];
            const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
            document.addEventListener('keydown', (e) => {
                this.konamiCode.push(e.keyCode);
                this.konamiCode = this.konamiCode.slice(-10);
                if (this.konamiCode.join(',') === konamiSequence.join(',')) {
                    this.ui.showToast('🎮 Secret mode: Cooperation bias revealed!');
                    console.log('EASTER EGG: The secret to winning is... moderate cooperation!');
                }
            });
        }
        
        bindControls() {
            const btnRun = document.getElementById('btn-run');
            const btnReset = document.getElementById('btn-reset');
            const btnExport = document.getElementById('btn-export');
            const speedSlider = document.getElementById('speed');
            const speedDisplay = document.getElementById('speed-display');
            
            btnRun.addEventListener('click', () => {
                if (this.running) {
                    this.stop();
                    btnRun.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg>
                        Run
                    `;
                    btnRun.classList.remove('running');
                } else {
                    this.start();
                    btnRun.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                        Pause
                    `;
                    btnRun.classList.add('running');
                }
            });
            
            btnReset.addEventListener('click', () => {
                this.reset();
            });
            
            btnExport.addEventListener('click', () => {
                this.exportData();
            });
            
            speedSlider.addEventListener('input', () => {
                this.speed = parseInt(speedSlider.value);
                this.gamesPerBatch = Math.max(1, Math.ceil(this.speed / 5));
                const estimatedGPS = this.speed * 20;
                speedDisplay.textContent = `~${estimatedGPS >= 1000 ? (estimatedGPS/1000).toFixed(1) + 'k' : estimatedGPS}/s`;
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ' && !e.target.matches('input, button')) {
                    e.preventDefault();
                    btnRun.click();
                }
                if (e.key === 'r' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    btnReset.click();
                }
            });
        }
        
        start() {
            this.running = true;
            this.lastUIUpdate = 0;
            this.gpsTracker = { lastTime: performance.now(), lastCount: this.stats.totalGames };
            this.runBatch();
        }
        
        stop() {
            this.running = false;
            if (this.timeoutId) {
                clearTimeout(this.timeoutId);
                this.timeoutId = null;
            }
        }
        
        reset() {
            this.stop();
            this.stats.reset();
            this.currentGPS = 0;
            this.updateUI();
            
            document.getElementById('btn-run').innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg>
                Run
            `;
            document.getElementById('btn-run').classList.remove('running');
            
            this.ui.showToast('Statistics reset');
        }
        
        runBatch() {
            if (!this.running) return;
            
            // Run a small batch of games (keeps each batch under ~8ms)
            const batchSize = Math.max(1, Math.min(this.gamesPerBatch, 20));
            
            for (let i = 0; i < batchSize; i++) {
                this.engine.reset();
                const result = this.engine.playGame();
                this.stats.recordGame(result);
            }
            
            // Update UI every ~100ms for smooth visuals without blocking
            const now = performance.now();
            if (now - this.lastUIUpdate > 100) {
                // Calculate actual games per second
                const elapsed = (now - this.gpsTracker.lastTime) / 1000;
                if (elapsed > 0) {
                    this.currentGPS = Math.round((this.stats.totalGames - this.gpsTracker.lastCount) / elapsed);
                    this.gpsTracker = { lastTime: now, lastCount: this.stats.totalGames };
                }
                
                this.updateUI();
                this.lastUIUpdate = now;
            }
            
            // Calculate delay based on speed setting
            // speed 1 = ~10 games/sec, speed 100 = ~2000 games/sec
            const targetGamesPerSecond = this.speed * 20;
            const delay = Math.max(0, (1000 / targetGamesPerSecond) * batchSize);
            
            // Use setTimeout to yield to browser, keeping UI responsive
            this.timeoutId = setTimeout(() => this.runBatch(), delay);
        }
        
        updateUI() {
            this.ui.updateStats(this.currentGPS);
            this.ui.updateAgentMatrix();
            this.ui.updateTopPerformers();
            this.charts.update(this.stats);
        }
        
        exportData() {
            const data = {
                totalGames: this.stats.totalGames,
                victories: this.stats.victories,
                sharedVictories: this.stats.sharedVictories,
                mutualDestructions: this.stats.mutualDestructions,
                avgRounds: this.stats.totalGames > 0 ? 
                    this.stats.totalRounds / this.stats.totalGames : 0,
                winRateByBias: this.stats.getWinRateByBias(),
                avgCoinsByBias: this.stats.getAvgCoinsByBias(),
                survivalByBias: this.stats.getSurvivalByBias(),
                winRateByStrategy: this.stats.getWinRateByStrategy(),
                avgCoinsByStrategy: this.stats.getAvgCoinsByStrategy(),
                topPerformers: this.stats.getTopPerformers(10),
                agentStats: {}
            };
            
            for (const agent of this.agents) {
                const stats = this.stats.agentStats[agent.id];
                data.agentStats[agent.name] = {
                    bias: agent.bias,
                    strategy: agent.strategy.name,
                    category: agent.strategy.category,
                    wins: stats.wins,
                    sharedWins: stats.sharedWins,
                    totalCoins: stats.totalCoins,
                    avgCoins: stats.gamesPlayed > 0 ? stats.totalCoins / stats.gamesPlayed : 0,
                    winRate: stats.gamesPlayed > 0 ? 
                        (stats.wins + stats.sharedWins * 0.5) / stats.gamesPlayed : 0,
                    gamesPlayed: stats.gamesPlayed
                };
            }
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `split-steal-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            this.ui.showToast('Data exported successfully');
        }
    }
    
    // Initialize application
    const app = new App();
    app.init();
    </script>
</body>
</html>