<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flying Evolution Algorithm</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 250px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-size: 11px;
            color: #ccc;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 200px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Wind Tunnel Controls</h3>
            
            <div class="control-group">
                <label>Wind Speed: <span id="windSpeedValue">10 m/s</span></label>
                <input type="range" id="windSpeed" min="1" max="20" value="10" step="0.1">
            </div>
            
            <div class="control-group">
                <label>Population Size: <span id="populationValue">10</span></label>
                <input type="range" id="populationSize" min="4" max="100" value="10" step="1">
            </div>
            
            <div class="control-group">
                <label>Test Duration: <span id="testDurationValue">60s</span></label>
                <input type="range" id="testDuration" min="10" max="180" value="60" step="5">
            </div>
            
            <button id="startEvolution">Start Evolution</button>
            <button id="resetSim">Reset</button>
            <button id="pausePlay">Pause</button>
        </div>
        
        <div id="stats">
            <h3>Generation Stats</h3>
            <div>Generation: <span id="generation">0</span></div>
            <div>Best Lift: <span id="bestLift">0.00 N</span></div>
            <div>Avg Lift: <span id="avgLift">0.00 N</span></div>
            <div>Test Time: <span id="testTime">0s</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, windTunnel;
        let flyingObjects = [];
        let particles = [];
        let evolutionRunning = false;
        let currentGeneration = 0;
        let testStartTime = 0;
        let animationId;
        
        // Wind tunnel parameters
        let windSpeed = 10; // m/s
        let populationSize = 10;
        let testDuration = 60; // seconds
        
        // Initialize the simulation
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Create wind tunnel
            createWindTunnel();
            
            // Create lighting
            setupLighting();
            
            // Create particle system
            createParticleSystem();
            
            // Create initial population
            createInitialPopulation();
            
            // Setup controls
            setupControls();
            
            // Start animation loop
            animate();
        }
        
        function createWindTunnel() {
            // Wind tunnel walls (transparent)
            const tunnelGeometry = new THREE.BoxGeometry(20, 10, 30);
            const tunnelMaterial = new THREE.MeshBasicMaterial({
                color: 0x4169E1,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            windTunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            scene.add(windTunnel);
            
            // Add grid floor for reference
            const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x444444);
            gridHelper.position.y = -5;
            scene.add(gridHelper);
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
        }
        
        function createParticleSystem() {
            // Create particle geometry
            const particleCount = 1000;
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // Start particles at the back of the tunnel
                positions[i3] = (Math.random() - 0.5) * 18; // x
                positions[i3 + 1] = (Math.random() - 0.5) * 8; // y
                positions[i3 + 2] = -14 + Math.random() * 2; // z (back of tunnel)
                
                // Initial velocity in wind direction
                velocities[i3] = 0; // x velocity
                velocities[i3 + 1] = 0; // y velocity  
                velocities[i3 + 2] = windSpeed; // z velocity (forward)
            }
            
            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ff88,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            
            // Store references for animation
            particles = {
                geometry: particleGeometry,
                positions: positions,
                velocities: velocities,
                count: particleCount
            };
        }
        
        // Flying object class
        class FlyingObject {
            constructor() {
                this.group = new THREE.Group();
                this.mass = 0.05 + Math.random() * 4.95; // 0.05 to 5.0 kg
                this.bodyAttitude = -5 + Math.random() * 30; // -5 to 25 degrees
                this.flappingFreq = 0.1 + Math.random() * 9.9; // 0.1 to 10 Hz
                this.articulationAngle = 5 + Math.random() * 80; // 5 to 85 degrees
                this.stiffness = 0.05 + Math.random() * 0.9; // 0.05 to 0.95
                
                this.currentLift = 0;
                this.totalLift = 0;
                this.testSamples = 0;
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 10
                );
                
                this.createBody();
                this.createWings();
                this.group.position.copy(this.position);
                scene.add(this.group);
            }
            
            createBody() {
                const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.15, 1.5, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Rotate to align with flight direction and apply body attitude
                this.body.rotation.z = Math.PI / 2; // Align horizontally
                this.body.rotation.y = THREE.MathUtils.degToRad(this.bodyAttitude);
                this.group.add(this.body);
            }
            
            createWings() {
                this.wings = [];
                
                for (let side = 0; side < 2; side++) {
                    const wing = new THREE.Group();
                    const wingSurfaces = [];
                    
                    // Create 4x4 grid of wing surfaces
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            const surfaceGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                            const surfaceMaterial = new THREE.MeshLambertMaterial({
                                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6),
                                transparent: true,
                                opacity: 0.8,
                                side: THREE.DoubleSide
                            });
                            
                            const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
                            
                            // Position in wing grid
                            surface.position.set(
                                (side === 0 ? 1 : -1) * (0.5 + i * 0.3),
                                j * 0.3 - 0.45,
                                0
                            );
                            
                            // Add some random deformation while maintaining continuity
                            const deformationX = (Math.random() - 0.5) * 0.2 * (1 - this.stiffness);
                            const deformationY = (Math.random() - 0.5) * 0.2 * (1 - this.stiffness);
                            surface.rotation.x = deformationX;
                            surface.rotation.y = deformationY;
                            
                            wingSurfaces.push(surface);
                            wing.add(surface);
                        }
                    }
                    
                    // Apply wing articulation
                    wing.rotation.z = THREE.MathUtils.degToRad(
                        (side === 0 ? 1 : -1) * this.articulationAngle
                    );
                    
                    this.wings.push({ group: wing, surfaces: wingSurfaces });
                    this.group.add(wing);
                }
            }
            
            update(deltaTime) {
                // Flapping animation
                const flappingOffset = Math.sin(Date.now() * 0.001 * this.flappingFreq * 2 * Math.PI) * 0.3;
                this.wings.forEach((wing, index) => {
                    const side = index === 0 ? 1 : -1;
                    wing.group.rotation.z = THREE.MathUtils.degToRad(side * this.articulationAngle) + flappingOffset;
                });
                
                // Simple lift calculation based on wing area, wind speed, and angle
                this.calculateLift();
                
                // Apply physics
                const gravity = new THREE.Vector3(0, -9.81 * this.mass, 0);
                const liftForce = new THREE.Vector3(0, this.currentLift, 0);
                
                const totalForce = gravity.add(liftForce);
                const acceleration = totalForce.divideScalar(this.mass);
                
                this.velocity.add(acceleration.multiplyScalar(deltaTime));
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Keep within wind tunnel bounds
                this.position.x = Math.max(-9, Math.min(9, this.position.x));
                this.position.y = Math.max(-4, Math.min(4, this.position.y));
                this.position.z = Math.max(-14, Math.min(14, this.position.z));
                
                this.group.position.copy(this.position);
                
                // Record lift data
                this.totalLift += this.currentLift;
                this.testSamples++;
            }
            
            calculateLift() {
                // Simplified aerodynamic calculation
                const wingArea = 16 * 0.3 * 0.3 * 2; // Total wing area
                const airDensity = 1.225; // kg/mÂ³ at sea level
                const effectiveWindSpeed = windSpeed - this.velocity.z;
                
                // Angle of attack effect (simplified)
                const angleOfAttack = Math.abs(this.bodyAttitude) * Math.PI / 180;
                const liftCoefficient = Math.sin(2 * angleOfAttack) * 0.8; // Simplified
                
                // Flapping effect
                const flappingBonus = Math.abs(Math.sin(Date.now() * 0.001 * this.flappingFreq * 2 * Math.PI)) * 0.5;
                
                this.currentLift = 0.5 * airDensity * effectiveWindSpeed * effectiveWindSpeed * wingArea * 
                                 (liftCoefficient + flappingBonus) * this.stiffness;
            }
            
            getAverageLift() {
                return this.testSamples > 0 ? this.totalLift / this.testSamples : 0;
            }
            
            dispose() {
                scene.remove(this.group);
            }
        }
        
        function createInitialPopulation() {
            // Clear existing population
            flyingObjects.forEach(obj => obj.dispose());
            flyingObjects = [];
            
            // Create new population
            for (let i = 0; i < populationSize; i++) {
                flyingObjects.push(new FlyingObject());
            }
        }
        
        function setupControls() {
            // Wind speed control
            const windSpeedSlider = document.getElementById('windSpeed');
            const windSpeedValue = document.getElementById('windSpeedValue');
            windSpeedSlider.addEventListener('input', (e) => {
                windSpeed = parseFloat(e.target.value);
                windSpeedValue.textContent = windSpeed.toFixed(1) + ' m/s';
            });
            
            // Population size control
            const populationSlider = document.getElementById('populationSize');
            const populationValue = document.getElementById('populationValue');
            populationSlider.addEventListener('input', (e) => {
                populationSize = parseInt(e.target.value);
                populationValue.textContent = populationSize;
                if (!evolutionRunning) {
                    createInitialPopulation();
                }
            });
            
            // Test duration control
            const testDurationSlider = document.getElementById('testDuration');
            const testDurationValue = document.getElementById('testDurationValue');
            testDurationSlider.addEventListener('input', (e) => {
                testDuration = parseInt(e.target.value);
                testDurationValue.textContent = testDuration + 's';
            });
            
            // Start evolution button
            document.getElementById('startEvolution').addEventListener('click', () => {
                evolutionRunning = true;
                testStartTime = Date.now();
                currentGeneration++;
                document.getElementById('startEvolution').textContent = 'Running...';
            });
            
            // Reset button
            document.getElementById('resetSim').addEventListener('click', () => {
                evolutionRunning = false;
                currentGeneration = 0;
                createInitialPopulation();
                document.getElementById('startEvolution').textContent = 'Start Evolution';
            });
            
            // Pause/Play button
            document.getElementById('pausePlay').addEventListener('click', () => {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                    document.getElementById('pausePlay').textContent = 'Play';
                } else {
                    animate();
                    document.getElementById('pausePlay').textContent = 'Pause';
                }
            });
        }
        
        function updateParticles() {
            const positions = particles.positions;
            const velocities = particles.velocities;
            
            for (let i = 0; i < particles.count; i++) {
                const i3 = i * 3;
                
                // Update positions
                positions[i3] += velocities[i3] * 0.016; // x
                positions[i3 + 1] += velocities[i3 + 1] * 0.016; // y
                positions[i3 + 2] += windSpeed * 0.016; // z (forward movement)
                
                // Reset particles that exit the tunnel
                if (positions[i3 + 2] > 15) {
                    positions[i3] = (Math.random() - 0.5) * 18;
                    positions[i3 + 1] = (Math.random() - 0.5) * 8;
                    positions[i3 + 2] = -14;
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
        }
        
        function updateStats() {
            if (flyingObjects.length === 0) return;
            
            const lifts = flyingObjects.map(obj => obj.getAverageLift());
            const bestLift = Math.max(...lifts);
            const avgLift = lifts.reduce((a, b) => a + b, 0) / lifts.length;
            
            document.getElementById('generation').textContent = currentGeneration;
            document.getElementById('bestLift').textContent = bestLift.toFixed(3) + ' N';
            document.getElementById('avgLift').textContent = avgLift.toFixed(3) + ' N';
            
            if (evolutionRunning) {
                const elapsed = (Date.now() - testStartTime) / 1000;
                document.getElementById('testTime').textContent = elapsed.toFixed(1) + 's';
                
                // Check if test is complete
                if (elapsed >= testDuration) {
                    runEvolution();
                }
            }
        }
        
        function runEvolution() {
            // Selection: Keep top 20%
            const sortedObjects = flyingObjects.sort((a, b) => b.getAverageLift() - a.getAverageLift());
            const survivors = sortedObjects.slice(0, Math.ceil(populationSize * 0.2));
            
            // Dispose of non-survivors
            sortedObjects.slice(Math.ceil(populationSize * 0.2)).forEach(obj => obj.dispose());
            
            // Create new generation through crossover and mutation
            const newPopulation = [];
            
            // Keep survivors
            survivors.forEach(survivor => {
                survivor.totalLift = 0;
                survivor.testSamples = 0;
                newPopulation.push(survivor);
            });
            
            // Create offspring
            while (newPopulation.length < populationSize) {
                const parent1 = survivors[Math.floor(Math.random() * survivors.length)];
                const parent2 = survivors[Math.floor(Math.random() * survivors.length)];
                
                const offspring = createOffspring(parent1, parent2);
                newPopulation.push(offspring);
            }
            
            flyingObjects = newPopulation;
            
            // Start next generation
            testStartTime = Date.now();
            currentGeneration++;
        }
        
        function createOffspring(parent1, parent2) {
            const offspring = new FlyingObject();
            
            // Crossover: randomly inherit traits from parents
            offspring.mass = Math.random() < 0.5 ? parent1.mass : parent2.mass;
            offspring.bodyAttitude = Math.random() < 0.5 ? parent1.bodyAttitude : parent2.bodyAttitude;
            offspring.flappingFreq = Math.random() < 0.5 ? parent1.flappingFreq : parent2.flappingFreq;
            offspring.articulationAngle = Math.random() < 0.5 ? parent1.articulationAngle : parent2.articulationAngle;
            offspring.stiffness = Math.random() < 0.5 ? parent1.stiffness : parent2.stiffness;
            
            // Mutation: small random changes
            const mutationRate = 0.1;
            if (Math.random() < mutationRate) {
                offspring.mass += (Math.random() - 0.5) * 0.5;
                offspring.mass = Math.max(0.05, Math.min(5.0, offspring.mass));
            }
            if (Math.random() < mutationRate) {
                offspring.bodyAttitude += (Math.random() - 0.5) * 10;
                offspring.bodyAttitude = Math.max(-5, Math.min(25, offspring.bodyAttitude));
            }
            if (Math.random() < mutationRate) {
                offspring.flappingFreq += (Math.random() - 0.5) * 2;
                offspring.flappingFreq = Math.max(0.1, Math.min(10, offspring.flappingFreq));
            }
            if (Math.random() < mutationRate) {
                offspring.articulationAngle += (Math.random() - 0.5) * 20;
                offspring.articulationAngle = Math.max(5, Math.min(85, offspring.articulationAngle));
            }
            if (Math.random() < mutationRate) {
                offspring.stiffness += (Math.random() - 0.5) * 0.2;
                offspring.stiffness = Math.max(0.05, Math.min(0.95, offspring.stiffness));
            }
            
            // Recreate the object with new parameters
            offspring.dispose();
            const newOffspring = new FlyingObject();
            newOffspring.mass = offspring.mass;
            newOffspring.bodyAttitude = offspring.bodyAttitude;
            newOffspring.flappingFreq = offspring.flappingFreq;
            newOffspring.articulationAngle = offspring.articulationAngle;
            newOffspring.stiffness = offspring.stiffness;
            
            return newOffspring;
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            const deltaTime = 0.016; // Assume 60fps
            
            // Update particles
            updateParticles();
            
            // Update flying objects
            flyingObjects.forEach(obj => obj.update(deltaTime));
            
            // Update stats
            updateStats();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize the simulation
        init();
    </script>
</body>
</html>