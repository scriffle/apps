<!DOCTYPE html>
<html>
<!-- Previous head and style sections remain the same -->
<head>
    <title>3D Wind Tunnel Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; }
        .container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            padding: 10px;
        }
        .wind-tunnel {
            width: 100%;
            height: 300px;
            border: 2px solid #444;
            position: relative;
            transition: border-color 0.3s;
        }
        .wind-tunnel.best {
            border-color: #4f4;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }
        .force-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            line-height: 1.4;
        }
        .shape-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #666;
            border-radius: 5px;
        }
        #control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
        }
        .control-group input {
            width: 100%;
        }
        .value-display {
            float: right;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Previous HTML remains the same -->
    <div id="control-panel">
        <div class="control-group">
            <label>
                Number of Instances: <span id="instance-value" class="value-display">12</span>
            </label>
            <input type="range" id="instance-control" min="2" max="12" value="12" step="1">
        </div>
        <div class="control-group">
            <label>
                Active Particles: <span id="particle-value" class="value-display">1000</span>
            </label>
            <input type="range" id="particle-control" min="100" max="10000" value="1000" step="100">
        </div>
    </div>
    <div class="container" id="tunnels"></div>

    <script>
        // Previous shared resources code remains the same
        const sharedGeometries = {
            tunnel: new THREE.BoxGeometry(10, 5, 20),
            particle: new THREE.SphereGeometry(0.06, 6, 6)
        };

        const sharedMaterials = {
            tunnel: new THREE.MeshBasicMaterial({
                color: 0x808080,
                wireframe: true
            }),
            testObject: new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                wireframe: true
            }),
            particle: new THREE.MeshBasicMaterial({ 
                color: 0xffff00
            })
        };

        function createSimpleCurvedSurface() {
            const width = 3;
            const height = 1.5;
            const segments = 2;
            
            const geometry = new THREE.ParametricBufferGeometry((u, v, target) => {
                const x = (u - 0.5) * width;
                const z = (v - 0.5) * width;
                
                const bendAmount = 0.3 + Math.random() * 0.4;
                const bendDirection = Math.random() > 0.5 ? 1 : -1;
                
                const y = bendDirection * bendAmount * Math.sin(Math.PI * u);
                
                target.set(x, y, z);
            }, segments, segments);
            
            return geometry;
        }

        // Previous Particle class remains the same
        class Particle {
            constructor() {
                this.mesh = new THREE.Mesh(sharedGeometries.particle, sharedMaterials.particle);
                this.velocity = new THREE.Vector3(0, 0, 0.15);
                this.reset();
            }

            reset() {
                this.mesh.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 3,
                    -10
                );
                this.velocity.set(0, 0, 0.15);
            }

            update(testObject) {
                const localPoint = Array.from(
                    { length: testObject.geometry.attributes.position.count }, 
                    (_, i) => new THREE.Vector3().fromBufferAttribute(testObject.geometry.attributes.position, i)
                );
                
                let minDist = Infinity;
                let surfaceNormal = new THREE.Vector3();

                localPoint.forEach(point => {
                    const worldPoint = point.clone().applyMatrix4(testObject.matrixWorld);
                    const dist = this.mesh.position.distanceTo(worldPoint);
                    if (dist < minDist) {
                        minDist = dist;
                        surfaceNormal.copy(worldPoint).sub(testObject.position).normalize();
                    }
                });

                if (minDist < 1) {
                    const deflectionForce = surfaceNormal.multiplyScalar(0.1 / minDist);
                    this.velocity.add(deflectionForce);
                    testObject.userData.forceAccumulator.y += deflectionForce.y * 0.1;
                }

                this.mesh.position.add(this.velocity);

                if (this.mesh.position.z > 10) {
                    this.reset();
                }

                this.velocity.lerp(new THREE.Vector3(0, 0, 0.15), 0.1);
            }
        }

        class WindTunnel {
            constructor(containerId, position) {
                this.container = document.createElement('div');
                this.container.className = 'wind-tunnel';
                document.getElementById('tunnels').appendChild(this.container);

                this.forceDisplay = document.createElement('div');
                this.forceDisplay.className = 'force-display';
                this.container.appendChild(this.forceDisplay);

                // Create main renderer
                this.renderer = new THREE.WebGLRenderer({
                    powerPreference: "high-performance",
                    preserveDrawingBuffer: false
                });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.container.appendChild(this.renderer.domElement);

                // Create preview renderer
                this.previewContainer = document.createElement('div');
                this.previewContainer.className = 'shape-preview';
                this.container.appendChild(this.previewContainer);
                
                this.previewRenderer = new THREE.WebGLRenderer({
                    alpha: true,
                    powerPreference: "low-power"
                });
                this.previewRenderer.setSize(100, 100);
                this.previewContainer.appendChild(this.previewRenderer.domElement);

                // Setup main scene
                this.scene = new THREE.Scene();
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 5, 5);
                this.scene.add(light);
                this.scene.add(new THREE.AmbientLight(0x404040));

                this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);

                // Setup preview scene
                this.previewScene = new THREE.Scene();
                this.previewScene.add(new THREE.AmbientLight(0xffffff));
                this.previewCamera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 1000);
                this.previewCamera.position.set(0, 5, 0);
                this.previewCamera.lookAt(0, 0, 0);

                this.tunnel = new THREE.Group();
                this.tunnel.add(new THREE.Mesh(sharedGeometries.tunnel, sharedMaterials.tunnel));

                const testObjectGeometry = createSimpleCurvedSurface();
                this.testObject = new THREE.Mesh(testObjectGeometry, sharedMaterials.testObject);
                this.testObject.position.z = -5;
                this.testObject.userData.forceAccumulator = new THREE.Vector3();
                this.testObject.userData.forceHistory = [];
                this.tunnel.add(this.testObject);

                // Create preview object
                this.previewObject = new THREE.Mesh(testObjectGeometry, sharedMaterials.testObject);
                this.previewScene.add(this.previewObject);

                this.particleGroup = new THREE.Group();
                this.tunnel.add(this.particleGroup);
                
                this.scene.add(this.tunnel);
                
                this.camera.position.z = 15;
                this.camera.position.y = 5;
                this.camera.lookAt(0, 0, 0);

                this.tunnel.rotation.y = position * Math.PI / 2;

                this.particles = [];
                this.targetParticleCount = 1000;
                this.lastParticleTime = 0;
                this.particleSpawnRate = 1000 / 120;

                this.forceHistoryLength = 60;
                
                this.isAnimating = true;
                this.animate();
            }

            // Previous methods remain the same
            calculateAverageForce() {
                const history = this.testObject.userData.forceHistory;
                if (history.length === 0) return 0;
                return history.reduce((sum, force) => sum + force, 0) / history.length;
            }

            getAverageForce() {
                return this.calculateAverageForce();
            }

            updateParticleCount(count) {
                this.targetParticleCount = count;
                while (this.particles.length > count) {
                    const particle = this.particles.pop();
                    this.particleGroup.remove(particle.mesh);
                }
            }

            destroy() {
                this.isAnimating = false;
                this.renderer.dispose();
                this.previewRenderer.dispose();
                this.container.remove();
            }

            animate = (timestamp) => {
                if (!this.isAnimating) return;
                requestAnimationFrame(this.animate);

                if (this.particles.length < this.targetParticleCount && 
                    timestamp - this.lastParticleTime > this.particleSpawnRate) {
                    const particle = new Particle();
                    this.particles.push(particle);
                    this.particleGroup.add(particle.mesh);
                    this.lastParticleTime = timestamp;
                }

                this.testObject.userData.forceAccumulator.set(0, 0, 0);

                this.particles.forEach(particle => {
                    particle.update(this.testObject);
                });

                const instantForce = this.testObject.userData.forceAccumulator.y;
                const history = this.testObject.userData.forceHistory;
                history.push(instantForce);
                if (history.length > this.forceHistoryLength) {
                    history.shift();
                }

                const avgForce = this.calculateAverageForce();
                
                this.forceDisplay.innerHTML = 
                    `Instant Force: ${instantForce.toFixed(3)}\n` +
                    `Average Force: ${avgForce.toFixed(3)}`;
                this.forceDisplay.style.color = avgForce > 0 ? '#8f8' : '#f88';

                this.tunnel.rotation.y += 0.001;
                
                // Render both main view and preview
                this.renderer.render(this.scene, this.camera);
                this.previewRenderer.render(this.previewScene, this.previewCamera);
            }
        }

        // Previous tunnel management code remains the same
        let tunnels = [];

        function updateTunnels(count) {
            tunnels.forEach(tunnel => tunnel.destroy());
            document.getElementById('tunnels').innerHTML = '';
            tunnels = [];

            const columns = Math.ceil(Math.sqrt(count));
            document.getElementById('tunnels').style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

            for (let i = 0; i < count; i++) {
                tunnels.push(new WindTunnel('tunnels', i));
            }
        }

        function updateParticles(count) {
            tunnels.forEach(tunnel => {
                tunnel.updateParticleCount(count);
            });
        }

        function highlightBestTunnel() {
            let maxForce = -Infinity;
            let bestTunnel = null;

            tunnels.forEach(tunnel => {
                const avgForce = tunnel.getAverageForce();
                if (avgForce > maxForce) {
                    maxForce = avgForce;
                    bestTunnel = tunnel;
                }
                tunnel.container.classList.remove('best');
            });

            if (bestTunnel && maxForce > 0) {
                bestTunnel.container.classList.add('best');
            }
        }

        const instanceControl = document.getElementById('instance-control');
        const particleControl = document.getElementById('particle-control');
        const instanceValue = document.getElementById('instance-value');
        const particleValue = document.getElementById('particle-value');

        instanceControl.addEventListener('input', (e) => {
            const count = parseInt(e.target.value);
            instanceValue.textContent = count;
            updateTunnels(count);
        });

        particleControl.addEventListener('input', (e) => {
            const count = parseInt(e.target.value);
            particleValue.textContent = count;
            updateParticles(count);
        });

        // Initial setup with 12 tunnels
        updateTunnels(12);

        // Regularly update best tunnel highlight
        setInterval(highlightBestTunnel, 1000);
    </script>
</body>
</html>