<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Species Flocking Ecosystem</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            font-size: 11px;
            border: 1px solid #333;
            max-width: 250px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            font-size: 11px;
            border: 1px solid #333;
            max-width: 220px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        #controls h4 {
            margin: 8px 0 4px 0;
            color: #0ff;
        }
        #controls label {
            display: block;
            margin: 3px 0;
        }
        #controls input[type="range"] {
            width: 100%;
            margin: 2px 0;
        }
        #controls button {
            width: 100%;
            margin: 2px 0;
            padding: 4px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            cursor: pointer;
        }
        #controls button:hover {
            background: #333;
        }
        .species-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
        }
        .species-count {
            float: right;
            color: #888;
        }
        #ecosystem-stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <h3 style="margin: 0 0 8px 0;">Ecosystem Status</h3>
        <div id="species-list"></div>
        <div id="ecosystem-stats">
            <div>Total Creatures: <span id="total-count">0</span></div>
            <div>Predation Rate: <span id="predation-rate">0</span>/s</div>
            <div>Birth Rate: <span id="birth-rate">0</span>/s</div>
            <div>FPS: <span id="fps">0</span></div>
            <div style="margin-top: 8px;">
                <canvas id="clock" width="60" height="60" style="border: 1px solid #333; border-radius: 50%;"></canvas>
                <span id="timeOfDay" style="vertical-align: top; margin-left: 5px;">Day</span>
            </div>
        </div>
        <div style="margin-top: 10px; font-size: 10px;">
            <div>Click: Add creature to dominant species</div>
            <div>Right-click: Remove nearest creature</div>
            <div>Shift+Click: Add food source</div>
        </div>
    </div>
    <div id="controls">
        <h3 style="margin: 0 0 8px 0;">Ecosystem Controls</h3>
        
        <h4>Global Settings</h4>
        <label>Time Speed: <input type="range" id="timeSpeed" min="0.1" max="3" step="0.1" value="1"></label>
        <label>Food Spawn Rate: <input type="range" id="foodRate" min="0" max="0.1" step="0.01" value="0.02"></label>
        <label>Evolution Rate: <input type="range" id="evolutionRate" min="0" max="0.1" step="0.01" value="0.02"></label>
        
        <h4>Species Mix</h4>
        <button id="addHawks">Add Hawks (Predator)</button>
        <button id="addSparrows">Add Sparrows (Prey)</button>
        <button id="addStarlings">Add Starlings (Omnivore)</button>
        <button id="addHummingbirds">Add Hummingbirds (Specialist)</button>
        <button id="addCrows">Add Crows (Scavenger)</button>
        <button id="addBats">Add Bats (Nocturnal)</button>
        
        <h4>Environment</h4>
        <button id="toggleDayNight">Toggle Day/Night</button>
        <button id="addNest">Add Nesting Area</button>
        <button id="addFlowers">Add Flower Patch</button>
        <button id="clearEnvironment">Clear Environment</button>
        
        <h4>Behaviors</h4>
        <label>Aggression: <input type="range" id="aggression" min="0" max="2" step="0.1" value="1"></label>
        <label>Fear Response: <input type="range" id="fear" min="0" max="2" step="0.1" value="1"></label>
        <label>Social Bonding: <input type="range" id="socialBonding" min="0" max="2" step="0.1" value="1"></label>
        <label>Territory Size: <input type="range" id="territorySize" min="50" max="300" step="25" value="150"></label>
        
        <h4>Simulation</h4>
        <button id="pausePlay">Pause/Play</button>
        <button id="reset">Reset Ecosystem</button>
        <label>Max Population: <input type="range" id="maxPop" min="500" max="5000" step="500" value="2000"></label>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
        
        // Constants
        const PI2 = Math.PI * 2;
        
        // Time
        let timeSpeed = 1;
        let dayTime = 0; // 0-1, 0=midnight, 0.5=noon
        let isDay = true;
        let paused = false;
        
        // Species definitions
        const SPECIES = {
            HAWK: {
                id: 0,
                name: 'Hawk',
                color: '#f44',
                size: 12,
                speed: 5,
                diet: 'carnivore',
                preyOn: ['SPARROW', 'HUMMINGBIRD', 'BAT'],
                flockSize: 3,
                perception: 80,
                energy: 1,
                birthRate: 0.00001,
                deathAge: 50000,
                territorial: true,
                nocturnal: false
            },
            SPARROW: {
                id: 1,
                name: 'Sparrow',
                color: '#fa4',
                size: 6,
                speed: 4,
                diet: 'herbivore',
                preyOn: [],
                flockSize: 20,
                perception: 50,
                energy: 0.8,
                birthRate: 0.00008,
                deathAge: 30000,
                territorial: false,
                nocturnal: false
            },
            STARLING: {
                id: 2,
                name: 'Starling',
                color: '#4af',
                size: 8,
                speed: 4.5,
                diet: 'omnivore',
                preyOn: ['HUMMINGBIRD'],
                flockSize: 50,
                perception: 60,
                energy: 0.9,
                birthRate: 0.00005,
                deathAge: 40000,
                territorial: false,
                nocturnal: false
            },
            HUMMINGBIRD: {
                id: 3,
                name: 'Hummingbird',
                color: '#f4f',
                size: 4,
                speed: 6,
                diet: 'specialist',
                preyOn: [],
                flockSize: 2,
                perception: 40,
                energy: 0.7,
                birthRate: 0.00003,
                deathAge: 20000,
                territorial: true,
                nocturnal: false
            },
            CROW: {
                id: 4,
                name: 'Crow',
                color: '#888',
                size: 10,
                speed: 4,
                diet: 'scavenger',
                preyOn: [],
                flockSize: 15,
                perception: 70,
                energy: 0.9,
                birthRate: 0.00004,
                deathAge: 45000,
                territorial: false,
                nocturnal: false
            },
            BAT: {
                id: 5,
                name: 'Bat',
                color: '#a4f',
                size: 7,
                speed: 5,
                diet: 'herbivore',
                preyOn: [],
                flockSize: 30,
                perception: 60,
                energy: 0.8,
                birthRate: 0.00006,
                deathAge: 35000,
                territorial: false,
                nocturnal: true
            }
        };
        
        // Global parameters
        let maxPopulation = 2000;
        let foodSpawnRate = 0.02;
        let evolutionRate = 0.02;
        let aggressionLevel = 1;
        let fearLevel = 1;
        let socialBonding = 1;
        let territorySize = 150;
        
        // Entity storage
        const creatures = [];
        const food = [];
        const nests = [];
        const flowers = [];
        const corpses = [];
        const territories = new Map();
        
        // Statistics
        let stats = {
            births: 0,
            deaths: 0,
            predations: 0,
            lastTime: Date.now()
        };
        
        // Spatial grid for performance
        const gridSize = 100;
        const gridCols = Math.ceil(canvas.width / gridSize);
        const gridRows = Math.ceil(canvas.height / gridSize);
        const grid = new Array(gridCols * gridRows);
        
        // Creature class
        class Creature {
            constructor(x, y, species) {
                this.pos = { x, y };
                this.vel = { 
                    x: (Math.random() - 0.5) * species.speed,
                    y: (Math.random() - 0.5) * species.speed
                };
                this.acc = { x: 0, y: 0 };
                this.species = species;
                this.age = 0;
                this.energy = species.energy;
                this.hunger = Math.random() * 0.3;
                this.fear = 0;
                this.mating = 0;
                this.target = null;
                this.state = 'wander';
                this.traits = {
                    speed: species.speed * (0.8 + Math.random() * 0.4),
                    size: species.size * (0.9 + Math.random() * 0.2),
                    aggression: Math.random(),
                    perception: species.perception * (0.8 + Math.random() * 0.4)
                };
                this.territoryCenter = null;
                this.nestSite = null;
                this.partner = null;
                this.lastMeal = 0;
                this.kills = 0;
                this.flockmates = [];
                this.pursuitTime = 0;
                this.digestTime = 0;
                this.restTime = 0;
            }
            
            update() {
                // Age and energy
                this.age++;
                this.energy -= 0.0001 * timeSpeed; // Energy drain
                this.hunger += 0.0002 * timeSpeed; // Hunger increase
                
                // Death conditions
                if (this.age > this.species.deathAge || this.energy <= 0 || this.hunger >= 1) {
                    console.log(`${this.species.name} died: age=${this.age}, energy=${this.energy}, hunger=${this.hunger}`);
                    this.die();
                    return false;
                }
                
                // Day/night activity
                const activeTime = this.species.nocturnal ? !isDay : isDay;
                if (!activeTime) {
                    this.vel.x *= 0.95;
                    this.vel.y *= 0.95;
                    return true;
                }
                
                // State machine
                this.updateState();
                
                // Movement
                this.vel.x += this.acc.x;
                this.vel.y += this.acc.y;
                
                const maxSpeed = this.traits.speed * (0.5 + this.energy * 0.5);
                const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
                if (speed > maxSpeed) {
                    this.vel.x = (this.vel.x / speed) * maxSpeed;
                    this.vel.y = (this.vel.y / speed) * maxSpeed;
                }
                
                this.pos.x += this.vel.x * timeSpeed;
                this.pos.y += this.vel.y * timeSpeed;
                
                // Wrap edges
                if (this.pos.x < 0) this.pos.x = canvas.width;
                else if (this.pos.x > canvas.width) this.pos.x = 0;
                if (this.pos.y < 0) this.pos.y = canvas.height;
                else if (this.pos.y > canvas.height) this.pos.y = 0;
                
                this.acc.x = 0;
                this.acc.y = 0;
                
                return true;
            }
            
            updateState() {
                // Priority-based state selection
                if (this.fear > 0.5) {
                    this.state = 'flee';
                    this.fear *= 0.98;
                } else if (this.hunger > 0.7 && this.energy < 0.7) {
                    this.state = 'hunt';
                } else if (this.mating > 0.8 && this.energy > 0.5 && this.age > 100) {
                    this.state = 'mate';
                } else if (this.species.territorial && !this.territoryCenter) {
                    this.state = 'claim';
                } else {
                    this.state = 'flock';
                    this.mating += 0.0001 * timeSpeed; // Slower mating urge buildup
                }
                
                // Execute behavior
                switch(this.state) {
                    case 'flee': this.flee(); break;
                    case 'hunt': this.hunt(); break;
                    case 'mate': this.seekMate(); break;
                    case 'claim': this.claimTerritory(); break;
                    case 'flock': this.flock(); break;
                }
            }
            
            flock() {
                const neighbors = this.getNeighbors();
                const same = neighbors.filter(n => n.species.id === this.species.id);
                
                if (same.length === 0) return;
                
                // Separation
                let sep = { x: 0, y: 0 };
                let sepCount = 0;
                
                // Alignment & Cohesion
                let ali = { x: 0, y: 0 };
                let coh = { x: 0, y: 0 };
                
                for (let other of same) {
                    const d = this.distance(other);
                    
                    if (d < 25 && d > 0) {
                        const diff = this.subtract(this.pos, other.pos);
                        diff.x /= d;
                        diff.y /= d;
                        sep.x += diff.x;
                        sep.y += diff.y;
                        sepCount++;
                    }
                    
                    ali.x += other.vel.x;
                    ali.y += other.vel.y;
                    coh.x += other.pos.x;
                    coh.y += other.pos.y;
                }
                
                // Apply forces
                if (sepCount > 0) {
                    sep.x /= sepCount;
                    sep.y /= sepCount;
                    this.applyForce(sep, 2);
                }
                
                if (same.length > 0) {
                    ali.x /= same.length;
                    ali.y /= same.length;
                    this.applyForce(this.subtract(ali, this.vel), 0.5 * socialBonding);
                    
                    coh.x /= same.length;
                    coh.y /= same.length;
                    const cohForce = this.subtract(coh, this.pos);
                    this.applyForce(cohForce, 0.5 * socialBonding);
                }
                
                // Wander
                const wander = {
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5
                };
                this.applyForce(wander, 1);
                
                // Territory keeping
                if (this.territoryCenter) {
                    const home = this.subtract(this.territoryCenter, this.pos);
                    const d = Math.sqrt(home.x * home.x + home.y * home.y);
                    if (d > territorySize) {
                        this.applyForce(home, 2);
                    }
                }
            }
            
            flee() {
                if (!this.target) {
                    // Find nearest threat
                    const threats = this.getNeighbors().filter(n => 
                        n.species.preyOn.includes(this.species.name)
                    );
                    
                    if (threats.length === 0) {
                        this.fear *= 0.9;
                        return;
                    }
                    
                    this.target = threats[0];
                    for (let t of threats) {
                        if (this.distance(t) < this.distance(this.target)) {
                            this.target = t;
                        }
                    }
                }
                
                if (this.target) {
                    const d = this.distance(this.target);
                    
                    // Panic spreading to flockmates
                    if (this.fear > 0.8) {
                        for (let f of this.flockmates) {
                            if (this.distance(f) < 50) {
                                f.fear = Math.max(f.fear, this.fear * 0.8);
                                f.target = this.target;
                            }
                        }
                    }
                    
                    // Evasion tactics
                    const away = this.subtract(this.pos, this.target.pos);
                    
                    // Zigzag when predator is close
                    if (d < 50) {
                        const perpendicular = {
                            x: -away.y,
                            y: away.x
                        };
                        const zigzag = Math.sin(this.age * 0.3) * 2;
                        away.x += perpendicular.x * zigzag;
                        away.y += perpendicular.y * zigzag;
                    }
                    
                    this.applyForce(away, 5 * fearLevel);
                    
                    // Flock cohesion during escape
                    if (this.flockmates.length > 0) {
                        let center = { x: 0, y: 0 };
                        for (let f of this.flockmates) {
                            center.x += f.pos.x;
                            center.y += f.pos.y;
                        }
                        center.x /= this.flockmates.length;
                        center.y /= this.flockmates.length;
                        
                        const toFlock = this.subtract(center, this.pos);
                        this.applyForce(toFlock, 1); // Stay with flock while fleeing
                    }
                    
                    // Clear target when safe
                    if (d > this.traits.perception * 2) {
                        this.target = null;
                    }
                }
            }
            
            wander() {
                const wander = {
                    x: Math.cos(this.age * 0.01 + this.traits.aggression * 10) * 0.5,
                    y: Math.sin(this.age * 0.01 + this.traits.aggression * 10) * 0.5
                };
                this.applyForce(wander, 1);
            }
            
            hunt() {
                if (this.species.diet === 'carnivore' || this.species.diet === 'omnivore') {
                    const prey = this.getNeighbors().filter(n => 
                        this.species.preyOn.includes(n.species.name)
                    );
                    
                    if (prey.length === 0) {
                        this.target = null;
                        this.pursuitTime = 0;
                        this.wander();
                        return;
                    }
                    
                    // Continue chasing current target or find new one
                    if (!this.target || !creatures.includes(this.target) || !prey.includes(this.target)) {
                        // Target selection based on vulnerability
                        let bestTarget = null;
                        let bestScore = -Infinity;
                        
                        for (let p of prey) {
                            let score = 100 - this.distance(p); // Closer is better
                            score -= p.energy * 50; // Weak prey is easier
                            score -= p.flockmates.length * 10; // Isolated prey is better
                            score += p.age < 1000 ? 20 : 0; // Young prey is easier
                            score += p.state === 'rest' ? 30 : 0; // Resting prey is vulnerable
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestTarget = p;
                            }
                        }
                        
                        this.target = bestTarget;
                        this.pursuitTime = 0;
                    }
                    
                    if (this.target && creatures.includes(this.target)) {
                        const d = this.distance(this.target);
                        
                        // Pursuit behavior
                        if (d < this.traits.perception) {
                            this.pursuitTime++;
                            
                            // Predict prey movement
                            const futurePos = {
                                x: this.target.pos.x + this.target.vel.x * 3,
                                y: this.target.pos.y + this.target.vel.y * 3
                            };
                            
                            const intercept = this.subtract(futurePos, this.pos);
                            this.applyForce(intercept, 4 * aggressionLevel);
                            
                            // Sprint burst when close
                            if (d < 30) {
                                this.applyForce(intercept, 6);
                                this.energy -= 0.0005; // Sprinting costs energy
                            }
                            
                            // Successful kill
                            if (d < this.traits.size) {
                                console.log(`${this.species.name} killed ${this.target.species.name}!`);
                                
                                // Create corpse before removing creature
                                corpses.push({
                                    pos: { x: this.target.pos.x, y: this.target.pos.y },
                                    size: this.target.traits.size,
                                    species: this.target.species.name,
                                    fresh: true,
                                    decay: 0
                                });
                                
                                // Kill the prey
                                this.target.die('predation');
                                
                                // Reward predator
                                this.kills++;
                                this.energy = Math.min(1, this.energy + 0.4);
                                this.hunger = 0;
                                this.lastMeal = this.age;
                                this.digestTime = 100; // Digest for a while
                                stats.predations++;
                                
                                // Alert nearby prey - fear spreads
                                const nearby = this.getNeighbors();
                                for (let n of nearby) {
                                    if (this.species.preyOn.includes(n.species.name)) {
                                        n.fear = 1;
                                        n.target = this;
                                        n.state = 'flee';
                                    }
                                }
                                
                                this.target = null;
                                this.pursuitTime = 0;
                            }
                            
                            // Give up if chase is too long
                            if (this.pursuitTime > 200) {
                                this.target = null;
                                this.pursuitTime = 0;
                                this.energy -= 0.02; // Failed hunt costs energy
                            }
                        } else {
                            // Lost target, search
                            this.target = null;
                            this.wander();
                        }
                    }
                }
            }
            
            forage() {
                if (this.species.diet === 'herbivore' || this.species.diet === 'omnivore') {
                    this.huntPlants();
                } else if (this.species.diet === 'specialist') {
                    this.huntFlowers();
                }
            }
            
            scavenge() {
                if (corpses.length === 0) {
                    this.forage();
                    return;
                }
                
                // Find freshest corpse
                let best = null;
                let bestScore = -Infinity;
                
                for (let c of corpses) {
                    const d = this.distance(c);
                    let score = 100 - d;
                    score += c.fresh ? 50 : 0;
                    score -= (c.decay || 0) * 100;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        best = c;
                    }
                }
                
                if (best) {
                    const seek = this.subtract(best.pos, this.pos);
                    this.applyForce(seek, 2);
                    
                    if (this.distance(best) < 15) {
                        this.energy = Math.min(1, this.energy + 0.3);
                        this.hunger = 0;
                        this.lastMeal = this.age;
                        corpses.splice(corpses.indexOf(best), 1);
                        this.digestTime = 30;
                    }
                }
            }
            
            huntPlants() {
                if (food.length === 0) return;
                
                let closest = food[0];
                let minDist = this.distance(closest);
                
                for (let f of food) {
                    const d = this.distance(f);
                    if (d < minDist) {
                        closest = f;
                        minDist = d;
                    }
                }
                
                const seek = this.subtract(closest.pos, this.pos);
                this.applyForce(seek, 2);
                
                if (minDist < 10) {
                    this.energy = Math.min(1, this.energy + 0.15);
                    this.hunger = Math.max(0, this.hunger - 0.3);
                    this.lastMeal = this.age;
                    food.splice(food.indexOf(closest), 1);
                }
            }
            
            huntFlowers() {
                if (flowers.length === 0) {
                    this.huntPlants();
                    return;
                }
                
                let closest = flowers[0];
                let minDist = this.distance(closest);
                
                for (let f of flowers) {
                    const d = this.distance(f);
                    if (d < minDist) {
                        closest = f;
                        minDist = d;
                    }
                }
                
                const seek = this.subtract(closest.pos, this.pos);
                this.applyForce(seek, 3);
                
                if (minDist < 20) {
                    this.energy = Math.min(1, this.energy + 0.05);
                    this.hunger *= 0.7;
                    closest.nectar -= 0.1;
                    if (closest.nectar <= 0) {
                        flowers.splice(flowers.indexOf(closest), 1);
                    }
                }
            }
            
            huntCorpses() {
                if (corpses.length === 0) {
                    this.huntPlants();
                    return;
                }
                
                let closest = corpses[0];
                let minDist = this.distance(closest);
                
                for (let c of corpses) {
                    const d = this.distance(c);
                    if (d < minDist) {
                        closest = c;
                        minDist = d;
                    }
                }
                
                const seek = this.subtract(closest.pos, this.pos);
                this.applyForce(seek, 2);
                
                if (minDist < 15) {
                    this.energy = Math.min(1, this.energy + 0.2);
                    this.hunger = 0;
                    corpses.splice(corpses.indexOf(closest), 1);
                }
            }
            
            seekMate() {
                const mates = this.getNeighbors().filter(n => 
                    n.species.id === this.species.id && 
                    n.mating > 0.7 &&
                    n !== this.partner
                );
                
                if (mates.length === 0) {
                    this.mating *= 0.95;
                    return;
                }
                
                const mate = mates[0];
                const d = this.distance(mate);
                
                if (d < 20) {
                    // Mating dance
                    const dance = {
                        x: Math.cos(this.age * 0.1) * 2,
                        y: Math.sin(this.age * 0.1) * 2
                    };
                    this.applyForce(dance, 1);
                    
                    // Reproduce
                    if (Math.random() < this.species.birthRate * 50 && creatures.length < maxPopulation) {
                        const baby = new Creature(
                            this.pos.x + (Math.random() - 0.5) * 20,
                            this.pos.y + (Math.random() - 0.5) * 20,
                            this.species
                        );
                        
                        // Inherit traits with mutation
                        baby.traits.speed = (this.traits.speed + mate.traits.speed) / 2 * (1 + (Math.random() - 0.5) * evolutionRate);
                        baby.traits.size = (this.traits.size + mate.traits.size) / 2 * (1 + (Math.random() - 0.5) * evolutionRate);
                        baby.traits.aggression = (this.traits.aggression + mate.traits.aggression) / 2 + (Math.random() - 0.5) * evolutionRate;
                        
                        creatures.push(baby);
                        stats.births++;
                        
                        this.mating = 0;
                        mate.mating = 0;
                        this.partner = mate;
                        mate.partner = this;
                    }
                } else {
                    const seek = this.subtract(mate.pos, this.pos);
                    this.applyForce(seek, 2);
                }
            }
            
            claimTerritory() {
                const key = `${Math.floor(this.pos.x / territorySize)},${Math.floor(this.pos.y / territorySize)}`;
                
                if (!territories.has(key) || territories.get(key).creature.energy < this.energy) {
                    territories.set(key, {
                        creature: this,
                        species: this.species.id,
                        center: {
                            x: Math.floor(this.pos.x / territorySize) * territorySize + territorySize / 2,
                            y: Math.floor(this.pos.y / territorySize) * territorySize + territorySize / 2
                        }
                    });
                    this.territoryCenter = territories.get(key).center;
                }
            }
            
            die(cause = 'natural') {
                const idx = creatures.indexOf(this);
                if (idx > -1) creatures.splice(idx, 1);
                
                // Leave corpse for scavengers (only if killed or large enough)
                if ((cause === 'predation' || this.traits.size > 6) && this.species.diet !== 'scavenger') {
                    corpses.push({
                        pos: { x: this.pos.x, y: this.pos.y },
                        size: this.traits.size,
                        species: this.species.name,
                        fresh: cause === 'predation',
                        decay: 0
                    });
                }
                
                // Remove from partner
                if (this.partner) {
                    this.partner.partner = null;
                }
                
                stats.deaths++;
            }
            
            getNeighbors() {
                return creatures.filter(c => 
                    c !== this && this.distance(c) < this.traits.perception
                );
            }
            
            distance(other) {
                const dx = this.pos.x - other.pos.x;
                const dy = this.pos.y - other.pos.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            subtract(a, b) {
                return { x: a.x - b.x, y: a.y - b.y };
            }
            
            applyForce(force, weight = 1) {
                const len = Math.sqrt(force.x * force.x + force.y * force.y);
                if (len > 0) {
                    force.x = (force.x / len) * weight * 0.1;
                    force.y = (force.y / len) * weight * 0.1;
                    this.acc.x += force.x;
                    this.acc.y += force.y;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(Math.atan2(this.vel.y, this.vel.x));
                
                // State-based colors
                let color = this.species.color;
                if (this.state === 'flee') {
                    color = '#fff'; // White when fleeing
                } else if (this.state === 'hunt') {
                    color = '#f80'; // Orange when hunting
                } else if (this.state === 'mate') {
                    color = '#f0f'; // Purple when mating
                } else if (this.state === 'digest') {
                    color = '#8f8'; // Green when digesting
                }
                
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.3 + this.energy * 0.7;
                
                const size = this.traits.size;
                
                // Different shapes for different states
                if (this.state === 'rest') {
                    // Resting - circle
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, 0, PI2);
                    ctx.fill();
                } else {
                    // Flying - arrow
                    ctx.beginPath();
                    ctx.moveTo(size, 0);
                    ctx.lineTo(-size/2, -size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Show pursuit lines for hunters
                    if (this.state === 'hunt' && this.target) {
                        ctx.strokeStyle = '#f00';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const dx = this.target.pos.x - this.pos.x;
                        const dy = this.target.pos.y - this.pos.y;
                        ctx.lineTo(dx * 0.3, dy * 0.3);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
        }
        
        // Initialize ecosystem
        function initEcosystem() {
            creatures.length = 0;
            food.length = 0;
            corpses.length = 0;
            territories.clear();
            
            // Add initial populations
            addCreatures('SPARROW', 100);
            addCreatures('STARLING', 50);
            addCreatures('HAWK', 10);
            addCreatures('HUMMINGBIRD', 30);
            
            // Add initial food
            for (let i = 0; i < 50; i++) {
                food.push({
                    pos: {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    }
                });
            }
            
            // Add some flowers
            for (let i = 0; i < 10; i++) {
                flowers.push({
                    pos: {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    },
                    nectar: 1
                });
            }
        }
        
        function addCreatures(speciesName, count) {
            const species = SPECIES[speciesName];
            for (let i = 0; i < count; i++) {
                creatures.push(new Creature(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    species
                ));
            }
        }
        
        // Update loop
        function update() {
            if (paused) return;
            
            // Update time
            dayTime += 0.00002 * timeSpeed; // Slower day/night cycle
            if (dayTime > 1) dayTime -= 1;
            isDay = dayTime > 0.25 && dayTime < 0.75;
            
            // Spawn food more frequently
            if (Math.random() < foodSpawnRate * 5) {
                food.push({
                    pos: {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    }
                });
            }
            
            // Regenerate flowers
            for (let f of flowers) {
                f.nectar = Math.min(1, f.nectar + 0.001);
            }
            
            // Update creatures
            for (let i = creatures.length - 1; i >= 0; i--) {
                if (!creatures[i].update()) {
                    creatures.splice(i, 1);
                }
            }
            
            // Clean old corpses
            for (let i = corpses.length - 1; i >= 0; i--) {
                corpses[i].decay += 0.005;
                corpses[i].fresh = false;
                if (corpses[i].decay > 1) {
                    corpses.splice(i, 1);
                }
            }
            
            // Update statistics
            updateStats();
        }
        
        // Render
        function render() {
            // Sky color based on time
            const skyBrightness = Math.sin(dayTime * PI2) * 0.5 + 0.5;
            const r = Math.floor(10 + skyBrightness * 20);
            const g = Math.floor(10 + skyBrightness * 30);
            const b = Math.floor(20 + skyBrightness * 60);
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw territories
            ctx.globalAlpha = 0.1;
            for (let [key, territory] of territories) {
                const species = Object.values(SPECIES).find(s => s.id === territory.species);
                ctx.fillStyle = species.color;
                ctx.fillRect(
                    territory.center.x - territorySize/2,
                    territory.center.y - territorySize/2,
                    territorySize,
                    territorySize
                );
            }
            ctx.globalAlpha = 1;
            
            // Draw nests
            ctx.fillStyle = 'rgba(139,69,19,0.5)';
            for (let nest of nests) {
                ctx.beginPath();
                ctx.arc(nest.pos.x, nest.pos.y, 30, 0, PI2);
                ctx.fill();
            }
            
            // Draw flowers
            for (let flower of flowers) {
                ctx.fillStyle = `rgba(255,105,180,${flower.nectar})`;
                ctx.beginPath();
                ctx.arc(flower.pos.x, flower.pos.y, 15, 0, PI2);
                ctx.fill();
                
                // Petals
                ctx.fillStyle = `rgba(255,192,203,${flower.nectar * 0.7})`;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * PI2;
                    ctx.beginPath();
                    ctx.arc(
                        flower.pos.x + Math.cos(angle) * 10,
                        flower.pos.y + Math.sin(angle) * 10,
                        8, 0, PI2
                    );
                    ctx.fill();
                }
            }
            
            // Draw food
            ctx.fillStyle = '#4f4';
            for (let f of food) {
                ctx.beginPath();
                ctx.arc(f.pos.x, f.pos.y, 3, 0, PI2);
                ctx.fill();
            }
            
            // Draw corpses with decay
            for (let c of corpses) {
                const decay = c.decay || 0;
                if (c.fresh) {
                    // Fresh kill - red
                    ctx.fillStyle = `rgba(255,0,0,${0.8 - decay})`;
                } else {
                    // Old corpse - brown
                    ctx.fillStyle = `rgba(139,69,19,${0.6 - decay})`;
                }
                ctx.beginPath();
                ctx.arc(c.pos.x, c.pos.y, c.size * (1 - decay * 0.5), 0, PI2);
                ctx.fill();
                
                // Scavenger attraction radius
                if (c.fresh) {
                    ctx.strokeStyle = `rgba(255,0,0,${0.1 - decay * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(c.pos.x, c.pos.y, 50, 0, PI2);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            
            // Draw creatures
            for (let creature of creatures) {
                creature.draw();
            }
            
            // Night overlay
            if (!isDay) {
                ctx.fillStyle = 'rgba(0,0,40,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw day/night clock
            const clockCanvas = document.getElementById('clock');
            const clockCtx = clockCanvas.getContext('2d');
            const cx = 30, cy = 30, radius = 25;
            
            // Clear clock
            clockCtx.fillStyle = '#000';
            clockCtx.fillRect(0, 0, 60, 60);
            
            // Draw clock face
            clockCtx.strokeStyle = '#444';
            clockCtx.beginPath();
            clockCtx.arc(cx, cy, radius, 0, PI2);
            clockCtx.stroke();
            
            // Draw sun/moon position
            const angle = dayTime * PI2 - Math.PI / 2;
            const px = cx + Math.cos(angle) * (radius - 5);
            const py = cy + Math.sin(angle) * (radius - 5);
            
            if (isDay) {
                // Sun
                clockCtx.fillStyle = '#ff0';
                clockCtx.beginPath();
                clockCtx.arc(px, py, 5, 0, PI2);
                clockCtx.fill();
            } else {
                // Moon
                clockCtx.fillStyle = '#ddd';
                clockCtx.beginPath();
                clockCtx.arc(px, py, 4, 0, PI2);
                clockCtx.fill();
            }
            
            // Update time label
            const hour = Math.floor(dayTime * 24);
            const timeStr = isDay ? `Day ${hour}:00` : `Night ${hour}:00`;
            document.getElementById('timeOfDay').textContent = timeStr;
        }
        
        // Update statistics display
        function updateStats() {
            const now = Date.now();
            const dt = (now - stats.lastTime) / 1000;
            
            if (dt > 1) {
                const birthRate = stats.births / dt;
                const deathRate = stats.deaths / dt;
                const predationRate = stats.predations / dt;
                
                document.getElementById('total-count').textContent = creatures.length;
                document.getElementById('birth-rate').textContent = birthRate.toFixed(1);
                document.getElementById('predation-rate').textContent = predationRate.toFixed(1);
                
                // Species counts
                const counts = {};
                for (let species of Object.values(SPECIES)) {
                    counts[species.name] = 0;
                }
                for (let creature of creatures) {
                    counts[creature.species.name]++;
                }
                
                let html = '';
                for (let [name, species] of Object.entries(SPECIES)) {
                    const count = counts[species.name];
                    const pct = creatures.length > 0 ? (count / creatures.length * 100).toFixed(1) : 0;
                    html += `<div>
                        <span class="species-indicator" style="background:${species.color}"></span>
                        ${species.name}: ${count} (${pct}%)
                        <span class="species-count">${species.diet}</span>
                    </div>`;
                }
                document.getElementById('species-list').innerHTML = html;
                
                stats.births = 0;
                stats.deaths = 0;
                stats.predations = 0;
                stats.lastTime = now;
            }
        }
        
        // Animation loop
        let lastFrameTime = performance.now();
        let frameCount = 0;
        
        function animate() {
            update();
            render();
            
            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastFrameTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = now;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Event handlers
        canvas.addEventListener('click', (e) => {
            if (e.shiftKey) {
                // Add food
                food.push({ pos: { x: e.clientX, y: e.clientY } });
            } else {
                // Add creature of dominant species
                const counts = {};
                for (let c of creatures) {
                    counts[c.species.name] = (counts[c.species.name] || 0) + 1;
                }
                let dominant = 'SPARROW';
                let maxCount = 0;
                for (let [species, count] of Object.entries(counts)) {
                    if (count > maxCount) {
                        dominant = species;
                        maxCount = count;
                    }
                }
                addCreatures(dominant, 1);
                creatures[creatures.length - 1].pos = { x: e.clientX, y: e.clientY };
            }
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // Remove nearest creature
            let nearest = null;
            let minDist = Infinity;
            for (let c of creatures) {
                const dx = c.pos.x - e.clientX;
                const dy = c.pos.y - e.clientY;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d < minDist) {
                    nearest = c;
                    minDist = d;
                }
            }
            if (nearest && minDist < 50) {
                nearest.die();
            }
        });
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Control handlers
        document.getElementById('timeSpeed').addEventListener('input', (e) => {
            timeSpeed = parseFloat(e.target.value);
        });
        
        document.getElementById('foodRate').addEventListener('input', (e) => {
            foodSpawnRate = parseFloat(e.target.value);
        });
        
        document.getElementById('evolutionRate').addEventListener('input', (e) => {
            evolutionRate = parseFloat(e.target.value);
        });
        
        document.getElementById('aggression').addEventListener('input', (e) => {
            aggressionLevel = parseFloat(e.target.value);
        });
        
        document.getElementById('fear').addEventListener('input', (e) => {
            fearLevel = parseFloat(e.target.value);
        });
        
        document.getElementById('socialBonding').addEventListener('input', (e) => {
            socialBonding = parseFloat(e.target.value);
        });
        
        document.getElementById('territorySize').addEventListener('input', (e) => {
            territorySize = parseFloat(e.target.value);
        });
        
        document.getElementById('maxPop').addEventListener('input', (e) => {
            maxPopulation = parseInt(e.target.value);
        });
        
        // Button handlers
        document.getElementById('addHawks').addEventListener('click', () => {
            addCreatures('HAWK', 5);
        });
        
        document.getElementById('addSparrows').addEventListener('click', () => {
            addCreatures('SPARROW', 20);
        });
        
        document.getElementById('addStarlings').addEventListener('click', () => {
            addCreatures('STARLING', 15);
        });
        
        document.getElementById('addHummingbirds').addEventListener('click', () => {
            addCreatures('HUMMINGBIRD', 10);
        });
        
        document.getElementById('addCrows').addEventListener('click', () => {
            addCreatures('CROW', 8);
        });
        
        document.getElementById('addBats').addEventListener('click', () => {
            addCreatures('BAT', 12);
        });
        
        document.getElementById('toggleDayNight').addEventListener('click', () => {
            dayTime = (dayTime + 0.5) % 1;
        });
        
        document.getElementById('addNest').addEventListener('click', () => {
            nests.push({
                pos: {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                }
            });
        });
        
        document.getElementById('addFlowers').addEventListener('click', () => {
            for (let i = 0; i < 5; i++) {
                flowers.push({
                    pos: {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    },
                    nectar: 1
                });
            }
        });
        
        document.getElementById('clearEnvironment').addEventListener('click', () => {
            food.length = 0;
            flowers.length = 0;
            nests.length = 0;
            corpses.length = 0;
        });
        
        document.getElementById('pausePlay').addEventListener('click', () => {
            paused = !paused;
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            initEcosystem();
        });
        
        // Initialize and start
        initEcosystem();
        animate();
    </script>
</body>
</html>