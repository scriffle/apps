<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two Species Flocking - Maximum Performance</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            font-size: 12px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            font-size: 11px;
        }
        #controls label {
            display: block;
            margin: 3px 0;
        }
        #controls input {
            width: 80px;
            margin-left: 5px;
        }
        .species1 { color: #0ff; }
        .species2 { color: #f0f; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>Total: <span id="count">0</span></div>
        <div><span class="species1">Cyan: <span id="count1">0</span></span></div>
        <div><span class="species2">Magenta: <span id="count2">0</span></span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div>Click: predator</div>
    </div>
    <div id="controls">
        <label>Sep: <input type="range" id="separation" min="0" max="5" step="0.5" value="1.5"></label>
        <label>Ali: <input type="range" id="alignment" min="0" max="5" step="0.5" value="1"></label>
        <label>Coh: <input type="range" id="cohesion" min="0" max="5" step="0.5" value="1"></label>
        <label>Avoid: <input type="range" id="avoidOther" min="0" max="10" step="0.5" value="4"></label>
        <label>Spd: <input type="range" id="maxSpeed" min="1" max="10" step="1" value="4"></label>
        <label>Cnt: <input type="range" id="arrowCount" min="1000" max="10000" step="1000" value="4000"></label>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Performance settings
        ctx.imageSmoothingEnabled = false;
        
        // Pre-calculate constants
        const PI2 = Math.PI * 2;
        const HALF_WIDTH = canvas.width * 0.5;
        const HALF_HEIGHT = canvas.height * 0.5;
        
        // Flocking parameters
        let sepWeight = 1.5;
        let aliWeight = 1;
        let cohWeight = 1;
        let avoidOtherWeight = 4;
        let maxSpeed = 4;
        let maxForce = 0.2;
        const perceptionRadius = 50;
        const perceptionRadiusSq = perceptionRadius * perceptionRadius;
        const avoidRadius = 25;
        const avoidRadiusSq = avoidRadius * avoidRadius;
        const otherSpeciesRadius = 60;
        const otherSpeciesRadiusSq = otherSpeciesRadius * otherSpeciesRadius;
        
        // Predator
        let predX = -1000;
        let predY = -1000;
        let predActive = false;
        const predRadiusSq = 10000; // 100 * 100
        
        // Performance tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        
        // Spatial grid for optimization
        const gridSize = 100;
        const gridCols = Math.ceil(canvas.width / gridSize) + 1;
        const gridRows = Math.ceil(canvas.height / gridSize) + 1;
        const grid = new Array(gridCols * gridRows);
        
        // Arrow properties stored in typed arrays for cache efficiency
        let arrowCount = 4000;
        const maxArrows = 10000;
        const posX = new Float32Array(maxArrows);
        const posY = new Float32Array(maxArrows);
        const velX = new Float32Array(maxArrows);
        const velY = new Float32Array(maxArrows);
        const accX = new Float32Array(maxArrows);
        const accY = new Float32Array(maxArrows);
        const species = new Uint8Array(maxArrows); // 0 or 1 for species type
        
        // Species counts
        let species1Count = 0;
        let species2Count = 0;
        
        // Initialize arrows
        function initArrows(count) {
            arrowCount = count;
            species1Count = Math.floor(count / 2);
            species2Count = count - species1Count;
            
            // Initialize species 1 (cyan)
            for (let i = 0; i < species1Count; i++) {
                posX[i] = Math.random() * canvas.width * 0.5; // Left half
                posY[i] = Math.random() * canvas.height;
                velX[i] = (Math.random() - 0.5) * maxSpeed;
                velY[i] = (Math.random() - 0.5) * maxSpeed;
                accX[i] = 0;
                accY[i] = 0;
                species[i] = 0;
            }
            
            // Initialize species 2 (magenta)
            for (let i = species1Count; i < count; i++) {
                posX[i] = canvas.width * 0.5 + Math.random() * canvas.width * 0.5; // Right half
                posY[i] = Math.random() * canvas.height;
                velX[i] = (Math.random() - 0.5) * maxSpeed;
                velY[i] = (Math.random() - 0.5) * maxSpeed;
                accX[i] = 0;
                accY[i] = 0;
                species[i] = 1;
            }
            
            document.getElementById('count').textContent = count;
            document.getElementById('count1').textContent = species1Count;
            document.getElementById('count2').textContent = species2Count;
        }
        
        initArrows(arrowCount);
        
        // Fast distance squared (no sqrt)
        function distSq(x1, y1, x2, y2) {
            let dx = x1 - x2;
            let dy = y1 - y2;
            
            // Wrap distance
            if (dx > HALF_WIDTH) dx -= canvas.width;
            else if (dx < -HALF_WIDTH) dx += canvas.width;
            if (dy > HALF_HEIGHT) dy -= canvas.height;
            else if (dy < -HALF_HEIGHT) dy += canvas.height;
            
            return dx * dx + dy * dy;
        }
        
        // Fast wrapped difference
        function wrapDiff(x1, y1, x2, y2, out) {
            out.x = x2 - x1;
            out.y = y2 - y1;
            
            if (out.x > HALF_WIDTH) out.x -= canvas.width;
            else if (out.x < -HALF_WIDTH) out.x += canvas.width;
            if (out.y > HALF_HEIGHT) out.y -= canvas.height;
            else if (out.y < -HALF_HEIGHT) out.y += canvas.height;
        }
        
        // Fast normalize and scale
        function setMag(vec, mag) {
            const lenSq = vec.x * vec.x + vec.y * vec.y;
            if (lenSq > 0) {
                const scale = mag / Math.sqrt(lenSq);
                vec.x *= scale;
                vec.y *= scale;
            }
        }
        
        // Fast limit
        function limit(vec, max) {
            const lenSq = vec.x * vec.x + vec.y * vec.y;
            if (lenSq > max * max) {
                const scale = max / Math.sqrt(lenSq);
                vec.x *= scale;
                vec.y *= scale;
            }
        }
        
        // Build spatial grid
        function buildGrid() {
            // Clear grid
            for (let i = 0; i < grid.length; i++) {
                grid[i] = null;
            }
            
            // Add arrows to grid
            for (let i = 0; i < arrowCount; i++) {
                const gx = Math.floor(posX[i] / gridSize);
                const gy = Math.floor(posY[i] / gridSize);
                const idx = gy * gridCols + gx;
                
                // Simple linked list in grid
                const old = grid[idx];
                grid[idx] = { i: i, next: old };
            }
        }
        
        // Get neighbors from grid
        function getNeighbors(i, neighbors, sameSpeciesNeighbors, otherSpeciesNeighbors) {
            let sameCount = 0;
            let otherCount = 0;
            const x = posX[i];
            const y = posY[i];
            const mySpecies = species[i];
            const gx = Math.floor(x / gridSize);
            const gy = Math.floor(y / gridSize);
            
            // Check 9 cells
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ngx = gx + dx;
                    const ngy = gy + dy;
                    
                    if (ngx >= 0 && ngx < gridCols && ngy >= 0 && ngy < gridRows) {
                        let node = grid[ngy * gridCols + ngx];
                        while (node) {
                            if (node.i !== i) {
                                const dSq = distSq(x, y, posX[node.i], posY[node.i]);
                                
                                if (species[node.i] === mySpecies && dSq < perceptionRadiusSq) {
                                    sameSpeciesNeighbors[sameCount++] = node.i;
                                    if (sameCount >= 30) break;
                                } else if (species[node.i] !== mySpecies && dSq < otherSpeciesRadiusSq) {
                                    otherSpeciesNeighbors[otherCount++] = node.i;
                                    if (otherCount >= 20) break;
                                }
                            }
                            node = node.next;
                        }
                    }
                }
            }
            
            neighbors[0] = sameCount;
            neighbors[1] = otherCount;
        }
        
        // Optimized flock calculation
        const neighborCounts = new Uint16Array(2);
        const sameSpeciesNeighbors = new Uint16Array(30);
        const otherSpeciesNeighbors = new Uint16Array(20);
        const sep = { x: 0, y: 0 };
        const ali = { x: 0, y: 0 };
        const coh = { x: 0, y: 0 };
        const avoid = { x: 0, y: 0 };
        const diff = { x: 0, y: 0 };
        
        function updateArrow(i) {
            // Reset forces
            sep.x = 0; sep.y = 0;
            ali.x = 0; ali.y = 0;
            coh.x = 0; coh.y = 0;
            avoid.x = 0; avoid.y = 0;
            let sepCount = 0;
            let total = 0;
            
            const x = posX[i];
            const y = posY[i];
            
            // Get neighbors
            getNeighbors(i, neighborCounts, sameSpeciesNeighbors, otherSpeciesNeighbors);
            const sameCount = neighborCounts[0];
            const otherCount = neighborCounts[1];
            
            // Process same species neighbors
            for (let n = 0; n < sameCount; n++) {
                const j = sameSpeciesNeighbors[n];
                const dSq = distSq(x, y, posX[j], posY[j]);
                
                if (dSq < avoidRadiusSq && dSq > 0) {
                    wrapDiff(x, y, posX[j], posY[j], diff);
                    const factor = 1 / Math.sqrt(dSq);
                    sep.x -= diff.x * factor;
                    sep.y -= diff.y * factor;
                    sepCount++;
                }
                
                ali.x += velX[j];
                ali.y += velY[j];
                coh.x += posX[j];
                coh.y += posY[j];
                total++;
            }
            
            // Process other species neighbors - strong avoidance
            for (let n = 0; n < otherCount; n++) {
                const j = otherSpeciesNeighbors[n];
                const dSq = distSq(x, y, posX[j], posY[j]);
                
                if (dSq > 0) {
                    wrapDiff(x, y, posX[j], posY[j], diff);
                    const factor = 1 / Math.sqrt(dSq);
                    avoid.x -= diff.x * factor;
                    avoid.y -= diff.y * factor;
                }
            }
            
            // Apply separation
            if (sepCount > 0) {
                sep.x /= sepCount;
                sep.y /= sepCount;
                setMag(sep, maxSpeed);
                sep.x -= velX[i];
                sep.y -= velY[i];
                limit(sep, maxForce);
                accX[i] += sep.x * sepWeight;
                accY[i] += sep.y * sepWeight;
            }
            
            // Apply alignment and cohesion
            if (total > 0) {
                // Alignment
                ali.x /= total;
                ali.y /= total;
                setMag(ali, maxSpeed);
                ali.x -= velX[i];
                ali.y -= velY[i];
                limit(ali, maxForce);
                accX[i] += ali.x * aliWeight;
                accY[i] += ali.y * aliWeight;
                
                // Cohesion
                coh.x /= total;
                coh.y /= total;
                wrapDiff(x, y, coh.x, coh.y, diff);
                setMag(diff, maxSpeed);
                diff.x -= velX[i];
                diff.y -= velY[i];
                limit(diff, maxForce);
                accX[i] += diff.x * cohWeight;
                accY[i] += diff.y * cohWeight;
            }
            
            // Apply other species avoidance
            if (otherCount > 0) {
                avoid.x /= otherCount;
                avoid.y /= otherCount;
                setMag(avoid, maxSpeed * 1.5);
                avoid.x -= velX[i];
                avoid.y -= velY[i];
                limit(avoid, maxForce * 2);
                accX[i] += avoid.x * avoidOtherWeight;
                accY[i] += avoid.y * avoidOtherWeight;
            }
            
            // Avoid predator
            if (predActive) {
                const pdSq = distSq(x, y, predX, predY);
                if (pdSq < predRadiusSq) {
                    wrapDiff(x, y, predX, predY, diff);
                    const mag = maxSpeed * 2 * (1 - pdSq / predRadiusSq);
                    setMag(diff, -mag);
                    diff.x -= velX[i];
                    diff.y -= velY[i];
                    limit(diff, maxForce * 3);
                    accX[i] += diff.x;
                    accY[i] += diff.y;
                }
            }
        }
        
        // Main update loop
        function update() {
            buildGrid();
            
            // Update all arrows
            for (let i = 0; i < arrowCount; i++) {
                accX[i] = 0;
                accY[i] = 0;
                updateArrow(i);
                
                // Update velocity
                velX[i] += accX[i];
                velY[i] += accY[i];
                
                // Limit speed
                const vSq = velX[i] * velX[i] + velY[i] * velY[i];
                if (vSq > maxSpeed * maxSpeed) {
                    const scale = maxSpeed / Math.sqrt(vSq);
                    velX[i] *= scale;
                    velY[i] *= scale;
                }
                
                // Update position
                posX[i] += velX[i];
                posY[i] += velY[i];
                
                // Wrap edges
                if (posX[i] < 0) posX[i] += canvas.width;
                else if (posX[i] > canvas.width) posX[i] -= canvas.width;
                if (posY[i] < 0) posY[i] += canvas.height;
                else if (posY[i] > canvas.height) posY[i] -= canvas.height;
            }
        }
        
        // Optimized rendering
        function render() {
            // Clear canvas completely - faster than fade
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // Draw species 1 (cyan)
            ctx.fillStyle = '#0ff';
            ctx.beginPath();
            
            for (let i = 0; i < arrowCount; i++) {
                if (species[i] === 0) {
                    const x = posX[i];
                    const y = posY[i];
                    const angle = Math.atan2(velY[i], velX[i]);
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // Triangle points
                    const x1 = x + cos * 8;
                    const y1 = y + sin * 8;
                    const x2 = x - cos * 4 - sin * 3;
                    const y2 = y - sin * 4 + cos * 3;
                    const x3 = x - cos * 4 + sin * 3;
                    const y3 = y - sin * 4 - cos * 3;
                    
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                }
            }
            
            ctx.fill();
            
            // Draw species 2 (magenta)
            ctx.fillStyle = '#f0f';
            ctx.beginPath();
            
            for (let i = 0; i < arrowCount; i++) {
                if (species[i] === 1) {
                    const x = posX[i];
                    const y = posY[i];
                    const angle = Math.atan2(velY[i], velX[i]);
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // Triangle points
                    const x1 = x + cos * 8;
                    const y1 = y + sin * 8;
                    const x2 = x - cos * 4 - sin * 3;
                    const y2 = y - sin * 4 + cos * 3;
                    const x3 = x - cos * 4 + sin * 3;
                    const y3 = y - sin * 4 - cos * 3;
                    
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                }
            }
            
            ctx.fill();
            ctx.restore();
            
            // Draw predator if active
            if (predActive) {
                ctx.fillStyle = 'rgba(255,0,0,0.8)';
                ctx.beginPath();
                ctx.arc(predX, predY, 8, 0, PI2);
                ctx.fill();
            }
        }
        
        // Animation loop
        function animate() {
            update();
            render();
            
            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps').textContent = fps;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Event handlers
        canvas.addEventListener('click', (e) => {
            predX = e.clientX;
            predY = e.clientY;
            predActive = true;
            setTimeout(() => predActive = false, 3000);
        });
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Control handlers
        document.getElementById('separation').addEventListener('input', (e) => {
            sepWeight = parseFloat(e.target.value);
        });
        
        document.getElementById('alignment').addEventListener('input', (e) => {
            aliWeight = parseFloat(e.target.value);
        });
        
        document.getElementById('cohesion').addEventListener('input', (e) => {
            cohWeight = parseFloat(e.target.value);
        });
        
        document.getElementById('avoidOther').addEventListener('input', (e) => {
            avoidOtherWeight = parseFloat(e.target.value);
        });
        
        document.getElementById('maxSpeed').addEventListener('input', (e) => {
            maxSpeed = parseFloat(e.target.value);
        });
        
        document.getElementById('arrowCount').addEventListener('input', (e) => {
            initArrows(parseInt(e.target.value));
        });
        
        // Start
        animate();
    </script>
</body>
</html>