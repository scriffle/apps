{
    "subject": "Algorithmics (HESS)",
    "version": "2024",
    "theme": {
      "primary": "#14181E",
      "secondary": "#20242A",
      "tertiary": "#2C3036",
      "accent": "#58C8A8",
      "accentDark": "#40A888",
      "success": "#4caf50",
      "warning": "#ff9800",
      "error": "#f44336",
      "neutral": "#607d8b",
      "text": "#FFFFFF",
      "textMuted": "#A8C0B8"
    },
    "categories": [
      {
        "name": "Exam Technique & Presentation",
        "concepts": [
          {
            "id": "ET001",
            "title": "Use reading time strategically",
            "questions": [
              {
                "text": "Start answering questions immediately once reading time begins to maximise your marks.",
                "answer": false,
                "explanation": "Reading time is for planning, not writing. Use it to scan the whole exam and identify high-value questions near the end. Questions like the final 10-mark problem need proper time allocation.",
                "studyTip": "Spot the big questions early—don't run out of time on them"
              },
              {
                "text": "Using reading time to identify high-mark questions helps you allocate sufficient time for them.",
                "answer": true,
                "explanation": "Weighty questions at the end often catch students short on time. Spotting them early lets you plan your pacing. A 10-mark question deserves proportionally more time.",
                "studyTip": "Reading time = strategy time. Find the 10-markers."
              }
            ]
          },
          {
            "id": "ET002",
            "title": "Manage time across questions",
            "questions": [
              {
                "text": "Since Section A is multiple choice, you should spend minimal time there and save everything for Section B.",
                "answer": false,
                "explanation": "Section A questions still require careful thought. Some involve recursive trees, complexity analysis, or precise definitions. Rushing causes avoidable errors on questions most students get right.",
                "studyTip": "Don't rush Section A—careful reading prevents silly mistakes"
              },
              {
                "text": "The number and sophistication of Algorithmics problems means time management is crucial.",
                "answer": true,
                "explanation": "Each question involves complex problem contexts. Strategic pacing ensures you complete all questions and have time for high-mark problems that require detailed responses.",
                "studyTip": "Plan your time: marks ÷ total marks × exam time per question"
              }
            ]
          },
          {
            "id": "ET003",
            "title": "Use scaffolding from earlier parts",
            "questions": [
              {
                "text": "Multi-part questions are designed independently, so earlier parts won't help with later parts.",
                "answer": false,
                "explanation": "Examiners deliberately scaffold questions. Earlier parts often hint at approaches for later parts—pseudocode may mirror proof structure, or graph representations set up algorithmic solutions.",
                "studyTip": "Part (a) often holds the key to part (c)"
              },
              {
                "text": "Earlier parts of scaffolded questions often provide structure or hints for later parts.",
                "answer": true,
                "explanation": "Many students miss this. If part (i) shows pseudocode, part (ii) may need a proof with the same structure. If earlier parts define a graph, later parts likely need graph algorithms.",
                "studyTip": "Stuck on a hard part? Look back at what you already solved."
              }
            ]
          },
          {
            "id": "ET004",
            "title": "Use provided helper functions",
            "questions": [
              {
                "text": "If a question provides a helper function like isPrereq(P,a,b), you should write your own version to show understanding.",
                "answer": false,
                "explanation": "Use provided helper functions directly. Writing your own wastes time, risks errors, and suggests you don't understand functional abstraction. The helpers simplify your pseudocode.",
                "studyTip": "Helper function given? Use it—don't rewrite it."
              },
              {
                "text": "Provided helper functions are designed to simplify your pseudocode and focus on key ideas.",
                "answer": true,
                "explanation": "Functional abstractions reduce complexity and improve readability. Using Prim(G) or nodePR(G,r,u) directly lets you focus on the algorithm logic, not reimplementing standard operations.",
                "studyTip": "Helpers = gifts. They make your code cleaner and faster to write."
              }
            ]
          },
          {
            "id": "ET005",
            "title": "Draw recursive trees",
            "questions": [
              {
                "text": "For questions about recursive calls, working through the recursion mentally is faster than drawing a tree.",
                "answer": false,
                "explanation": "Drawing a recursive tree makes redundant calls visible and prevents counting errors. Mental tracking of multiple branches is error-prone, especially under exam pressure.",
                "studyTip": "Recursion question? Draw the tree—every time."
              },
              {
                "text": "Drawing a recursive tree helps identify redundant calls and trace execution clearly.",
                "answer": true,
                "explanation": "This skill is explicitly recommended by examiners. Recursive trees show exactly which calls occur and how many times—essential for questions about memoisation or counting calls.",
                "studyTip": "Trees don't lie. Your memory might."
              }
            ]
          },
          {
            "id": "ET006",
            "title": "Address the scenario specifically",
            "questions": [
              {
                "text": "Generic algorithm descriptions work for any problem context, so you don't need to reference specific scenario details.",
                "answer": false,
                "explanation": "Examiners want you to show you understand how algorithms apply to the given scenario. Generic descriptions suggest you're reciting memorised content without genuine understanding.",
                "studyTip": "Use the scenario's names and features—not generic placeholders"
              },
              {
                "text": "Your responses should reference specific features of the given scenario, not just describe generic approaches.",
                "answer": true,
                "explanation": "If the question involves scheduling gym programs, explain how nodes represent programs and edges represent conflicts between specific resources. Connect algorithms to the problem context.",
                "studyTip": "Generic = vague. Specific = full marks."
              }
            ]
          }
        ]
      },
      {
        "name": "Mathematical & Calculation Skills",
        "concepts": [
          {
            "id": "MC001",
            "title": "Analyse time complexity systematically",
            "questions": [
              {
                "text": "For time complexity, just state the final Big-O notation without showing how you calculated it.",
                "answer": false,
                "explanation": "You must show your working. Identify the complexity of each component, explain how they combine, and derive the final answer. Just writing O(n²) without justification scores poorly.",
                "studyTip": "Component by component: analyse, then combine"
              },
              {
                "text": "Time complexity analysis requires identifying the complexity of each algorithm component and how they combine.",
                "answer": true,
                "explanation": "High-scoring responses state: 'Lines 4-7 take O(r·c). Lines 8-9 take O(n²). Combined: O(rc + n²).' Each component's complexity and the combination must be explicit.",
                "studyTip": "Show the maths: loop × loop = nested complexity"
              }
            ]
          },
          {
            "id": "MC002",
            "title": "Apply the Master Theorem correctly",
            "questions": [
              {
                "text": "The Master Theorem only works for divide-and-conquer algorithms that split into exactly two subproblems.",
                "answer": false,
                "explanation": "The Master Theorem works for recurrences of form T(n) = aT(n/b) + f(n), where a is the number of subproblems (can be any positive integer), b is the factor by which input shrinks, and f(n) is the work at each level.",
                "studyTip": "Master Theorem: any a ≥ 1, any b > 1"
              },
              {
                "text": "The Master Theorem requires understanding how subproblem count, input reduction, and per-level work interact.",
                "answer": true,
                "explanation": "You need to identify a (subproblems), b (input shrinkage), and f(n) (work per level). Then compare f(n) to n^(log_b(a)) to determine which case applies.",
                "studyTip": "Find a, b, f(n). Compare f(n) to n^(log_b a)."
              }
            ]
          },
          {
            "id": "MC003",
            "title": "Distinguish variables in complexity",
            "questions": [
              {
                "text": "If a grid has r rows and c columns with n regions, then n = r × c, so you can use them interchangeably.",
                "answer": false,
                "explanation": "This is a common error. The number of regions n may differ from r × c depending on the problem definition. Don't assume relationships between variables—read the question carefully.",
                "studyTip": "n, r, c may be independent—check the problem definition"
              },
              {
                "text": "When analysing complexity, you must use variables as defined in the problem, not assume relationships.",
                "answer": true,
                "explanation": "If the problem defines n as regions and r, c as grid dimensions, your complexity should correctly distinguish O(rc) from O(n²). Assuming n = rc when it's not loses marks.",
                "studyTip": "Use the exact variable definitions. No assumptions."
              }
            ]
          },
          {
            "id": "MC004",
            "title": "Use ADT signatures correctly",
            "questions": [
              {
                "text": "Function signatures can use descriptive names like 'minutes' and 'numberOfPeople' to show what parameters mean.",
                "answer": false,
                "explanation": "Formal signatures use types, not variable names. Write: add_new_task: graph × element × integer × integer × list → graph. The types show structure; documentation explains meaning.",
                "studyTip": "Signatures use types, not variable names"
              },
              {
                "text": "ADT function signatures should specify input and output types, like: operation: type₁ × type₂ → type₃.",
                "answer": true,
                "explanation": "A correct signature shows the operation name, Cartesian product of input types, and output type. For example: add_new_task: graph × element × integer × integer × list → graph.",
                "studyTip": "Format: name: input_type₁ × input_type₂ → output_type"
              }
            ]
          },
          {
            "id": "MC005",
            "title": "Explain recurrence relations clearly",
            "questions": [
              {
                "text": "For recurrence relations, just solve for the closed form—you don't need to explain what each term represents.",
                "answer": false,
                "explanation": "Explain what the recurrence captures. S(n) = 3S(n/3) + O(n) means: three subproblems of size n/3, plus O(n) work to divide and combine. The interpretation matters for understanding.",
                "studyTip": "State what each term in the recurrence represents"
              },
              {
                "text": "Explaining recurrence relations requires stating what each term represents in the algorithm's execution.",
                "answer": true,
                "explanation": "For T(n) = T(n-2) + O(n): 'The algorithm reduces the problem size by 2 each step (hence n-2), and does O(n) work at each step.' Connect the maths to the algorithm.",
                "studyTip": "Each term has meaning—explain the meaning"
              }
            ]
          }
        ]
      },
      {
        "name": "Graph & Data Analysis Skills",
        "concepts": [
          {
            "id": "GD001",
            "title": "Include all graph elements",
            "questions": [
              {
                "text": "When drawing a graph from a scenario, you only need to include nodes—edges can be assumed from context.",
                "answer": false,
                "explanation": "You must explicitly include all edges with correct weights. High-scoring responses show every edge and label each weight. Incomplete graphs suggest incomplete understanding.",
                "studyTip": "Every edge, every weight—no assumptions"
              },
              {
                "text": "Graph representations must include all nodes, all edges, and correct edge weights where applicable.",
                "answer": true,
                "explanation": "Whether drawing or describing, show nodes representing entities, edges representing relationships, and weights representing costs or distances. Missing any element loses marks.",
                "studyTip": "Nodes + edges + weights = complete graph"
              }
            ]
          },
          {
            "id": "GD002",
            "title": "Distinguish directed vs undirected",
            "questions": [
              {
                "text": "Direction arrows on edges are optional styling—they don't change how the graph works mathematically.",
                "answer": false,
                "explanation": "Directed and undirected graphs are fundamentally different. In a directed graph, edge (A,B) is an ordered pair—you can traverse from A to B but not necessarily B to A unless that edge also exists.",
                "studyTip": "Directed: arrows matter. Undirected: bidirectional."
              },
              {
                "text": "In a directed graph, an edge is an ordered pair of nodes—(A,B) differs from (B,A).",
                "answer": true,
                "explanation": "Many students confuse this. A directed edge from A to B only allows traversal in that direction. Algorithms like topological sort specifically require directed graphs.",
                "studyTip": "Ordered pair → one-way street"
              }
            ]
          },
          {
            "id": "GD003",
            "title": "Define complete vs connected graphs",
            "questions": [
              {
                "text": "A complete graph is the same as a connected graph—both mean all nodes can reach all other nodes.",
                "answer": false,
                "explanation": "They're different. A connected graph has a path between every pair of nodes. A complete graph has a direct edge between every pair of nodes. Complete implies connected, but not vice versa.",
                "studyTip": "Complete = every possible edge exists. Connected = paths exist."
              },
              {
                "text": "In a complete graph, every pair of nodes has a direct edge connecting them.",
                "answer": true,
                "explanation": "A complete graph with n nodes has n(n-1)/2 edges (undirected) or n(n-1) edges (directed). This is the maximum possible. 'Connected' only requires paths, not direct edges.",
                "studyTip": "Complete: direct edges everywhere. Connected: just need paths."
              }
            ]
          },
          {
            "id": "GD004",
            "title": "Understand DAG properties",
            "questions": [
              {
                "text": "A directed acyclic graph (DAG) is simply any graph where you can't form a circle by following edges.",
                "answer": false,
                "explanation": "A DAG is specifically a directed graph with no cycles. You follow edges in their direction, and no path returns to its starting node. The 'directed' part is essential to the definition.",
                "studyTip": "DAG: directed + acyclic. Both parts required."
              },
              {
                "text": "In a DAG, no path following edge directions will return to its starting node.",
                "answer": true,
                "explanation": "This is the formal definition: traversing from any node along edge directions, you cannot return to where you started. DAGs are fundamental for topological ordering and scheduling problems.",
                "studyTip": "Follow the arrows—you can never get back"
              }
            ]
          }
        ]
      },
      {
        "name": "Conceptual Understanding",
        "concepts": [
          {
            "id": "CU001",
            "title": "Distinguish P, NP, NP-Complete, NP-Hard",
            "questions": [
              {
                "text": "NP-Complete and NP-Hard problems are the same thing—both terms describe the hardest problems in NP.",
                "answer": false,
                "explanation": "They're related but different. NP-Complete problems are in NP AND are NP-Hard. NP-Hard problems need not be in NP—some cannot even be verified in polynomial time. Example: optimisation TSP is NP-Hard but not NP-Complete.",
                "studyTip": "NP-Complete = in NP + NP-Hard. NP-Hard ≠ necessarily in NP."
              },
              {
                "text": "NP-Hard problems include problems that may not be verifiable in polynomial time.",
                "answer": true,
                "explanation": "NP-Hard means any NP problem can be reduced to it in polynomial time. But NP-Hard problems don't have to be in NP themselves. The optimisation version of TSP (find the best tour) is NP-Hard but not in NP.",
                "studyTip": "NP-Hard is about reducibility, not verifiability"
              }
            ]
          },
          {
            "id": "CU002",
            "title": "Know standard problem types",
            "questions": [
              {
                "text": "The change-making problem is about exchanging currency—it doesn't have a specific algorithmic definition.",
                "answer": false,
                "explanation": "The change-making problem asks: given coin denominations, find the minimum number of coins to make a target amount. It's a classic dynamic programming problem with well-defined structure.",
                "studyTip": "Change-making = minimise coin count. Classic DP problem."
              },
              {
                "text": "Standard problems like graph colouring, TSP, and change-making have specific definitions you must know.",
                "answer": true,
                "explanation": "Examiners expect precise definitions. Graph colouring: minimum colours so no adjacent nodes share a colour. TSP: shortest route visiting all cities. Change-making: minimum coins for a target value.",
                "studyTip": "Know the classic problems cold—definitions and complexity classes"
              }
            ]
          },
          {
            "id": "CU003",
            "title": "Distinguish soft and hard limits",
            "questions": [
              {
                "text": "Intractable problems are the same as undecidable problems—both cannot be solved by any algorithm.",
                "answer": false,
                "explanation": "Undecidable problems hit hard limits—no algorithm exists. Intractable problems hit soft limits—algorithms exist but are impractical for large inputs due to exponential time. Intractable problems CAN be solved for small inputs.",
                "studyTip": "Undecidable = no algorithm. Intractable = impractical algorithm."
              },
              {
                "text": "Intractable problems cannot be solved in polynomial time, representing soft limits of computability.",
                "answer": true,
                "explanation": "Soft limits mean solutions exist but require exponential time or space. Hard limits (undecidable problems) mean no algorithm can ever solve them. Both are different barriers to computation.",
                "studyTip": "Soft limit: too slow. Hard limit: impossible."
              }
            ]
          },
          {
            "id": "CU004",
            "title": "Understand LIFO vs FIFO",
            "questions": [
              {
                "text": "Stacks and queues are interchangeable ADTs since both store ordered collections of items.",
                "answer": false,
                "explanation": "They have fundamentally different access patterns. Stacks are LIFO (Last-In, First-Out)—newest item accessed first. Queues are FIFO (First-In, First-Out)—oldest item accessed first. Different problems require different structures.",
                "studyTip": "Stack = LIFO (undo button). Queue = FIFO (waiting line)."
              },
              {
                "text": "A stack ADT accesses items on a Last-In, First-Out (LIFO) basis.",
                "answer": true,
                "explanation": "New items go on top; removal happens from top. The function call stack is a classic example—the most recent function call completes before returning to the caller.",
                "studyTip": "Stack: last one in, first one out"
              }
            ]
          },
          {
            "id": "CU005",
            "title": "Identify weak vs strong AI",
            "questions": [
              {
                "text": "A robot that solves puzzles by pattern matching possesses strong AI because it achieves the goal.",
                "answer": false,
                "explanation": "Strong AI requires genuine understanding, not just successful task completion. Pattern matching and rule-following imitates understanding without possessing it. This is weak AI—impressive performance without true comprehension.",
                "studyTip": "Strong AI = understands. Weak AI = imitates understanding."
              },
              {
                "text": "Weak AI solves problems through pattern matching without genuine understanding.",
                "answer": true,
                "explanation": "Current AI systems, however impressive, use pattern matching and learned rules. They don't understand problems the way humans do—they process symbols effectively without comprehending meaning.",
                "studyTip": "Does it understand, or just pattern-match?"
              }
            ]
          },
          {
            "id": "CU006",
            "title": "Map problems to known types",
            "questions": [
              {
                "text": "If a problem looks new, you should invent a new algorithm rather than trying to map it to known problems.",
                "answer": false,
                "explanation": "Many exam problems are analogues of classical problems in disguise. Timetabling often maps to graph colouring. Routing often maps to shortest path. Recognising the underlying structure lets you apply known solutions.",
                "studyTip": "New problem? Look for familiar structure underneath."
              },
              {
                "text": "Recognising that a new problem is analogous to a known problem lets you apply established solutions.",
                "answer": true,
                "explanation": "Examiners test this skill explicitly. If timetabling with conflicts maps to graph colouring, you can discuss the problem's complexity class and applicable algorithms (backtracking, simulated annealing).",
                "studyTip": "Same structure = same solutions apply"
              }
            ]
          }
        ]
      },
      {
        "name": "Common Misconceptions",
        "concepts": [
          {
            "id": "CM001",
            "title": "ADTs require explicit mapping",
            "questions": [
              {
                "text": "Stating 'use a graph' is sufficient when asked to describe how to represent a scenario with an ADT.",
                "answer": false,
                "explanation": "You must explain how scenario features map to ADT components. 'Nodes represent courses. Edges connect courses that share instructors or rooms. Edge weights represent conflict severity.' Generic 'use a graph' is inadequate.",
                "studyTip": "Name it AND explain what each part represents"
              },
              {
                "text": "ADT descriptions must specify how each scenario feature maps to ADT components.",
                "answer": true,
                "explanation": "High-scoring responses explicitly state: 'Jobs stored in a dictionary keyed by ID, containing type, phone, pickup time. A priority queue orders jobs by urgency.' Each scenario feature gets a home.",
                "studyTip": "What does each node represent? Each edge? Each attribute?"
              }
            ]
          },
          {
            "id": "CM002",
            "title": "Proofs must use algorithm components",
            "questions": [
              {
                "text": "A general mathematical proof is acceptable even if it doesn't reference the specific algorithm being analysed.",
                "answer": false,
                "explanation": "Algorithm correctness proofs must connect to the algorithm's actual components. Reference specific lines, variables, and operations. Abstract proofs that ignore the algorithm's structure miss the point.",
                "studyTip": "Proof step → algorithm line. Connect them."
              },
              {
                "text": "Proofs of algorithm correctness must explicitly reference the algorithm's components and operations.",
                "answer": true,
                "explanation": "If proving a loop invariant, reference the loop. If proving by contradiction, state assumptions about the algorithm's output. The proof and algorithm should be tightly coupled.",
                "studyTip": "Generic proof ≠ algorithm proof. Reference the code."
              }
            ]
          },
          {
            "id": "CM003",
            "title": "Base cases need explicit handling",
            "questions": [
              {
                "text": "If a recursive algorithm works for large inputs, the base case is obviously correct and doesn't need explanation.",
                "answer": false,
                "explanation": "Inductive proofs require explicit base case verification. State what happens when n=0, n=1, or the input is empty. 'For a graph with 0 nodes, an empty path contains all nodes' is necessary.",
                "studyTip": "Always state the base case explicitly"
              },
              {
                "text": "Inductive proofs require explicit statements showing the base case(s) satisfy the claimed property.",
                "answer": true,
                "explanation": "You can't skip this. For any induction: (1) State and verify base case(s). (2) Assume property holds for k. (3) Prove it holds for k+1. All three steps are mandatory.",
                "studyTip": "Base case first. Always."
              }
            ]
          },
          {
            "id": "CM004",
            "title": "Prerequisites may be indirect",
            "questions": [
              {
                "text": "If task B requires task A, and A is not an immediate prerequisite of B, then A is not a prerequisite at all.",
                "answer": false,
                "explanation": "Prerequisites can be indirect. If C requires B and B requires A, then A is a prerequisite of C even though it's not immediate. Your algorithm must handle transitive prerequisites.",
                "studyTip": "Prerequisite ≠ immediate prerequisite. Check transitivity."
              },
              {
                "text": "An algorithm finding prerequisites must account for both immediate and indirect dependencies.",
                "answer": true,
                "explanation": "Many students only check immediate prerequisites. Use recursion or transitive closure to find all prerequisites in a dependency chain. Missing indirect dependencies is a common error.",
                "studyTip": "Direct AND indirect: trace the whole chain"
              }
            ]
          },
          {
            "id": "CM005",
            "title": "Optimisation vs decision problems differ",
            "questions": [
              {
                "text": "The optimisation and decision versions of a problem always have the same complexity class.",
                "answer": false,
                "explanation": "They can differ. The decision version of TSP ('Is there a tour under length k?') is in NP—a solution can be verified by summing edges. The optimisation version ('Find the shortest tour') is NP-Hard but not in NP.",
                "studyTip": "Decision: yes/no, verifiable. Optimisation: find best, may not be."
              },
              {
                "text": "Decision problems ask yes/no questions; optimisation problems ask for the best solution.",
                "answer": true,
                "explanation": "This distinction affects complexity analysis. Decision problems can often be verified in polynomial time (placing them in NP). Optimisation problems may not have efficiently verifiable optimal solutions.",
                "studyTip": "'Is there...?' = decision. 'Find the best...' = optimisation."
              }
            ]
          },
          {
            "id": "CM006",
            "title": "Data models have space limits",
            "questions": [
              {
                "text": "Any data model is valid as long as it logically represents the problem—space requirements don't matter.",
                "answer": false,
                "explanation": "Factorial or exponential space growth makes data models impractical. If storing all possible trips requires n! entries, the model hits soft limits of computability. Consider practical space constraints.",
                "studyTip": "Factorial space = unusable for large n"
              },
              {
                "text": "Data models storing factorial or exponential amounts of data become impractical due to space limits.",
                "answer": true,
                "explanation": "A model storing all possible orderings of n items needs n! entries. For n=20, that's over 2×10¹⁸ entries—more than any computer can store. This is the soft limit of computability applied to space.",
                "studyTip": "n! grows faster than you think. Too fast."
              }
            ]
          }
        ]
      },
      {
        "name": "Problem-Solving Strategies",
        "concepts": [
          {
            "id": "PS001",
            "title": "Practise writing pseudocode",
            "questions": [
              {
                "text": "Since pseudocode has no strict syntax, any informal description of an algorithm will earn full marks.",
                "answer": false,
                "explanation": "Pseudocode must be clear, precise, and follow consistent conventions. Use proper structure: indentation, keywords (For, While, If, Return), and clear variable naming. Vague descriptions don't demonstrate algorithmic thinking.",
                "studyTip": "Pseudocode: structured, precise, readable"
              },
              {
                "text": "Pseudocode appears on every Algorithmics exam—regular practice is essential preparation.",
                "answer": true,
                "explanation": "Examiners explicitly state this skill is assessed every year. Practise writing algorithms with proper structure, using helper functions, and handling edge cases. This skill needs consistent development.",
                "studyTip": "Write pseudocode weekly. Every week."
              }
            ]
          },
          {
            "id": "PS002",
            "title": "Practise writing proofs",
            "questions": [
              {
                "text": "If you understand an algorithm intuitively, you don't need to practise formal proofs—you can explain it when needed.",
                "answer": false,
                "explanation": "Proofs require specific structure and rigour that differs from intuitive understanding. Induction, contradiction, and loop invariants each have conventions you must practise to execute correctly under exam pressure.",
                "studyTip": "Understanding ≠ proving. Practise the proof structure."
              },
              {
                "text": "Recent exams have required algorithm correctness proofs—practise proof techniques regularly.",
                "answer": true,
                "explanation": "Examiners note this is a recurring requirement. Practise proof by induction (base case + inductive step), proof by contradiction (assume negation → derive contradiction), and loop invariants (init, maintenance, termination).",
                "studyTip": "Proof question incoming. Prepare for it."
              }
            ]
          },
          {
            "id": "PS003",
            "title": "Compare algorithm design patterns",
            "questions": [
              {
                "text": "Backtracking and brute-force are the same—both try all possible solutions.",
                "answer": false,
                "explanation": "They differ fundamentally. Brute-force generates complete solutions then checks validity. Backtracking generates partial solutions and abandons branches that can't lead to valid solutions. Backtracking prunes the search space.",
                "studyTip": "Backtracking prunes early. Brute-force checks late."
              },
              {
                "text": "Backtracking improves on brute-force by discarding partial solutions that cannot lead to valid solutions.",
                "answer": true,
                "explanation": "By pruning early, backtracking avoids exploring entire subtrees of invalid solutions. This doesn't change the worst-case complexity class but can dramatically reduce average-case time.",
                "studyTip": "Backtracking: abandon bad paths early"
              }
            ]
          },
          {
            "id": "PS004",
            "title": "Choose algorithms for context",
            "questions": [
              {
                "text": "The algorithm with the best theoretical complexity is always the right choice for a problem.",
                "answer": false,
                "explanation": "Context matters. For small inputs, simpler algorithms may outperform theoretically better ones. For NP-hard problems, you might need heuristics. Problem size, required solution quality, and time constraints all affect choice.",
                "studyTip": "Best complexity ≠ best choice. Consider the context."
              },
              {
                "text": "Algorithm selection should consider problem size, solution quality requirements, and practical constraints.",
                "answer": true,
                "explanation": "A gym with few courses might afford backtracking for timetabling. A massive scheduling problem needs simulated annealing for approximate solutions. Match the algorithm to the constraints.",
                "studyTip": "Small problem → exact algorithm. Large problem → approximation?"
              }
            ]
          },
          {
            "id": "PS005",
            "title": "Explain simulated annealing clearly",
            "questions": [
              {
                "text": "Simulated annealing only accepts improvements, making it a form of hill climbing.",
                "answer": false,
                "explanation": "The key difference: simulated annealing accepts worse solutions with probability that decreases over time. This prevents getting stuck in local optima. At high temperature, bad moves are more likely; as temperature drops, the algorithm becomes more selective.",
                "studyTip": "SA accepts bad moves early, rejects them later"
              },
              {
                "text": "Simulated annealing accepts worse solutions with decreasing probability to escape local optima.",
                "answer": true,
                "explanation": "The 'temperature' controls acceptance probability. Start hot (accept many bad moves), cool gradually (become selective). This exploration-exploitation balance helps find global optima in complex landscapes.",
                "studyTip": "Hot: explore. Cool: exploit."
              }
            ]
          },
          {
            "id": "PS006",
            "title": "Match algorithm to problem type",
            "questions": [
              {
                "text": "When finding minimum total edge weight connecting all nodes, use Dijkstra's algorithm.",
                "answer": false,
                "explanation": "That's minimum spanning tree—use Prim's or Kruskal's algorithm. Dijkstra's finds shortest paths from a source. Different problems require different algorithms. Know which tool fits which job.",
                "studyTip": "MST: Prim's/Kruskal's. Shortest path: Dijkstra's/Bellman-Ford."
              },
              {
                "text": "Prim's algorithm finds minimum spanning trees; Dijkstra's finds shortest paths from a source.",
                "answer": true,
                "explanation": "Both work on weighted graphs but solve different problems. MST connects all nodes with minimum total weight. Single-source shortest path finds minimum path weight to each node from a starting point.",
                "studyTip": "Connect all: MST. Reach all from one: shortest path."
              }
            ]
          },
          {
            "id": "PS007",
            "title": "Consider AI risks specifically",
            "questions": [
              {
                "text": "AI risks are general technology risks—the same concerns apply to any computer system.",
                "answer": false,
                "explanation": "AI has specific risks: bias in training data reinforcing discrimination, privacy concerns with data used for training, lack of transparency in why decisions are made. These are distinct from general technology risks.",
                "studyTip": "AI-specific: bias, privacy, transparency"
              },
              {
                "text": "AI risks include bias in training data, privacy of training data, and transparency of decision-making.",
                "answer": true,
                "explanation": "Answers mentioning general risks (like 'crashes' or 'hacking') miss the point. Examiners want AI-specific concerns: biased recommendations, unexplainable outputs, data misuse.",
                "studyTip": "What makes AI risks different from normal tech risks?"
              }
            ]
          },
          {
            "id": "PS008",
            "title": "Use heuristics appropriately",
            "questions": [
              {
                "text": "A* algorithm can use any heuristic function—the choice doesn't affect whether it finds the optimal path.",
                "answer": false,
                "explanation": "A* only guarantees optimal paths with admissible heuristics—ones that never overestimate the true cost. If h(n) > actual cost, A* might find suboptimal paths. The heuristic choice is critical.",
                "studyTip": "Admissible heuristic: never overestimates"
              },
              {
                "text": "A* guarantees optimal solutions when using an admissible heuristic that never overestimates true cost.",
                "answer": true,
                "explanation": "Admissibility ensures A* never incorrectly dismisses the optimal path. With pre-computed shortest distances as h(n), A* efficiently explores toward the goal while guaranteeing optimality.",
                "studyTip": "A* + admissible heuristic = optimal and efficient"
              }
            ]
          }
        ]
      }
    ]
  }