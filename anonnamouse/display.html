<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>a nonna mouse</title>
<meta name="description" content="a nonna mouse anonymous classroom comment display">
<style>
/* ═══════════════════════════════════════════════════════════
   CSS RESET & VARIABLES
   ═══════════════════════════════════════════════════════════ */

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* ── Color palette ── */
  --bg-primary: #faf8f5;
  --bg-gradient-start: #faf8f5;
  --bg-gradient-end: #f0ece6;
  --text-primary: #3a3530;
  --text-secondary: #7a7570;
  --text-muted: #a8a3a0;

  /* Pastel card colors */
  --pastel-1: #fce4ec; /* soft pink */
  --pastel-2: #e8f5e9; /* soft green */
  --pastel-3: #e3f2fd; /* soft blue */
  --pastel-4: #fff9c4; /* soft yellow */
  --pastel-5: #f3e5f5; /* soft lavender */
  --pastel-6: #fff3e0; /* soft peach */
  --pastel-7: #e0f7fa; /* soft cyan */
  --pastel-8: #fbe9e7; /* soft coral */

  /* Post-it colors */
  --postit-yellow: #fff9a8;
  --postit-pink: #ffb6c1;
  --postit-blue: #b3d4fc;
  --postit-green: #b5e8b5;
  --postit-orange: #ffd4a3;
  --postit-lavender: #d4c5f9;

  /* UI */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.08), 0 2px 4px rgba(0,0,0,0.04);
  --shadow-lg: 0 8px 24px rgba(0,0,0,0.10), 0 4px 8px rgba(0,0,0,0.05);
  --shadow-postit: 2px 3px 8px rgba(0,0,0,0.12), 0 1px 3px rgba(0,0,0,0.06);

  --radius-sm: 8px;
  --radius-md: 14px;
  --radius-lg: 20px;

  --font-body: 'Segoe UI', system-ui, -apple-system, sans-serif;
  --font-size-comment: clamp(22px, 2.5vw, 32px);
  --font-size-pinned: clamp(28px, 3vw, 42px);
  --font-size-brand: clamp(14px, 1.2vw, 18px);

  --transition-fade: 0.5s ease;
  --transition-crossfade: 0.8s ease;
  --transition-mode: 0.3s ease;
}

/* ── Dark mode ── */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #1a1816;
    --bg-gradient-start: #1a1816;
    --bg-gradient-end: #242220;
    --text-primary: #e8e4e0;
    --text-secondary: #a8a4a0;
    --text-muted: #706c68;

    --pastel-1: #4a2030;
    --pastel-2: #204a28;
    --pastel-3: #203848;
    --pastel-4: #4a4820;
    --pastel-5: #382048;
    --pastel-6: #4a3620;
    --pastel-7: #204848;
    --pastel-8: #4a2820;

    --postit-yellow: #6a6830;
    --postit-pink: #6a3040;
    --postit-blue: #304060;
    --postit-green: #306030;
    --postit-orange: #6a4830;
    --postit-lavender: #483060;

    --shadow-sm: 0 1px 3px rgba(0,0,0,0.20), 0 1px 2px rgba(0,0,0,0.14);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.25), 0 2px 4px rgba(0,0,0,0.15);
    --shadow-lg: 0 8px 24px rgba(0,0,0,0.30), 0 4px 8px rgba(0,0,0,0.18);
    --shadow-postit: 2px 3px 8px rgba(0,0,0,0.30), 0 1px 3px rgba(0,0,0,0.20);
  }
}

/* ── Reduced motion ── */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* ═══════════════════════════════════════════════════════════
   BASE LAYOUT
   ═══════════════════════════════════════════════════════════ */

html, body {
  width: 100vw;
  height: 100dvh;
  overflow: hidden;
  font-family: var(--font-body);
  color: var(--text-primary);
  background: linear-gradient(160deg, var(--bg-gradient-start), var(--bg-gradient-end));
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Subtle texture overlay */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: radial-gradient(circle at 20% 80%, rgba(180,160,140,0.04) 0%, transparent 50%),
                    radial-gradient(circle at 80% 20%, rgba(180,160,140,0.04) 0%, transparent 50%);
  pointer-events: none;
  z-index: 0;
}

/* ── Main display container ── */
.display-root {
  position: relative;
  width: 100vw;
  height: 100dvh;
  overflow: hidden;
  z-index: 1;
}

/* ── Branding ── */
.branding {
  position: fixed;
  top: 16px;
  left: 20px;
  font-size: var(--font-size-brand);
  color: var(--text-muted);
  z-index: 100;
  user-select: none;
  letter-spacing: 0.02em;
  opacity: 0.7;
}


/* ═══════════════════════════════════════════════════════════
   EMPTY STATE
   ═══════════════════════════════════════════════════════════ */

.empty-state {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  opacity: 1;
  transition: opacity var(--transition-fade);
  pointer-events: none;
}

.empty-state.is-hidden {
  opacity: 0;
}

.empty-state-icon {
  font-size: clamp(48px, 6vw, 80px);
  animation: empty-pulse 3s ease-in-out infinite;
}

.empty-state-text {
  font-size: clamp(20px, 2.5vw, 32px);
  color: var(--text-secondary);
  font-weight: 300;
  letter-spacing: 0.02em;
}

@keyframes empty-pulse {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.05); }
}

/* ═══════════════════════════════════════════════════════════
   MODE CONTAINERS — fade in/out on mode switch
   ═══════════════════════════════════════════════════════════ */

.mode-container {
  position: absolute;
  inset: 0;
  opacity: 0;
  transition: opacity var(--transition-mode);
  pointer-events: none;
}

.mode-container.is-active {
  opacity: 1;
  pointer-events: auto;
}

/* ═══════════════════════════════════════════════════════════
   CARDS MODE
   ═══════════════════════════════════════════════════════════ */

.cards-viewport {
  width: 100%;
  height: 100%;
  padding: 60px 40px 60px 40px;
  display: flex;
  flex-direction: column;
  gap: 24px;
  overflow: hidden;
}

.cards-pinned-area {
  flex-shrink: 0;
  display: flex;
  justify-content: center;
  min-height: 0;
}

.cards-grid {
  flex: 1;
  display: flex;
  flex-wrap: wrap;
  align-content: flex-start;
  justify-content: center;
  gap: 18px;
  overflow: hidden;
  padding: 8px;
}

/* Individual card */
.comment-card {
  padding: 20px 26px;
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-md);
  font-size: var(--font-size-comment);
  line-height: 1.45;
  max-width: 560px;
  min-width: 200px;
  word-wrap: break-word;
  overflow-wrap: break-word;
  opacity: 0;
  transform: translateY(20px) scale(0.98);
  animation: card-enter 0.5s ease forwards;
}

@keyframes card-enter {
  0% { opacity: 0; transform: translateY(20px) scale(0.98); }
  60% { transform: translateY(-2px) scale(1.02); }
  100% { opacity: 1; transform: translateY(0) scale(1); }
}

/* Card history — older cards shrink slightly */
.comment-card.is-old {
  opacity: 0.7;
  transform: scale(0.95);
  transition: opacity 0.5s ease, transform 0.5s ease;
}

/* Pinned card (cards mode) */
.comment-card.is-pinned {
  font-size: var(--font-size-pinned);
  max-width: 720px;
  box-shadow: var(--shadow-lg);
  position: relative;
  padding-left: 50px;
}

.comment-card.is-pinned::before {
  content: '\1F4CC'; /* pin emoji */
  position: absolute;
  top: 14px;
  left: 18px;
  font-size: 0.6em;
  opacity: 0.6;
}

/* Crossfade for cycling */
.comment-card.is-cycling-out {
  animation: card-cycle-out 0.8s ease forwards;
}

.comment-card.is-cycling-in {
  animation: card-cycle-in 0.8s ease forwards;
}

@keyframes card-cycle-out {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(0.97); }
}

@keyframes card-cycle-in {
  0% { opacity: 0; transform: scale(1.02); }
  100% { opacity: 1; transform: scale(1); }
}

/* New comment flash */
.comment-card.is-new-flash {
  animation: new-flash 1.2s ease;
}

@keyframes new-flash {
  0% { box-shadow: var(--shadow-md); }
  30% { box-shadow: 0 0 0 4px rgba(180,160,100,0.25), var(--shadow-lg); }
  100% { box-shadow: var(--shadow-md); }
}

/* ═══════════════════════════════════════════════════════════
   TICKER MODE
   ═══════════════════════════════════════════════════════════ */

.ticker-viewport {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.ticker-upper {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  padding: 40px;
}

.ticker-brand {
  font-size: clamp(36px, 5vw, 64px);
  color: var(--text-primary);
  font-weight: 300;
  letter-spacing: 0.04em;
  user-select: none;
}

/* Ticker pinned area — above the scroll strip */
.ticker-pinned {
  max-width: 700px;
  width: 100%;
  text-align: center;
  padding: 18px 28px;
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-md);
  font-size: var(--font-size-pinned);
  line-height: 1.45;
  position: relative;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.ticker-pinned::before {
  content: '\1F4CC';
  position: absolute;
  top: 12px;
  left: 16px;
  font-size: 0.55em;
  opacity: 0.6;
}

.ticker-pinned.is-hidden {
  display: none;
}

/* Ticker strip — bottom third */
.ticker-strip {
  flex-shrink: 0;
  height: 33.33vh;
  overflow: hidden;
  position: relative;
  border-top: 1px solid rgba(0,0,0,0.05);
  display: flex;
  align-items: center;
}

@media (prefers-color-scheme: dark) {
  .ticker-strip {
    border-top-color: rgba(255,255,255,0.06);
  }
}

.ticker-track {
  display: flex;
  align-items: center;
  gap: 60px;
  white-space: nowrap;
  will-change: transform;
  animation: ticker-scroll var(--ticker-duration, 30s) linear infinite;
}

@keyframes ticker-scroll {
  0% { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}

.ticker-item {
  display: inline-block;
  padding: 16px 28px;
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-sm);
  font-size: var(--font-size-comment);
  line-height: 1.4;
  flex-shrink: 0;
  max-width: 600px;
  white-space: normal;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* ═══════════════════════════════════════════════════════════
   POST-ITS MODE
   ═══════════════════════════════════════════════════════════ */

.postits-viewport {
  width: 100%;
  height: 100%;
  position: relative;
  padding: 60px 40px;
  overflow: hidden;
}

.postit-note {
  position: absolute;
  width: clamp(180px, 22vw, 280px);
  min-height: 120px;
  padding: 22px 20px 28px 20px;
  font-size: var(--font-size-comment);
  line-height: 1.4;
  box-shadow: var(--shadow-postit);
  word-wrap: break-word;
  overflow-wrap: break-word;
  opacity: 0;
  animation: postit-stick 0.5s ease forwards;

  /* Folded corner effect */
  clip-path: polygon(0 0, 100% 0, 100% calc(100% - 18px), calc(100% - 18px) 100%, 0 100%);
}

/* Corner fold overlay */
.postit-note::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0;
  width: 18px;
  height: 18px;
  background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.06) 50%);
  pointer-events: none;
}

@keyframes postit-stick {
  0% { opacity: 0; transform: rotate(var(--postit-rot, 0deg)) scale(0.8) translateY(-20px); }
  60% { opacity: 1; transform: rotate(var(--postit-rot, 0deg)) scale(1.03) translateY(2px); }
  100% { opacity: 1; transform: rotate(var(--postit-rot, 0deg)) scale(1) translateY(0); }
}

/* Pinned post-it */
.postit-note.is-pinned {
  width: clamp(240px, 28vw, 360px);
  font-size: var(--font-size-pinned);
  z-index: 10;
  box-shadow: var(--shadow-lg);
  padding-top: 32px;
}

.postit-pin-icon {
  position: absolute;
  top: 6px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.55em;
  opacity: 0.6;
}

/* Post-it cycling */
.postit-note.is-cycling-out {
  animation: postit-out 0.8s ease forwards;
}

@keyframes postit-out {
  0% { opacity: 1; }
  100% { opacity: 0; transform: rotate(var(--postit-rot, 0deg)) scale(0.9); }
}

.postit-note.is-new-flash {
  animation: postit-flash 1.2s ease;
}

@keyframes postit-flash {
  0% { box-shadow: var(--shadow-postit); }
  30% { box-shadow: 0 0 0 4px rgba(180,160,100,0.3), var(--shadow-lg); }
  100% { box-shadow: var(--shadow-postit); }
}

/* ═══════════════════════════════════════════════════════════
   BLANKED OVERLAY
   ═══════════════════════════════════════════════════════════ */

.blanked-overlay {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 9000;
  display: none;
  align-items: center;
  justify-content: center;
}
.blanked-overlay.is-active {
  display: flex;
}

/* ═══════════════════════════════════════════════════════════
   FONT SIZE OVERRIDES
   ═══════════════════════════════════════════════════════════ */

.display-root.font-large {
  --font-size-comment: clamp(28px, 3.2vw, 42px);
  --font-size-pinned: clamp(36px, 4vw, 56px);
}
.display-root.font-xlarge {
  --font-size-comment: clamp(34px, 4vw, 52px);
  --font-size-pinned: clamp(44px, 5vw, 68px);
}

/* ═══════════════════════════════════════════════════════════
   THEME OVERRIDES
   ═══════════════════════════════════════════════════════════ */

.display-root.theme-light {
  --bg-primary: #faf8f5;
  --bg-gradient-start: #faf8f5;
  --bg-gradient-end: #f0ece6;
  --text-primary: #3a3530;
  --text-secondary: #7a7570;
  --text-muted: #a8a3a0;
}
.display-root.theme-dark {
  --bg-primary: #1a1816;
  --bg-gradient-start: #1a1816;
  --bg-gradient-end: #242220;
  --text-primary: #e8e4e0;
  --text-secondary: #a8a4a0;
  --text-muted: #706c68;
  --pastel-1: #4a2030;
  --pastel-2: #204a28;
  --pastel-3: #203848;
  --pastel-4: #4a4820;
  --pastel-5: #382048;
  --pastel-6: #4a3620;
  --pastel-7: #204848;
  --pastel-8: #4a2820;
  --postit-yellow: #6a6830;
  --postit-pink: #6a3040;
  --postit-blue: #304060;
  --postit-green: #306030;
  --postit-orange: #6a4830;
  --postit-lavender: #483060;
}

/* ═══════════════════════════════════════════════════════════
   CONTROL OVERLAY
   ═══════════════════════════════════════════════════════════ */

.ctrl-toggle-btn {
  position: fixed;
  bottom: 16px;
  left: 16px;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid rgba(128,128,128,0.25);
  background: rgba(128,128,128,0.12);
  color: var(--text-muted);
  font-size: 1.2rem;
  cursor: pointer;
  z-index: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  opacity: 0.4;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
.ctrl-toggle-btn:hover {
  opacity: 1;
  background: rgba(128,128,128,0.25);
}

.ctrl-panel {
  position: fixed;
  bottom: 70px;
  left: 16px;
  width: 320px;
  max-width: calc(100vw - 32px);
  max-height: 80vh;
  overflow-y: auto;
  overscroll-behavior: contain;
  background: rgba(255,255,255,0.95);
  border: 1px solid rgba(0,0,0,0.1);
  border-radius: 14px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.15);
  z-index: 500;
  padding: 20px;
  display: none;
  flex-direction: column;
  gap: 16px;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  font-size: 14px;
  color: #333;
}
@media (prefers-color-scheme: dark) {
  .ctrl-panel {
    background: rgba(30,28,26,0.95);
    border-color: rgba(255,255,255,0.1);
    color: #ddd;
  }
}
.display-root.theme-dark .ctrl-panel {
  background: rgba(30,28,26,0.95);
  border-color: rgba(255,255,255,0.1);
  color: #ddd;
}
.display-root.theme-light .ctrl-panel {
  background: rgba(255,255,255,0.95);
  border-color: rgba(0,0,0,0.1);
  color: #333;
}
.ctrl-panel.is-open {
  display: flex;
}
.ctrl-panel__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.ctrl-panel__title {
  font-weight: 700;
  font-size: 15px;
}
.ctrl-panel__close {
  background: none;
  border: none;
  font-size: 18px;
  cursor: pointer;
  color: inherit;
  opacity: 0.6;
  padding: 4px 8px;
  border-radius: 6px;
}
.ctrl-panel__close:hover {
  opacity: 1;
  background: rgba(128,128,128,0.15);
}

/* Auth section */
.ctrl-auth {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.ctrl-auth__input {
  padding: 8px 12px;
  border: 1px solid rgba(128,128,128,0.3);
  border-radius: 8px;
  font-size: 14px;
  background: rgba(128,128,128,0.08);
  color: inherit;
  font-family: inherit;
}
.ctrl-auth__input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59,130,246,0.2);
}
.ctrl-auth__btn {
  padding: 8px 16px;
  border: none;
  border-radius: 8px;
  background: #3b82f6;
  color: white;
  font-weight: 600;
  cursor: pointer;
  font-size: 14px;
  font-family: inherit;
}
.ctrl-auth__btn:hover { background: #2563eb; }
.ctrl-auth__btn:disabled { opacity: 0.5; cursor: not-allowed; }
.ctrl-auth__error {
  color: #ef4444;
  font-size: 12px;
  min-height: 16px;
}

/* Control groups */
.ctrl-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.ctrl-group__title {
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  opacity: 0.55;
}
.ctrl-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}
.ctrl-row label {
  font-size: 13px;
  font-weight: 500;
}
.ctrl-row select,
.ctrl-row input[type="number"] {
  padding: 6px 10px;
  border: 1px solid rgba(128,128,128,0.3);
  border-radius: 6px;
  font-size: 13px;
  background: rgba(128,128,128,0.08);
  color: inherit;
  min-width: 100px;
  font-family: inherit;
}
.ctrl-row input[type="range"] {
  flex: 1;
  accent-color: #3b82f6;
  cursor: pointer;
}
.ctrl-value {
  font-size: 12px;
  font-weight: 700;
  font-family: monospace;
  min-width: 2.5em;
  text-align: end;
}

/* Toggle switch */
.ctrl-toggle-switch {
  position: relative;
  width: 40px;
  height: 22px;
  flex-shrink: 0;
}
.ctrl-toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
  position: absolute;
}
.ctrl-toggle-track {
  position: absolute;
  inset: 0;
  background: rgba(128,128,128,0.3);
  border-radius: 11px;
  cursor: pointer;
  transition: background 0.2s;
}
.ctrl-toggle-track::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 18px;
  height: 18px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.ctrl-toggle-switch input:checked + .ctrl-toggle-track {
  background: #3b82f6;
}
.ctrl-toggle-switch input:checked + .ctrl-toggle-track::before {
  transform: translateX(18px);
}

/* Mode buttons */
.ctrl-modes {
  display: flex;
  gap: 0;
  border: 1px solid rgba(128,128,128,0.3);
  border-radius: 8px;
  overflow: hidden;
}
.ctrl-mode-btn {
  flex: 1;
  padding: 8px 4px;
  border: none;
  background: transparent;
  color: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
  font-family: inherit;
}
.ctrl-mode-btn + .ctrl-mode-btn {
  border-left: 1px solid rgba(128,128,128,0.3);
}
.ctrl-mode-btn.is-active {
  background: #3b82f6;
  color: white;
}
.ctrl-mode-btn:hover:not(.is-active) {
  background: rgba(128,128,128,0.1);
}

/* Panic button */
.ctrl-blank-btn {
  width: 100%;
  padding: 10px;
  border: 2px solid #ef4444;
  border-radius: 8px;
  background: rgba(239,68,68,0.1);
  color: #ef4444;
  font-weight: 700;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s;
  text-transform: uppercase;
  font-family: inherit;
}
.ctrl-blank-btn:hover {
  background: #ef4444;
  color: white;
}
.ctrl-blank-btn.is-blanked {
  background: #ef4444;
  color: white;
}

/* Save button */
.ctrl-save-btn {
  width: 100%;
  padding: 10px;
  border: none;
  border-radius: 8px;
  background: #3b82f6;
  color: white;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.15s;
  font-family: inherit;
}
.ctrl-save-btn:hover { background: #2563eb; }
.ctrl-save-btn:disabled { opacity: 0.5; cursor: not-allowed; }
</style>
</head>
<body>

<div class="display-root" id="displayRoot" role="main" aria-live="polite">

  <!-- Branding -->
  <div class="branding" aria-hidden="true">&#x1F42D; a nonna mouse</div>

  <!-- Empty state -->
  <div class="empty-state" id="emptyState">
    <div class="empty-state-icon" aria-hidden="true">&#x1F42D;</div>
    <div class="empty-state-text">Waiting for submissions&hellip;</div>
  </div>

  <!-- ═══ CARDS MODE ═══ -->
  <div class="mode-container" id="modeCards">
    <div class="cards-viewport">
      <div class="cards-pinned-area" id="cardsPinnedArea"></div>
      <div class="cards-grid" id="cardsGrid"></div>
    </div>
  </div>

  <!-- ═══ TICKER MODE ═══ -->
  <div class="mode-container" id="modeTicker">
    <div class="ticker-viewport">
      <div class="ticker-upper">
        <div class="ticker-brand" aria-hidden="true">&#x1F42D; a nonna mouse</div>
        <div class="ticker-pinned is-hidden" id="tickerPinned"></div>
      </div>
      <div class="ticker-strip">
        <div class="ticker-track" id="tickerTrack"></div>
      </div>
    </div>
  </div>

  <!-- ═══ POST-ITS MODE ═══ -->
  <div class="mode-container" id="modePostits">
    <div class="postits-viewport" id="postitsViewport"></div>
  </div>

  <!-- Blanked overlay -->
  <div class="blanked-overlay" id="blankedOverlay" aria-hidden="true"></div>

</div>

<!-- Control overlay toggle button -->
<button class="ctrl-toggle-btn" id="ctrlToggleBtn" type="button" aria-label="Open display controls" title="Display Controls">&#x2699;</button>

<!-- Control overlay panel -->
<div class="ctrl-panel" id="ctrlPanel" role="dialog" aria-label="Display controls">
  <div class="ctrl-panel__header">
    <span class="ctrl-panel__title">&#x1F42D; Display Controls</span>
    <button class="ctrl-panel__close" id="ctrlCloseBtn" type="button" aria-label="Close">&times;</button>
  </div>

  <!-- Auth (shown until passphrase entered) -->
  <div class="ctrl-auth" id="ctrlAuth">
    <label for="ctrlPassInput" style="font-size:13px;font-weight:600;opacity:0.7;">Admin passphrase to unlock controls:</label>
    <input type="password" class="ctrl-auth__input" id="ctrlPassInput" placeholder="Enter passphrase..." autocomplete="off" spellcheck="false">
    <div class="ctrl-auth__error" id="ctrlAuthError"></div>
    <button class="ctrl-auth__btn" id="ctrlUnlockBtn" type="button">Unlock</button>
  </div>

  <!-- Controls (hidden until authed) -->
  <div id="ctrlControls" style="flex-direction:column;gap:16px;" hidden>

    <!-- Mode -->
    <div class="ctrl-group">
      <div class="ctrl-group__title">Mode</div>
      <div class="ctrl-modes" id="ctrlModes">
        <button class="ctrl-mode-btn is-active" data-mode="cards" type="button">Cards</button>
        <button class="ctrl-mode-btn" data-mode="ticker" type="button">Ticker</button>
        <button class="ctrl-mode-btn" data-mode="postits" type="button">Post-its</button>
      </div>
    </div>

    <!-- Cycling -->
    <div class="ctrl-group">
      <div class="ctrl-group__title">Cycling</div>
      <div class="ctrl-row">
        <span>Auto-cycle</span>
        <label class="ctrl-toggle-switch" for="ctrlAutoCycle">
          <input type="checkbox" id="ctrlAutoCycle">
          <span class="ctrl-toggle-track"></span>
        </label>
      </div>
      <div class="ctrl-row">
        <label for="ctrlCycleSpeed">Speed</label>
        <input type="range" id="ctrlCycleSpeed" min="3" max="30" step="1" value="8">
        <span class="ctrl-value" id="ctrlCycleSpeedVal">8s</span>
      </div>
    </div>

    <!-- Appearance -->
    <div class="ctrl-group">
      <div class="ctrl-group__title">Appearance</div>
      <div class="ctrl-row">
        <label for="ctrlHistoryDepth">History depth</label>
        <input type="number" id="ctrlHistoryDepth" min="1" max="50" step="1" value="12" style="width:70px;">
      </div>
      <div class="ctrl-row">
        <label for="ctrlFontSize">Font size</label>
        <select id="ctrlFontSize">
          <option value="normal">Normal</option>
          <option value="large">Large</option>
          <option value="xlarge">Extra Large</option>
        </select>
      </div>
      <div class="ctrl-row">
        <label for="ctrlTheme">Theme</label>
        <select id="ctrlTheme">
          <option value="auto">Auto</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
    </div>

    <!-- Blank display -->
    <button class="ctrl-blank-btn" id="ctrlBlankBtn" type="button">&#x26A0; Blank Display</button>

    <!-- Save -->
    <button class="ctrl-save-btn" id="ctrlSaveBtn" type="button">Save Settings</button>
  </div>
</div>

<script>
(function() {
  'use strict';

  /* ═══════════════════════════════════════════════════════════
     CONFIGURATION
     ═══════════════════════════════════════════════════════════ */

  /** @type {string} Base URL for the Google Apps Script web app */
  var API_URL = 'https://script.google.com/macros/s/AKfycbxsXnN9DcrTQZeeB90xvTF70h0VA59LjNAz1vj3FJeE_H999VYuJi18jxBiSPDiP_Tzwg/exec';

  /** @type {number} Polling interval for new approved comments (ms) */
  var POLL_APPROVED_MS = 5000;

  /** @type {number} Polling interval for config/state (ms) */
  var POLL_STATE_MS = 15000;

  /** @type {number} Auto-cycle interval between comments (ms) */
  var CYCLE_INTERVAL_MS = 8000;

  /* ═══════════════════════════════════════════════════════════
     PASTEL COLOR SETS
     ═══════════════════════════════════════════════════════════ */

  var PASTEL_COLORS = [
    'var(--pastel-1)', 'var(--pastel-2)', 'var(--pastel-3)', 'var(--pastel-4)',
    'var(--pastel-5)', 'var(--pastel-6)', 'var(--pastel-7)', 'var(--pastel-8)'
  ];

  var POSTIT_COLORS = [
    'var(--postit-yellow)', 'var(--postit-pink)', 'var(--postit-blue)',
    'var(--postit-green)', 'var(--postit-orange)', 'var(--postit-lavender)'
  ];

  /* ═══════════════════════════════════════════════════════════
     APPLICATION STATE
     ═══════════════════════════════════════════════════════════ */

  /** @type {Array<{id:string, text:string, approvedAt:string, pinned:boolean}>} */
  var comments = [];

  /** @type {string} Last seen comment ID for incremental polling */
  var lastSeenId = '';

  /** @type {string} Current display mode: 'cards' | 'ticker' | 'postits' */
  var currentMode = 'cards';

  /** @type {boolean} Whether auto-cycle is enabled */
  var autoCycleOn = false;

  /** @type {string} ID of the currently pinned comment */
  var pinnedCommentId = '';

  /** @type {number} Current index for auto-cycling through comment history */
  var cycleIndex = 0;

  /** @type {number|null} Auto-cycle timer reference */
  var cycleTimer = null;

  /** @type {boolean} Whether the initial data load has completed */
  var initialLoadDone = false;

  /** @type {number} Counter to trigger periodic full refresh for delete reconciliation */
  var pollCycleCount = 0;
  var FULL_REFRESH_EVERY = 6; // full refresh every 6th poll (i.e. every 30s at 5s interval)

  /** @type {number} Max comments visible (from config) */
  var historyDepth = 12;

  /** @type {string} Font size class: 'normal' | 'large' | 'xlarge' */
  var fontSize = 'normal';

  /** @type {string} Theme override: 'auto' | 'light' | 'dark' */
  var displayTheme = 'auto';

  /** @type {boolean} Whether display is blanked */
  var displayBlanked = false;

  /** @type {number} Cycle speed in seconds */
  var cycleSpeedSec = 8;

  /** @type {string} Cached passphrase for display-side config writes */
  var ctrlPassphrase = sessionStorage.getItem('anm_display_pass') || '';

  /** @type {boolean} Whether display overlay is authed */
  var ctrlAuthed = false;

  /* ═══════════════════════════════════════════════════════════
     DOM REFERENCES
     ═══════════════════════════════════════════════════════════ */

  var displayRoot = document.getElementById('displayRoot');
  var emptyState = document.getElementById('emptyState');

  // Cards mode
  var modeCards = document.getElementById('modeCards');
  var cardsPinnedArea = document.getElementById('cardsPinnedArea');
  var cardsGrid = document.getElementById('cardsGrid');

  // Ticker mode
  var modeTicker = document.getElementById('modeTicker');
  var tickerPinned = document.getElementById('tickerPinned');
  var tickerTrack = document.getElementById('tickerTrack');

  // Post-its mode
  var modePostits = document.getElementById('modePostits');
  var postitsViewport = document.getElementById('postitsViewport');

  // Blanked overlay
  var blankedOverlay = document.getElementById('blankedOverlay');

  // Control overlay
  var ctrlToggleBtn = document.getElementById('ctrlToggleBtn');
  var ctrlPanel = document.getElementById('ctrlPanel');
  var ctrlCloseBtn = document.getElementById('ctrlCloseBtn');
  var ctrlAuth = document.getElementById('ctrlAuth');
  var ctrlPassInput = document.getElementById('ctrlPassInput');
  var ctrlAuthError = document.getElementById('ctrlAuthError');
  var ctrlUnlockBtn = document.getElementById('ctrlUnlockBtn');
  var ctrlControls = document.getElementById('ctrlControls');
  var ctrlModes = document.getElementById('ctrlModes');
  var ctrlAutoCycleInput = document.getElementById('ctrlAutoCycle');
  var ctrlCycleSpeedInput = document.getElementById('ctrlCycleSpeed');
  var ctrlCycleSpeedVal = document.getElementById('ctrlCycleSpeedVal');
  var ctrlHistoryDepth = document.getElementById('ctrlHistoryDepth');
  var ctrlFontSize = document.getElementById('ctrlFontSize');
  var ctrlThemeSelect = document.getElementById('ctrlTheme');
  var ctrlBlankBtn = document.getElementById('ctrlBlankBtn');
  var ctrlSaveBtn = document.getElementById('ctrlSaveBtn');

  /* ═══════════════════════════════════════════════════════════
     API HELPERS
     ═══════════════════════════════════════════════════════════ */

  /**
   * Call the Apps Script backend with a given route and payload.
   * @param {string} route - API route name
   * @param {Object} payload - Request payload
   * @returns {Promise<Object>} Parsed response data
   */
  function apiCall(route, payload) {
    var url = API_URL + '?route=' + encodeURIComponent(route) +
              '&payload=' + encodeURIComponent(JSON.stringify(payload || {}));

    return fetch(url, { method: 'GET', mode: 'cors' })
      .then(function(resp) {
        if (!resp.ok) {
          throw new Error('HTTP ' + resp.status);
        }
        return resp.json();
      })
      .then(function(json) {
        if (!json.ok) {
          throw new Error(json.error || 'API error');
        }
        return json.data;
      });
  }

  /* ═══════════════════════════════════════════════════════════
     POLLING — APPROVED COMMENTS
     ═══════════════════════════════════════════════════════════ */

  /**
   * Fetch approved comments.
   * Incremental most of the time (sinceId), but every FULL_REFRESH_EVERY polls
   * does a full fetch to detect deletions and reconcile the local list.
   */
  function pollApproved() {
    pollCycleCount++;
    var doFullRefresh = !lastSeenId || (pollCycleCount % FULL_REFRESH_EVERY === 0);

    var payload = {};
    if (!doFullRefresh && lastSeenId) {
      payload.sinceId = lastSeenId;
    }

    apiCall('getApproved', payload)
      .then(function(data) {
        if (!Array.isArray(data)) return;

        if (doFullRefresh && initialLoadDone) {
          // ── Full reconciliation: replace local list with server truth ──
          var serverIds = {};
          for (var s = 0; s < data.length; s++) { serverIds[data[s].id] = true; }

          // Detect if anything changed (deletions, additions, pin changes)
          var changed = comments.length !== data.length;
          if (!changed) {
            for (var c = 0; c < comments.length; c++) {
              if (!serverIds[comments[c].id]) { changed = true; break; }
            }
          }
          if (!changed) {
            // Check for pin status changes
            for (var p = 0; p < data.length; p++) {
              var ex = findCommentById(data[p].id);
              if (ex && ex.pinned !== data[p].pinned) { changed = true; break; }
            }
          }

          // Rebuild the local list from server data
          comments = [];
          for (var d = 0; d < data.length; d++) {
            comments.push({
              id: data[d].id,
              text: data[d].text,
              approvedAt: data[d].approvedAt,
              pinned: data[d].pinned
            });
          }

          if (comments.length > 0) {
            lastSeenId = comments[comments.length - 1].id;
          } else {
            lastSeenId = '';
          }

          if (changed) {
            renderCurrentMode();
          }
        } else {
          // ── Incremental: append new comments only ──
          var newComments = [];

          data.forEach(function(item) {
            var existing = findCommentById(item.id);
            if (existing) {
              existing.pinned = item.pinned;
              return;
            }
            comments.push({
              id: item.id,
              text: item.text,
              approvedAt: item.approvedAt,
              pinned: item.pinned
            });
            newComments.push(item.id);
          });

          if (comments.length > 0) {
            lastSeenId = comments[comments.length - 1].id;
          }

          if (!initialLoadDone) {
            initialLoadDone = true;
            renderCurrentMode();
          } else if (newComments.length > 0) {
            onNewComments(newComments);
          }
        }

        updateEmptyState();
      })
      .catch(function(err) {
        console.warn('a nonna mouse display: poll error', err.message);
      });
  }

  /**
   * Find a comment object by its ID.
   * @param {string} id
   * @returns {Object|undefined}
   */
  function findCommentById(id) {
    for (var i = 0; i < comments.length; i++) {
      if (comments[i].id === id) return comments[i];
    }
    return undefined;
  }

  /* ═══════════════════════════════════════════════════════════
     POLLING — STATE / CONFIG
     ═══════════════════════════════════════════════════════════ */

  /**
   * Fetch server state: displayMode, autoCycle, pinnedCommentId.
   */
  function pollState() {
    apiCall('getState', {})
      .then(function(data) {
        if (!data || !data.config) return;

        var cfg = data.config;
        var needsRerender = false;

        // Display mode
        var newMode = String(cfg.displayMode || 'cards').toLowerCase();
        if (['cards', 'ticker', 'postits'].indexOf(newMode) === -1) {
          newMode = 'cards';
        }
        if (newMode !== currentMode) {
          switchMode(newMode);
        }

        // Auto-cycle
        var newAutoCycle = String(cfg.autoCycle).toLowerCase() === 'true';
        if (newAutoCycle !== autoCycleOn) {
          autoCycleOn = newAutoCycle;
          manageCycleTimer();
          needsRerender = true;
        }

        // Cycle speed
        var newSpeed = Number(cfg.cycleSpeed) || 8;
        if (newSpeed !== cycleSpeedSec) {
          cycleSpeedSec = newSpeed;
          CYCLE_INTERVAL_MS = cycleSpeedSec * 1000;
          manageCycleTimer(); // restart timer with new interval
        }

        // History depth
        var newDepth = Number(cfg.historyDepth) || 12;
        if (newDepth !== historyDepth) {
          historyDepth = newDepth;
          needsRerender = true;
        }

        // Font size
        var newFontSize = String(cfg.fontSize || 'normal').toLowerCase();
        if (['normal', 'large', 'xlarge'].indexOf(newFontSize) === -1) newFontSize = 'normal';
        if (newFontSize !== fontSize) {
          fontSize = newFontSize;
          applyFontSize();
          needsRerender = true;
        }

        // Theme
        var newTheme = String(cfg.displayTheme || 'auto').toLowerCase();
        if (['auto', 'light', 'dark'].indexOf(newTheme) === -1) newTheme = 'auto';
        if (newTheme !== displayTheme) {
          displayTheme = newTheme;
          applyTheme();
          needsRerender = true;
        }

        // Blanked
        var newBlanked = String(cfg.displayBlanked).toLowerCase() === 'true';
        if (newBlanked !== displayBlanked) {
          displayBlanked = newBlanked;
          applyBlanked();
        }

        // Pinned comment
        var newPinned = String(cfg.pinnedCommentId || '');
        if (newPinned !== pinnedCommentId) {
          pinnedCommentId = newPinned;
          comments.forEach(function(c) {
            c.pinned = (c.id === pinnedCommentId);
          });
          needsRerender = true;
        }

        if (needsRerender) {
          renderCurrentMode();
        }

        // Sync overlay controls if open
        syncOverlayControls();
      })
      .catch(function(err) {
        console.warn('a nonna mouse display: state poll error', err.message);
      });
  }

  /* ═══════════════════════════════════════════════════════════
     EMPTY STATE
     ═══════════════════════════════════════════════════════════ */

  /** Show or hide the empty state based on comment count. */
  function updateEmptyState() {
    var hasComments = comments.length > 0;
    if (hasComments) {
      emptyState.classList.add('is-hidden');
      displayRoot.classList.remove('is-empty');
    } else {
      emptyState.classList.remove('is-hidden');
      displayRoot.classList.add('is-empty');
    }
  }

  /* ═══════════════════════════════════════════════════════════
     MODE SWITCHING
     ═══════════════════════════════════════════════════════════ */

  var modeContainers = {
    cards: modeCards,
    ticker: modeTicker,
    postits: modePostits
  };

  /**
   * Switch to a new display mode with fade transition.
   * Fades out the old mode (0.3s), then renders and fades in the new mode.
   * @param {string} newMode
   */
  function switchMode(newMode) {
    // Fade out current mode container
    var oldContainer = modeContainers[currentMode];
    if (oldContainer) {
      oldContainer.classList.remove('is-active');
    }

    currentMode = newMode;

    // After fade-out completes, render and fade in the new mode
    setTimeout(function() {
      renderCurrentMode(); // This also activates the new container
    }, 320);

    // Restart cycle timer for the new mode
    manageCycleTimer();
  }

  /** Render the currently active mode. */
  function renderCurrentMode() {
    // Deactivate all
    Object.keys(modeContainers).forEach(function(key) {
      modeContainers[key].classList.remove('is-active');
    });

    switch (currentMode) {
      case 'cards':
        renderCards();
        break;
      case 'ticker':
        renderTicker();
        break;
      case 'postits':
        renderPostits();
        break;
    }

    // Activate
    var container = modeContainers[currentMode];
    if (container) {
      container.classList.add('is-active');
    }
  }

  /* ═══════════════════════════════════════════════════════════
     COLOR HELPERS
     ═══════════════════════════════════════════════════════════ */

  /**
   * Get a pastel color for a given index.
   * @param {number} index
   * @returns {string} CSS color variable
   */
  function getPastelColor(index) {
    return PASTEL_COLORS[index % PASTEL_COLORS.length];
  }

  /**
   * Get a post-it color for a given index.
   * @param {number} index
   * @returns {string} CSS color variable
   */
  function getPostitColor(index) {
    return POSTIT_COLORS[index % POSTIT_COLORS.length];
  }

  /* ═══════════════════════════════════════════════════════════
     SAFE TEXT HELPER (XSS prevention)
     ═══════════════════════════════════════════════════════════ */

  /**
   * Create a text node safely — never uses innerHTML.
   * @param {HTMLElement} el
   * @param {string} text
   */
  function setTextSafe(el, text) {
    el.textContent = text;
  }

  /* ═══════════════════════════════════════════════════════════
     CARDS MODE RENDERING
     ═══════════════════════════════════════════════════════════ */

  /** Render all cards: pinned + grid of non-pinned comments. */
  function renderCards() {
    cardsPinnedArea.innerHTML = '';
    cardsGrid.innerHTML = '';

    var pinned = getPinnedComment();
    var nonPinned = getNonPinnedComments();

    // Render pinned card
    if (pinned) {
      var pinnedCard = createCardElement(pinned, 0, true);
      cardsPinnedArea.appendChild(pinnedCard);
    }

    // If auto-cycling, show one comment at a time (plus pinned)
    if (autoCycleOn && nonPinned.length > 0) {
      var idx = cycleIndex % nonPinned.length;
      var card = createCardElement(nonPinned[idx], idx, false);
      card.style.maxWidth = '700px';
      cardsGrid.style.justifyContent = 'center';
      cardsGrid.style.alignContent = 'center';
      cardsGrid.appendChild(card);
    } else {
      // Show all cards, newest first, up to a reasonable limit
      cardsGrid.style.justifyContent = 'center';
      cardsGrid.style.alignContent = 'flex-start';
      var reversed = nonPinned.slice().reverse();
      var maxVisible = historyDepth;
      reversed.forEach(function(c, i) {
        if (i >= maxVisible) return;
        var card = createCardElement(c, i, false);
        if (i >= 6) {
          card.classList.add('is-old');
        }
        cardsGrid.appendChild(card);
      });
    }
  }

  /**
   * Create a card DOM element.
   * @param {Object} comment
   * @param {number} colorIndex
   * @param {boolean} isPinned
   * @returns {HTMLElement}
   */
  function createCardElement(comment, colorIndex, isPinned) {
    var card = document.createElement('div');
    card.className = 'comment-card';
    card.setAttribute('data-id', comment.id);
    card.style.backgroundColor = getPastelColor(colorIndex);

    if (isPinned) {
      card.classList.add('is-pinned');
    }

    setTextSafe(card, comment.text);
    return card;
  }

  /* ═══════════════════════════════════════════════════════════
     TICKER MODE RENDERING
     ═══════════════════════════════════════════════════════════ */

  /** Render the ticker: pinned above, scrolling strip below. */
  function renderTicker() {
    tickerTrack.innerHTML = '';

    // Pinned
    var pinned = getPinnedComment();
    if (pinned) {
      tickerPinned.classList.remove('is-hidden');
      setTextSafe(tickerPinned, pinned.text);
      tickerPinned.style.backgroundColor = getPastelColor(0);
    } else {
      tickerPinned.classList.add('is-hidden');
    }

    // Ticker items — non-pinned comments
    var allForTicker = getNonPinnedComments();
    if (allForTicker.length === 0) return;

    // Build the first half of the ticker track
    var fragment = document.createDocumentFragment();
    allForTicker.forEach(function(c, i) {
      var item = document.createElement('div');
      item.className = 'ticker-item';
      item.setAttribute('data-id', c.id);
      item.style.backgroundColor = getPastelColor(i);
      setTextSafe(item, c.text);
      fragment.appendChild(item);
    });

    // Duplicate the full set for seamless infinite scroll.
    // The CSS animation scrolls exactly -50%, so when the first set
    // scrolls off-screen, the second set fills in identically and
    // the animation restarts seamlessly.
    var duplicate = fragment.cloneNode(true);

    tickerTrack.appendChild(fragment);
    tickerTrack.appendChild(duplicate);

    // Calculate scroll duration so the first half scrolls at ~80px/s
    requestAnimationFrame(function() {
      var halfWidth = tickerTrack.scrollWidth / 2;
      // 80px per second for comfortable reading speed
      var duration = Math.max(15, halfWidth / 80);
      tickerTrack.style.setProperty('--ticker-duration', duration + 's');
    });
  }

  /* ═══════════════════════════════════════════════════════════
     POST-ITS MODE RENDERING
     ═══════════════════════════════════════════════════════════ */

  /** Render post-it notes scattered across the viewport. */
  function renderPostits() {
    postitsViewport.innerHTML = '';

    var pinned = getPinnedComment();
    var nonPinned = getNonPinnedComments();

    // If auto-cycling, show pinned + one cycled comment
    var toRender = [];
    if (autoCycleOn && nonPinned.length > 0) {
      var idx = cycleIndex % nonPinned.length;
      toRender = [nonPinned[idx]];
    } else {
      // Show all, newest first, up to limit
      toRender = nonPinned.slice().reverse().slice(0, Math.min(historyDepth, 10));
    }

    // Place pinned post-it in a prominent center-top position
    if (pinned) {
      var pinnedNote = createPostitElement(pinned, 0, true);
      // Center-top position
      pinnedNote.style.left = '50%';
      pinnedNote.style.top = '80px';
      pinnedNote.style.transform = 'translateX(-50%) rotate(0deg)';
      pinnedNote.style.setProperty('--postit-rot', '0deg');
      postitsViewport.appendChild(pinnedNote);
    }

    // Scatter non-pinned post-its
    var positions = generateScatterPositions(toRender.length, pinned ? true : false);
    toRender.forEach(function(c, i) {
      var note = createPostitElement(c, i, false);
      var pos = positions[i];
      note.style.left = pos.x + '%';
      note.style.top = pos.y + '%';
      var rot = (Math.random() * 10 - 5).toFixed(1);
      note.style.setProperty('--postit-rot', rot + 'deg');
      note.style.animationDelay = (i * 0.08) + 's';
      postitsViewport.appendChild(note);
    });
  }

  /**
   * Create a post-it note DOM element.
   * @param {Object} comment
   * @param {number} colorIndex
   * @param {boolean} isPinned
   * @returns {HTMLElement}
   */
  function createPostitElement(comment, colorIndex, isPinned) {
    var note = document.createElement('div');
    note.className = 'postit-note';
    note.setAttribute('data-id', comment.id);
    note.style.backgroundColor = getPostitColor(colorIndex);

    if (isPinned) {
      note.classList.add('is-pinned');
      // Add pin icon
      var icon = document.createElement('span');
      icon.className = 'postit-pin-icon';
      icon.setAttribute('aria-hidden', 'true');
      icon.textContent = '\uD83D\uDCCC';
      note.appendChild(icon);
    }

    var textSpan = document.createElement('span');
    setTextSafe(textSpan, comment.text);
    note.appendChild(textSpan);

    return note;
  }

  /**
   * Generate grid-based positions for post-it notes so they never overlap.
   * Uses a grid layout with slight random jitter for a natural feel.
   * @param {number} count
   * @param {boolean} hasPinned
   * @returns {Array<{x:number, y:number}>}
   */
  function generateScatterPositions(count, hasPinned) {
    if (count === 0) return [];

    // Available area (percentages)
    var left = 3, right = 72;    // leave room for post-it width (~22vw)
    var top = hasPinned ? 28 : 6;
    var bottom = 72;             // leave room for post-it height

    var areaW = right - left;
    var areaH = bottom - top;

    // Calculate grid: try to fill a rectangle nicely
    var cols = Math.ceil(Math.sqrt(count * (areaW / areaH)));
    var rows = Math.ceil(count / cols);
    if (cols < 1) cols = 1;
    if (rows < 1) rows = 1;

    var cellW = areaW / cols;
    var cellH = areaH / rows;

    // Jitter range: stay within cell but add randomness
    var jitterX = Math.min(cellW * 0.25, 4);
    var jitterY = Math.min(cellH * 0.25, 4);

    var positions = [];
    for (var i = 0; i < count; i++) {
      var col = i % cols;
      var row = Math.floor(i / cols);

      var x = left + col * cellW + cellW * 0.15 + (Math.random() * 2 - 1) * jitterX;
      var y = top  + row * cellH + cellH * 0.1  + (Math.random() * 2 - 1) * jitterY;

      positions.push({ x: x, y: y });
    }

    return positions;
  }

  /* ═══════════════════════════════════════════════════════════
     COMMENT HELPERS
     ═══════════════════════════════════════════════════════════ */

  /**
   * Get the pinned comment, if any.
   * @returns {Object|null}
   */
  function getPinnedComment() {
    if (!pinnedCommentId) return null;
    return findCommentById(pinnedCommentId) || null;
  }

  /**
   * Get all non-pinned comments in chronological order.
   * @returns {Array<Object>}
   */
  function getNonPinnedComments() {
    return comments.filter(function(c) {
      return c.id !== pinnedCommentId;
    });
  }

  /* ═══════════════════════════════════════════════════════════
     NEW COMMENT HANDLING
     ═══════════════════════════════════════════════════════════ */

  /**
   * Called when new comments arrive via polling.
   * @param {Array<string>} newIds - IDs of newly added comments
   */
  function onNewComments(newIds) {
    // Re-render the current mode to incorporate new comments
    renderCurrentMode();

    // Apply flash highlight to new comment elements
    requestAnimationFrame(function() {
      newIds.forEach(function(id) {
        var el = document.querySelector('[data-id="' + CSS.escape(id) + '"]');
        if (el) {
          el.classList.add('is-new-flash');
          // Remove the class after animation completes
          setTimeout(function() {
            el.classList.remove('is-new-flash');
          }, 1300);
        }
      });
    });
  }

  /* ═══════════════════════════════════════════════════════════
     AUTO-CYCLE
     ═══════════════════════════════════════════════════════════ */

  /** Start or stop the auto-cycle timer based on current state. */
  function manageCycleTimer() {
    // Clear existing timer
    if (cycleTimer !== null) {
      clearInterval(cycleTimer);
      cycleTimer = null;
    }

    if (!autoCycleOn) return;
    if (currentMode === 'ticker') return; // Ticker scrolls on its own

    cycleTimer = setInterval(function() {
      advanceCycle();
    }, CYCLE_INTERVAL_MS);
  }

  /** Advance to the next comment in the cycle with crossfade. */
  function advanceCycle() {
    var nonPinned = getNonPinnedComments();
    if (nonPinned.length === 0) return;

    // Find current visible cycling elements and fade them out
    var currentEls = [];
    if (currentMode === 'cards') {
      currentEls = cardsGrid.querySelectorAll('.comment-card');
    } else if (currentMode === 'postits') {
      currentEls = postitsViewport.querySelectorAll('.postit-note:not(.is-pinned)');
    }

    // Apply cycling-out class
    for (var i = 0; i < currentEls.length; i++) {
      currentEls[i].classList.add('is-cycling-out');
    }

    // After the fade-out completes, advance index and re-render
    setTimeout(function() {
      cycleIndex = (cycleIndex + 1) % nonPinned.length;
      renderCurrentMode();
    }, 800);
  }

  /* ═══════════════════════════════════════════════════════════
     DISPLAY CONFIG HELPERS
     ═══════════════════════════════════════════════════════════ */

  /** Apply font size CSS class to the display root. */
  function applyFontSize() {
    displayRoot.classList.remove('font-large', 'font-xlarge');
    if (fontSize === 'large') displayRoot.classList.add('font-large');
    else if (fontSize === 'xlarge') displayRoot.classList.add('font-xlarge');
  }

  /** Apply theme CSS class to the display root and body. */
  function applyTheme() {
    displayRoot.classList.remove('theme-light', 'theme-dark');
    document.body.style.background = '';
    if (displayTheme === 'light') {
      displayRoot.classList.add('theme-light');
    } else if (displayTheme === 'dark') {
      displayRoot.classList.add('theme-dark');
    }
    // 'auto' = no override class, system preference applies
  }

  /** Show or hide the blanked overlay. */
  function applyBlanked() {
    if (displayBlanked) {
      blankedOverlay.classList.add('is-active');
      blankedOverlay.setAttribute('aria-hidden', 'false');
    } else {
      blankedOverlay.classList.remove('is-active');
      blankedOverlay.setAttribute('aria-hidden', 'true');
    }
  }

  /* ═══════════════════════════════════════════════════════════
     CONTROL OVERLAY
     ═══════════════════════════════════════════════════════════ */

  /** Open the control overlay panel. */
  function openCtrlPanel() {
    ctrlPanel.classList.add('is-open');
    syncOverlayControls();
    if (ctrlAuthed) {
      ctrlAuth.style.display = 'none';
      ctrlControls.hidden = false;
      ctrlControls.style.display = 'flex';
    } else {
      ctrlAuth.style.display = 'flex';
      ctrlControls.hidden = true;
      ctrlControls.style.display = 'none';
      ctrlPassInput.focus();
    }
  }

  /** Close the control overlay panel. */
  function closeCtrlPanel() {
    ctrlPanel.classList.remove('is-open');
  }

  /** Attempt to unlock overlay controls with passphrase. */
  function unlockCtrlPanel() {
    var pass = ctrlPassInput.value.trim();
    if (!pass) {
      ctrlAuthError.textContent = 'Please enter the passphrase.';
      return;
    }

    ctrlUnlockBtn.disabled = true;
    ctrlUnlockBtn.textContent = 'Verifying...';
    ctrlAuthError.textContent = '';

    // Verify by calling updateConfig with no changes
    apiCall('updateConfig', { passphrase: pass, settings: {} })
      .then(function() {
        ctrlPassphrase = pass;
        ctrlAuthed = true;
        sessionStorage.setItem('anm_display_pass', pass);
        ctrlAuth.style.display = 'none';
        ctrlControls.hidden = false;
        ctrlControls.style.display = 'flex';
        syncOverlayControls();
      })
      .catch(function(err) {
        var msg = (err.message || '').toLowerCase();
        if (msg.indexOf('passphrase') !== -1 || msg.indexOf('invalid') !== -1) {
          ctrlAuthError.textContent = 'Invalid passphrase.';
        } else {
          ctrlAuthError.textContent = 'Connection error.';
        }
        ctrlPassInput.focus();
        ctrlPassInput.select();
      })
      .finally(function() {
        ctrlUnlockBtn.disabled = false;
        ctrlUnlockBtn.textContent = 'Unlock';
      });
  }

  /** Try to auto-auth display overlay with cached passphrase. */
  function tryAutoAuthOverlay() {
    if (!ctrlPassphrase) return;
    apiCall('updateConfig', { passphrase: ctrlPassphrase, settings: {} })
      .then(function() {
        ctrlAuthed = true;
      })
      .catch(function() {
        ctrlPassphrase = '';
        ctrlAuthed = false;
        sessionStorage.removeItem('anm_display_pass');
      });
  }

  /** Sync overlay controls to match current display state. */
  function syncOverlayControls() {
    if (!ctrlAuthed) return;

    // Mode buttons
    ctrlModes.querySelectorAll('.ctrl-mode-btn').forEach(function(btn) {
      btn.classList.toggle('is-active', btn.getAttribute('data-mode') === currentMode);
    });

    // Auto-cycle
    ctrlAutoCycleInput.checked = autoCycleOn;

    // Cycle speed
    ctrlCycleSpeedInput.value = cycleSpeedSec;
    ctrlCycleSpeedVal.textContent = cycleSpeedSec + 's';

    // History depth
    ctrlHistoryDepth.value = historyDepth;

    // Font size
    ctrlFontSize.value = fontSize;

    // Theme
    ctrlThemeSelect.value = displayTheme;

    // Blank button
    ctrlBlankBtn.classList.toggle('is-blanked', displayBlanked);
    ctrlBlankBtn.textContent = displayBlanked ? '\u2705 Blanked \u2014 Restore' : '\u26A0 Blank Display';
  }

  /** Save settings from the overlay controls. */
  function saveOverlaySettings() {
    if (!ctrlAuthed) return;

    var activeMode = currentMode;
    ctrlModes.querySelectorAll('.ctrl-mode-btn').forEach(function(btn) {
      if (btn.classList.contains('is-active')) activeMode = btn.getAttribute('data-mode');
    });

    var settings = {
      displayMode: activeMode,
      autoCycle: ctrlAutoCycleInput.checked,
      cycleSpeed: Number(ctrlCycleSpeedInput.value) || 8,
      historyDepth: Number(ctrlHistoryDepth.value) || 12,
      fontSize: ctrlFontSize.value,
      displayTheme: ctrlThemeSelect.value
    };

    ctrlSaveBtn.disabled = true;
    ctrlSaveBtn.textContent = 'Saving...';

    apiCall('updateConfig', { passphrase: ctrlPassphrase, settings: settings })
      .then(function() {
        ctrlSaveBtn.textContent = '\u2713 Saved!';
        setTimeout(function() {
          ctrlSaveBtn.textContent = 'Save Settings';
          ctrlSaveBtn.disabled = false;
        }, 1500);
        // Force a state refresh to apply changes
        pollState();
      })
      .catch(function(err) {
        ctrlSaveBtn.textContent = 'Error!';
        setTimeout(function() {
          ctrlSaveBtn.textContent = 'Save Settings';
          ctrlSaveBtn.disabled = false;
        }, 2000);
        console.warn('Save failed:', err.message);
      });
  }

  /** Toggle blank display from the overlay. */
  function toggleOverlayBlank() {
    if (!ctrlAuthed) return;
    var newBlanked = !displayBlanked;

    apiCall('updateConfig', { passphrase: ctrlPassphrase, settings: { displayBlanked: newBlanked } })
      .then(function() {
        displayBlanked = newBlanked;
        applyBlanked();
        syncOverlayControls();
      })
      .catch(function(err) {
        console.warn('Blank toggle failed:', err.message);
      });
  }

  /** Bind all overlay event listeners. */
  function bindOverlayEvents() {
    // Toggle panel open/close
    ctrlToggleBtn.addEventListener('click', function() {
      if (ctrlPanel.classList.contains('is-open')) {
        closeCtrlPanel();
      } else {
        openCtrlPanel();
      }
    });

    ctrlCloseBtn.addEventListener('click', closeCtrlPanel);

    // Auth
    ctrlUnlockBtn.addEventListener('click', unlockCtrlPanel);
    ctrlPassInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') unlockCtrlPanel();
    });

    // Mode buttons (instant save)
    ctrlModes.querySelectorAll('.ctrl-mode-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        if (!ctrlAuthed) return;
        var newMode = btn.getAttribute('data-mode');
        ctrlModes.querySelectorAll('.ctrl-mode-btn').forEach(function(b) {
          b.classList.toggle('is-active', b.getAttribute('data-mode') === newMode);
        });
        // Instant save mode change
        apiCall('updateConfig', { passphrase: ctrlPassphrase, settings: { displayMode: newMode } })
          .then(function() { pollState(); })
          .catch(function(err) { console.warn('Mode change failed:', err.message); });
      });
    });

    // Cycle speed live value
    ctrlCycleSpeedInput.addEventListener('input', function() {
      ctrlCycleSpeedVal.textContent = this.value + 's';
    });

    // Blank button (instant save)
    ctrlBlankBtn.addEventListener('click', toggleOverlayBlank);

    // Save button
    ctrlSaveBtn.addEventListener('click', saveOverlaySettings);

    // Close on Escape
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && ctrlPanel.classList.contains('is-open')) {
        closeCtrlPanel();
      }
    });
  }

  /* ═══════════════════════════════════════════════════════════
     INITIALIZATION
     ═══════════════════════════════════════════════════════════ */

  /** Boot the display client. */
  function init() {
    // Mark empty initially
    updateEmptyState();

    // Activate the default mode container
    modeContainers[currentMode].classList.add('is-active');

    // Bind overlay control events
    bindOverlayEvents();

    // Try auto-auth for display overlay (cached passphrase)
    tryAutoAuthOverlay();

    // Initial data fetch
    pollApproved();
    pollState();

    // Start polling intervals
    setInterval(pollApproved, POLL_APPROVED_MS);
    setInterval(pollState, POLL_STATE_MS);
  }

  /* ═══════════════════════════════════════════════════════════
     LAUNCH
     ═══════════════════════════════════════════════════════════ */

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();
</script>
</body>
</html>
