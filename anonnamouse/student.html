<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>a nonna mouse</title>
<style>
/* ========================================================
   CSS — Mobile-first, dark mode, reduced motion support
   ======================================================== */

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Light mode palette — calm blues, greens, grays */
  --bg-primary: #f0f4f8;
  --bg-secondary: #ffffff;
  --bg-input: #ffffff;
  --text-primary: #2d3748;
  --text-secondary: #718096;
  --text-muted: #a0aec0;
  --accent: #4a90a4;
  --accent-hover: #3a7a94;
  --accent-disabled: #b0c4ce;
  --success: #48bb78;
  --success-bg: #f0fff4;
  --warning: #ed8936;
  --warning-bg: #fffaf0;
  --error: #e53e3e;
  --error-bg: #fff5f5;
  --info: #4299e1;
  --info-bg: #ebf8ff;
  --border: #e2e8f0;
  --shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 4px 14px rgba(0, 0, 0, 0.1);
  --radius: 12px;
  --radius-sm: 8px;
  --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  --transition-speed: 0.2s;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #1a202c;
    --bg-secondary: #2d3748;
    --bg-input: #2d3748;
    --text-primary: #e2e8f0;
    --text-secondary: #a0aec0;
    --text-muted: #718096;
    --accent: #63b3c6;
    --accent-hover: #76c8db;
    --accent-disabled: #4a6670;
    --success: #68d391;
    --success-bg: #1c3a2a;
    --warning: #f6ad55;
    --warning-bg: #3d2e1a;
    --error: #fc8181;
    --error-bg: #3d1f1f;
    --info: #63b3de;
    --info-bg: #1a2d3d;
    --border: #4a5568;
    --shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 4px 14px rgba(0, 0, 0, 0.4);
  }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

html {
  font-size: 16px;
  -webkit-text-size-adjust: 100%;
}

body {
  font-family: var(--font);
  background-color: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px;
  line-height: 1.5;
}

/* Brand header */
.brand-header {
  text-align: center;
  padding: 20px 0 8px;
  user-select: none;
}

.brand-logo {
  font-size: 2rem;
  line-height: 1;
  margin-bottom: 4px;
}

.brand-name {
  font-size: 1.4rem;
  font-weight: 700;
  color: var(--accent);
  letter-spacing: -0.02em;
}

.brand-subtitle {
  font-size: 0.8rem;
  color: var(--text-muted);
  margin-top: 2px;
}

/* Main card container */
.card {
  width: 100%;
  max-width: 480px;
  background: var(--bg-secondary);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 20px;
  margin-top: 12px;
}

/* Textarea */
.comment-area {
  position: relative;
  margin-bottom: 12px;
}

.comment-input {
  width: 100%;
  min-height: 120px;
  max-height: 300px;
  padding: 14px 16px;
  font-family: var(--font);
  font-size: 1rem;
  line-height: 1.5;
  color: var(--text-primary);
  background: var(--bg-input);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  resize: vertical;
  outline: none;
  transition: border-color var(--transition-speed) ease;
}

.comment-input:focus {
  border-color: var(--accent);
}

.comment-input:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.comment-input::placeholder {
  color: var(--text-muted);
}

/* Character counter */
.char-counter {
  text-align: right;
  font-size: 0.8rem;
  color: var(--text-muted);
  margin-top: 4px;
  transition: color var(--transition-speed) ease;
}

.char-counter.warn {
  color: var(--warning);
  font-weight: 600;
}

.char-counter.over {
  color: var(--error);
  font-weight: 700;
}

/* Submit button */
.submit-btn {
  width: 100%;
  padding: 14px 20px;
  font-family: var(--font);
  font-size: 1rem;
  font-weight: 600;
  color: #ffffff;
  background: var(--accent);
  border: none;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background-color var(--transition-speed) ease, transform 0.1s ease, opacity var(--transition-speed) ease;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.submit-btn:hover:not(:disabled) {
  background: var(--accent-hover);
}

.submit-btn:active:not(:disabled) {
  transform: scale(0.98);
}

.submit-btn:disabled {
  background: var(--accent-disabled);
  cursor: not-allowed;
  opacity: 0.7;
}

/* Status message */
.status-msg {
  margin-top: 12px;
  padding: 10px 14px;
  border-radius: var(--radius-sm);
  font-size: 0.9rem;
  font-weight: 500;
  text-align: center;
  display: none;
  animation: fadeIn 0.25s ease;
}

.status-msg.visible {
  display: block;
}

.status-msg.success {
  background: var(--success-bg);
  color: var(--success);
}

.status-msg.error {
  background: var(--error-bg);
  color: var(--error);
}

.status-msg.warning {
  background: var(--warning-bg);
  color: var(--warning);
}

.status-msg.info {
  background: var(--info-bg);
  color: var(--info);
}

/* Cooldown timer */
.cooldown-display {
  margin-top: 12px;
  padding: 10px 14px;
  border-radius: var(--radius-sm);
  background: var(--info-bg);
  color: var(--info);
  font-size: 0.9rem;
  font-weight: 500;
  text-align: center;
  display: none;
}

.cooldown-display.visible {
  display: block;
}

/* Session inactive overlay */
.session-inactive {
  text-align: center;
  padding: 32px 20px;
  display: none;
}

.session-inactive.visible {
  display: block;
}

.session-inactive-icon {
  font-size: 2.5rem;
  margin-bottom: 12px;
  opacity: 0.6;
}

.session-inactive-text {
  font-size: 1.1rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.session-inactive-sub {
  font-size: 0.85rem;
  color: var(--text-muted);
  margin-top: 6px;
}

/* TF.js loading indicator */
.tf-status {
  text-align: center;
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-top: 16px;
  opacity: 0.7;
  transition: opacity var(--transition-speed) ease;
}

.tf-status.loaded {
  opacity: 0;
  pointer-events: none;
}

/* Fade-in animation */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Desktop scaling */
@media (min-width: 600px) {
  body {
    padding: 32px 24px;
  }

  .brand-header {
    padding-top: 32px;
  }

  .card {
    padding: 28px;
  }

  .comment-input {
    min-height: 140px;
  }
}

/* Skip-to-content link */
.skip-link {
  position: absolute;
  top: -100px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--primary);
  color: #fff;
  padding: 8px 16px;
  border-radius: var(--radius-sm);
  z-index: 100;
  font-size: 0.9rem;
  text-decoration: none;
}
.skip-link:focus {
  top: 8px;
}

/* Screen-reader only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

/* Focus-visible on submit button */
.submit-btn:focus-visible {
  outline: 3px solid var(--primary);
  outline-offset: 2px;
}
</style>
</head>
<body>

<a class="skip-link" href="#comment-input">Skip to comment box</a>

<!-- Brand header -->
<header class="brand-header">
  <h1 class="brand-name">a nonna mouse</h1>
  <div class="brand-logo" aria-hidden="true">&#x1F42D;</div>
  <div class="brand-subtitle">anonymous classroom backchannel</div>
</header>

<!-- Main card — submission form -->
<main class="card" id="form-card">
  <div class="comment-area">
    <label for="comment-input" class="sr-only">Your anonymous comment</label>
    <textarea
      class="comment-input"
      id="comment-input"
      placeholder="Share your thought anonymously..."
    ></textarea>
    <div class="char-counter" id="char-counter">280 remaining</div>
  </div>
  <button class="submit-btn" id="submit-btn" type="button">Submit</button>
  <div class="status-msg" id="status-msg" role="status" aria-live="polite"></div>
  <div class="cooldown-display" id="cooldown-display" aria-live="polite"></div>
</main>

<!-- Session inactive state (hidden by default) -->
<div class="session-inactive" id="session-inactive">
  <div class="session-inactive-icon" aria-hidden="true">&#x1F634;</div>
  <div class="session-inactive-text">Session not active</div>
  <div class="session-inactive-sub">Waiting for your teacher to start a session...</div>
</div>

<!-- TF.js loading indicator -->
<div class="tf-status" id="tf-status">Enhanced safety loading...</div>

<!-- TensorFlow.js and Toxicity model from CDN -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/toxicity"></script>

<script>
(function () {
  'use strict';

  /* ==============================================================
     CONFIGURATION
     ============================================================== */

  /** Base URL for the Google Apps Script web-app deployment */
  var API_URL = 'https://script.google.com/macros/s/AKfycbxsXnN9DcrTQZeeB90xvTF70h0VA59LjNAz1vj3FJeE_H999VYuJi18jxBiSPDiP_Tzwg/exec';

  /** Defaults — overwritten by server getState response */
  var config = {
    cooldownMinutes: 1,
    maxLength: 280,
    sessionActive: false
  };

  /** Polling interval for getState (ms) */
  var POLL_ACTIVE = 10000;  // 10s when session is active
  var POLL_IDLE   = 30000;  // 30s when session is inactive
  var POLL_BG     = 60000;  // 60s when tab is hidden

  /* ==============================================================
     DOM REFERENCES
     ============================================================== */

  var commentInput = document.getElementById('comment-input');
  var charCounter = document.getElementById('char-counter');
  var submitBtn = document.getElementById('submit-btn');
  var statusMsg = document.getElementById('status-msg');
  var cooldownDisplay = document.getElementById('cooldown-display');
  var formCard = document.getElementById('form-card');
  var sessionInactive = document.getElementById('session-inactive');
  var tfStatus = document.getElementById('tf-status');

  /* ==============================================================
     STATE
     ============================================================== */

  var deviceId = '';
  var cooldownEndTime = 0;       // timestamp (ms) when cooldown expires
  var cooldownInterval = null;
  var pollTimer = null;
  var isSubmitting = false;

  /** TensorFlow.js toxicity model */
  var tfModel = null;
  var tfModelLoading = false;
  var tfModelReady = false;

  /* ==============================================================
     1. DEVICE IDENTITY — triple-redundant UUID
     ============================================================== */

  /**
   * Retrieve or generate a persistent device UUID.
   * Stored in localStorage, sessionStorage, and a cookie.
   */
  function initDeviceId() {
    var KEY = 'anm_device_id';

    // Try to load from any of the three stores
    var fromLocal = null;
    var fromSession = null;
    var fromCookie = null;

    try { fromLocal = localStorage.getItem(KEY); } catch (e) { /* private browsing */ }
    try { fromSession = sessionStorage.getItem(KEY); } catch (e) { /* private browsing */ }
    fromCookie = getCookie(KEY);

    deviceId = fromLocal || fromSession || fromCookie || '';

    if (!deviceId) {
      deviceId = crypto.randomUUID();
    }

    // Write back to all three
    try { localStorage.setItem(KEY, deviceId); } catch (e) { /* ignore */ }
    try { sessionStorage.setItem(KEY, deviceId); } catch (e) { /* ignore */ }
    setCookie(KEY, deviceId, 365);
  }

  /** Read a cookie by name */
  function getCookie(name) {
    var match = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '=([^;]*)'));
    return match ? decodeURIComponent(match[1]) : null;
  }

  /** Set a cookie with max-age in days */
  function setCookie(name, value, days) {
    var maxAge = days * 86400;
    document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + maxAge + '; SameSite=Lax';
  }

  /* ==============================================================
     2. API LAYER — GET requests with route + payload params
     ============================================================== */

  /**
   * Call the server API.
   * @param {string} route — the route name (e.g. 'getState', 'submit')
   * @param {Object} payload — will be JSON-stringified and URL-encoded
   * @returns {Promise<Object>} parsed JSON response
   */
  function apiCall(route, payload) {
    var url = API_URL +
      '?route=' + encodeURIComponent(route) +
      '&payload=' + encodeURIComponent(JSON.stringify(payload || {}));

    return fetch(url, { method: 'GET', mode: 'cors' })
      .then(function (res) {
        if (!res.ok) {
          throw new Error('HTTP ' + res.status);
        }
        return res.json();
      });
  }

  /* ==============================================================
     3. POLLING — getState every 30 s
     ============================================================== */

  function fetchState() {
    return apiCall('getState', {})
      .then(function (resp) {
        if (resp && resp.ok && resp.data && resp.data.config) {
          var cfg = resp.data.config;
          if (cfg.cooldownMinutes !== undefined) config.cooldownMinutes = Number(cfg.cooldownMinutes);
          if (cfg.maxLength !== undefined) config.maxLength = Number(cfg.maxLength);
          config.sessionActive = String(cfg.sessionActive).toLowerCase() === 'true';
        }
        applyConfig();
      })
      .catch(function () {
        // Silently ignore polling errors — keep last known config
      });
  }

  function getPollInterval() {
    if (document.hidden) return POLL_BG;
    if (!config.sessionActive) return POLL_IDLE;
    return POLL_ACTIVE;
  }

  function schedulePoll() {
    if (pollTimer) clearTimeout(pollTimer);
    pollTimer = setTimeout(function () {
      fetchState();
      schedulePoll();
    }, getPollInterval());
  }

  function startPolling() {
    fetchState();
    schedulePoll();
  }

  // Re-poll immediately when tab becomes visible
  document.addEventListener('visibilitychange', function () {
    if (!document.hidden) {
      fetchState();
      schedulePoll();
    }
  });

  function applyConfig() {
    // Update maxLength on textarea
    commentInput.setAttribute('maxlength', config.maxLength);
    updateCharCounter();

    // Show/hide session active state
    if (config.sessionActive) {
      formCard.style.display = '';
      sessionInactive.classList.remove('visible');
    } else {
      formCard.style.display = 'none';
      sessionInactive.classList.add('visible');
    }
  }

  /* ==============================================================
     4. CHARACTER COUNTER
     ============================================================== */

  function updateCharCounter() {
    var remaining = config.maxLength - commentInput.value.length;
    charCounter.textContent = remaining + ' remaining';

    charCounter.classList.remove('warn', 'over');
    if (remaining < 0) {
      charCounter.classList.add('over');
    } else if (remaining <= 30) {
      charCounter.classList.add('warn');
    }
  }

  /* ==============================================================
     5. STATUS MESSAGES
     ============================================================== */

  /** @param {'success'|'error'|'warning'|'info'} type */
  function showStatus(text, type) {
    statusMsg.textContent = text;
    statusMsg.className = 'status-msg visible ' + (type || 'info');

    // Auto-hide after 5 s for success/info
    if (type === 'success' || type === 'info') {
      setTimeout(function () {
        statusMsg.classList.remove('visible');
      }, 5000);
    }
  }

  function hideStatus() {
    statusMsg.classList.remove('visible');
  }

  /* ==============================================================
     6. COOLDOWN TIMER
     ============================================================== */

  function startCooldown(seconds) {
    cooldownEndTime = Date.now() + seconds * 1000;
    submitBtn.disabled = true;
    commentInput.disabled = true;
    updateCooldownDisplay();

    if (cooldownInterval) clearInterval(cooldownInterval);
    cooldownInterval = setInterval(updateCooldownDisplay, 1000);
  }

  function updateCooldownDisplay() {
    var remaining = Math.max(0, Math.ceil((cooldownEndTime - Date.now()) / 1000));

    if (remaining <= 0) {
      clearInterval(cooldownInterval);
      cooldownInterval = null;
      cooldownDisplay.classList.remove('visible');
      submitBtn.disabled = false;
      commentInput.disabled = false;
      return;
    }

    var mins = Math.floor(remaining / 60);
    var secs = remaining % 60;
    var label = 'You can submit again in ';
    if (mins > 0) label += mins + 'm ';
    label += secs + 's';

    cooldownDisplay.textContent = label;
    cooldownDisplay.classList.add('visible');
  }

  /* ==============================================================
     7. MODERATION PIPELINE
     ============================================================== */

  /* ---------------------------------------------------------------
     7a. Blocklist — expanded profane / slur / sexual words
     Stemmer handles most morphological variants (-ing, -ed, -er, -s)
     so only base forms and irregular variants are needed.
     --------------------------------------------------------------- */

  var BLOCKLIST = new Set([
    // --- Core profanity ---
    'fuck', 'fucker', 'fuckers', 'fucking', 'fucked', 'fucks', 'motherfucker',
    'motherfucking', 'clusterfuck', 'fuckwit', 'fuckface', 'fuckoff',
    'shit', 'shitty', 'shits', 'shitting', 'bullshit', 'dipshit', 'shithead',
    'shitbag', 'shithole', 'horseshit', 'apeshit', 'batshit',
    'ass', 'asshole', 'assholes', 'asses', 'arsehole', 'arse', 'asshat',
    'assclown', 'asswipe', 'badass', 'dumbass', 'fatass', 'hardass', 'lardass',
    'bitch', 'bitches', 'bitchy', 'bitching', 'sonofabitch',
    'damn', 'damnit', 'goddamn', 'goddamnit', 'dammit',
    'crap', 'crappy',
    'piss', 'pissed', 'pissoff',
    'bollocks', 'bugger', 'bloody', 'blimey', 'shag', 'shagging', 'sod', 'sodoff',

    // --- Genital / body terms used as insults ---
    'dick', 'dicks', 'dickhead', 'dickheads', 'dickweed', 'dickwad',
    'cock', 'cocks', 'cocksucker', 'cocksucking', 'cockhead', 'cockface',
    'cunt', 'cunts', 'thundercunt',
    'pussy', 'pussies',
    'twat', 'twats',
    'knob', 'knobhead', 'knobend',
    'bellend',
    'prick', 'pricks',
    'tits', 'titties', 'boobs', 'boobies',
    'penis', 'vagina', 'clitoris', 'anus',

    // --- Sexual acts / terms ---
    'blowjob', 'handjob', 'rimjob', 'circlejerk',
    'porn', 'porno', 'pornography', 'hentai', 'xxx',
    'cum', 'cumming', 'cumshot', 'jizz', 'spunk', 'semen',
    'dildo', 'dildos', 'vibrator',
    'whore', 'whores', 'slut', 'sluts', 'slutty', 'skank', 'skanky', 'hoe',
    'hooker', 'prostitute',
    'orgasm', 'orgy', 'threesome', 'gangbang', 'bondage', 'fetish',
    'masturbate', 'masturbation', 'wank', 'jerkoff', 'jackoff',
    'erection', 'boner',
    'buttplug', 'strapon',

    // --- Racial / ethnic slurs ---
    'nigger', 'niggers', 'nigga', 'niggas', 'negro',
    'spic', 'spics', 'spick', 'spik',
    'chink', 'chinks',
    'wetback', 'wetbacks',
    'kike', 'kikes',
    'gook', 'gooks',
    'beaner', 'beaners',
    'coon', 'coons', 'darkie', 'darkies',
    'honky', 'honkey', 'cracker', 'crackers',
    'gringo', 'gringos',
    'redskin', 'redskins',
    'raghead', 'ragheads', 'towelhead', 'towelheads',
    'sandnigger', 'camel jockey',
    'chinaman', 'zipperhead',
    'wog', 'wogs', 'paki', 'pakis',
    'jap', 'japs', 'nip', 'nips',
    'abo', 'abos',

    // --- Homophobic / transphobic slurs ---
    'fag', 'fags', 'faggot', 'faggots', 'faggy',
    'dyke', 'dykes',
    'tranny', 'trannies', 'shemale',
    'homo', 'homos', 'lesbo', 'lesbos',
    'queer', // note: context-dependent but flagging for review is appropriate
    'pansy', 'pansies', 'sissy', 'sissies',
    'sodomite', 'sodomites',

    // --- Ableist slurs ---
    'retard', 'retards', 'retarded', 'tard', 'tards',
    'spaz', 'spazz', 'spastic',
    'cripple', 'crippled',
    'mongoloid', 'mong',
    'lame',

    // --- Misogynist / gendered insults ---
    'bastard', 'bastards',
    'douche', 'douchebag', 'douchebags', 'douchenozzle',
    'jackass', 'jackasses',
    'wanker', 'wankers',
    'tosser', 'tossers',
    'milf',
    'thot', 'incel',

    // --- Violence / threat words ---
    'kill', 'murder', 'stab', 'strangle', 'shoot', 'bomb',
    'rape', 'raped', 'rapist', 'raping',
    'molest', 'molester', 'molesting',
    'pedophile', 'paedophile', 'pedo', 'paedo',
    'torture', 'torturing',
    'suicide', 'suicidal',
    'kys', 'unalive',

    // --- Drug references (school context) ---
    'cocaine', 'heroin', 'meth', 'methamphetamine', 'ecstasy',
    'weed', 'marijuana', 'stoner', 'crackhead', 'junkie',
    'overdose',

    // --- Misc offensive ---
    'scum', 'scumbag', 'sleazebag', 'lowlife',
    'pervert', 'perv', 'creep', 'creepy',
    'loser', 'moron', 'imbecile', 'idiot',
    'stupid', 'dumb', 'braindead',
    'ugly', 'fugly', 'fatso', 'lardass',
    'stfu', 'gtfo', 'lmfao', 'wtf', 'omfg'
  ]);

  /**
   * Scunthorpe whitelist — innocent words that contain profane substrings
   * or are in the blocklist but have common innocent uses.
   * These are excluded from blocklist matching.
   */
  var WHITELIST = new Set([
    'classic', 'classics', 'classical',
    'assassin', 'assassins', 'assassination', 'assassinate',
    'class', 'classes', 'classed', 'classify',
    'bass', 'bassist',
    'assume', 'assumed', 'assumption', 'assumes',
    'assist', 'assistant', 'assistance',
    'asset', 'assets',
    'assign', 'assigned', 'assignment',
    'associate', 'associated', 'association',
    'passage', 'passenger', 'passengers',
    'compass', 'encompass',
    'mass', 'massive', 'amass',
    'brass', 'grass', 'grassland',
    'embassy',
    'harass', 'harassment',
    'basement',
    'scunthorpe',
    'cockburn', 'cockpit', 'cockatoo', 'cocktail', 'peacock',
    'hancock', 'babcock', 'hitchcock',
    'therapist', 'therapists', 'therapy',
    'grape', 'grapes',
    'title', 'titled', 'subtitle',
    'button', 'buttons',
    'shitake', 'shiitake',
    'analysis', 'analyst',
    'canal', 'canals',
    'peniston', 'penistone',
    'dickens', 'dickensian',
    'middlesex', 'essex', 'sussex', 'wessex',
    'sextant', 'sextet',
    'country', 'countries',
    'count', 'counter', 'county', 'recount',
    'document', 'documented',
    'execute', 'executed', 'execution',
    'organism', 'organic', 'organize',
    'angina',
    'cumulative', 'accumulate', 'circumstance',
    'homo sapiens', 'homogeneous', 'homophone',
    'niggardly',
    'snigger', 'sniggered',
    'bigger', 'digger', 'trigger', 'jigger',
    'flicker', 'knickers',
    'spicket', 'spice', 'spiced',
    'shell', 'hello', 'shelter',
    'dam', 'damage', 'damp',
    'grape', 'drape', 'scrape',
    'manslaughter',
    'laughter',
    'skilled', 'skills',
    'killed' // academic context — history, literature
  ]);

  /* ---------------------------------------------------------------
     7b. Sentiment dictionary (AFINN-style)
     --------------------------------------------------------------- */

  /** Negative words: value -1 to -5 */
  var NEGATIVE_WORDS = {
    'hate': -4, 'hated': -4, 'hating': -4, 'hatred': -5,
    'kill': -4, 'killed': -4, 'killing': -4, 'killer': -4,
    'die': -3, 'died': -3, 'dying': -3, 'death': -3, 'dead': -3,
    'stupid': -3, 'stupidity': -3,
    'ugly': -3,
    'loser': -3, 'losers': -3,
    'dumb': -3, 'dumber': -3, 'dumbest': -3,
    'terrible': -3, 'terribly': -3,
    'awful': -3, 'awfully': -3,
    'horrible': -3, 'horribly': -3, 'horrid': -3,
    'idiot': -4, 'idiots': -4, 'idiotic': -4,
    'moron': -4, 'morons': -4, 'moronic': -4,
    'pathetic': -3, 'pathetically': -3,
    'worthless': -4,
    'disgusting': -4, 'disgusted': -3, 'disgust': -3,
    'destroy': -3, 'destroyed': -3, 'destroying': -3, 'destruction': -3,
    'attack': -3, 'attacked': -3, 'attacking': -3,
    'hurt': -3, 'hurting': -3, 'hurtful': -3,
    'harm': -3, 'harmed': -3, 'harmful': -3, 'harming': -3,
    'suffer': -3, 'suffered': -3, 'suffering': -3,
    'abuse': -4, 'abused': -4, 'abusive': -4,
    'toxic': -3, 'vile': -4,
    'trash': -2, 'garbage': -2, 'junk': -2,
    'angry': -2, 'anger': -3, 'furious': -3, 'rage': -4,
    'annoying': -2, 'annoyed': -2, 'irritating': -2,
    'boring': -2, 'bored': -2,
    'cruel': -4, 'cruelty': -4,
    'evil': -4, 'wicked': -3,
    'vicious': -4,
    'nasty': -3,
    'mean': -2,
    'lame': -2,
    'suck': -2, 'sucks': -2, 'sucked': -2,
    'fail': -2, 'failed': -2, 'failure': -3,
    'wrong': -2, 'worst': -4, 'worse': -3, 'bad': -2,
    'weak': -2, 'useless': -3,
    'miserable': -3, 'misery': -3,
    'despise': -4, 'detest': -4, 'loathe': -4,
    'threat': -3, 'threaten': -3, 'threatening': -3,
    'violent': -4, 'violence': -4,
    'hostile': -3, 'hostility': -3,
    'shame': -2, 'shameful': -3,
    'reject': -2, 'rejected': -3,
    'fear': -2, 'scared': -2, 'terrified': -3, 'terror': -4,
    'pain': -2, 'painful': -3,
    'sad': -2, 'sadness': -3
  };

  /** Positive words: value +1 to +5 */
  var POSITIVE_WORDS = {
    'good': 2, 'great': 3, 'excellent': 4, 'amazing': 4, 'awesome': 4,
    'wonderful': 4, 'fantastic': 4, 'brilliant': 4, 'outstanding': 5,
    'love': 3, 'loved': 3, 'loving': 3, 'lovely': 3,
    'like': 1, 'liked': 1,
    'happy': 3, 'happiness': 3, 'happily': 3,
    'joy': 3, 'joyful': 3,
    'kind': 3, 'kindness': 3, 'kindly': 2,
    'nice': 2, 'nicer': 2, 'nicest': 3,
    'beautiful': 3, 'beauty': 3,
    'helpful': 2, 'help': 1,
    'thank': 2, 'thanks': 2, 'thankful': 3, 'grateful': 3,
    'best': 4, 'better': 2,
    'fun': 2, 'funny': 2,
    'cool': 2,
    'smart': 2, 'clever': 2, 'wise': 2,
    'brave': 3, 'courage': 3, 'courageous': 3,
    'strong': 2, 'strength': 2,
    'success': 3, 'successful': 3,
    'perfect': 4, 'perfectly': 4,
    'agree': 1, 'agreed': 1,
    'peaceful': 2, 'peace': 2,
    'safe': 1, 'secure': 2,
    'inspire': 3, 'inspired': 3, 'inspiring': 3,
    'hope': 2, 'hopeful': 2,
    'excited': 3, 'exciting': 3
  };

  /* ---------------------------------------------------------------
     Layer 1 — Text Normalization
     --------------------------------------------------------------- */

  /**
   * Normalize text for moderation analysis.
   * - Unicode NFKD + strip combining diacriticals
   * - Strip zero-width characters
   * - Leet-speak decode
   * - Strip separators between word chars
   * - Collapse 3+ repeated chars to 2
   * @param {string} text
   * @returns {string} normalized lowercase text
   */
  function normalizeText(text) {
    var s = text;

    // Unicode NFKD normalization and strip combining diacritical marks (U+0300..U+036F)
    s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');

    // Strip zero-width characters
    s = s.replace(/[\u200B\u200C\u200D\uFEFF\u180E]/g, '');

    // Lowercase
    s = s.toLowerCase();

    // Multi-character substitutions first (before single-char leet speak)
    s = s.replace(/ph/g, 'f');

    // Leet speak decode
    s = s.replace(/0/g, 'o')
         .replace(/1/g, 'i')
         .replace(/3/g, 'e')
         .replace(/4/g, 'a')
         .replace(/5/g, 's')
         .replace(/7/g, 't')
         .replace(/@/g, 'a')
         .replace(/\$/g, 's')
         .replace(/!/g, 'i')
         .replace(/\|/g, 'l')
         .replace(/\+/g, 't');

    // Strip separators between word characters (dots, dashes, underscores, asterisks, etc.)
    // e.g. "f.u.c.k" → "fuck", "f*ck" → "fck", "a-s-s" → "ass"
    // NOTE: spaces are NOT stripped — they must be preserved for tokenization.
    s = s.replace(/(\w)[.\-_*#~^]+(?=\w)/g, '$1');

    // Collapse 3+ repeated characters to 2
    s = s.replace(/(.)\1{2,}/g, '$1$1');

    return s;
  }

  /* ---------------------------------------------------------------
     Layer 1b — Tokenize and simple stemming
     --------------------------------------------------------------- */

  /**
   * Tokenize text into lowercase alpha-only tokens.
   * @param {string} text — already normalized
   * @returns {string[]}
   */
  function tokenize(text) {
    return text.match(/[a-z]+/g) || [];
  }

  /**
   * Very simple suffix-stripping stemmer.
   * Removes common English suffixes for matching against the blocklist.
   * @param {string} word
   * @returns {string}
   */
  function simpleStem(word) {
    if (word.length <= 3) return word;

    // Order matters — try longest suffixes first
    if (word.endsWith('ing') && word.length > 5) return word.slice(0, -3);
    if (word.endsWith('ers') && word.length > 5) return word.slice(0, -3);
    if (word.endsWith('ed') && word.length > 4) return word.slice(0, -2);
    if (word.endsWith('er') && word.length > 4) return word.slice(0, -2);
    if (word.endsWith('es') && word.length > 4) return word.slice(0, -2);
    if (word.endsWith('s') && word.length > 3) return word.slice(0, -1);

    return word;
  }

  /* ---------------------------------------------------------------
     Layer 2 — Blocklist Lookup
     --------------------------------------------------------------- */

  /**
   * Check if any token (or its stem) appears in the blocklist.
   * @param {string[]} tokens — normalized, lowercase tokens
   * @returns {{score: number, matched: string[]}}
   */
  function checkBlocklist(tokens) {
    var matched = [];
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      var stem = simpleStem(token);
      // Skip whitelisted innocent words (Scunthorpe problem prevention)
      if (WHITELIST.has(token) || WHITELIST.has(stem)) continue;
      if (BLOCKLIST.has(token) || BLOCKLIST.has(stem)) {
        matched.push(token);
      }
    }
    return {
      score: matched.length > 0 ? 1.0 : 0,
      matched: matched
    };
  }

  /* ---------------------------------------------------------------
     Layer 3 — Phonetic Matching (Soundex)
     --------------------------------------------------------------- */

  /**
   * Compute the Soundex code for a word (4 characters).
   * Standard American Soundex algorithm.
   * @param {string} word — lowercase alpha string
   * @returns {string} Soundex code, e.g. "F200"
   */
  function soundex(word) {
    if (!word || word.length === 0) return '0000';

    // Soundex coding table
    var map = {
      b: '1', f: '1', p: '1', v: '1',
      c: '2', g: '2', j: '2', k: '2', q: '2', s: '2', x: '2', z: '2',
      d: '3', t: '3',
      l: '4',
      m: '5', n: '5',
      r: '6'
    };

    var first = word[0].toUpperCase();
    var code = first;
    var lastDigit = map[word[0]] || '0';

    for (var i = 1; i < word.length && code.length < 4; i++) {
      var ch = word[i];
      var digit = map[ch];
      if (digit && digit !== lastDigit) {
        code += digit;
        lastDigit = digit;
      } else if (!digit) {
        // Vowels (a,e,i,o,u,y) reset last digit — same-coded consonants
        // separated by a vowel are coded twice.
        // H and W are transparent — do NOT reset lastDigit.
        if (ch !== 'h' && ch !== 'w') {
          lastDigit = '0';
        }
      }
    }

    // Pad with zeros
    while (code.length < 4) {
      code += '0';
    }

    return code;
  }

  /** Pre-computed Soundex codes for all blocklist words */
  var BLOCKLIST_SOUNDEX = new Set();
  (function () {
    BLOCKLIST.forEach(function (word) {
      BLOCKLIST_SOUNDEX.add(soundex(word));
    });
  })();

  /**
   * Check if any token phonetically matches a blocklist word via Soundex.
   * @param {string[]} tokens
   * @returns {{score: number, matched: string[]}}
   */
  function checkPhonetic(tokens) {
    var matched = [];
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (token.length < 2) continue; // skip single chars — too many false positives
      if (WHITELIST.has(token) || WHITELIST.has(simpleStem(token))) continue;
      var code = soundex(token);
      if (BLOCKLIST_SOUNDEX.has(code)) {
        // Make sure it's not already a direct blocklist hit (avoid double counting)
        if (!BLOCKLIST.has(token) && !BLOCKLIST.has(simpleStem(token))) {
          matched.push(token);
        }
      }
    }
    return {
      score: matched.length > 0 ? 0.8 : 0,
      matched: matched
    };
  }

  /* ---------------------------------------------------------------
     Layer 4 — Fuzzy Matching (Levenshtein Distance)
     --------------------------------------------------------------- */

  /**
   * Compute the Levenshtein edit distance between two strings.
   * Uses an optimized single-row DP approach.
   * @param {string} a
   * @param {string} b
   * @returns {number}
   */
  function levenshtein(a, b) {
    if (a === b) return 0;
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;

    // Ensure a is the shorter string for space efficiency
    if (a.length > b.length) {
      var tmp = a;
      a = b;
      b = tmp;
    }

    var aLen = a.length;
    var bLen = b.length;

    // Single-row DP
    var row = new Array(aLen + 1);
    for (var i = 0; i <= aLen; i++) {
      row[i] = i;
    }

    for (var j = 1; j <= bLen; j++) {
      var prev = row[0];
      row[0] = j;
      for (var k = 1; k <= aLen; k++) {
        var cost = a[k - 1] === b[j - 1] ? 0 : 1;
        var val = Math.min(
          row[k] + 1,        // deletion
          row[k - 1] + 1,    // insertion
          prev + cost         // substitution
        );
        prev = row[k];
        row[k] = val;
      }
    }

    return row[aLen];
  }

  /** Blocklist words as an array for fuzzy matching, with lengths pre-computed */
  var BLOCKLIST_ARRAY = [];
  (function () {
    BLOCKLIST.forEach(function (w) {
      BLOCKLIST_ARRAY.push({ word: w, len: w.length });
    });
  })();

  /**
   * Check if any input token of length 5+ is within Levenshtein distance 2
   * of a blocklist word of similar length (+-2 chars).
   * @param {string[]} tokens
   * @returns {{score: number, matched: string[]}}
   */
  function checkFuzzy(tokens) {
    var matched = [];
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (token.length < 5) continue;

      // Skip whitelisted and already-matched words
      if (WHITELIST.has(token) || WHITELIST.has(simpleStem(token))) continue;
      if (BLOCKLIST.has(token) || BLOCKLIST.has(simpleStem(token))) continue;

      for (var j = 0; j < BLOCKLIST_ARRAY.length; j++) {
        var entry = BLOCKLIST_ARRAY[j];
        // Only compare words of similar length (within +-2)
        if (Math.abs(token.length - entry.len) > 2) continue;

        var dist = levenshtein(token, entry.word);
        if (dist <= 2) {
          matched.push(token);
          break; // one match is enough for this token
        }
      }
    }
    return {
      score: matched.length > 0 ? 0.7 : 0,
      matched: matched
    };
  }

  /* ---------------------------------------------------------------
     Layer 5 — Sentiment Analysis
     --------------------------------------------------------------- */

  /**
   * Compute a comparative sentiment score for the text.
   * @param {string[]} tokens — normalized tokens
   * @returns {{score: number, comparative: number}}
   */
  function checkSentiment(tokens) {
    if (tokens.length === 0) return { score: 0, comparative: 0 };

    var sum = 0;
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (NEGATIVE_WORDS.hasOwnProperty(token)) {
        sum += NEGATIVE_WORDS[token];
      } else if (POSITIVE_WORDS.hasOwnProperty(token)) {
        sum += POSITIVE_WORDS[token];
      }
    }

    var comparative = sum / tokens.length;

    // Map highly negative sentiment (below -2) to toxicity 0.6
    var score = comparative < -2 ? 0.6 : 0;

    return {
      score: score,
      comparative: comparative
    };
  }

  /* ---------------------------------------------------------------
     Layer 6 — Pattern Detection
     --------------------------------------------------------------- */

  /**
   * Detect aggressive / threatening patterns in the original (un-normalized) text
   * and the normalized text.
   * @param {string} originalText — raw user input
   * @param {string} normalizedText — output of normalizeText()
   * @returns {{score: number, flags: string[]}}
   */
  function checkPatterns(originalText, normalizedText) {
    var flags = [];
    var score = 0;

    // --- Threatening patterns (highest priority, score 1.0) ---
    var threats = [
      /kill\s*your\s*self/i,
      /\bkys\b/i,
      /go\s*die/i,
      /\bunalive\b/i,
      /kill\s*you/i,
      /hope\s*you\s*die/i
    ];
    for (var t = 0; t < threats.length; t++) {
      if (threats[t].test(normalizedText) || threats[t].test(originalText)) {
        flags.push('threat');
        score = Math.max(score, 1.0);
        break;
      }
    }

    // --- ALL CAPS aggression (>70% uppercase, message >5 chars) ---
    if (originalText.length > 5) {
      var alphaChars = originalText.replace(/[^a-zA-Z]/g, '');
      if (alphaChars.length > 0) {
        var upperCount = (alphaChars.match(/[A-Z]/g) || []).length;
        var upperRatio = upperCount / alphaChars.length;
        if (upperRatio > 0.7) {
          flags.push('all_caps');
          score = Math.max(score, 0.4);
        }
      }
    }

    // --- Excessive punctuation (3+ consecutive ! or ?) ---
    if (/[!?]{3,}/.test(originalText)) {
      flags.push('excessive_punctuation');
      score = Math.max(score, 0.3);
    }

    return {
      score: score,
      flags: flags
    };
  }

  /* ---------------------------------------------------------------
     Composite Scoring — Layers 1-6 (synchronous)
     --------------------------------------------------------------- */

  /**
   * Run the full synchronous moderation pipeline.
   * @param {string} rawText — user's original input
   * @returns {{compositeScore: number, categories: string[], details: Object}}
   */
  function moderateSync(rawText) {
    var normalizedText = normalizeText(rawText);
    var tokens = tokenize(normalizedText);
    var categories = [];

    // Layer 2 — Blocklist
    var blocklist = checkBlocklist(tokens);
    if (blocklist.score > 0) categories.push('blocklist');

    // Layer 3 — Phonetic
    var phonetic = checkPhonetic(tokens);
    if (phonetic.score > 0) categories.push('phonetic');

    // Layer 4 — Fuzzy
    var fuzzy = checkFuzzy(tokens);
    if (fuzzy.score > 0) categories.push('fuzzy');

    // Layer 5 — Sentiment
    var sentiment = checkSentiment(tokens);
    if (sentiment.score > 0) categories.push('negative_sentiment');

    // Layer 6 — Patterns
    var patterns = checkPatterns(rawText, normalizedText);
    if (patterns.flags.length > 0) categories = categories.concat(patterns.flags);

    // Composite: MAX across all layer scores (most conservative)
    var compositeScore = Math.max(
      blocklist.score,
      phonetic.score,
      fuzzy.score,
      sentiment.score,
      patterns.score
    );

    return {
      compositeScore: compositeScore,
      categories: categories,
      details: {
        blocklist: blocklist,
        phonetic: phonetic,
        fuzzy: fuzzy,
        sentiment: sentiment,
        patterns: patterns
      }
    };
  }

  /* ---------------------------------------------------------------
     Layer 7 — TensorFlow.js Toxicity (async, enhancement)
     --------------------------------------------------------------- */

  /**
   * Lazily load the TensorFlow.js toxicity model.
   * Called via requestIdleCallback after page load.
   */
  function loadToxicityModel() {
    if (tfModelReady || tfModelLoading) return;
    tfModelLoading = true;

    // Ensure the toxicity library is available
    if (typeof toxicity === 'undefined' || typeof tf === 'undefined') {
      tfStatus.textContent = '';
      tfStatus.classList.add('loaded');
      tfModelLoading = false;
      return;
    }

    var threshold = 0.8;
    toxicity.load(threshold).then(function (model) {
      tfModel = model;
      tfModelReady = true;
      tfModelLoading = false;
      tfStatus.textContent = 'Enhanced safety ready';
      setTimeout(function () {
        tfStatus.classList.add('loaded');
      }, 2000);
    }).catch(function () {
      tfModelLoading = false;
      tfStatus.textContent = '';
      tfStatus.classList.add('loaded');
    });
  }

  /**
   * Run the TF.js toxicity model on text.
   * @param {string} text
   * @returns {Promise<{score: number, labels: string[]}>}
   */
  function checkToxicityModel(text) {
    if (!tfModelReady || !tfModel) {
      return Promise.resolve({ score: 0, labels: [] });
    }

    return tfModel.classify([text]).then(function (predictions) {
      var flaggedLabels = [];
      var maxScore = 0;

      for (var i = 0; i < predictions.length; i++) {
        var p = predictions[i];
        // Each prediction has results array; index 0 is the input sentence
        if (p.results && p.results[0] && p.results[0].match === true) {
          flaggedLabels.push(p.label);
          // The probabilities array: [not_toxic, toxic]
          var toxicProb = p.results[0].probabilities[1];
          if (toxicProb > maxScore) {
            maxScore = toxicProb;
          }
        }
      }

      return {
        score: flaggedLabels.length > 0 ? 0.9 : 0,
        labels: flaggedLabels
      };
    }).catch(function () {
      return { score: 0, labels: [] };
    });
  }

  /* ==============================================================
     8. SUBMISSION FLOW
     ============================================================== */

  function handleSubmit() {
    if (isSubmitting) return;

    // Sanitise: keep only letters, digits, spaces, newlines, and ,.'?
    var rawText = commentInput.value
      .replace(/[^a-zA-Z0-9 ,.\n'?]+/g, '')
      .replace(/[^\S\n]+/g, ' ')
      .replace(/\n{2,}/g, '\n')
      .trim();

    // Push cleaned value back into the textarea so the user sees it
    commentInput.value = rawText;

    // Empty check
    if (!rawText) {
      showStatus('Please type a comment first.', 'warning');
      return;
    }

    // Session check
    if (!config.sessionActive) {
      showStatus('Session is not active.', 'warning');
      return;
    }

    // Cooldown check (client-side)
    if (Date.now() < cooldownEndTime) {
      showStatus('Please wait for the cooldown to finish.', 'warning');
      return;
    }

    hideStatus();

    // Run synchronous moderation (layers 1-6)
    var modResult = moderateSync(rawText);

    // If TF.js model is ready, run it synchronously-ish before submission
    if (tfModelReady) {
      isSubmitting = true;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Checking...';
      checkToxicityModel(rawText).then(function (tfResult) {
        if (tfResult.score > 0) {
          // Merge TF.js score into composite
          if (tfResult.score > modResult.compositeScore) {
            modResult.compositeScore = tfResult.score;
          }
          modResult.categories = modResult.categories.concat(tfResult.labels.map(function (l) { return 'tf:' + l; }));
        }
        isSubmitting = false;
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit';
        proceedWithSubmission(rawText, modResult);
      }).catch(function () {
        isSubmitting = false;
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit';
        proceedWithSubmission(rawText, modResult);
      });
      return;
    }

    proceedWithSubmission(rawText, modResult);
  }

  /**
   * Continue submission after all moderation checks complete.
   */
  function proceedWithSubmission(rawText, modResult) {
    // All content is submitted regardless of score — teacher reviews flagged items.
    // High scores are flagged for review, not hard-blocked.
    // This follows the "triage, not filter" philosophy.
    isSubmitting = true;
    submitBtn.disabled = true;
    submitBtn.textContent = 'Submitting...';

    var payload = {
      deviceId: deviceId,
      text: rawText,
      moderationScore: Math.round(modResult.compositeScore * 1000) / 1000,
      flagCategories: modResult.categories
    };

    apiCall('submit', payload)
      .then(function (resp) {
        isSubmitting = false;
        submitBtn.textContent = 'Submit';

        if (resp && resp.ok) {
          showStatus('Submitted!', 'success');
          commentInput.value = '';
          updateCharCounter();

          // Start cooldown (skip if cooldown is 0)
          if (config.cooldownMinutes > 0) {
            startCooldown(config.cooldownMinutes * 60);
          }
        } else {
          // Server returned an error
          var errMsg = (resp && resp.error) ? resp.error : 'Something went wrong.';

          // Detect cooldown error from message
          if (errMsg.indexOf('Cooldown') !== -1) {
            // Parse remaining seconds from "Please wait X seconds"
            var match = errMsg.match(/(\d+)\s*seconds/);
            var remaining = match ? parseInt(match[1], 10) : config.cooldownMinutes * 60;
            startCooldown(remaining);
            showStatus('Cooldown active \u2014 please wait.', 'warning');
          } else if (errMsg.indexOf('not active') !== -1) {
            config.sessionActive = false;
            applyConfig();
            showStatus('Session is not active.', 'warning');
          } else {
            showStatus(errMsg, 'error');
            submitBtn.disabled = false;
          }
        }
      })
      .catch(function (err) {
        isSubmitting = false;
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit';
        showStatus('Network error \u2014 please try again.', 'error');
      });

  }

  /* ==============================================================
     9. EVENT BINDINGS
     ============================================================== */

  // Live-strip disallowed characters as the user types
  commentInput.addEventListener('input', function () {
    var cursor = commentInput.selectionStart;
    var before = commentInput.value;
    var cleaned = before.replace(/[^a-zA-Z0-9 ,.\n'?]+/g, '').replace(/[^\S\n]+/g, ' ').replace(/\n{2,}/g, '\n');
    if (cleaned !== before) {
      commentInput.value = cleaned;
      // Adjust cursor for removed chars before the cursor position
      var removed = before.length - cleaned.length;
      commentInput.selectionStart = commentInput.selectionEnd = Math.max(0, cursor - removed);
    }
    updateCharCounter();
  });

  // Block paste entirely
  commentInput.addEventListener('paste', function (e) {
    e.preventDefault();
  });

  // Block drag-and-drop text into the textarea
  commentInput.addEventListener('drop', function (e) {
    e.preventDefault();
  });

  // Submit button click
  submitBtn.addEventListener('click', handleSubmit);

  // Enter key submits (without Shift held, for single-line feel; Shift+Enter for newline)
  commentInput.addEventListener('keydown', function (e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  });

  /* ==============================================================
     10. INITIALIZATION
     ============================================================== */

  // Generate / load device ID
  initDeviceId();

  // Apply initial config (before server response)
  applyConfig();

  // Fetch server state and begin polling
  startPolling();

  // Lazy-load TF.js toxicity model
  if (typeof requestIdleCallback === 'function') {
    requestIdleCallback(loadToxicityModel, { timeout: 5000 });
  } else {
    // Fallback for Safari / older browsers
    setTimeout(loadToxicityModel, 3000);
  }

})();
</script>
</body>
</html>
